{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"b4971f6f-3eb8-4233-85d7-ab2ab20ae72e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BVSVCg7HDnno1ngYL3ubNJ","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement these two tasks in order. Let me start by exploring the current codebase structure to understand how dependencies and labels are implemented."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21181,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21181},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"5c6a5cb0-8a5d-40b6-810f-df467c68e20a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BVSVCg7HDnno1ngYL3ubNJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","name":"Task","input":{"subagent_type":"Explore","prompt":"I need to understand the current implementation of:\n1. The `dep` command - how dependencies work, what types exist, the CLI interface\n2. The `label` command - how labels work, what subcommands exist\n\nSearch for:\n- src/cli/dep*.zig files\n- src/cli/label*.zig files\n- src/models/dependency.zig or similar\n- src/storage/graph.zig\n- src/cli/args.zig for the command definitions\n\nI need to understand:\n1. Current dependency types supported\n2. Current dep subcommands (add, remove, list, tree, cycles)\n3. Current label subcommands\n4. How the CLI arg parsing works for these commands","description":"Explore dep and label code"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21181,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21181},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a244295b-4d23-43a0-8ae4-202dedc44bc4"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"I need to understand the current implementation of:\n1. The `dep` command - how dependencies work, what types exist, the CLI interface\n2. The `label` command - how labels work, what subcommands exist\n\nSearch for:\n- src/cli/dep*.zig files\n- src/cli/label*.zig files\n- src/models/dependency.zig or similar\n- src/storage/graph.zig\n- src/cli/args.zig for the command definitions\n\nI need to understand:\n1. Current dependency types supported\n2. Current dep subcommands (add, remove, list, tree, cycles)\n3. Current label subcommands\n4. How the CLI arg parsing works for these commands"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"387ec28e-9b2a-40d1-9414-c2e7b57523d4"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S4MMB2AE6H73HFgWDqz9zu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013T2y6rFW3aGfLeQvxbJzds","name":"Glob","input":{"pattern":"src/cli/dep*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3971,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3971},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9efa1a75-63f7-4086-ae0e-57cb3c25f2ce"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S4MMB2AE6H73HFgWDqz9zu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SnkrtDv2gBTdS6vXDxT8ok","name":"Glob","input":{"pattern":"src/cli/label*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3971,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3971},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"e0d994e8-f9ac-4e8c-9a86-ccda278da897"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013T2y6rFW3aGfLeQvxbJzds","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/dep.zig"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"57e23b15-bf56-41da-9057-50dcd9d42d25"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S4MMB2AE6H73HFgWDqz9zu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AzgPBDv5FP8Lcupax2FmiP","name":"Glob","input":{"pattern":"src/models/dep*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3971,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3971},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"862b0285-4ae8-4362-b109-da42125b4e96"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SnkrtDv2gBTdS6vXDxT8ok","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/label.zig"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"bfaaa6f0-5865-4dbb-a0f0-83885a7e352c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S4MMB2AE6H73HFgWDqz9zu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V1VsnBWoma5nXDWdnPVMSL","name":"Glob","input":{"pattern":"src/storage/graph.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3971,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3971},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"c432b18a-763a-4d9b-bb37-5e209e87d189"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AzgPBDv5FP8Lcupax2FmiP","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/models/dependency.zig"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"fb5b69bb-742f-4f6b-9fe6-89230df4ed36"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S4MMB2AE6H73HFgWDqz9zu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kth5ZMGV6RtckJZUqvgHuo","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3971,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3971},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"eb222c7d-f093-4714-a621-99a2281641b5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V1VsnBWoma5nXDWdnPVMSL","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/storage/graph.zig"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"092b8112-223c-4c12-9786-89d6b7f96cbe"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (28591 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01Kth5ZMGV6RtckJZUqvgHuo"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d5914d74-70ab-4afd-a64d-ea8242709060","tool_use_result":"Error: File content (28591 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TiduPeyzTS8AAoi7ZMYa1x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RoM7TCW57pquoB7fg6byvW","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":676,"cache_read_input_tokens":13187,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":676},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"1f3b9abd-be44-45e9-bf81-031fb7c78e8b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RoM7TCW57pquoB7fg6byvW","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    robot: bool = false, // Line-oriented machine-readable output for scripting\n    13→    quiet: bool = false,\n    14→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    15→    verbose: u8 = 0,\n    16→    no_color: bool = false,\n    17→    wrap: bool = false, // Wrap long lines in plain text output\n    18→    stats: bool = false, // Show token savings stats for TOON output\n    19→    data_path: ?[]const u8 = null,\n    20→    actor: ?[]const u8 = null,\n    21→    lock_timeout: u32 = 5000,\n    22→    no_auto_flush: bool = false,\n    23→    no_auto_import: bool = false,\n    24→\n    25→    /// Returns true if structured output (JSON or TOON) is enabled.\n    26→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    27→        return self.json or self.toon;\n    28→    }\n    29→\n    30→    /// Returns true if any machine-readable output is enabled.\n    31→    pub fn isMachineOutput(self: GlobalOptions) bool {\n    32→        return self.json or self.toon or self.robot;\n    33→    }\n    34→};\n    35→\n    36→/// All available subcommands.\n    37→pub const Command = union(enum) {\n    38→    // Workspace\n    39→    init: InitArgs,\n    40→    info: void,\n    41→    stats: void,\n    42→    doctor: void,\n    43→    config: ConfigArgs,\n    44→    orphans: OrphansArgs,\n    45→    lint: LintArgs,\n    46→    where: void,\n    47→\n    48→    // Issue CRUD\n    49→    create: CreateArgs,\n    50→    q: QuickArgs,\n    51→    show: ShowArgs,\n    52→    update: UpdateArgs,\n    53→    close: CloseArgs,\n    54→    reopen: ReopenArgs,\n    55→    delete: DeleteArgs,\n    56→\n    57→    // Batch Operations\n    58→    add_batch: AddBatchArgs,\n    59→    import_cmd: ImportArgs,\n    60→\n    61→    // Query\n    62→    list: ListArgs,\n    63→    ready: ReadyArgs,\n    64→    blocked: BlockedArgs,\n    65→    search: SearchArgs,\n    66→    stale: StaleArgs,\n    67→    count: CountArgs,\n    68→    defer_cmd: DeferArgs,\n    69→    undefer: UndeferArgs,\n    70→\n    71→    // Dependencies\n    72→    dep: DepArgs,\n    73→    graph: GraphArgs,\n    74→\n    75→    // Epics\n    76→    epic: EpicArgs,\n    77→\n    78→    // Labels\n    79→    label: LabelArgs,\n    80→\n    81→    // Comments\n    82→    comments: CommentsArgs,\n    83→\n    84→    // Audit\n    85→    history: HistoryArgs,\n    86→    audit: AuditArgs,\n    87→\n    88→    // Changelog\n    89→    changelog: ChangelogArgs,\n    90→\n    91→    // Sync\n    92→    sync: SyncArgs,\n    93→\n    94→    // System\n    95→    version: void,\n    96→    schema: void,\n    97→    completions: CompletionsArgs,\n    98→    metrics: MetricsArgs,\n    99→\n   100→    // Saved Queries\n   101→    query: QueryArgs,\n   102→\n   103→    // Self-upgrade\n   104→    upgrade: UpgradeArgs,\n   105→\n   106→    // Help\n   107→    help: HelpArgs,\n   108→};\n   109→\n   110→/// Init command arguments.\n   111→pub const InitArgs = struct {\n   112→    prefix: []const u8 = \"bd\",\n   113→};\n   114→\n   115→/// Create command arguments.\n   116→pub const CreateArgs = struct {\n   117→    title: []const u8,\n   118→    description: ?[]const u8 = null,\n   119→    issue_type: ?[]const u8 = null,\n   120→    priority: ?[]const u8 = null,\n   121→    assignee: ?[]const u8 = null,\n   122→    owner: ?[]const u8 = null,\n   123→    design: ?[]const u8 = null,\n   124→    acceptance_criteria: ?[]const u8 = null,\n   125→    external_ref: ?[]const u8 = null,\n   126→    labels: []const []const u8 = &[_][]const u8{},\n   127→    deps: []const []const u8 = &[_][]const u8{},\n   128→    due: ?[]const u8 = null,\n   129→    estimate: ?i32 = null,\n   130→    ephemeral: bool = false, // Local-only, not written to JSONL\n   131→};\n   132→\n   133→/// Quick capture command arguments.\n   134→pub const QuickArgs = struct {\n   135→    title: []const u8,\n   136→    priority: ?[]const u8 = null,\n   137→};\n   138→\n   139→/// Show command arguments.\n   140→pub const ShowArgs = struct {\n   141→    id: []const u8,\n   142→    with_comments: bool = true,\n   143→    with_history: bool = false,\n   144→};\n   145→\n   146→/// Update command arguments.\n   147→pub const UpdateArgs = struct {\n   148→    id: []const u8,\n   149→    title: ?[]const u8 = null,\n   150→    description: ?[]const u8 = null,\n   151→    issue_type: ?[]const u8 = null,\n   152→    priority: ?[]const u8 = null,\n   153→    assignee: ?[]const u8 = null,\n   154→    owner: ?[]const u8 = null,\n   155→    design: ?[]const u8 = null,\n   156→    acceptance_criteria: ?[]const u8 = null,\n   157→    external_ref: ?[]const u8 = null,\n   158→    status: ?[]const u8 = null,\n   159→    /// Expected version for optimistic locking (compare-and-swap).\n   160→    expected_version: ?u64 = null,\n   161→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   162→    claim: bool = false,\n   163→};\n   164→\n   165→/// Close command arguments.\n   166→pub const CloseArgs = struct {\n   167→    id: []const u8,\n   168→    reason: ?[]const u8 = null,\n   169→    session: ?[]const u8 = null,\n   170→};\n   171→\n   172→/// Reopen command arguments.\n   173→pub const ReopenArgs = struct {\n   174→    id: []const u8,\n   175→};\n   176→\n   177→/// Delete command arguments.\n   178→pub const DeleteArgs = struct {\n   179→    /// Single issue ID to delete (mutually exclusive with from_file).\n   180→    id: ?[]const u8 = null,\n   181→    /// Path to file containing issue IDs to delete (one per line).\n   182→    from_file: ?[]const u8 = null,\n   183→    /// Delete issue and all its dependents recursively.\n   184→    cascade: bool = false,\n   185→    /// Prune from database immediately instead of marking as tombstone.\n   186→    hard: bool = false,\n   187→    /// Preview what would be deleted without making changes.\n   188→    dry_run: bool = false,\n   189→};\n   190→\n   191→/// Add-batch command arguments.\n   192→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   193→pub const AddBatchArgs = struct {\n   194→    file: ?[]const u8 = null, // Read from file instead of stdin\n   195→    format: BatchFormat = .titles, // Input format\n   196→};\n   197→\n   198→/// Batch input format.\n   199→pub const BatchFormat = enum {\n   200→    titles, // One title per line\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"0eec83d7-ab95-48a0-a19e-fe24a9b23cf8"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TiduPeyzTS8AAoi7ZMYa1x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JcStFE8YbV31Qtd4u1Wvwq","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":676,"cache_read_input_tokens":13187,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":676},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b12cbd12-6aad-48af-aa23-437c8a15d329"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JcStFE8YbV31Qtd4u1Wvwq","type":"tool_result","content":"     1→//! Dependency management commands for beads_zig.\n     2→//!\n     3→//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n     4→//! `bz dep remove <child> <parent>` - Remove dependency\n     5→//! `bz dep list <id>` - List dependencies for an issue\n     6→//!\n     7→//! Manages relationships between issues.\n     8→\n     9→const std = @import(\"std\");\n    10→const models = @import(\"../models/mod.zig\");\n    11→const storage = @import(\"../storage/mod.zig\");\n    12→const common = @import(\"common.zig\");\n    13→const args = @import(\"args.zig\");\n    14→const test_util = @import(\"../test_util.zig\");\n    15→\n    16→const Dependency = models.Dependency;\n    17→const DependencyType = models.DependencyType;\n    18→const CommandContext = common.CommandContext;\n    19→const DependencyGraph = common.DependencyGraph;\n    20→const DependencyGraphError = storage.DependencyGraphError;\n    21→\n    22→pub const DepError = error{\n    23→    WorkspaceNotInitialized,\n    24→    IssueNotFound,\n    25→    CycleDetected,\n    26→    SelfDependency,\n    27→    StorageError,\n    28→    OutOfMemory,\n    29→};\n    30→\n    31→pub const DepResult = struct {\n    32→    success: bool,\n    33→    action: ?[]const u8 = null,\n    34→    child: ?[]const u8 = null,\n    35→    parent: ?[]const u8 = null,\n    36→    depends_on: ?[]const []const u8 = null,\n    37→    blocks: ?[]const []const u8 = null,\n    38→    message: ?[]const u8 = null,\n    39→};\n    40→\n    41→pub fn run(\n    42→    dep_args: args.DepArgs,\n    43→    global: args.GlobalOptions,\n    44→    allocator: std.mem.Allocator,\n    45→) !void {\n    46→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    47→        return DepError.WorkspaceNotInitialized;\n    48→    };\n    49→    defer ctx.deinit();\n    50→\n    51→    var graph = ctx.createGraph();\n    52→\n    53→    switch (dep_args.subcommand) {\n    54→        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n    55→        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n    56→        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n    57→        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n    58→        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    59→    }\n    60→}\n    61→\n    62→fn runAdd(\n    63→    graph: *DependencyGraph,\n    64→    ctx: *CommandContext,\n    65→    add_args: anytype,\n    66→    global: args.GlobalOptions,\n    67→    allocator: std.mem.Allocator,\n    68→) !void {\n    69→    const structured_output = global.isStructuredOutput();\n    70→    if (!try ctx.store.exists(add_args.child)) {\n    71→        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n    72→        return DepError.IssueNotFound;\n    73→    }\n    74→\n    75→    if (!try ctx.store.exists(add_args.parent)) {\n    76→        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n    77→        return DepError.IssueNotFound;\n    78→    }\n    79→\n    80→    const now = std.time.timestamp();\n    81→    const dep = Dependency{\n    82→        .issue_id = add_args.child,\n    83→        .depends_on_id = add_args.parent,\n    84→        .dep_type = DependencyType.fromString(add_args.dep_type),\n    85→        .created_at = now,\n    86→        .created_by = global.actor,\n    87→        .metadata = null,\n    88→        .thread_id = null,\n    89→    };\n    90→\n    91→    graph.addDependency(dep) catch |err| {\n    92→        const msg = switch (err) {\n    93→            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n    94→            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n    95→            DependencyGraphError.IssueNotFound => \"issue not found\",\n    96→            else => \"failed to add dependency\",\n    97→        };\n    98→        try outputError(&ctx.output, structured_output, msg);\n    99→\n   100→        return switch (err) {\n   101→            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n   102→            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n   103→            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n   104→            else => DepError.StorageError,\n   105→        };\n   106→    };\n   107→\n   108→    try ctx.saveIfAutoFlush();\n   109→\n   110→    if (structured_output) {\n   111→        try ctx.output.printJson(DepResult{\n   112→            .success = true,\n   113→            .action = \"added\",\n   114→            .child = add_args.child,\n   115→            .parent = add_args.parent,\n   116→        });\n   117→    } else if (!global.quiet) {\n   118→        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n   119→    }\n   120→}\n   121→\n   122→fn runRemove(\n   123→    graph: *DependencyGraph,\n   124→    ctx: *CommandContext,\n   125→    remove_args: anytype,\n   126→    global: args.GlobalOptions,\n   127→) !void {\n   128→    const structured_output = global.isStructuredOutput();\n   129→    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n   130→        const msg = if (err == DependencyGraphError.IssueNotFound)\n   131→            \"issue not found\"\n   132→        else\n   133→            \"failed to remove dependency\";\n   134→        try outputError(&ctx.output, structured_output, msg);\n   135→\n   136→        return if (err == DependencyGraphError.IssueNotFound)\n   137→            DepError.IssueNotFound\n   138→        else\n   139→            DepError.StorageError;\n   140→    };\n   141→\n   142→    try ctx.saveIfAutoFlush();\n   143→\n   144→    if (structured_output) {\n   145→        try ctx.output.printJson(DepResult{\n   146→            .success = true,\n   147→            .action = \"removed\",\n   148→            .child = remove_args.child,\n   149→            .parent = remove_args.parent,\n   150→        });\n   151→    } else if (!global.quiet) {\n   152→        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n   153→    }\n   154→}\n   155→\n   156→fn runList(\n   157→    graph: *DependencyGraph,\n   158→    output: *common.Output,\n   159→    list_args: anytype,\n   160→    global: args.GlobalOptions,\n   161→    allocator: std.mem.Allocator,\n   162→) !void {\n   163→    const deps = try graph.getDependencies(list_args.id);\n   164→    defer graph.freeDependencies(deps);\n   165→\n   166→    const dependents = try graph.getDependents(list_args.id);\n   167→    defer graph.freeDependencies(dependents);\n   168→\n   169→    if (global.isStructuredOutput()) {\n   170→        var depends_on_ids: ?[][]const u8 = null;\n   171→        var blocks_ids: ?[][]const u8 = null;\n   172→\n   173→        if (deps.len > 0) {\n   174→            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n   175→            for (deps, 0..) |dep, i| {\n   176→                depends_on_ids.?[i] = dep.depends_on_id;\n   177→            }\n   178→        }\n   179→\n   180→        if (dependents.len > 0) {\n   181→            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n   182→            for (dependents, 0..) |dep, i| {\n   183→                blocks_ids.?[i] = dep.issue_id;\n   184→            }\n   185→        }\n   186→\n   187→        defer {\n   188→            if (depends_on_ids) |ids| allocator.free(ids);\n   189→            if (blocks_ids) |ids| allocator.free(ids);\n   190→        }\n   191→\n   192→        try output.printJson(DepResult{\n   193→            .success = true,\n   194→            .depends_on = depends_on_ids,\n   195→            .blocks = blocks_ids,\n   196→        });\n   197→    } else {\n   198→        if (deps.len > 0) {\n   199→            try output.println(\"Depends on:\", .{});\n   200→            for (deps) |dep| {\n   201→                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n   202→            }\n   203→        } else {\n   204→            try output.println(\"Depends on: (none)\", .{});\n   205→        }\n   206→\n   207→        if (dependents.len > 0) {\n   208→            try output.println(\"Blocks:\", .{});\n   209→            for (dependents) |dep| {\n   210→                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n   211→            }\n   212→        } else {\n   213→            try output.println(\"Blocks: (none)\", .{});\n   214→        }\n   215→    }\n   216→}\n   217→\n   218→/// Tree node for JSON output.\n   219→const TreeNode = struct {\n   220→    id: []const u8,\n   221→    title: []const u8,\n   222→    status: []const u8,\n   223→    children: ?[]const TreeNode = null,\n   224→};\n   225→\n   226→fn runTree(\n   227→    graph: *DependencyGraph,\n   228→    ctx: *CommandContext,\n   229→    tree_args: anytype,\n   230→    global: args.GlobalOptions,\n   231→    allocator: std.mem.Allocator,\n   232→) !void {\n   233→    const id = tree_args.id;\n   234→\n   235→    // Check if issue exists\n   236→    const issue = try ctx.store.get(id);\n   237→    if (issue == null) {\n   238→        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n   239→        return DepError.IssueNotFound;\n   240→    }\n   241→    var i = issue.?;\n   242→    defer i.deinit(allocator);\n   243→\n   244→    if (global.isStructuredOutput()) {\n   245→        // Build tree structure for JSON output\n   246→        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n   247→        defer freeTreeNode(root, allocator);\n   248→\n   249→        try ctx.output.printJson(.{\n   250→            .success = true,\n   251→            .tree = root,\n   252→        });\n   253→    } else {\n   254→        // ASCII tree output\n   255→        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n   256→\n   257→        // Show what this issue depends on (upstream dependencies)\n   258→        const deps = try graph.getDependencies(id);\n   259→        defer graph.freeDependencies(deps);\n   260→\n   261→        if (deps.len > 0) {\n   262→            try ctx.output.println(\"Depends on:\", .{});\n   263→            var visited: std.StringHashMapUnmanaged(void) = .{};\n   264→            defer {\n   265→                var it = visited.keyIterator();\n   266→                while (it.next()) |key| allocator.free(key.*);\n   267→                visited.deinit(allocator);\n   268→            }\n   269→\n   270→            for (deps, 0..) |dep, idx| {\n   271→                const is_last = (idx == deps.len - 1);\n   272→                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n   273→            }\n   274→        }\n   275→\n   276→        // Show what depends on this issue (downstream dependents)\n   277→        const dependents = try graph.getDependents(id);\n   278→        defer graph.freeDependencies(dependents);\n   279→\n   280→        if (dependents.len > 0) {\n   281→            try ctx.output.print(\"\\n\", .{});\n   282→            try ctx.output.println(\"Blocked by this:\", .{});\n   283→            for (dependents, 0..) |dep, idx| {\n   284→                const is_last = (idx == dependents.len - 1);\n   285→                const prefix = if (is_last) \"`-- \" else \"|-- \";\n   286→                const dep_issue = try ctx.store.get(dep.issue_id);\n   287→                if (dep_issue) |di| {\n   288→                    var d = di;\n   289→                    defer d.deinit(allocator);\n   290→                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n   291→                } else {\n   292→                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n   293→                }\n   294→            }\n   295→        }\n   296→    }\n   297→}\n   298→\n   299→fn printTreeBranch(\n   300→    output: *common.Output,\n   301→    graph: *DependencyGraph,\n   302→    ctx: *CommandContext,\n   303→    id: []const u8,\n   304→    prefix: []const u8,\n   305→    is_last: bool,\n   306→    visited: *std.StringHashMapUnmanaged(void),\n   307→    allocator: std.mem.Allocator,\n   308→    depth: usize,\n   309→    max_depth: usize,\n   310→) !void {\n   311→    // Check for cycles\n   312→    if (visited.contains(id)) {\n   313→        const branch = if (is_last) \"`-- \" else \"|-- \";\n   314→        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n   315→        return;\n   316→    }\n   317→\n   318→    // Depth limit\n   319→    if (depth >= max_depth) {\n   320→        const branch = if (is_last) \"`-- \" else \"|-- \";\n   321→        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n   322→        return;\n   323→    }\n   324→\n   325→    // Mark as visited\n   326→    const id_copy = try allocator.dupe(u8, id);\n   327→    errdefer allocator.free(id_copy);\n   328→    try visited.put(allocator, id_copy, {});\n   329→\n   330→    // Get issue details\n   331→    const issue = try ctx.store.get(id);\n   332→    const branch = if (is_last) \"`-- \" else \"|-- \";\n   333→\n   334→    if (issue) |i| {\n   335→        var iss = i;\n   336→        defer iss.deinit(allocator);\n   337→        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n   338→    } else {\n   339→        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n   340→        return;\n   341→    }\n   342→\n   343→    // Get dependencies of this issue\n   344→    const deps = try graph.getDependencies(id);\n   345→    defer graph.freeDependencies(deps);\n   346→\n   347→    // Build new prefix for children\n   348→    var new_prefix_buf: [256]u8 = undefined;\n   349→    const extension = if (is_last) \"    \" else \"|   \";\n   350→    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n   351→\n   352→    for (deps, 0..) |dep, idx| {\n   353→        const child_is_last = (idx == deps.len - 1);\n   354→        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n   355→    }\n   356→}\n   357→\n   358→fn buildTreeNode(\n   359→    graph: *DependencyGraph,\n   360→    ctx: *CommandContext,\n   361→    id: []const u8,\n   362→    allocator: std.mem.Allocator,\n   363→    depth: usize,\n   364→    max_depth: usize,\n   365→) !TreeNode {\n   366→    const issue = try ctx.store.get(id);\n   367→    var title: []const u8 = \"(not found)\";\n   368→    var status: []const u8 = \"unknown\";\n   369→\n   370→    if (issue) |i| {\n   371→        var iss = i;\n   372→        defer iss.deinit(allocator);\n   373→        title = try allocator.dupe(u8, iss.title);\n   374→        status = iss.status.toString();\n   375→    }\n   376→\n   377→    if (depth >= max_depth) {\n   378→        return TreeNode{\n   379→            .id = try allocator.dupe(u8, id),\n   380→            .title = title,\n   381→            .status = try allocator.dupe(u8, status),\n   382→            .children = null,\n   383→        };\n   384→    }\n   385→\n   386→    const deps = try graph.getDependencies(id);\n   387→    defer graph.freeDependencies(deps);\n   388→\n   389→    var children: ?[]TreeNode = null;\n   390→    if (deps.len > 0) {\n   391→        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n   392→        for (deps, 0..) |dep, idx| {\n   393→            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n   394→        }\n   395→        children = child_nodes;\n   396→    }\n   397→\n   398→    return TreeNode{\n   399→        .id = try allocator.dupe(u8, id),\n   400→        .title = title,\n   401→        .status = try allocator.dupe(u8, status),\n   402→        .children = children,\n   403→    };\n   404→}\n   405→\n   406→fn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n   407→    allocator.free(node.id);\n   408→    allocator.free(node.title);\n   409→    allocator.free(node.status);\n   410→    if (node.children) |children| {\n   411→        for (children) |child| {\n   412→            freeTreeNode(child, allocator);\n   413→        }\n   414→        allocator.free(children);\n   415→    }\n   416→}\n   417→\n   418→fn runCycles(\n   419→    graph: *DependencyGraph,\n   420→    output: *common.Output,\n   421→    global: args.GlobalOptions,\n   422→    allocator: std.mem.Allocator,\n   423→) !void {\n   424→    const cycles = try graph.detectCycles();\n   425→    const structured_output = global.isStructuredOutput();\n   426→\n   427→    if (cycles) |c| {\n   428→        defer graph.freeCycles(c);\n   429→\n   430→        if (structured_output) {\n   431→            var cycle_strs = try allocator.alloc([]const u8, c.len);\n   432→            defer allocator.free(cycle_strs);\n   433→            for (c, 0..) |cycle, i| {\n   434→                cycle_strs[i] = cycle;\n   435→            }\n   436→            try output.printJson(.{\n   437→                .success = true,\n   438→                .cycles_found = true,\n   439→                .cycles = cycle_strs,\n   440→            });\n   441→        } else {\n   442→            try output.warn(\"Cycles detected:\", .{});\n   443→            for (c) |cycle| {\n   444→                try output.print(\"  {s}\\n\", .{cycle});\n   445→            }\n   446→        }\n   447→    } else {\n   448→        if (structured_output) {\n   449→            try output.printJson(.{\n   450→                .success = true,\n   451→                .cycles_found = false,\n   452→            });\n   453→        } else {\n   454→            try output.success(\"No cycles detected\", .{});\n   455→        }\n   456→    }\n   457→}\n   458→\n   459→fn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n   460→    if (json_mode) {\n   461→        try output.printJson(DepResult{\n   462→            .success = false,\n   463→            .message = message,\n   464→        });\n   465→    } else {\n   466→        try output.err(\"{s}\", .{message});\n   467→    }\n   468→}\n   469→\n   470→// --- Tests ---\n   471→\n   472→test \"DepError enum exists\" {\n   473→    const err: DepError = DepError.CycleDetected;\n   474→    try std.testing.expect(err == DepError.CycleDetected);\n   475→}\n   476→\n   477→test \"DepResult struct works\" {\n   478→    const result = DepResult{\n   479→        .success = true,\n   480→        .action = \"added\",\n   481→        .child = \"bd-child\",\n   482→        .parent = \"bd-parent\",\n   483→    };\n   484→    try std.testing.expect(result.success);\n   485→    try std.testing.expectEqualStrings(\"added\", result.action.?);\n   486→}\n   487→\n   488→test \"run detects uninitialized workspace\" {\n   489→    const allocator = std.testing.allocator;\n   490→\n   491→    const dep_args = args.DepArgs{\n   492→        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   493→    };\n   494→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   495→\n   496→    const result = run(dep_args, global, allocator);\n   497→    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n   498→}\n   499→\n   500→test \"runList returns empty for empty workspace\" {\n   501→    const allocator = std.testing.allocator;\n   502→\n   503→    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n   504→    defer allocator.free(tmp_dir_path);\n   505→    defer test_util.cleanupTestDir(tmp_dir_path);\n   506→\n   507→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   508→    defer allocator.free(data_path);\n   509→\n   510→    try std.fs.cwd().makeDir(data_path);\n   511→\n   512→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   513→    defer allocator.free(issues_path);\n   514→\n   515→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   516→    f.close();\n   517→\n   518→    const dep_args = args.DepArgs{\n   519→        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   520→    };\n   521→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   522→\n   523→    try run(dep_args, global, allocator);\n   524→}\n   525→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d91f04e5-a1e6-4496-a73f-d773b65697a1"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TiduPeyzTS8AAoi7ZMYa1x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TaYS8kPaRvg3LjA9ZaNgqr","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":676,"cache_read_input_tokens":13187,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":676},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b24e1d88-abea-4933-b68a-29f02a069b7d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TaYS8kPaRvg3LjA9ZaNgqr","type":"tool_result","content":"     1→//! Label commands for beads_zig.\n     2→//!\n     3→//! `bz label add <id> <labels...>` - Add labels to an issue\n     4→//! `bz label remove <id> <labels...>` - Remove labels from an issue\n     5→//! `bz label list <id>` - List labels on an issue\n     6→//! `bz label list-all` - List all labels in the project\n     7→\n     8→const std = @import(\"std\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→\n    12→const CommandContext = common.CommandContext;\n    13→\n    14→pub const LabelError = error{\n    15→    WorkspaceNotInitialized,\n    16→    StorageError,\n    17→    IssueNotFound,\n    18→    OutOfMemory,\n    19→};\n    20→\n    21→pub const LabelResult = struct {\n    22→    success: bool,\n    23→    id: ?[]const u8 = null,\n    24→    labels: ?[]const []const u8 = null,\n    25→    added: ?[]const []const u8 = null,\n    26→    removed: ?[]const []const u8 = null,\n    27→    message: ?[]const u8 = null,\n    28→};\n    29→\n    30→pub fn run(\n    31→    label_args: args.LabelArgs,\n    32→    global: args.GlobalOptions,\n    33→    allocator: std.mem.Allocator,\n    34→) !void {\n    35→    switch (label_args.subcommand) {\n    36→        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n    37→        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n    38→        .list => |list| try runList(list.id, global, allocator),\n    39→        .list_all => try runListAll(global, allocator),\n    40→    }\n    41→}\n    42→\n    43→fn runAdd(\n    44→    id: []const u8,\n    45→    labels: []const []const u8,\n    46→    global: args.GlobalOptions,\n    47→    allocator: std.mem.Allocator,\n    48→) !void {\n    49→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    50→        return LabelError.WorkspaceNotInitialized;\n    51→    };\n    52→    defer ctx.deinit();\n    53→\n    54→    // Verify issue exists\n    55→    if (!try ctx.store.exists(id)) {\n    56→        if (global.isStructuredOutput()) {\n    57→            try ctx.output.printJson(LabelResult{\n    58→                .success = false,\n    59→                .id = id,\n    60→                .message = \"issue not found\",\n    61→            });\n    62→        } else {\n    63→            try ctx.output.err(\"issue not found: {s}\", .{id});\n    64→        }\n    65→        return LabelError.IssueNotFound;\n    66→    }\n    67→\n    68→    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    69→    defer added_labels.deinit(allocator);\n    70→\n    71→    for (labels) |label| {\n    72→        // Check if already has label\n    73→        const existing = try ctx.store.getLabels(id);\n    74→        defer {\n    75→            for (existing) |lbl| {\n    76→                allocator.free(lbl);\n    77→            }\n    78→            allocator.free(existing);\n    79→        }\n    80→\n    81→        var has_label = false;\n    82→        for (existing) |existing_label| {\n    83→            if (std.mem.eql(u8, existing_label, label)) {\n    84→                has_label = true;\n    85→                break;\n    86→            }\n    87→        }\n    88→\n    89→        if (!has_label) {\n    90→            try ctx.store.addLabel(id, label);\n    91→            try added_labels.append(allocator, label);\n    92→        }\n    93→    }\n    94→\n    95→    try ctx.saveIfAutoFlush();\n    96→\n    97→    if (global.isStructuredOutput()) {\n    98→        try ctx.output.printJson(LabelResult{\n    99→            .success = true,\n   100→            .id = id,\n   101→            .added = added_labels.items,\n   102→        });\n   103→    } else if (global.quiet) {\n   104→        for (added_labels.items) |label| {\n   105→            try ctx.output.print(\"{s}\\n\", .{label});\n   106→        }\n   107→    } else {\n   108→        if (added_labels.items.len > 0) {\n   109→            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n   110→        } else {\n   111→            try ctx.output.info(\"No new labels added (already present)\", .{});\n   112→        }\n   113→    }\n   114→}\n   115→\n   116→fn runRemove(\n   117→    id: []const u8,\n   118→    labels: []const []const u8,\n   119→    global: args.GlobalOptions,\n   120→    allocator: std.mem.Allocator,\n   121→) !void {\n   122→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   123→        return LabelError.WorkspaceNotInitialized;\n   124→    };\n   125→    defer ctx.deinit();\n   126→\n   127→    // Verify issue exists\n   128→    if (!try ctx.store.exists(id)) {\n   129→        if (global.isStructuredOutput()) {\n   130→            try ctx.output.printJson(LabelResult{\n   131→                .success = false,\n   132→                .id = id,\n   133→                .message = \"issue not found\",\n   134→            });\n   135→        } else {\n   136→            try ctx.output.err(\"issue not found: {s}\", .{id});\n   137→        }\n   138→        return LabelError.IssueNotFound;\n   139→    }\n   140→\n   141→    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n   142→    defer removed_labels.deinit(allocator);\n   143→\n   144→    for (labels) |label| {\n   145→        // Check if has label\n   146→        const existing = try ctx.store.getLabels(id);\n   147→        defer {\n   148→            for (existing) |lbl| {\n   149→                allocator.free(lbl);\n   150→            }\n   151→            allocator.free(existing);\n   152→        }\n   153→\n   154→        var has_label = false;\n   155→        for (existing) |existing_label| {\n   156→            if (std.mem.eql(u8, existing_label, label)) {\n   157→                has_label = true;\n   158→                break;\n   159→            }\n   160→        }\n   161→\n   162→        if (has_label) {\n   163→            try ctx.store.removeLabel(id, label);\n   164→            try removed_labels.append(allocator, label);\n   165→        }\n   166→    }\n   167→\n   168→    try ctx.saveIfAutoFlush();\n   169→\n   170→    if (global.isStructuredOutput()) {\n   171→        try ctx.output.printJson(LabelResult{\n   172→            .success = true,\n   173→            .id = id,\n   174→            .removed = removed_labels.items,\n   175→        });\n   176→    } else if (global.quiet) {\n   177→        for (removed_labels.items) |label| {\n   178→            try ctx.output.print(\"{s}\\n\", .{label});\n   179→        }\n   180→    } else {\n   181→        if (removed_labels.items.len > 0) {\n   182→            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n   183→        } else {\n   184→            try ctx.output.info(\"No labels removed (not present)\", .{});\n   185→        }\n   186→    }\n   187→}\n   188→\n   189→fn runList(\n   190→    id: []const u8,\n   191→    global: args.GlobalOptions,\n   192→    allocator: std.mem.Allocator,\n   193→) !void {\n   194→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   195→        return LabelError.WorkspaceNotInitialized;\n   196→    };\n   197→    defer ctx.deinit();\n   198→\n   199→    // Verify issue exists\n   200→    if (!try ctx.store.exists(id)) {\n   201→        if (global.isStructuredOutput()) {\n   202→            try ctx.output.printJson(LabelResult{\n   203→                .success = false,\n   204→                .id = id,\n   205→                .message = \"issue not found\",\n   206→            });\n   207→        } else {\n   208→            try ctx.output.err(\"issue not found: {s}\", .{id});\n   209→        }\n   210→        return LabelError.IssueNotFound;\n   211→    }\n   212→\n   213→    const label_list = try ctx.store.getLabels(id);\n   214→    defer {\n   215→        for (label_list) |lbl| {\n   216→            allocator.free(lbl);\n   217→        }\n   218→        allocator.free(label_list);\n   219→    }\n   220→\n   221→    if (global.isStructuredOutput()) {\n   222→        try ctx.output.printJson(LabelResult{\n   223→            .success = true,\n   224→            .id = id,\n   225→            .labels = label_list,\n   226→        });\n   227→    } else if (global.quiet) {\n   228→        for (label_list) |label| {\n   229→            try ctx.output.print(\"{s}\\n\", .{label});\n   230→        }\n   231→    } else {\n   232→        if (label_list.len == 0) {\n   233→            try ctx.output.info(\"No labels on {s}\", .{id});\n   234→        } else {\n   235→            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n   236→            for (label_list) |label| {\n   237→                try ctx.output.print(\"  {s}\\n\", .{label});\n   238→            }\n   239→        }\n   240→    }\n   241→}\n   242→\n   243→fn runListAll(\n   244→    global: args.GlobalOptions,\n   245→    allocator: std.mem.Allocator,\n   246→) !void {\n   247→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   248→        return LabelError.WorkspaceNotInitialized;\n   249→    };\n   250→    defer ctx.deinit();\n   251→\n   252→    // Collect all unique labels across all issues\n   253→    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n   254→    defer {\n   255→        var key_it = all_labels.keyIterator();\n   256→        while (key_it.next()) |key| {\n   257→            allocator.free(key.*);\n   258→        }\n   259→        all_labels.deinit(allocator);\n   260→    }\n   261→\n   262→    for (ctx.store.issues.items) |issue| {\n   263→        if (issue.status.eql(.tombstone)) continue;\n   264→\n   265→        for (issue.labels) |label| {\n   266→            if (!all_labels.contains(label)) {\n   267→                const label_copy = try allocator.dupe(u8, label);\n   268→                try all_labels.put(allocator, label_copy, {});\n   269→            }\n   270→        }\n   271→    }\n   272→\n   273→    // Convert to sorted slice\n   274→    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n   275→    defer label_list.deinit(allocator);\n   276→\n   277→    var key_it = all_labels.keyIterator();\n   278→    while (key_it.next()) |key| {\n   279→        try label_list.append(allocator, key.*);\n   280→    }\n   281→\n   282→    // Sort alphabetically\n   283→    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n   284→        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n   285→            return std.mem.lessThan(u8, a, b);\n   286→        }\n   287→    }.lessThan);\n   288→\n   289→    if (global.isStructuredOutput()) {\n   290→        try ctx.output.printJson(LabelResult{\n   291→            .success = true,\n   292→            .labels = label_list.items,\n   293→        });\n   294→    } else if (global.quiet) {\n   295→        for (label_list.items) |label| {\n   296→            try ctx.output.print(\"{s}\\n\", .{label});\n   297→        }\n   298→    } else {\n   299→        if (label_list.items.len == 0) {\n   300→            try ctx.output.info(\"No labels in project\", .{});\n   301→        } else {\n   302→            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n   303→            for (label_list.items) |label| {\n   304→                try ctx.output.print(\"  {s}\\n\", .{label});\n   305→            }\n   306→        }\n   307→    }\n   308→}\n   309→\n   310→// --- Tests ---\n   311→\n   312→test \"LabelError enum exists\" {\n   313→    const err: LabelError = LabelError.WorkspaceNotInitialized;\n   314→    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n   315→}\n   316→\n   317→test \"LabelResult struct works\" {\n   318→    const result = LabelResult{\n   319→        .success = true,\n   320→        .id = \"bd-test\",\n   321→    };\n   322→    try std.testing.expect(result.success);\n   323→    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n   324→}\n   325→\n   326→test \"runAdd detects uninitialized workspace\" {\n   327→    const allocator = std.testing.allocator;\n   328→    const labels = [_][]const u8{\"test\"};\n   329→\n   330→    const label_args = args.LabelArgs{\n   331→        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n   332→    };\n   333→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   334→\n   335→    const result = run(label_args, global, allocator);\n   336→    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   337→}\n   338→\n   339→test \"runList detects uninitialized workspace\" {\n   340→    const allocator = std.testing.allocator;\n   341→\n   342→    const label_args = args.LabelArgs{\n   343→        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   344→    };\n   345→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   346→\n   347→    const result = run(label_args, global, allocator);\n   348→    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   349→}\n   350→\n   351→test \"runListAll detects uninitialized workspace\" {\n   352→    const allocator = std.testing.allocator;\n   353→\n   354→    const label_args = args.LabelArgs{\n   355→        .subcommand = .{ .list_all = {} },\n   356→    };\n   357→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   358→\n   359→    const result = run(label_args, global, allocator);\n   360→    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   361→}\n   362→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"f17a1598-51ae-4a61-843e-729d74241bd8"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TiduPeyzTS8AAoi7ZMYa1x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013GXpHYHTPbmj426aFRwuci","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/dependency.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":676,"cache_read_input_tokens":13187,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":676},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"472c6986-96a7-4183-99ea-ba8d9d60fe95"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013GXpHYHTPbmj426aFRwuci","type":"tool_result","content":"     1→//! Dependency types and the Dependency struct for tracking relationships between issues.\n     2→//!\n     3→//! Dependencies model the relationships between issues - blocking relationships,\n     4→//! parent-child hierarchies, and other associations. The dependency graph\n     5→//! enables the \"ready\" query (issues with no blockers) and cycle detection.\n     6→\n     7→const std = @import(\"std\");\n     8→\n     9→/// Dependency relationship types between issues.\n    10→pub const DependencyType = union(enum) {\n    11→    blocks,\n    12→    parent_child,\n    13→    conditional_blocks,\n    14→    waits_for,\n    15→    related,\n    16→    discovered_from,\n    17→    replies_to,\n    18→    relates_to,\n    19→    duplicates,\n    20→    supersedes,\n    21→    caused_by,\n    22→    custom: []const u8,\n    23→\n    24→    const Self = @This();\n    25→\n    26→    /// Convert DependencyType to its string representation.\n    27→    pub fn toString(self: Self) []const u8 {\n    28→        return switch (self) {\n    29→            .blocks => \"blocks\",\n    30→            .parent_child => \"parent_child\",\n    31→            .conditional_blocks => \"conditional_blocks\",\n    32→            .waits_for => \"waits_for\",\n    33→            .related => \"related\",\n    34→            .discovered_from => \"discovered_from\",\n    35→            .replies_to => \"replies_to\",\n    36→            .relates_to => \"relates_to\",\n    37→            .duplicates => \"duplicates\",\n    38→            .supersedes => \"supersedes\",\n    39→            .caused_by => \"caused_by\",\n    40→            .custom => |s| s,\n    41→        };\n    42→    }\n    43→\n    44→    /// Parse a string into a DependencyType (case-insensitive for known values).\n    45→    /// Returns .custom for unknown values.\n    46→    pub fn fromString(s: []const u8) Self {\n    47→        if (std.ascii.eqlIgnoreCase(s, \"blocks\")) return .blocks;\n    48→        if (std.ascii.eqlIgnoreCase(s, \"parent_child\")) return .parent_child;\n    49→        if (std.ascii.eqlIgnoreCase(s, \"conditional_blocks\")) return .conditional_blocks;\n    50→        if (std.ascii.eqlIgnoreCase(s, \"waits_for\")) return .waits_for;\n    51→        if (std.ascii.eqlIgnoreCase(s, \"related\")) return .related;\n    52→        if (std.ascii.eqlIgnoreCase(s, \"discovered_from\")) return .discovered_from;\n    53→        if (std.ascii.eqlIgnoreCase(s, \"replies_to\")) return .replies_to;\n    54→        if (std.ascii.eqlIgnoreCase(s, \"relates_to\")) return .relates_to;\n    55→        if (std.ascii.eqlIgnoreCase(s, \"duplicates\")) return .duplicates;\n    56→        if (std.ascii.eqlIgnoreCase(s, \"supersedes\")) return .supersedes;\n    57→        if (std.ascii.eqlIgnoreCase(s, \"caused_by\")) return .caused_by;\n    58→        return .{ .custom = s };\n    59→    }\n    60→\n    61→    /// Check equality between two DependencyTypes.\n    62→    pub fn eql(a: Self, b: Self) bool {\n    63→        const Tag = std.meta.Tag(Self);\n    64→        const tag_a: Tag = a;\n    65→        const tag_b: Tag = b;\n    66→        if (tag_a != tag_b) return false;\n    67→        return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n    68→    }\n    69→\n    70→    /// JSON serialization for std.json.\n    71→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    72→        try jws.write(self.toString());\n    73→    }\n    74→\n    75→    /// JSON deserialization for std.json.\n    76→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    77→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    78→        const str = switch (token) {\n    79→            .string, .allocated_string => |s| s,\n    80→            else => return error.UnexpectedToken,\n    81→        };\n    82→        return fromString(str);\n    83→    }\n    84→\n    85→    /// JSON deserialization from already-parsed value.\n    86→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    87→        _ = allocator;\n    88→        _ = options;\n    89→        return switch (source) {\n    90→            .string => |s| fromString(s),\n    91→            else => error.UnexpectedToken,\n    92→        };\n    93→    }\n    94→};\n    95→\n    96→/// A dependency relationship between two issues.\n    97→/// issue_id depends ON depends_on_id (issue_id is blocked BY depends_on_id).\n    98→pub const Dependency = struct {\n    99→    issue_id: []const u8,\n   100→    depends_on_id: []const u8,\n   101→    dep_type: DependencyType,\n   102→    created_at: i64,\n   103→    created_by: ?[]const u8,\n   104→    metadata: ?[]const u8,\n   105→    thread_id: ?[]const u8,\n   106→\n   107→    const Self = @This();\n   108→\n   109→    /// Check deep equality between two Dependencies.\n   110→    pub fn eql(a: Self, b: Self) bool {\n   111→        if (!std.mem.eql(u8, a.issue_id, b.issue_id)) return false;\n   112→        if (!std.mem.eql(u8, a.depends_on_id, b.depends_on_id)) return false;\n   113→        if (!DependencyType.eql(a.dep_type, b.dep_type)) return false;\n   114→        if (a.created_at != b.created_at) return false;\n   115→        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n   116→        if (!optionalStrEql(a.metadata, b.metadata)) return false;\n   117→        if (!optionalStrEql(a.thread_id, b.thread_id)) return false;\n   118→        return true;\n   119→    }\n   120→\n   121→    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n   122→        const a_val = a orelse return b == null;\n   123→        const b_val = b orelse return false;\n   124→        return std.mem.eql(u8, a_val, b_val);\n   125→    }\n   126→};\n   127→\n   128→// --- DependencyType Tests ---\n   129→\n   130→test \"DependencyType.toString returns correct strings for known types\" {\n   131→    try std.testing.expectEqualStrings(\"blocks\", (DependencyType{ .blocks = {} }).toString());\n   132→    try std.testing.expectEqualStrings(\"parent_child\", (DependencyType{ .parent_child = {} }).toString());\n   133→    try std.testing.expectEqualStrings(\"conditional_blocks\", (DependencyType{ .conditional_blocks = {} }).toString());\n   134→    try std.testing.expectEqualStrings(\"waits_for\", (DependencyType{ .waits_for = {} }).toString());\n   135→    try std.testing.expectEqualStrings(\"related\", (DependencyType{ .related = {} }).toString());\n   136→    try std.testing.expectEqualStrings(\"discovered_from\", (DependencyType{ .discovered_from = {} }).toString());\n   137→    try std.testing.expectEqualStrings(\"replies_to\", (DependencyType{ .replies_to = {} }).toString());\n   138→    try std.testing.expectEqualStrings(\"relates_to\", (DependencyType{ .relates_to = {} }).toString());\n   139→    try std.testing.expectEqualStrings(\"duplicates\", (DependencyType{ .duplicates = {} }).toString());\n   140→    try std.testing.expectEqualStrings(\"supersedes\", (DependencyType{ .supersedes = {} }).toString());\n   141→    try std.testing.expectEqualStrings(\"caused_by\", (DependencyType{ .caused_by = {} }).toString());\n   142→}\n   143→\n   144→test \"DependencyType.toString returns custom string for custom type\" {\n   145→    const custom = DependencyType{ .custom = \"my_custom_dep\" };\n   146→    try std.testing.expectEqualStrings(\"my_custom_dep\", custom.toString());\n   147→}\n   148→\n   149→test \"DependencyType.fromString parses known types correctly\" {\n   150→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"blocks\"));\n   151→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"parent_child\"));\n   152→    try std.testing.expectEqual(DependencyType.conditional_blocks, DependencyType.fromString(\"conditional_blocks\"));\n   153→    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"waits_for\"));\n   154→    try std.testing.expectEqual(DependencyType.related, DependencyType.fromString(\"related\"));\n   155→    try std.testing.expectEqual(DependencyType.discovered_from, DependencyType.fromString(\"discovered_from\"));\n   156→    try std.testing.expectEqual(DependencyType.replies_to, DependencyType.fromString(\"replies_to\"));\n   157→    try std.testing.expectEqual(DependencyType.relates_to, DependencyType.fromString(\"relates_to\"));\n   158→    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"duplicates\"));\n   159→    try std.testing.expectEqual(DependencyType.supersedes, DependencyType.fromString(\"supersedes\"));\n   160→    try std.testing.expectEqual(DependencyType.caused_by, DependencyType.fromString(\"caused_by\"));\n   161→}\n   162→\n   163→test \"DependencyType.fromString is case-insensitive\" {\n   164→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"BLOCKS\"));\n   165→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"Blocks\"));\n   166→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"bLoCkS\"));\n   167→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"PARENT_CHILD\"));\n   168→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"Parent_Child\"));\n   169→    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"WAITS_FOR\"));\n   170→    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"DUPLICATES\"));\n   171→}\n   172→\n   173→test \"DependencyType.fromString returns custom for unknown values\" {\n   174→    const result = DependencyType.fromString(\"unknown_dep_type\");\n   175→    switch (result) {\n   176→        .custom => |s| try std.testing.expectEqualStrings(\"unknown_dep_type\", s),\n   177→        else => return error.TestExpectedCustom,\n   178→    }\n   179→}\n   180→\n   181→test \"DependencyType toString/fromString roundtrip for known types\" {\n   182→    const dep_types = [_]DependencyType{\n   183→        .blocks,\n   184→        .parent_child,\n   185→        .conditional_blocks,\n   186→        .waits_for,\n   187→        .related,\n   188→        .discovered_from,\n   189→        .replies_to,\n   190→        .relates_to,\n   191→        .duplicates,\n   192→        .supersedes,\n   193→        .caused_by,\n   194→    };\n   195→\n   196→    for (dep_types) |dep_type| {\n   197→        const str = dep_type.toString();\n   198→        const parsed = DependencyType.fromString(str);\n   199→        try std.testing.expectEqual(dep_type, parsed);\n   200→    }\n   201→}\n   202→\n   203→test \"DependencyType toString/fromString roundtrip for custom type\" {\n   204→    const original = DependencyType{ .custom = \"my_workflow_dep\" };\n   205→    const str = original.toString();\n   206→    const parsed = DependencyType.fromString(str);\n   207→\n   208→    switch (parsed) {\n   209→        .custom => |s| try std.testing.expectEqualStrings(\"my_workflow_dep\", s),\n   210→        else => return error.TestExpectedCustom,\n   211→    }\n   212→}\n   213→\n   214→test \"DependencyType.eql compares correctly\" {\n   215→    try std.testing.expect(DependencyType.eql(.blocks, .blocks));\n   216→    try std.testing.expect(DependencyType.eql(.parent_child, .parent_child));\n   217→    try std.testing.expect(!DependencyType.eql(.blocks, .parent_child));\n   218→    try std.testing.expect(!DependencyType.eql(.waits_for, .duplicates));\n   219→\n   220→    const custom1 = DependencyType{ .custom = \"foo\" };\n   221→    const custom2 = DependencyType{ .custom = \"foo\" };\n   222→    const custom3 = DependencyType{ .custom = \"bar\" };\n   223→    try std.testing.expect(DependencyType.eql(custom1, custom2));\n   224→    try std.testing.expect(!DependencyType.eql(custom1, custom3));\n   225→    try std.testing.expect(!DependencyType.eql(custom1, .blocks));\n   226→}\n   227→\n   228→test \"DependencyType JSON serialization roundtrip\" {\n   229→    const allocator = std.testing.allocator;\n   230→\n   231→    const dep_types = [_]DependencyType{\n   232→        .blocks,\n   233→        .parent_child,\n   234→        .conditional_blocks,\n   235→        .waits_for,\n   236→        .related,\n   237→        .discovered_from,\n   238→        .replies_to,\n   239→        .relates_to,\n   240→        .duplicates,\n   241→        .supersedes,\n   242→        .caused_by,\n   243→    };\n   244→\n   245→    for (dep_types) |dep_type| {\n   246→        var aw: std.io.Writer.Allocating = .init(allocator);\n   247→        defer aw.deinit();\n   248→\n   249→        try std.json.Stringify.value(dep_type, .{}, &aw.writer);\n   250→        const json_str = aw.written();\n   251→\n   252→        const parsed = try std.json.parseFromSlice(DependencyType, allocator, json_str, .{});\n   253→        defer parsed.deinit();\n   254→\n   255→        try std.testing.expectEqual(dep_type, parsed.value);\n   256→    }\n   257→}\n   258→\n   259→test \"DependencyType JSON deserialization of custom type\" {\n   260→    const allocator = std.testing.allocator;\n   261→\n   262→    const json_str = \"\\\"custom_relationship\\\"\";\n   263→    const parsed = try std.json.parseFromSlice(DependencyType, allocator, json_str, .{});\n   264→    defer parsed.deinit();\n   265→\n   266→    switch (parsed.value) {\n   267→        .custom => |s| try std.testing.expectEqualStrings(\"custom_relationship\", s),\n   268→        else => return error.TestExpectedCustom,\n   269→    }\n   270→}\n   271→\n   272→test \"DependencyType JSON serializes as lowercase string\" {\n   273→    const allocator = std.testing.allocator;\n   274→\n   275→    var aw: std.io.Writer.Allocating = .init(allocator);\n   276→    defer aw.deinit();\n   277→\n   278→    try std.json.Stringify.value(DependencyType.blocks, .{}, &aw.writer);\n   279→\n   280→    try std.testing.expectEqualStrings(\"\\\"blocks\\\"\", aw.written());\n   281→}\n   282→\n   283→// --- Dependency Tests ---\n   284→\n   285→test \"Dependency.eql compares all fields\" {\n   286→    const dep1 = Dependency{\n   287→        .issue_id = \"bd-abc123\",\n   288→        .depends_on_id = \"bd-def456\",\n   289→        .dep_type = .blocks,\n   290→        .created_at = 1706540000,\n   291→        .created_by = \"alice@example.com\",\n   292→        .metadata = null,\n   293→        .thread_id = null,\n   294→    };\n   295→\n   296→    const dep2 = Dependency{\n   297→        .issue_id = \"bd-abc123\",\n   298→        .depends_on_id = \"bd-def456\",\n   299→        .dep_type = .blocks,\n   300→        .created_at = 1706540000,\n   301→        .created_by = \"alice@example.com\",\n   302→        .metadata = null,\n   303→        .thread_id = null,\n   304→    };\n   305→\n   306→    try std.testing.expect(Dependency.eql(dep1, dep2));\n   307→}\n   308→\n   309→test \"Dependency.eql detects issue_id difference\" {\n   310→    const dep1 = Dependency{\n   311→        .issue_id = \"bd-abc123\",\n   312→        .depends_on_id = \"bd-def456\",\n   313→        .dep_type = .blocks,\n   314→        .created_at = 1706540000,\n   315→        .created_by = null,\n   316→        .metadata = null,\n   317→        .thread_id = null,\n   318→    };\n   319→\n   320→    const dep2 = Dependency{\n   321→        .issue_id = \"bd-xyz789\",\n   322→        .depends_on_id = \"bd-def456\",\n   323→        .dep_type = .blocks,\n   324→        .created_at = 1706540000,\n   325→        .created_by = null,\n   326→        .metadata = null,\n   327→        .thread_id = null,\n   328→    };\n   329→\n   330→    try std.testing.expect(!Dependency.eql(dep1, dep2));\n   331→}\n   332→\n   333→test \"Dependency.eql detects dep_type difference\" {\n   334→    const dep1 = Dependency{\n   335→        .issue_id = \"bd-abc123\",\n   336→        .depends_on_id = \"bd-def456\",\n   337→        .dep_type = .blocks,\n   338→        .created_at = 1706540000,\n   339→        .created_by = null,\n   340→        .metadata = null,\n   341→        .thread_id = null,\n   342→    };\n   343→\n   344→    const dep2 = Dependency{\n   345→        .issue_id = \"bd-abc123\",\n   346→        .depends_on_id = \"bd-def456\",\n   347→        .dep_type = .waits_for,\n   348→        .created_at = 1706540000,\n   349→        .created_by = null,\n   350→        .metadata = null,\n   351→        .thread_id = null,\n   352→    };\n   353→\n   354→    try std.testing.expect(!Dependency.eql(dep1, dep2));\n   355→}\n   356→\n   357→test \"Dependency.eql detects optional field differences\" {\n   358→    const dep1 = Dependency{\n   359→        .issue_id = \"bd-abc123\",\n   360→        .depends_on_id = \"bd-def456\",\n   361→        .dep_type = .blocks,\n   362→        .created_at = 1706540000,\n   363→        .created_by = \"alice@example.com\",\n   364→        .metadata = null,\n   365→        .thread_id = null,\n   366→    };\n   367→\n   368→    const dep2 = Dependency{\n   369→        .issue_id = \"bd-abc123\",\n   370→        .depends_on_id = \"bd-def456\",\n   371→        .dep_type = .blocks,\n   372→        .created_at = 1706540000,\n   373→        .created_by = null,\n   374→        .metadata = null,\n   375→        .thread_id = null,\n   376→    };\n   377→\n   378→    try std.testing.expect(!Dependency.eql(dep1, dep2));\n   379→}\n   380→\n   381→test \"Dependency.eql handles metadata comparison\" {\n   382→    const dep1 = Dependency{\n   383→        .issue_id = \"bd-abc123\",\n   384→        .depends_on_id = \"bd-def456\",\n   385→        .dep_type = .blocks,\n   386→        .created_at = 1706540000,\n   387→        .created_by = null,\n   388→        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n   389→        .thread_id = null,\n   390→    };\n   391→\n   392→    const dep2 = Dependency{\n   393→        .issue_id = \"bd-abc123\",\n   394→        .depends_on_id = \"bd-def456\",\n   395→        .dep_type = .blocks,\n   396→        .created_at = 1706540000,\n   397→        .created_by = null,\n   398→        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n   399→        .thread_id = null,\n   400→    };\n   401→\n   402→    const dep3 = Dependency{\n   403→        .issue_id = \"bd-abc123\",\n   404→        .depends_on_id = \"bd-def456\",\n   405→        .dep_type = .blocks,\n   406→        .created_at = 1706540000,\n   407→        .created_by = null,\n   408→        .metadata = \"{\\\"other\\\":\\\"data\\\"}\",\n   409→        .thread_id = null,\n   410→    };\n   411→\n   412→    try std.testing.expect(Dependency.eql(dep1, dep2));\n   413→    try std.testing.expect(!Dependency.eql(dep1, dep3));\n   414→}\n   415→\n   416→test \"Dependency JSON serialization with all fields\" {\n   417→    const allocator = std.testing.allocator;\n   418→\n   419→    const dep = Dependency{\n   420→        .issue_id = \"bd-abc123\",\n   421→        .depends_on_id = \"bd-def456\",\n   422→        .dep_type = .blocks,\n   423→        .created_at = 1706540000,\n   424→        .created_by = \"alice@example.com\",\n   425→        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n   426→        .thread_id = \"thread-001\",\n   427→    };\n   428→\n   429→    var aw: std.io.Writer.Allocating = .init(allocator);\n   430→    defer aw.deinit();\n   431→\n   432→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   433→    const json_str = aw.written();\n   434→\n   435→    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n   436→    defer parsed.deinit();\n   437→\n   438→    try std.testing.expect(Dependency.eql(dep, parsed.value));\n   439→}\n   440→\n   441→test \"Dependency JSON serialization with null fields\" {\n   442→    const allocator = std.testing.allocator;\n   443→\n   444→    const dep = Dependency{\n   445→        .issue_id = \"bd-abc123\",\n   446→        .depends_on_id = \"bd-def456\",\n   447→        .dep_type = .parent_child,\n   448→        .created_at = 1706540000,\n   449→        .created_by = null,\n   450→        .metadata = null,\n   451→        .thread_id = null,\n   452→    };\n   453→\n   454→    var aw: std.io.Writer.Allocating = .init(allocator);\n   455→    defer aw.deinit();\n   456→\n   457→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   458→    const json_str = aw.written();\n   459→\n   460→    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n   461→    defer parsed.deinit();\n   462→\n   463→    try std.testing.expect(Dependency.eql(dep, parsed.value));\n   464→}\n   465→\n   466→test \"Dependency JSON serialization roundtrip with custom dep_type\" {\n   467→    const allocator = std.testing.allocator;\n   468→\n   469→    const dep = Dependency{\n   470→        .issue_id = \"bd-abc123\",\n   471→        .depends_on_id = \"bd-def456\",\n   472→        .dep_type = DependencyType{ .custom = \"my_custom_relation\" },\n   473→        .created_at = 1706540000,\n   474→        .created_by = \"bob@example.com\",\n   475→        .metadata = null,\n   476→        .thread_id = null,\n   477→    };\n   478→\n   479→    var aw: std.io.Writer.Allocating = .init(allocator);\n   480→    defer aw.deinit();\n   481→\n   482→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   483→    const json_str = aw.written();\n   484→\n   485→    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n   486→    defer parsed.deinit();\n   487→\n   488→    try std.testing.expectEqualStrings(dep.issue_id, parsed.value.issue_id);\n   489→    try std.testing.expectEqualStrings(dep.depends_on_id, parsed.value.depends_on_id);\n   490→    try std.testing.expectEqual(dep.created_at, parsed.value.created_at);\n   491→    switch (parsed.value.dep_type) {\n   492→        .custom => |s| try std.testing.expectEqualStrings(\"my_custom_relation\", s),\n   493→        else => return error.TestExpectedCustom,\n   494→    }\n   495→}\n   496→\n   497→test \"Dependency JSON contains expected fields\" {\n   498→    const allocator = std.testing.allocator;\n   499→\n   500→    const dep = Dependency{\n   501→        .issue_id = \"bd-test\",\n   502→        .depends_on_id = \"bd-blocker\",\n   503→        .dep_type = .blocks,\n   504→        .created_at = 1234567890,\n   505→        .created_by = null,\n   506→        .metadata = null,\n   507→        .thread_id = null,\n   508→    };\n   509→\n   510→    var aw: std.io.Writer.Allocating = .init(allocator);\n   511→    defer aw.deinit();\n   512→\n   513→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   514→    const json_str = aw.written();\n   515→\n   516→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"issue_id\\\"\") != null);\n   517→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"depends_on_id\\\"\") != null);\n   518→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"dep_type\\\"\") != null);\n   519→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"created_at\\\"\") != null);\n   520→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"created_by\\\"\") != null);\n   521→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"metadata\\\"\") != null);\n   522→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"thread_id\\\"\") != null);\n   523→}\n   524→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"725bbef8-85af-4251-9004-e1375513eb29"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TiduPeyzTS8AAoi7ZMYa1x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AjTyQZx2bqZjy5aB9mugZK","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":676,"cache_read_input_tokens":13187,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":676},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"0e66f7e1-690f-430f-be0e-217d8bf3718a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AjTyQZx2bqZjy5aB9mugZK","type":"tool_result","content":"     1→//! Dependency graph operations for beads_zig.\n     2→//!\n     3→//! Provides dependency management including:\n     4→//! - Add/remove dependencies\n     5→//! - Cycle detection (DFS algorithm)\n     6→//! - Query dependencies and dependents\n     7→//! - Ready/blocked issue queries\n     8→\n     9→const std = @import(\"std\");\n    10→const store_mod = @import(\"store.zig\");\n    11→const IssueStore = store_mod.IssueStore;\n    12→const Issue = @import(\"../models/issue.zig\").Issue;\n    13→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    14→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    15→const Status = @import(\"../models/status.zig\").Status;\n    16→\n    17→pub const DependencyGraphError = error{\n    18→    SelfDependency,\n    19→    CycleDetected,\n    20→    DependencyNotFound,\n    21→    IssueNotFound,\n    22→};\n    23→\n    24→pub const DependencyGraph = struct {\n    25→    store: *IssueStore,\n    26→    allocator: std.mem.Allocator,\n    27→\n    28→    const Self = @This();\n    29→\n    30→    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n    31→        return .{\n    32→            .store = store,\n    33→            .allocator = allocator,\n    34→        };\n    35→    }\n    36→\n    37→    /// Add a dependency (issue_id depends on depends_on_id).\n    38→    /// Returns error.SelfDependency if trying to depend on self.\n    39→    /// Returns error.CycleDetected if adding would create a cycle.\n    40→    pub fn addDependency(self: *Self, dep: Dependency) !void {\n    41→        // Check for self-dependency\n    42→        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n    43→            return DependencyGraphError.SelfDependency;\n    44→        }\n    45→\n    46→        // Check if issue exists\n    47→        const issue = self.store.getRef(dep.issue_id) orelse\n    48→            return DependencyGraphError.IssueNotFound;\n    49→\n    50→        // Check for cycles before inserting\n    51→        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n    52→            return DependencyGraphError.CycleDetected;\n    53→        }\n    54→\n    55→        // Check if dependency already exists\n    56→        for (issue.dependencies) |existing| {\n    57→            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n    58→                return; // Already exists, no-op\n    59→            }\n    60→        }\n    61→\n    62→        // Clone and add the dependency\n    63→        const cloned = try cloneDependency(dep, self.allocator);\n    64→        errdefer freeDependency(@constCast(&cloned), self.allocator);\n    65→\n    66→        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n    67→        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n    68→        new_deps[issue.dependencies.len] = cloned;\n    69→\n    70→        // Only free the old array, not the dependency contents (they're now in new_deps)\n    71→        if (issue.dependencies.len > 0) {\n    72→            self.allocator.free(issue.dependencies);\n    73→        }\n    74→        issue.dependencies = new_deps;\n    75→\n    76→        try self.store.markDirty(dep.issue_id);\n    77→    }\n    78→\n    79→    /// Remove a dependency.\n    80→    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n    81→        const issue = self.store.getRef(issue_id) orelse\n    82→            return DependencyGraphError.IssueNotFound;\n    83→\n    84→        var found_idx: ?usize = null;\n    85→        for (issue.dependencies, 0..) |dep, i| {\n    86→            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n    87→                found_idx = i;\n    88→                break;\n    89→            }\n    90→        }\n    91→\n    92→        if (found_idx) |fi| {\n    93→            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n    94→\n    95→            if (issue.dependencies.len == 1) {\n    96→                self.allocator.free(issue.dependencies);\n    97→                issue.dependencies = &[_]Dependency{};\n    98→            } else {\n    99→                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n   100→                var j: usize = 0;\n   101→                for (issue.dependencies, 0..) |dep, i| {\n   102→                    if (i != fi) {\n   103→                        new_deps[j] = dep;\n   104→                        j += 1;\n   105→                    }\n   106→                }\n   107→                self.allocator.free(issue.dependencies);\n   108→                issue.dependencies = new_deps;\n   109→            }\n   110→\n   111→            try self.store.markDirty(issue_id);\n   112→        }\n   113→    }\n   114→\n   115→    /// Get dependencies for an issue (what it depends on).\n   116→    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n   117→        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n   118→\n   119→        if (issue.dependencies.len == 0) return &[_]Dependency{};\n   120→\n   121→        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n   122→        errdefer self.allocator.free(deps);\n   123→\n   124→        for (issue.dependencies, 0..) |dep, i| {\n   125→            deps[i] = try cloneDependency(dep, self.allocator);\n   126→        }\n   127→\n   128→        return deps;\n   129→    }\n   130→\n   131→    /// Get dependents of an issue (what depends on it).\n   132→    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n   133→        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n   134→        errdefer {\n   135→            for (deps.items) |*dep| {\n   136→                freeDependency(dep, self.allocator);\n   137→            }\n   138→            deps.deinit(self.allocator);\n   139→        }\n   140→\n   141→        for (self.store.getAllRef()) |issue| {\n   142→            for (issue.dependencies) |dep| {\n   143→                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n   144→                    const cloned = try cloneDependency(dep, self.allocator);\n   145→                    try deps.append(self.allocator, cloned);\n   146→                }\n   147→            }\n   148→        }\n   149→\n   150→        return deps.toOwnedSlice(self.allocator);\n   151→    }\n   152→\n   153→    /// Check if adding a dependency would create a cycle.\n   154→    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n   155→    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n   156→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   157→        defer {\n   158→            var key_it = visited.keyIterator();\n   159→            while (key_it.next()) |key| {\n   160→                self.allocator.free(key.*);\n   161→            }\n   162→            visited.deinit(self.allocator);\n   163→        }\n   164→\n   165→        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n   166→    }\n   167→\n   168→    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n   169→        if (std.mem.eql(u8, from, target)) return true;\n   170→        if (visited.contains(from)) return false;\n   171→\n   172→        const from_copy = try self.allocator.dupe(u8, from);\n   173→        errdefer self.allocator.free(from_copy);\n   174→        try visited.put(self.allocator, from_copy, {});\n   175→\n   176→        const issue = self.store.getRef(from) orelse return false;\n   177→\n   178→        for (issue.dependencies) |dep| {\n   179→            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n   180→                return true;\n   181→            }\n   182→        }\n   183→        return false;\n   184→    }\n   185→\n   186→    /// Detect all cycles in the dependency graph.\n   187→    /// Returns array of cycle paths, or null if no cycles.\n   188→    pub fn detectCycles(self: *Self) !?[][]const u8 {\n   189→        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n   190→        defer {\n   191→            var it = all_issues.keyIterator();\n   192→            while (it.next()) |key| {\n   193→                self.allocator.free(key.*);\n   194→            }\n   195→            all_issues.deinit(self.allocator);\n   196→        }\n   197→\n   198→        // Collect all issue IDs involved in dependencies\n   199→        for (self.store.getAllRef()) |issue| {\n   200→            if (issue.dependencies.len > 0) {\n   201→                if (!all_issues.contains(issue.id)) {\n   202→                    const id_copy = try self.allocator.dupe(u8, issue.id);\n   203→                    try all_issues.put(self.allocator, id_copy, {});\n   204→                }\n   205→                for (issue.dependencies) |dep| {\n   206→                    if (!all_issues.contains(dep.depends_on_id)) {\n   207→                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n   208→                        try all_issues.put(self.allocator, id_copy, {});\n   209→                    }\n   210→                }\n   211→            }\n   212→        }\n   213→\n   214→        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n   215→        errdefer {\n   216→            for (cycles.items) |c| {\n   217→                self.allocator.free(c);\n   218→            }\n   219→            cycles.deinit(self.allocator);\n   220→        }\n   221→\n   222→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   223→        defer visited.deinit(self.allocator);\n   224→\n   225→        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n   226→        defer rec_stack.deinit(self.allocator);\n   227→\n   228→        var it = all_issues.keyIterator();\n   229→        while (it.next()) |key| {\n   230→            if (!visited.contains(key.*)) {\n   231→                var path: std.ArrayListUnmanaged([]const u8) = .{};\n   232→                defer path.deinit(self.allocator);\n   233→\n   234→                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n   235→                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n   236→                    try cycles.append(self.allocator, cycle_str);\n   237→                }\n   238→            }\n   239→        }\n   240→\n   241→        if (cycles.items.len == 0) {\n   242→            return null;\n   243→        }\n   244→\n   245→        return try cycles.toOwnedSlice(self.allocator);\n   246→    }\n   247→\n   248→    fn detectCycleDfs(\n   249→        self: *Self,\n   250→        node: []const u8,\n   251→        visited: *std.StringHashMapUnmanaged(void),\n   252→        rec_stack: *std.StringHashMapUnmanaged(void),\n   253→        path: *std.ArrayListUnmanaged([]const u8),\n   254→    ) !bool {\n   255→        try visited.put(self.allocator, node, {});\n   256→        try rec_stack.put(self.allocator, node, {});\n   257→        try path.append(self.allocator, node);\n   258→\n   259→        const issue = self.store.getRef(node) orelse {\n   260→            _ = path.pop();\n   261→            _ = rec_stack.remove(node);\n   262→            return false;\n   263→        };\n   264→\n   265→        for (issue.dependencies) |dep| {\n   266→            if (!visited.contains(dep.depends_on_id)) {\n   267→                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n   268→                    return true;\n   269→                }\n   270→            } else if (rec_stack.contains(dep.depends_on_id)) {\n   271→                try path.append(self.allocator, dep.depends_on_id);\n   272→                return true;\n   273→            }\n   274→        }\n   275→\n   276→        _ = rec_stack.remove(node);\n   277→        _ = path.pop();\n   278→        return false;\n   279→    }\n   280→\n   281→    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n   282→    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n   283→        const now = std.time.timestamp();\n   284→\n   285→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   286→        errdefer {\n   287→            for (results.items) |*issue| {\n   288→                issue.deinit(self.allocator);\n   289→            }\n   290→            results.deinit(self.allocator);\n   291→        }\n   292→\n   293→        for (self.store.getAllRef()) |issue| {\n   294→            // Must be open (or deferred if include_deferred is set)\n   295→            if (statusEql(issue.status, .deferred)) {\n   296→                if (!include_deferred) continue;\n   297→            } else if (!statusEql(issue.status, .open)) {\n   298→                continue;\n   299→            }\n   300→\n   301→            // Must not be deferred to future (unless including deferred)\n   302→            if (!include_deferred) {\n   303→                if (issue.defer_until.value) |defer_time| {\n   304→                    if (defer_time > now) continue;\n   305→                }\n   306→            }\n   307→\n   308→            // Must not have any open blockers\n   309→            var has_open_blocker = false;\n   310→            for (issue.dependencies) |dep| {\n   311→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   312→                    if (!statusEql(blocker.status, .closed) and\n   313→                        !statusEql(blocker.status, .tombstone))\n   314→                    {\n   315→                        has_open_blocker = true;\n   316→                        break;\n   317→                    }\n   318→                }\n   319→            }\n   320→            if (has_open_blocker) continue;\n   321→\n   322→            try results.append(self.allocator, try issue.clone(self.allocator));\n   323→        }\n   324→\n   325→        // Sort by priority then created_at\n   326→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   327→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   328→                if (a.priority.value != b.priority.value) {\n   329→                    return a.priority.value < b.priority.value;\n   330→                }\n   331→                return a.created_at.value < b.created_at.value;\n   332→            }\n   333→        }.lessThan);\n   334→\n   335→        return results.toOwnedSlice(self.allocator);\n   336→    }\n   337→\n   338→    /// Get all blocked issues (open issues with unresolved dependencies).\n   339→    pub fn getBlockedIssues(self: *Self) ![]Issue {\n   340→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   341→        errdefer {\n   342→            for (results.items) |*issue| {\n   343→                issue.deinit(self.allocator);\n   344→            }\n   345→            results.deinit(self.allocator);\n   346→        }\n   347→\n   348→        for (self.store.getAllRef()) |issue| {\n   349→            // Must be open\n   350→            if (!statusEql(issue.status, .open)) continue;\n   351→\n   352→            // Must have at least one open blocker\n   353→            var has_open_blocker = false;\n   354→            for (issue.dependencies) |dep| {\n   355→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   356→                    if (!statusEql(blocker.status, .closed) and\n   357→                        !statusEql(blocker.status, .tombstone))\n   358→                    {\n   359→                        has_open_blocker = true;\n   360→                        break;\n   361→                    }\n   362→                }\n   363→            }\n   364→            if (!has_open_blocker) continue;\n   365→\n   366→            try results.append(self.allocator, try issue.clone(self.allocator));\n   367→        }\n   368→\n   369→        // Sort by priority then created_at\n   370→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   371→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   372→                if (a.priority.value != b.priority.value) {\n   373→                    return a.priority.value < b.priority.value;\n   374→                }\n   375→                return a.created_at.value < b.created_at.value;\n   376→            }\n   377→        }.lessThan);\n   378→\n   379→        return results.toOwnedSlice(self.allocator);\n   380→    }\n   381→\n   382→    /// Get blockers for an issue (open issues that this issue depends on).\n   383→    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n   384→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   385→        errdefer {\n   386→            for (results.items) |*issue| {\n   387→                issue.deinit(self.allocator);\n   388→            }\n   389→            results.deinit(self.allocator);\n   390→        }\n   391→\n   392→        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n   393→\n   394→        for (issue.dependencies) |dep| {\n   395→            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   396→                if (!statusEql(blocker.status, .closed) and\n   397→                    !statusEql(blocker.status, .tombstone))\n   398→                {\n   399→                    try results.append(self.allocator, try blocker.clone(self.allocator));\n   400→                }\n   401→            }\n   402→        }\n   403→\n   404→        return results.toOwnedSlice(self.allocator);\n   405→    }\n   406→\n   407→    /// Free an array of dependencies.\n   408→    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n   409→        for (deps) |*dep| {\n   410→            freeDependency(dep, self.allocator);\n   411→        }\n   412→        self.allocator.free(deps);\n   413→    }\n   414→\n   415→    /// Free an array of issues.\n   416→    pub fn freeIssues(self: *Self, issues: []Issue) void {\n   417→        for (issues) |*issue| {\n   418→            issue.deinit(self.allocator);\n   419→        }\n   420→        self.allocator.free(issues);\n   421→    }\n   422→\n   423→    /// Free an array of cycle strings.\n   424→    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n   425→        for (cycles) |c| {\n   426→            self.allocator.free(c);\n   427→        }\n   428→        self.allocator.free(cycles);\n   429→    }\n   430→\n   431→    /// Get direct children of a parent issue (issues with parent_child dependency).\n   432→    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {\n   433→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   434→        errdefer {\n   435→            for (results.items) |*issue| {\n   436→                issue.deinit(self.allocator);\n   437→            }\n   438→            results.deinit(self.allocator);\n   439→        }\n   440→\n   441→        for (self.store.getAllRef()) |issue| {\n   442→            for (issue.dependencies) |dep| {\n   443→                if (depTypeEql(dep.dep_type, .parent_child) and\n   444→                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n   445→                {\n   446→                    try results.append(self.allocator, try issue.clone(self.allocator));\n   447→                    break;\n   448→                }\n   449→            }\n   450→        }\n   451→\n   452→        return results.toOwnedSlice(self.allocator);\n   453→    }\n   454→\n   455→    /// Get all descendants of a parent issue recursively.\n   456→    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {\n   457→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   458→        errdefer {\n   459→            for (results.items) |*issue| {\n   460→                issue.deinit(self.allocator);\n   461→            }\n   462→            results.deinit(self.allocator);\n   463→        }\n   464→\n   465→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   466→        defer visited.deinit(self.allocator);\n   467→\n   468→        try self.collectDescendants(parent_id, &results, &visited);\n   469→\n   470→        return results.toOwnedSlice(self.allocator);\n   471→    }\n   472→\n   473→    fn collectDescendants(\n   474→        self: *Self,\n   475→        parent_id: []const u8,\n   476→        results: *std.ArrayListUnmanaged(Issue),\n   477→        visited: *std.StringHashMapUnmanaged(void),\n   478→    ) !void {\n   479→        for (self.store.getAllRef()) |issue| {\n   480→            if (visited.contains(issue.id)) continue;\n   481→\n   482→            for (issue.dependencies) |dep| {\n   483→                if (depTypeEql(dep.dep_type, .parent_child) and\n   484→                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n   485→                {\n   486→                    try visited.put(self.allocator, issue.id, {});\n   487→                    try results.append(self.allocator, try issue.clone(self.allocator));\n   488→                    try self.collectDescendants(issue.id, results, visited);\n   489→                    break;\n   490→                }\n   491→            }\n   492→        }\n   493→    }\n   494→\n   495→    /// Check if an issue is a child (direct or descendant) of a given parent.\n   496→    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {\n   497→        const issue = self.store.getRef(issue_id) orelse return false;\n   498→\n   499→        for (issue.dependencies) |dep| {\n   500→            if (depTypeEql(dep.dep_type, .parent_child)) {\n   501→                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {\n   502→                    return true;\n   503→                }\n   504→                if (recursive) {\n   505→                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {\n   506→                        return true;\n   507→                    }\n   508→                }\n   509→            }\n   510→        }\n   511→        return false;\n   512→    }\n   513→};\n   514→\n   515→// Helper functions\n   516→fn statusEql(a: Status, b: Status) bool {\n   517→    const Tag = std.meta.Tag(Status);\n   518→    const tag_a: Tag = a;\n   519→    const tag_b: Tag = b;\n   520→    if (tag_a != tag_b) return false;\n   521→    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n   522→}\n   523→\n   524→fn depTypeEql(a: DependencyType, b: DependencyType) bool {\n   525→    const Tag = std.meta.Tag(DependencyType);\n   526→    const tag_a: Tag = a;\n   527→    const tag_b: Tag = b;\n   528→    if (tag_a != tag_b) return false;\n   529→    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n   530→}\n   531→\n   532→fn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n   533→    var result: Dependency = undefined;\n   534→\n   535→    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n   536→    errdefer allocator.free(result.issue_id);\n   537→\n   538→    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n   539→    errdefer allocator.free(result.depends_on_id);\n   540→\n   541→    result.dep_type = switch (dep.dep_type) {\n   542→        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n   543→        else => dep.dep_type,\n   544→    };\n   545→\n   546→    result.created_at = dep.created_at;\n   547→    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n   548→    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n   549→    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n   550→\n   551→    return result;\n   552→}\n   553→\n   554→fn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n   555→    allocator.free(dep.issue_id);\n   556→    allocator.free(dep.depends_on_id);\n   557→    switch (dep.dep_type) {\n   558→        .custom => |s| allocator.free(s),\n   559→        else => {},\n   560→    }\n   561→    if (dep.created_by) |c| allocator.free(c);\n   562→    if (dep.metadata) |m| allocator.free(m);\n   563→    if (dep.thread_id) |t| allocator.free(t);\n   564→}\n   565→\n   566→// --- Tests ---\n   567→\n   568→test \"DependencyGraph rejects self-dependency\" {\n   569→    const allocator = std.testing.allocator;\n   570→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   571→    defer store.deinit();\n   572→\n   573→    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n   574→\n   575→    var graph = DependencyGraph.init(&store, allocator);\n   576→\n   577→    const dep = Dependency{\n   578→        .issue_id = \"bd-self\",\n   579→        .depends_on_id = \"bd-self\",\n   580→        .dep_type = .blocks,\n   581→        .created_at = 1706540000,\n   582→        .created_by = null,\n   583→        .metadata = null,\n   584→        .thread_id = null,\n   585→    };\n   586→\n   587→    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n   588→}\n   589→\n   590→test \"DependencyGraph rejects direct cycle\" {\n   591→    const allocator = std.testing.allocator;\n   592→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   593→    defer store.deinit();\n   594→\n   595→    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n   596→    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n   597→\n   598→    var graph = DependencyGraph.init(&store, allocator);\n   599→\n   600→    // A depends on B\n   601→    try graph.addDependency(.{\n   602→        .issue_id = \"bd-a\",\n   603→        .depends_on_id = \"bd-b\",\n   604→        .dep_type = .blocks,\n   605→        .created_at = 1706540000,\n   606→        .created_by = null,\n   607→        .metadata = null,\n   608→        .thread_id = null,\n   609→    });\n   610→\n   611→    // B depends on A would create a cycle\n   612→    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n   613→        .issue_id = \"bd-b\",\n   614→        .depends_on_id = \"bd-a\",\n   615→        .dep_type = .blocks,\n   616→        .created_at = 1706540000,\n   617→        .created_by = null,\n   618→        .metadata = null,\n   619→        .thread_id = null,\n   620→    }));\n   621→}\n   622→\n   623→test \"DependencyGraph rejects indirect cycle\" {\n   624→    const allocator = std.testing.allocator;\n   625→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   626→    defer store.deinit();\n   627→\n   628→    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n   629→    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n   630→    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n   631→\n   632→    var graph = DependencyGraph.init(&store, allocator);\n   633→\n   634→    // A depends on B\n   635→    try graph.addDependency(.{\n   636→        .issue_id = \"bd-a\",\n   637→        .depends_on_id = \"bd-b\",\n   638→        .dep_type = .blocks,\n   639→        .created_at = 1706540000,\n   640→        .created_by = null,\n   641→        .metadata = null,\n   642→        .thread_id = null,\n   643→    });\n   644→\n   645→    // B depends on C\n   646→    try graph.addDependency(.{\n   647→        .issue_id = \"bd-b\",\n   648→        .depends_on_id = \"bd-c\",\n   649→        .dep_type = .blocks,\n   650→        .created_at = 1706540000,\n   651→        .created_by = null,\n   652→        .metadata = null,\n   653→        .thread_id = null,\n   654→    });\n   655→\n   656→    // C depends on A would create a cycle\n   657→    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n   658→        .issue_id = \"bd-c\",\n   659→        .depends_on_id = \"bd-a\",\n   660→        .dep_type = .blocks,\n   661→        .created_at = 1706540000,\n   662→        .created_by = null,\n   663→        .metadata = null,\n   664→        .thread_id = null,\n   665→    }));\n   666→}\n   667→\n   668→test \"DependencyGraph getReadyIssues excludes blocked\" {\n   669→    const allocator = std.testing.allocator;\n   670→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   671→    defer store.deinit();\n   672→\n   673→    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n   674→    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n   675→    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n   676→\n   677→    var graph = DependencyGraph.init(&store, allocator);\n   678→\n   679→    try graph.addDependency(.{\n   680→        .issue_id = \"bd-blocked\",\n   681→        .depends_on_id = \"bd-blocker\",\n   682→        .dep_type = .blocks,\n   683→        .created_at = 1706540000,\n   684→        .created_by = null,\n   685→        .metadata = null,\n   686→        .thread_id = null,\n   687→    });\n   688→\n   689→    const ready = try graph.getReadyIssues(false);\n   690→    defer graph.freeIssues(ready);\n   691→\n   692→    try std.testing.expectEqual(@as(usize, 2), ready.len);\n   693→\n   694→    // Verify blocked is not in the list\n   695→    for (ready) |issue| {\n   696→        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n   697→    }\n   698→}\n   699→\n   700→test \"DependencyGraph getReadyIssues includes when blocker closed\" {\n   701→    const allocator = std.testing.allocator;\n   702→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   703→    defer store.deinit();\n   704→\n   705→    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n   706→    blocker.status = .closed;\n   707→    try store.insert(blocker);\n   708→    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n   709→\n   710→    var graph = DependencyGraph.init(&store, allocator);\n   711→\n   712→    try graph.addDependency(.{\n   713→        .issue_id = \"bd-child\",\n   714→        .depends_on_id = \"bd-blocker\",\n   715→        .dep_type = .blocks,\n   716→        .created_at = 1706540000,\n   717→        .created_by = null,\n   718→        .metadata = null,\n   719→        .thread_id = null,\n   720→    });\n   721→\n   722→    const ready = try graph.getReadyIssues(false);\n   723→    defer graph.freeIssues(ready);\n   724→\n   725→    try std.testing.expectEqual(@as(usize, 1), ready.len);\n   726→    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n   727→}\n   728→\n   729→test \"DependencyGraph getBlockedIssues returns only blocked\" {\n   730→    const allocator = std.testing.allocator;\n   731→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   732→    defer store.deinit();\n   733→\n   734→    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n   735→    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n   736→    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n   737→\n   738→    var graph = DependencyGraph.init(&store, allocator);\n   739→\n   740→    try graph.addDependency(.{\n   741→        .issue_id = \"bd-blocked\",\n   742→        .depends_on_id = \"bd-blocker\",\n   743→        .dep_type = .blocks,\n   744→        .created_at = 1706540000,\n   745→        .created_by = null,\n   746→        .metadata = null,\n   747→        .thread_id = null,\n   748→    });\n   749→\n   750→    const blocked = try graph.getBlockedIssues();\n   751→    defer graph.freeIssues(blocked);\n   752→\n   753→    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n   754→    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n   755→}\n   756→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"18a862fd-116d-495d-af5b-44c070f8569b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012EJKPNEcaGxYSuj87rk1QA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JZb2LxFKmoXKGSFnFn8JpD","name":"Grep","input":{"pattern":"pub const DepArgs|pub const LabelArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":33019,"cache_read_input_tokens":13863,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":33019},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7de19afa-06d5-4074-99db-3c138815defa"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JZb2LxFKmoXKGSFnFn8JpD","type":"tool_result","content":"356-    },\n357-    remove: struct {\n358-        child: []const u8,\n359-        parent: []const u8,\n360-    },\n361-    list: struct {\n362-        id: []const u8,\n363-    },\n364-    tree: struct {\n365-        id: []const u8,\n366-    },\n367-    cycles: void,\n368-};\n369-\n370-/// Dependency command arguments.\n371:pub const DepArgs = struct {\n372-    subcommand: DepSubcommand,\n373-};\n374-\n375-/// Graph command output formats.\n376-pub const GraphFormat = enum {\n377-    ascii,\n378-    dot,\n379-\n380-    pub fn fromString(s: []const u8) ?GraphFormat {\n381-        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n382-        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n383-        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n384-        return null;\n385-    }\n386-};\n--\n397-    add: struct {\n398-        id: []const u8,\n399-        labels: []const []const u8,\n400-    },\n401-    remove: struct {\n402-        id: []const u8,\n403-        labels: []const []const u8,\n404-    },\n405-    list: struct {\n406-        id: []const u8,\n407-    },\n408-    list_all: void,\n409-};\n410-\n411-/// Label command arguments.\n412:pub const LabelArgs = struct {\n413-    subcommand: LabelSubcommand,\n414-};\n415-\n416-/// Comments subcommand variants.\n417-pub const CommentsSubcommand = union(enum) {\n418-    add: struct {\n419-        id: []const u8,\n420-        text: []const u8,\n421-    },\n422-    list: struct {\n423-        id: []const u8,\n424-    },\n425-};\n426-\n427-/// Comments command arguments."}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"cb069cf8-2873-456e-aea8-1143a5bd79b0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S8o66DAvT1hv2ZJRX2LYpD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XCVCuZYzaWXH8aGPAh24gT","name":"Grep","input":{"pattern":"pub const DepSubcommand|pub const LabelSubcommand","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":753,"cache_read_input_tokens":46882,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":753},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"27f92684-8380-4abe-8a0a-5731c1e21e5f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XCVCuZYzaWXH8aGPAh24gT","type":"tool_result","content":"331-    },\n332-    add: struct {\n333-        epic_id: []const u8,\n334-        issue_id: []const u8,\n335-    },\n336-    remove: struct {\n337-        epic_id: []const u8,\n338-        issue_id: []const u8,\n339-    },\n340-    list: struct {\n341-        epic_id: []const u8,\n342-    },\n343-};\n344-\n345-/// Epic command arguments.\n346-pub const EpicArgs = struct {\n347-    subcommand: EpicSubcommand,\n348-};\n349-\n350-/// Dependency subcommand variants.\n351:pub const DepSubcommand = union(enum) {\n352-    add: struct {\n353-        child: []const u8,\n354-        parent: []const u8,\n355-        dep_type: []const u8 = \"blocks\",\n356-    },\n357-    remove: struct {\n358-        child: []const u8,\n359-        parent: []const u8,\n360-    },\n361-    list: struct {\n362-        id: []const u8,\n363-    },\n364-    tree: struct {\n365-        id: []const u8,\n366-    },\n367-    cycles: void,\n368-};\n369-\n370-/// Dependency command arguments.\n371-pub const DepArgs = struct {\n--\n376-pub const GraphFormat = enum {\n377-    ascii,\n378-    dot,\n379-\n380-    pub fn fromString(s: []const u8) ?GraphFormat {\n381-        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n382-        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n383-        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n384-        return null;\n385-    }\n386-};\n387-\n388-/// Graph command arguments.\n389-pub const GraphArgs = struct {\n390-    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n391-    format: GraphFormat = .ascii,\n392-    depth: ?u32 = null, // Max depth for tree traversal\n393-};\n394-\n395-/// Label subcommand variants.\n396:pub const LabelSubcommand = union(enum) {\n397-    add: struct {\n398-        id: []const u8,\n399-        labels: []const []const u8,\n400-    },\n401-    remove: struct {\n402-        id: []const u8,\n403-        labels: []const []const u8,\n404-    },\n405-    list: struct {\n406-        id: []const u8,\n407-    },\n408-    list_all: void,\n409-};\n410-\n411-/// Label command arguments.\n412-pub const LabelArgs = struct {\n413-    subcommand: LabelSubcommand,\n414-};\n415-\n416-/// Comments subcommand variants."}]},"parent_tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"570d0538-1d7f-41e1-8c34-086b9972cd04"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J5RHNRC2oURHbvJv4vdjWk","type":"tool_result","content":[{"type":"text","text":"Perfect! Now let me create a comprehensive report with all the information I've gathered.\n\n## Summary: `dep` and `label` Command Implementation\n\nI've successfully mapped out the current implementation of both commands. Here's a complete analysis:\n\n---\n\n## 1. DEP COMMAND\n\n### File: `/home/hotschmoe/beads_zig/src/cli/dep.zig`\n\n#### Subcommands:\n- **add** - Add a dependency relationship\n  - Arguments: `child`, `parent`, `dep_type` (optional, defaults to \"blocks\")\n  - Creates: Issue `child` depends on issue `parent`\n  - Validation: Checks for self-dependencies, cycles, issue existence\n  \n- **remove** - Remove a dependency relationship\n  - Arguments: `child`, `parent`\n  - Removes the dependency link\n  \n- **list** - List dependencies for an issue\n  - Arguments: `id`\n  - Output: Shows both \"Depends on\" and \"Blocks\" sections\n  \n- **tree** - Display dependency tree\n  - Arguments: `id`\n  - Shows upstream (depends on) and downstream (blocked by) relationships\n  - ASCII tree view with cycle detection\n  - Supports JSON output with nested tree structure\n  \n- **cycles** - Detect cycles in dependency graph\n  - No arguments\n  - Returns formatted cycle paths or success message\n\n#### Output Handling:\n- Structured output support (JSON)\n- Plain text with nice formatting\n- Quiet mode support\n- Error handling with `DepError` enum\n\n#### Data Model:\n```zig\n// From src/models/dependency.zig\npub const Dependency = struct {\n    issue_id: []const u8,          // The issue that depends\n    depends_on_id: []const u8,     // What it depends on\n    dep_type: DependencyType,      // Type of relationship\n    created_at: i64,               // Timestamp\n    created_by: ?[]const u8,       // Actor who created\n    metadata: ?[]const u8,         // Custom metadata\n    thread_id: ?[]const u8,        // Optional thread reference\n};\n```\n\n---\n\n## 2. DEPENDENCY TYPES\n\n### File: `/home/hotschmoe/beads_zig/src/models/dependency.zig`\n\nThe system supports **11 predefined types** plus custom types:\n\n1. **blocks** - Direct blocking relationship\n2. **parent_child** - Hierarchical parent-child relationship\n3. **conditional_blocks** - Blocks under certain conditions\n4. **waits_for** - Waiting/dependency relationship\n5. **related** - General relation\n6. **discovered_from** - Origin/discovery link\n7. **replies_to** - Response/reply link\n8. **relates_to** - Related association\n9. **duplicates** - Duplicate marking\n10. **supersedes** - Replacement/supersession\n11. **caused_by** - Causation link\n12. **custom** - User-defined custom type (string value)\n\nFeatures:\n- Case-insensitive parsing\n- String serialization/deserialization\n- JSON support with custom type handling\n- Equality comparison\n\n---\n\n## 3. DEPENDENCY GRAPH\n\n### File: `/home/hotschmoe/beads_zig/src/storage/graph.zig`\n\nCore operations:\n- **addDependency()** - Add with cycle detection (DFS algorithm)\n- **removeDependency()** - Remove relationships\n- **getDependencies()** - Query what an issue depends on\n- **getDependents()** - Query what depends on an issue\n- **wouldCreateCycle()** - Cycle detection before adding\n- **detectCycles()** - Find all cycles in graph\n- **getReadyIssues()** - Issues with no open blockers (for \"ready\" query)\n- **getBlockedIssues()** - Issues with open blockers\n- **getBlockers()** - Specific blockers for an issue\n- **getChildren()** - Direct children (parent_child type)\n- **getDescendants()** - All descendants recursively\n\nCycle detection uses DFS with recursion stack tracking.\n\n---\n\n## 4. LABEL COMMAND\n\n### File: `/home/hotschmoe/beads_zig/src/cli/label.zig`\n\n#### Subcommands:\n- **add** - Add labels to an issue\n  - Arguments: `id`, variadic `labels`\n  - Checks for duplicates before adding\n  - Outputs count of newly added labels\n  \n- **remove** - Remove labels from an issue\n  - Arguments: `id`, variadic `labels`\n  - Only removes labels that exist\n  - Outputs count of removed labels\n  \n- **list** - List labels on a specific issue\n  - Arguments: `id`\n  - Shows all labels on that issue\n  \n- **list-all** - List all unique labels in project\n  - No arguments\n  - Collects unique labels across all issues\n  - Sorted alphabetically\n  - Excludes tombstone (deleted) issues\n\n#### Output Handling:\n- Structured output (JSON)\n- Plain text formatting\n- Quiet mode support (just outputs label names)\n- Error handling with `LabelError` enum\n\n---\n\n## 5. CLI ARGUMENT PARSING\n\n### File: `/home/hotschmoe/beads_zig/src/cli/args.zig`\n\n#### DepArgs Structure:\n```zig\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n```\n\n#### LabelArgs Structure:\n```zig\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n```\n\n---\n\n## 6. COMMAND INVOCATION PATTERN\n\nBoth commands follow the same pattern in `common.zig`:\n\n```\nbz dep add <child> <parent> [--type <dep_type>]\nbz dep remove <child> <parent>\nbz dep list <id>\nbz dep tree <id>\nbz dep cycles\n\nbz label add <id> <label1> [<label2> ...]\nbz label remove <id> <label1> [<label2> ...]\nbz label list <id>\nbz label list-all\n```\n\n---\n\n## 7. ERROR HANDLING\n\n**DepError types:**\n- WorkspaceNotInitialized\n- IssueNotFound\n- CycleDetected\n- SelfDependency\n- StorageError\n- OutOfMemory\n\n**LabelError types:**\n- WorkspaceNotInitialized\n- StorageError\n- IssueNotFound\n- OutOfMemory\n\n---\n\n## 8. KEY FILES REFERENCE\n\n- `/home/hotschmoe/beads_zig/src/cli/dep.zig` - Dependency command implementation\n- `/home/hotschmoe/beads_zig/src/cli/label.zig` - Label command implementation\n- `/home/hotschmoe/beads_zig/src/models/dependency.zig` - Dependency data model\n- `/home/hotschmoe/beads_zig/src/storage/graph.zig` - Dependency graph operations\n- `/home/hotschmoe/beads_zig/src/cli/args.zig` - Argument parsing structures (lines 351-414 contain dep/label args)"},{"type":"text","text":"agentId: a08a077 (for resuming to continue this agent's work if needed)"}]}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"20937651-5946-4094-b53a-5ab0a30073c3","tool_use_result":{"status":"completed","prompt":"I need to understand the current implementation of:\n1. The `dep` command - how dependencies work, what types exist, the CLI interface\n2. The `label` command - how labels work, what subcommands exist\n\nSearch for:\n- src/cli/dep*.zig files\n- src/cli/label*.zig files\n- src/models/dependency.zig or similar\n- src/storage/graph.zig\n- src/cli/args.zig for the command definitions\n\nI need to understand:\n1. Current dependency types supported\n2. Current dep subcommands (add, remove, list, tree, cycles)\n3. Current label subcommands\n4. How the CLI arg parsing works for these commands","agentId":"a08a077","content":[{"type":"text","text":"Perfect! Now let me create a comprehensive report with all the information I've gathered.\n\n## Summary: `dep` and `label` Command Implementation\n\nI've successfully mapped out the current implementation of both commands. Here's a complete analysis:\n\n---\n\n## 1. DEP COMMAND\n\n### File: `/home/hotschmoe/beads_zig/src/cli/dep.zig`\n\n#### Subcommands:\n- **add** - Add a dependency relationship\n  - Arguments: `child`, `parent`, `dep_type` (optional, defaults to \"blocks\")\n  - Creates: Issue `child` depends on issue `parent`\n  - Validation: Checks for self-dependencies, cycles, issue existence\n  \n- **remove** - Remove a dependency relationship\n  - Arguments: `child`, `parent`\n  - Removes the dependency link\n  \n- **list** - List dependencies for an issue\n  - Arguments: `id`\n  - Output: Shows both \"Depends on\" and \"Blocks\" sections\n  \n- **tree** - Display dependency tree\n  - Arguments: `id`\n  - Shows upstream (depends on) and downstream (blocked by) relationships\n  - ASCII tree view with cycle detection\n  - Supports JSON output with nested tree structure\n  \n- **cycles** - Detect cycles in dependency graph\n  - No arguments\n  - Returns formatted cycle paths or success message\n\n#### Output Handling:\n- Structured output support (JSON)\n- Plain text with nice formatting\n- Quiet mode support\n- Error handling with `DepError` enum\n\n#### Data Model:\n```zig\n// From src/models/dependency.zig\npub const Dependency = struct {\n    issue_id: []const u8,          // The issue that depends\n    depends_on_id: []const u8,     // What it depends on\n    dep_type: DependencyType,      // Type of relationship\n    created_at: i64,               // Timestamp\n    created_by: ?[]const u8,       // Actor who created\n    metadata: ?[]const u8,         // Custom metadata\n    thread_id: ?[]const u8,        // Optional thread reference\n};\n```\n\n---\n\n## 2. DEPENDENCY TYPES\n\n### File: `/home/hotschmoe/beads_zig/src/models/dependency.zig`\n\nThe system supports **11 predefined types** plus custom types:\n\n1. **blocks** - Direct blocking relationship\n2. **parent_child** - Hierarchical parent-child relationship\n3. **conditional_blocks** - Blocks under certain conditions\n4. **waits_for** - Waiting/dependency relationship\n5. **related** - General relation\n6. **discovered_from** - Origin/discovery link\n7. **replies_to** - Response/reply link\n8. **relates_to** - Related association\n9. **duplicates** - Duplicate marking\n10. **supersedes** - Replacement/supersession\n11. **caused_by** - Causation link\n12. **custom** - User-defined custom type (string value)\n\nFeatures:\n- Case-insensitive parsing\n- String serialization/deserialization\n- JSON support with custom type handling\n- Equality comparison\n\n---\n\n## 3. DEPENDENCY GRAPH\n\n### File: `/home/hotschmoe/beads_zig/src/storage/graph.zig`\n\nCore operations:\n- **addDependency()** - Add with cycle detection (DFS algorithm)\n- **removeDependency()** - Remove relationships\n- **getDependencies()** - Query what an issue depends on\n- **getDependents()** - Query what depends on an issue\n- **wouldCreateCycle()** - Cycle detection before adding\n- **detectCycles()** - Find all cycles in graph\n- **getReadyIssues()** - Issues with no open blockers (for \"ready\" query)\n- **getBlockedIssues()** - Issues with open blockers\n- **getBlockers()** - Specific blockers for an issue\n- **getChildren()** - Direct children (parent_child type)\n- **getDescendants()** - All descendants recursively\n\nCycle detection uses DFS with recursion stack tracking.\n\n---\n\n## 4. LABEL COMMAND\n\n### File: `/home/hotschmoe/beads_zig/src/cli/label.zig`\n\n#### Subcommands:\n- **add** - Add labels to an issue\n  - Arguments: `id`, variadic `labels`\n  - Checks for duplicates before adding\n  - Outputs count of newly added labels\n  \n- **remove** - Remove labels from an issue\n  - Arguments: `id`, variadic `labels`\n  - Only removes labels that exist\n  - Outputs count of removed labels\n  \n- **list** - List labels on a specific issue\n  - Arguments: `id`\n  - Shows all labels on that issue\n  \n- **list-all** - List all unique labels in project\n  - No arguments\n  - Collects unique labels across all issues\n  - Sorted alphabetically\n  - Excludes tombstone (deleted) issues\n\n#### Output Handling:\n- Structured output (JSON)\n- Plain text formatting\n- Quiet mode support (just outputs label names)\n- Error handling with `LabelError` enum\n\n---\n\n## 5. CLI ARGUMENT PARSING\n\n### File: `/home/hotschmoe/beads_zig/src/cli/args.zig`\n\n#### DepArgs Structure:\n```zig\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n```\n\n#### LabelArgs Structure:\n```zig\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n```\n\n---\n\n## 6. COMMAND INVOCATION PATTERN\n\nBoth commands follow the same pattern in `common.zig`:\n\n```\nbz dep add <child> <parent> [--type <dep_type>]\nbz dep remove <child> <parent>\nbz dep list <id>\nbz dep tree <id>\nbz dep cycles\n\nbz label add <id> <label1> [<label2> ...]\nbz label remove <id> <label1> [<label2> ...]\nbz label list <id>\nbz label list-all\n```\n\n---\n\n## 7. ERROR HANDLING\n\n**DepError types:**\n- WorkspaceNotInitialized\n- IssueNotFound\n- CycleDetected\n- SelfDependency\n- StorageError\n- OutOfMemory\n\n**LabelError types:**\n- WorkspaceNotInitialized\n- StorageError\n- IssueNotFound\n- OutOfMemory\n\n---\n\n## 8. KEY FILES REFERENCE\n\n- `/home/hotschmoe/beads_zig/src/cli/dep.zig` - Dependency command implementation\n- `/home/hotschmoe/beads_zig/src/cli/label.zig` - Label command implementation\n- `/home/hotschmoe/beads_zig/src/models/dependency.zig` - Dependency data model\n- `/home/hotschmoe/beads_zig/src/storage/graph.zig` - Dependency graph operations\n- `/home/hotschmoe/beads_zig/src/cli/args.zig` - Argument parsing structures (lines 351-414 contain dep/label args)"}],"totalDurationMs":28313,"totalTokens":48612,"totalToolUseCount":12,"usage":{"input_tokens":4,"cache_creation_input_tokens":972,"cache_read_input_tokens":47635,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":972},"output_tokens":1,"service_tier":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019FU33UbcfeiPDzQC8nfQ6A","type":"message","role":"assistant","content":[{"type":"text","text":"The exploration shows that:\n1. Most dependency types already exist in the model, but some are missing or named differently\n2. The `dep` command needs `--metadata`, `--direction`, and `--format mermaid` flags\n3. The `label` command needs a `rename` subcommand\n\nLet me read the specific files to understand the current implementation details."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2288,"cache_read_input_tokens":39157,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2288},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7cc7acb9-5f79-46f5-96d3-7a700d8d8b17"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019FU33UbcfeiPDzQC8nfQ6A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RmnKrq15kfuNUMXZggtphb","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/dependency.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2288,"cache_read_input_tokens":39157,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2288},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"8405cfbe-5b51-4939-8b6f-dc41c3b75659"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RmnKrq15kfuNUMXZggtphb","type":"tool_result","content":"     1→//! Dependency types and the Dependency struct for tracking relationships between issues.\n     2→//!\n     3→//! Dependencies model the relationships between issues - blocking relationships,\n     4→//! parent-child hierarchies, and other associations. The dependency graph\n     5→//! enables the \"ready\" query (issues with no blockers) and cycle detection.\n     6→\n     7→const std = @import(\"std\");\n     8→\n     9→/// Dependency relationship types between issues.\n    10→pub const DependencyType = union(enum) {\n    11→    blocks,\n    12→    parent_child,\n    13→    conditional_blocks,\n    14→    waits_for,\n    15→    related,\n    16→    discovered_from,\n    17→    replies_to,\n    18→    relates_to,\n    19→    duplicates,\n    20→    supersedes,\n    21→    caused_by,\n    22→    custom: []const u8,\n    23→\n    24→    const Self = @This();\n    25→\n    26→    /// Convert DependencyType to its string representation.\n    27→    pub fn toString(self: Self) []const u8 {\n    28→        return switch (self) {\n    29→            .blocks => \"blocks\",\n    30→            .parent_child => \"parent_child\",\n    31→            .conditional_blocks => \"conditional_blocks\",\n    32→            .waits_for => \"waits_for\",\n    33→            .related => \"related\",\n    34→            .discovered_from => \"discovered_from\",\n    35→            .replies_to => \"replies_to\",\n    36→            .relates_to => \"relates_to\",\n    37→            .duplicates => \"duplicates\",\n    38→            .supersedes => \"supersedes\",\n    39→            .caused_by => \"caused_by\",\n    40→            .custom => |s| s,\n    41→        };\n    42→    }\n    43→\n    44→    /// Parse a string into a DependencyType (case-insensitive for known values).\n    45→    /// Returns .custom for unknown values.\n    46→    pub fn fromString(s: []const u8) Self {\n    47→        if (std.ascii.eqlIgnoreCase(s, \"blocks\")) return .blocks;\n    48→        if (std.ascii.eqlIgnoreCase(s, \"parent_child\")) return .parent_child;\n    49→        if (std.ascii.eqlIgnoreCase(s, \"conditional_blocks\")) return .conditional_blocks;\n    50→        if (std.ascii.eqlIgnoreCase(s, \"waits_for\")) return .waits_for;\n    51→        if (std.ascii.eqlIgnoreCase(s, \"related\")) return .related;\n    52→        if (std.ascii.eqlIgnoreCase(s, \"discovered_from\")) return .discovered_from;\n    53→        if (std.ascii.eqlIgnoreCase(s, \"replies_to\")) return .replies_to;\n    54→        if (std.ascii.eqlIgnoreCase(s, \"relates_to\")) return .relates_to;\n    55→        if (std.ascii.eqlIgnoreCase(s, \"duplicates\")) return .duplicates;\n    56→        if (std.ascii.eqlIgnoreCase(s, \"supersedes\")) return .supersedes;\n    57→        if (std.ascii.eqlIgnoreCase(s, \"caused_by\")) return .caused_by;\n    58→        return .{ .custom = s };\n    59→    }\n    60→\n    61→    /// Check equality between two DependencyTypes.\n    62→    pub fn eql(a: Self, b: Self) bool {\n    63→        const Tag = std.meta.Tag(Self);\n    64→        const tag_a: Tag = a;\n    65→        const tag_b: Tag = b;\n    66→        if (tag_a != tag_b) return false;\n    67→        return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n    68→    }\n    69→\n    70→    /// JSON serialization for std.json.\n    71→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    72→        try jws.write(self.toString());\n    73→    }\n    74→\n    75→    /// JSON deserialization for std.json.\n    76→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    77→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    78→        const str = switch (token) {\n    79→            .string, .allocated_string => |s| s,\n    80→            else => return error.UnexpectedToken,\n    81→        };\n    82→        return fromString(str);\n    83→    }\n    84→\n    85→    /// JSON deserialization from already-parsed value.\n    86→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    87→        _ = allocator;\n    88→        _ = options;\n    89→        return switch (source) {\n    90→            .string => |s| fromString(s),\n    91→            else => error.UnexpectedToken,\n    92→        };\n    93→    }\n    94→};\n    95→\n    96→/// A dependency relationship between two issues.\n    97→/// issue_id depends ON depends_on_id (issue_id is blocked BY depends_on_id).\n    98→pub const Dependency = struct {\n    99→    issue_id: []const u8,\n   100→    depends_on_id: []const u8,\n   101→    dep_type: DependencyType,\n   102→    created_at: i64,\n   103→    created_by: ?[]const u8,\n   104→    metadata: ?[]const u8,\n   105→    thread_id: ?[]const u8,\n   106→\n   107→    const Self = @This();\n   108→\n   109→    /// Check deep equality between two Dependencies.\n   110→    pub fn eql(a: Self, b: Self) bool {\n   111→        if (!std.mem.eql(u8, a.issue_id, b.issue_id)) return false;\n   112→        if (!std.mem.eql(u8, a.depends_on_id, b.depends_on_id)) return false;\n   113→        if (!DependencyType.eql(a.dep_type, b.dep_type)) return false;\n   114→        if (a.created_at != b.created_at) return false;\n   115→        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n   116→        if (!optionalStrEql(a.metadata, b.metadata)) return false;\n   117→        if (!optionalStrEql(a.thread_id, b.thread_id)) return false;\n   118→        return true;\n   119→    }\n   120→\n   121→    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n   122→        const a_val = a orelse return b == null;\n   123→        const b_val = b orelse return false;\n   124→        return std.mem.eql(u8, a_val, b_val);\n   125→    }\n   126→};\n   127→\n   128→// --- DependencyType Tests ---\n   129→\n   130→test \"DependencyType.toString returns correct strings for known types\" {\n   131→    try std.testing.expectEqualStrings(\"blocks\", (DependencyType{ .blocks = {} }).toString());\n   132→    try std.testing.expectEqualStrings(\"parent_child\", (DependencyType{ .parent_child = {} }).toString());\n   133→    try std.testing.expectEqualStrings(\"conditional_blocks\", (DependencyType{ .conditional_blocks = {} }).toString());\n   134→    try std.testing.expectEqualStrings(\"waits_for\", (DependencyType{ .waits_for = {} }).toString());\n   135→    try std.testing.expectEqualStrings(\"related\", (DependencyType{ .related = {} }).toString());\n   136→    try std.testing.expectEqualStrings(\"discovered_from\", (DependencyType{ .discovered_from = {} }).toString());\n   137→    try std.testing.expectEqualStrings(\"replies_to\", (DependencyType{ .replies_to = {} }).toString());\n   138→    try std.testing.expectEqualStrings(\"relates_to\", (DependencyType{ .relates_to = {} }).toString());\n   139→    try std.testing.expectEqualStrings(\"duplicates\", (DependencyType{ .duplicates = {} }).toString());\n   140→    try std.testing.expectEqualStrings(\"supersedes\", (DependencyType{ .supersedes = {} }).toString());\n   141→    try std.testing.expectEqualStrings(\"caused_by\", (DependencyType{ .caused_by = {} }).toString());\n   142→}\n   143→\n   144→test \"DependencyType.toString returns custom string for custom type\" {\n   145→    const custom = DependencyType{ .custom = \"my_custom_dep\" };\n   146→    try std.testing.expectEqualStrings(\"my_custom_dep\", custom.toString());\n   147→}\n   148→\n   149→test \"DependencyType.fromString parses known types correctly\" {\n   150→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"blocks\"));\n   151→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"parent_child\"));\n   152→    try std.testing.expectEqual(DependencyType.conditional_blocks, DependencyType.fromString(\"conditional_blocks\"));\n   153→    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"waits_for\"));\n   154→    try std.testing.expectEqual(DependencyType.related, DependencyType.fromString(\"related\"));\n   155→    try std.testing.expectEqual(DependencyType.discovered_from, DependencyType.fromString(\"discovered_from\"));\n   156→    try std.testing.expectEqual(DependencyType.replies_to, DependencyType.fromString(\"replies_to\"));\n   157→    try std.testing.expectEqual(DependencyType.relates_to, DependencyType.fromString(\"relates_to\"));\n   158→    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"duplicates\"));\n   159→    try std.testing.expectEqual(DependencyType.supersedes, DependencyType.fromString(\"supersedes\"));\n   160→    try std.testing.expectEqual(DependencyType.caused_by, DependencyType.fromString(\"caused_by\"));\n   161→}\n   162→\n   163→test \"DependencyType.fromString is case-insensitive\" {\n   164→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"BLOCKS\"));\n   165→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"Blocks\"));\n   166→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"bLoCkS\"));\n   167→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"PARENT_CHILD\"));\n   168→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"Parent_Child\"));\n   169→    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"WAITS_FOR\"));\n   170→    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"DUPLICATES\"));\n   171→}\n   172→\n   173→test \"DependencyType.fromString returns custom for unknown values\" {\n   174→    const result = DependencyType.fromString(\"unknown_dep_type\");\n   175→    switch (result) {\n   176→        .custom => |s| try std.testing.expectEqualStrings(\"unknown_dep_type\", s),\n   177→        else => return error.TestExpectedCustom,\n   178→    }\n   179→}\n   180→\n   181→test \"DependencyType toString/fromString roundtrip for known types\" {\n   182→    const dep_types = [_]DependencyType{\n   183→        .blocks,\n   184→        .parent_child,\n   185→        .conditional_blocks,\n   186→        .waits_for,\n   187→        .related,\n   188→        .discovered_from,\n   189→        .replies_to,\n   190→        .relates_to,\n   191→        .duplicates,\n   192→        .supersedes,\n   193→        .caused_by,\n   194→    };\n   195→\n   196→    for (dep_types) |dep_type| {\n   197→        const str = dep_type.toString();\n   198→        const parsed = DependencyType.fromString(str);\n   199→        try std.testing.expectEqual(dep_type, parsed);\n   200→    }\n   201→}\n   202→\n   203→test \"DependencyType toString/fromString roundtrip for custom type\" {\n   204→    const original = DependencyType{ .custom = \"my_workflow_dep\" };\n   205→    const str = original.toString();\n   206→    const parsed = DependencyType.fromString(str);\n   207→\n   208→    switch (parsed) {\n   209→        .custom => |s| try std.testing.expectEqualStrings(\"my_workflow_dep\", s),\n   210→        else => return error.TestExpectedCustom,\n   211→    }\n   212→}\n   213→\n   214→test \"DependencyType.eql compares correctly\" {\n   215→    try std.testing.expect(DependencyType.eql(.blocks, .blocks));\n   216→    try std.testing.expect(DependencyType.eql(.parent_child, .parent_child));\n   217→    try std.testing.expect(!DependencyType.eql(.blocks, .parent_child));\n   218→    try std.testing.expect(!DependencyType.eql(.waits_for, .duplicates));\n   219→\n   220→    const custom1 = DependencyType{ .custom = \"foo\" };\n   221→    const custom2 = DependencyType{ .custom = \"foo\" };\n   222→    const custom3 = DependencyType{ .custom = \"bar\" };\n   223→    try std.testing.expect(DependencyType.eql(custom1, custom2));\n   224→    try std.testing.expect(!DependencyType.eql(custom1, custom3));\n   225→    try std.testing.expect(!DependencyType.eql(custom1, .blocks));\n   226→}\n   227→\n   228→test \"DependencyType JSON serialization roundtrip\" {\n   229→    const allocator = std.testing.allocator;\n   230→\n   231→    const dep_types = [_]DependencyType{\n   232→        .blocks,\n   233→        .parent_child,\n   234→        .conditional_blocks,\n   235→        .waits_for,\n   236→        .related,\n   237→        .discovered_from,\n   238→        .replies_to,\n   239→        .relates_to,\n   240→        .duplicates,\n   241→        .supersedes,\n   242→        .caused_by,\n   243→    };\n   244→\n   245→    for (dep_types) |dep_type| {\n   246→        var aw: std.io.Writer.Allocating = .init(allocator);\n   247→        defer aw.deinit();\n   248→\n   249→        try std.json.Stringify.value(dep_type, .{}, &aw.writer);\n   250→        const json_str = aw.written();\n   251→\n   252→        const parsed = try std.json.parseFromSlice(DependencyType, allocator, json_str, .{});\n   253→        defer parsed.deinit();\n   254→\n   255→        try std.testing.expectEqual(dep_type, parsed.value);\n   256→    }\n   257→}\n   258→\n   259→test \"DependencyType JSON deserialization of custom type\" {\n   260→    const allocator = std.testing.allocator;\n   261→\n   262→    const json_str = \"\\\"custom_relationship\\\"\";\n   263→    const parsed = try std.json.parseFromSlice(DependencyType, allocator, json_str, .{});\n   264→    defer parsed.deinit();\n   265→\n   266→    switch (parsed.value) {\n   267→        .custom => |s| try std.testing.expectEqualStrings(\"custom_relationship\", s),\n   268→        else => return error.TestExpectedCustom,\n   269→    }\n   270→}\n   271→\n   272→test \"DependencyType JSON serializes as lowercase string\" {\n   273→    const allocator = std.testing.allocator;\n   274→\n   275→    var aw: std.io.Writer.Allocating = .init(allocator);\n   276→    defer aw.deinit();\n   277→\n   278→    try std.json.Stringify.value(DependencyType.blocks, .{}, &aw.writer);\n   279→\n   280→    try std.testing.expectEqualStrings(\"\\\"blocks\\\"\", aw.written());\n   281→}\n   282→\n   283→// --- Dependency Tests ---\n   284→\n   285→test \"Dependency.eql compares all fields\" {\n   286→    const dep1 = Dependency{\n   287→        .issue_id = \"bd-abc123\",\n   288→        .depends_on_id = \"bd-def456\",\n   289→        .dep_type = .blocks,\n   290→        .created_at = 1706540000,\n   291→        .created_by = \"alice@example.com\",\n   292→        .metadata = null,\n   293→        .thread_id = null,\n   294→    };\n   295→\n   296→    const dep2 = Dependency{\n   297→        .issue_id = \"bd-abc123\",\n   298→        .depends_on_id = \"bd-def456\",\n   299→        .dep_type = .blocks,\n   300→        .created_at = 1706540000,\n   301→        .created_by = \"alice@example.com\",\n   302→        .metadata = null,\n   303→        .thread_id = null,\n   304→    };\n   305→\n   306→    try std.testing.expect(Dependency.eql(dep1, dep2));\n   307→}\n   308→\n   309→test \"Dependency.eql detects issue_id difference\" {\n   310→    const dep1 = Dependency{\n   311→        .issue_id = \"bd-abc123\",\n   312→        .depends_on_id = \"bd-def456\",\n   313→        .dep_type = .blocks,\n   314→        .created_at = 1706540000,\n   315→        .created_by = null,\n   316→        .metadata = null,\n   317→        .thread_id = null,\n   318→    };\n   319→\n   320→    const dep2 = Dependency{\n   321→        .issue_id = \"bd-xyz789\",\n   322→        .depends_on_id = \"bd-def456\",\n   323→        .dep_type = .blocks,\n   324→        .created_at = 1706540000,\n   325→        .created_by = null,\n   326→        .metadata = null,\n   327→        .thread_id = null,\n   328→    };\n   329→\n   330→    try std.testing.expect(!Dependency.eql(dep1, dep2));\n   331→}\n   332→\n   333→test \"Dependency.eql detects dep_type difference\" {\n   334→    const dep1 = Dependency{\n   335→        .issue_id = \"bd-abc123\",\n   336→        .depends_on_id = \"bd-def456\",\n   337→        .dep_type = .blocks,\n   338→        .created_at = 1706540000,\n   339→        .created_by = null,\n   340→        .metadata = null,\n   341→        .thread_id = null,\n   342→    };\n   343→\n   344→    const dep2 = Dependency{\n   345→        .issue_id = \"bd-abc123\",\n   346→        .depends_on_id = \"bd-def456\",\n   347→        .dep_type = .waits_for,\n   348→        .created_at = 1706540000,\n   349→        .created_by = null,\n   350→        .metadata = null,\n   351→        .thread_id = null,\n   352→    };\n   353→\n   354→    try std.testing.expect(!Dependency.eql(dep1, dep2));\n   355→}\n   356→\n   357→test \"Dependency.eql detects optional field differences\" {\n   358→    const dep1 = Dependency{\n   359→        .issue_id = \"bd-abc123\",\n   360→        .depends_on_id = \"bd-def456\",\n   361→        .dep_type = .blocks,\n   362→        .created_at = 1706540000,\n   363→        .created_by = \"alice@example.com\",\n   364→        .metadata = null,\n   365→        .thread_id = null,\n   366→    };\n   367→\n   368→    const dep2 = Dependency{\n   369→        .issue_id = \"bd-abc123\",\n   370→        .depends_on_id = \"bd-def456\",\n   371→        .dep_type = .blocks,\n   372→        .created_at = 1706540000,\n   373→        .created_by = null,\n   374→        .metadata = null,\n   375→        .thread_id = null,\n   376→    };\n   377→\n   378→    try std.testing.expect(!Dependency.eql(dep1, dep2));\n   379→}\n   380→\n   381→test \"Dependency.eql handles metadata comparison\" {\n   382→    const dep1 = Dependency{\n   383→        .issue_id = \"bd-abc123\",\n   384→        .depends_on_id = \"bd-def456\",\n   385→        .dep_type = .blocks,\n   386→        .created_at = 1706540000,\n   387→        .created_by = null,\n   388→        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n   389→        .thread_id = null,\n   390→    };\n   391→\n   392→    const dep2 = Dependency{\n   393→        .issue_id = \"bd-abc123\",\n   394→        .depends_on_id = \"bd-def456\",\n   395→        .dep_type = .blocks,\n   396→        .created_at = 1706540000,\n   397→        .created_by = null,\n   398→        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n   399→        .thread_id = null,\n   400→    };\n   401→\n   402→    const dep3 = Dependency{\n   403→        .issue_id = \"bd-abc123\",\n   404→        .depends_on_id = \"bd-def456\",\n   405→        .dep_type = .blocks,\n   406→        .created_at = 1706540000,\n   407→        .created_by = null,\n   408→        .metadata = \"{\\\"other\\\":\\\"data\\\"}\",\n   409→        .thread_id = null,\n   410→    };\n   411→\n   412→    try std.testing.expect(Dependency.eql(dep1, dep2));\n   413→    try std.testing.expect(!Dependency.eql(dep1, dep3));\n   414→}\n   415→\n   416→test \"Dependency JSON serialization with all fields\" {\n   417→    const allocator = std.testing.allocator;\n   418→\n   419→    const dep = Dependency{\n   420→        .issue_id = \"bd-abc123\",\n   421→        .depends_on_id = \"bd-def456\",\n   422→        .dep_type = .blocks,\n   423→        .created_at = 1706540000,\n   424→        .created_by = \"alice@example.com\",\n   425→        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n   426→        .thread_id = \"thread-001\",\n   427→    };\n   428→\n   429→    var aw: std.io.Writer.Allocating = .init(allocator);\n   430→    defer aw.deinit();\n   431→\n   432→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   433→    const json_str = aw.written();\n   434→\n   435→    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n   436→    defer parsed.deinit();\n   437→\n   438→    try std.testing.expect(Dependency.eql(dep, parsed.value));\n   439→}\n   440→\n   441→test \"Dependency JSON serialization with null fields\" {\n   442→    const allocator = std.testing.allocator;\n   443→\n   444→    const dep = Dependency{\n   445→        .issue_id = \"bd-abc123\",\n   446→        .depends_on_id = \"bd-def456\",\n   447→        .dep_type = .parent_child,\n   448→        .created_at = 1706540000,\n   449→        .created_by = null,\n   450→        .metadata = null,\n   451→        .thread_id = null,\n   452→    };\n   453→\n   454→    var aw: std.io.Writer.Allocating = .init(allocator);\n   455→    defer aw.deinit();\n   456→\n   457→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   458→    const json_str = aw.written();\n   459→\n   460→    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n   461→    defer parsed.deinit();\n   462→\n   463→    try std.testing.expect(Dependency.eql(dep, parsed.value));\n   464→}\n   465→\n   466→test \"Dependency JSON serialization roundtrip with custom dep_type\" {\n   467→    const allocator = std.testing.allocator;\n   468→\n   469→    const dep = Dependency{\n   470→        .issue_id = \"bd-abc123\",\n   471→        .depends_on_id = \"bd-def456\",\n   472→        .dep_type = DependencyType{ .custom = \"my_custom_relation\" },\n   473→        .created_at = 1706540000,\n   474→        .created_by = \"bob@example.com\",\n   475→        .metadata = null,\n   476→        .thread_id = null,\n   477→    };\n   478→\n   479→    var aw: std.io.Writer.Allocating = .init(allocator);\n   480→    defer aw.deinit();\n   481→\n   482→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   483→    const json_str = aw.written();\n   484→\n   485→    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n   486→    defer parsed.deinit();\n   487→\n   488→    try std.testing.expectEqualStrings(dep.issue_id, parsed.value.issue_id);\n   489→    try std.testing.expectEqualStrings(dep.depends_on_id, parsed.value.depends_on_id);\n   490→    try std.testing.expectEqual(dep.created_at, parsed.value.created_at);\n   491→    switch (parsed.value.dep_type) {\n   492→        .custom => |s| try std.testing.expectEqualStrings(\"my_custom_relation\", s),\n   493→        else => return error.TestExpectedCustom,\n   494→    }\n   495→}\n   496→\n   497→test \"Dependency JSON contains expected fields\" {\n   498→    const allocator = std.testing.allocator;\n   499→\n   500→    const dep = Dependency{\n   501→        .issue_id = \"bd-test\",\n   502→        .depends_on_id = \"bd-blocker\",\n   503→        .dep_type = .blocks,\n   504→        .created_at = 1234567890,\n   505→        .created_by = null,\n   506→        .metadata = null,\n   507→        .thread_id = null,\n   508→    };\n   509→\n   510→    var aw: std.io.Writer.Allocating = .init(allocator);\n   511→    defer aw.deinit();\n   512→\n   513→    try std.json.Stringify.value(dep, .{}, &aw.writer);\n   514→    const json_str = aw.written();\n   515→\n   516→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"issue_id\\\"\") != null);\n   517→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"depends_on_id\\\"\") != null);\n   518→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"dep_type\\\"\") != null);\n   519→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"created_at\\\"\") != null);\n   520→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"created_by\\\"\") != null);\n   521→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"metadata\\\"\") != null);\n   522→    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"thread_id\\\"\") != null);\n   523→}\n   524→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"69780579-2756-46fe-ad1b-91aee5f94bac","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/models/dependency.zig","content":"//! Dependency types and the Dependency struct for tracking relationships between issues.\n//!\n//! Dependencies model the relationships between issues - blocking relationships,\n//! parent-child hierarchies, and other associations. The dependency graph\n//! enables the \"ready\" query (issues with no blockers) and cycle detection.\n\nconst std = @import(\"std\");\n\n/// Dependency relationship types between issues.\npub const DependencyType = union(enum) {\n    blocks,\n    parent_child,\n    conditional_blocks,\n    waits_for,\n    related,\n    discovered_from,\n    replies_to,\n    relates_to,\n    duplicates,\n    supersedes,\n    caused_by,\n    custom: []const u8,\n\n    const Self = @This();\n\n    /// Convert DependencyType to its string representation.\n    pub fn toString(self: Self) []const u8 {\n        return switch (self) {\n            .blocks => \"blocks\",\n            .parent_child => \"parent_child\",\n            .conditional_blocks => \"conditional_blocks\",\n            .waits_for => \"waits_for\",\n            .related => \"related\",\n            .discovered_from => \"discovered_from\",\n            .replies_to => \"replies_to\",\n            .relates_to => \"relates_to\",\n            .duplicates => \"duplicates\",\n            .supersedes => \"supersedes\",\n            .caused_by => \"caused_by\",\n            .custom => |s| s,\n        };\n    }\n\n    /// Parse a string into a DependencyType (case-insensitive for known values).\n    /// Returns .custom for unknown values.\n    pub fn fromString(s: []const u8) Self {\n        if (std.ascii.eqlIgnoreCase(s, \"blocks\")) return .blocks;\n        if (std.ascii.eqlIgnoreCase(s, \"parent_child\")) return .parent_child;\n        if (std.ascii.eqlIgnoreCase(s, \"conditional_blocks\")) return .conditional_blocks;\n        if (std.ascii.eqlIgnoreCase(s, \"waits_for\")) return .waits_for;\n        if (std.ascii.eqlIgnoreCase(s, \"related\")) return .related;\n        if (std.ascii.eqlIgnoreCase(s, \"discovered_from\")) return .discovered_from;\n        if (std.ascii.eqlIgnoreCase(s, \"replies_to\")) return .replies_to;\n        if (std.ascii.eqlIgnoreCase(s, \"relates_to\")) return .relates_to;\n        if (std.ascii.eqlIgnoreCase(s, \"duplicates\")) return .duplicates;\n        if (std.ascii.eqlIgnoreCase(s, \"supersedes\")) return .supersedes;\n        if (std.ascii.eqlIgnoreCase(s, \"caused_by\")) return .caused_by;\n        return .{ .custom = s };\n    }\n\n    /// Check equality between two DependencyTypes.\n    pub fn eql(a: Self, b: Self) bool {\n        const Tag = std.meta.Tag(Self);\n        const tag_a: Tag = a;\n        const tag_b: Tag = b;\n        if (tag_a != tag_b) return false;\n        return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n    }\n\n    /// JSON serialization for std.json.\n    pub fn jsonStringify(self: Self, jws: anytype) !void {\n        try jws.write(self.toString());\n    }\n\n    /// JSON deserialization for std.json.\n    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n        const str = switch (token) {\n            .string, .allocated_string => |s| s,\n            else => return error.UnexpectedToken,\n        };\n        return fromString(str);\n    }\n\n    /// JSON deserialization from already-parsed value.\n    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n        _ = allocator;\n        _ = options;\n        return switch (source) {\n            .string => |s| fromString(s),\n            else => error.UnexpectedToken,\n        };\n    }\n};\n\n/// A dependency relationship between two issues.\n/// issue_id depends ON depends_on_id (issue_id is blocked BY depends_on_id).\npub const Dependency = struct {\n    issue_id: []const u8,\n    depends_on_id: []const u8,\n    dep_type: DependencyType,\n    created_at: i64,\n    created_by: ?[]const u8,\n    metadata: ?[]const u8,\n    thread_id: ?[]const u8,\n\n    const Self = @This();\n\n    /// Check deep equality between two Dependencies.\n    pub fn eql(a: Self, b: Self) bool {\n        if (!std.mem.eql(u8, a.issue_id, b.issue_id)) return false;\n        if (!std.mem.eql(u8, a.depends_on_id, b.depends_on_id)) return false;\n        if (!DependencyType.eql(a.dep_type, b.dep_type)) return false;\n        if (a.created_at != b.created_at) return false;\n        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n        if (!optionalStrEql(a.metadata, b.metadata)) return false;\n        if (!optionalStrEql(a.thread_id, b.thread_id)) return false;\n        return true;\n    }\n\n    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n        const a_val = a orelse return b == null;\n        const b_val = b orelse return false;\n        return std.mem.eql(u8, a_val, b_val);\n    }\n};\n\n// --- DependencyType Tests ---\n\ntest \"DependencyType.toString returns correct strings for known types\" {\n    try std.testing.expectEqualStrings(\"blocks\", (DependencyType{ .blocks = {} }).toString());\n    try std.testing.expectEqualStrings(\"parent_child\", (DependencyType{ .parent_child = {} }).toString());\n    try std.testing.expectEqualStrings(\"conditional_blocks\", (DependencyType{ .conditional_blocks = {} }).toString());\n    try std.testing.expectEqualStrings(\"waits_for\", (DependencyType{ .waits_for = {} }).toString());\n    try std.testing.expectEqualStrings(\"related\", (DependencyType{ .related = {} }).toString());\n    try std.testing.expectEqualStrings(\"discovered_from\", (DependencyType{ .discovered_from = {} }).toString());\n    try std.testing.expectEqualStrings(\"replies_to\", (DependencyType{ .replies_to = {} }).toString());\n    try std.testing.expectEqualStrings(\"relates_to\", (DependencyType{ .relates_to = {} }).toString());\n    try std.testing.expectEqualStrings(\"duplicates\", (DependencyType{ .duplicates = {} }).toString());\n    try std.testing.expectEqualStrings(\"supersedes\", (DependencyType{ .supersedes = {} }).toString());\n    try std.testing.expectEqualStrings(\"caused_by\", (DependencyType{ .caused_by = {} }).toString());\n}\n\ntest \"DependencyType.toString returns custom string for custom type\" {\n    const custom = DependencyType{ .custom = \"my_custom_dep\" };\n    try std.testing.expectEqualStrings(\"my_custom_dep\", custom.toString());\n}\n\ntest \"DependencyType.fromString parses known types correctly\" {\n    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"blocks\"));\n    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"parent_child\"));\n    try std.testing.expectEqual(DependencyType.conditional_blocks, DependencyType.fromString(\"conditional_blocks\"));\n    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"waits_for\"));\n    try std.testing.expectEqual(DependencyType.related, DependencyType.fromString(\"related\"));\n    try std.testing.expectEqual(DependencyType.discovered_from, DependencyType.fromString(\"discovered_from\"));\n    try std.testing.expectEqual(DependencyType.replies_to, DependencyType.fromString(\"replies_to\"));\n    try std.testing.expectEqual(DependencyType.relates_to, DependencyType.fromString(\"relates_to\"));\n    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"duplicates\"));\n    try std.testing.expectEqual(DependencyType.supersedes, DependencyType.fromString(\"supersedes\"));\n    try std.testing.expectEqual(DependencyType.caused_by, DependencyType.fromString(\"caused_by\"));\n}\n\ntest \"DependencyType.fromString is case-insensitive\" {\n    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"BLOCKS\"));\n    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"Blocks\"));\n    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"bLoCkS\"));\n    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"PARENT_CHILD\"));\n    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"Parent_Child\"));\n    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"WAITS_FOR\"));\n    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"DUPLICATES\"));\n}\n\ntest \"DependencyType.fromString returns custom for unknown values\" {\n    const result = DependencyType.fromString(\"unknown_dep_type\");\n    switch (result) {\n        .custom => |s| try std.testing.expectEqualStrings(\"unknown_dep_type\", s),\n        else => return error.TestExpectedCustom,\n    }\n}\n\ntest \"DependencyType toString/fromString roundtrip for known types\" {\n    const dep_types = [_]DependencyType{\n        .blocks,\n        .parent_child,\n        .conditional_blocks,\n        .waits_for,\n        .related,\n        .discovered_from,\n        .replies_to,\n        .relates_to,\n        .duplicates,\n        .supersedes,\n        .caused_by,\n    };\n\n    for (dep_types) |dep_type| {\n        const str = dep_type.toString();\n        const parsed = DependencyType.fromString(str);\n        try std.testing.expectEqual(dep_type, parsed);\n    }\n}\n\ntest \"DependencyType toString/fromString roundtrip for custom type\" {\n    const original = DependencyType{ .custom = \"my_workflow_dep\" };\n    const str = original.toString();\n    const parsed = DependencyType.fromString(str);\n\n    switch (parsed) {\n        .custom => |s| try std.testing.expectEqualStrings(\"my_workflow_dep\", s),\n        else => return error.TestExpectedCustom,\n    }\n}\n\ntest \"DependencyType.eql compares correctly\" {\n    try std.testing.expect(DependencyType.eql(.blocks, .blocks));\n    try std.testing.expect(DependencyType.eql(.parent_child, .parent_child));\n    try std.testing.expect(!DependencyType.eql(.blocks, .parent_child));\n    try std.testing.expect(!DependencyType.eql(.waits_for, .duplicates));\n\n    const custom1 = DependencyType{ .custom = \"foo\" };\n    const custom2 = DependencyType{ .custom = \"foo\" };\n    const custom3 = DependencyType{ .custom = \"bar\" };\n    try std.testing.expect(DependencyType.eql(custom1, custom2));\n    try std.testing.expect(!DependencyType.eql(custom1, custom3));\n    try std.testing.expect(!DependencyType.eql(custom1, .blocks));\n}\n\ntest \"DependencyType JSON serialization roundtrip\" {\n    const allocator = std.testing.allocator;\n\n    const dep_types = [_]DependencyType{\n        .blocks,\n        .parent_child,\n        .conditional_blocks,\n        .waits_for,\n        .related,\n        .discovered_from,\n        .replies_to,\n        .relates_to,\n        .duplicates,\n        .supersedes,\n        .caused_by,\n    };\n\n    for (dep_types) |dep_type| {\n        var aw: std.io.Writer.Allocating = .init(allocator);\n        defer aw.deinit();\n\n        try std.json.Stringify.value(dep_type, .{}, &aw.writer);\n        const json_str = aw.written();\n\n        const parsed = try std.json.parseFromSlice(DependencyType, allocator, json_str, .{});\n        defer parsed.deinit();\n\n        try std.testing.expectEqual(dep_type, parsed.value);\n    }\n}\n\ntest \"DependencyType JSON deserialization of custom type\" {\n    const allocator = std.testing.allocator;\n\n    const json_str = \"\\\"custom_relationship\\\"\";\n    const parsed = try std.json.parseFromSlice(DependencyType, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    switch (parsed.value) {\n        .custom => |s| try std.testing.expectEqualStrings(\"custom_relationship\", s),\n        else => return error.TestExpectedCustom,\n    }\n}\n\ntest \"DependencyType JSON serializes as lowercase string\" {\n    const allocator = std.testing.allocator;\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(DependencyType.blocks, .{}, &aw.writer);\n\n    try std.testing.expectEqualStrings(\"\\\"blocks\\\"\", aw.written());\n}\n\n// --- Dependency Tests ---\n\ntest \"Dependency.eql compares all fields\" {\n    const dep1 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = \"alice@example.com\",\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    const dep2 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = \"alice@example.com\",\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expect(Dependency.eql(dep1, dep2));\n}\n\ntest \"Dependency.eql detects issue_id difference\" {\n    const dep1 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    const dep2 = Dependency{\n        .issue_id = \"bd-xyz789\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expect(!Dependency.eql(dep1, dep2));\n}\n\ntest \"Dependency.eql detects dep_type difference\" {\n    const dep1 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    const dep2 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .waits_for,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expect(!Dependency.eql(dep1, dep2));\n}\n\ntest \"Dependency.eql detects optional field differences\" {\n    const dep1 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = \"alice@example.com\",\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    const dep2 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expect(!Dependency.eql(dep1, dep2));\n}\n\ntest \"Dependency.eql handles metadata comparison\" {\n    const dep1 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n        .thread_id = null,\n    };\n\n    const dep2 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n        .thread_id = null,\n    };\n\n    const dep3 = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = \"{\\\"other\\\":\\\"data\\\"}\",\n        .thread_id = null,\n    };\n\n    try std.testing.expect(Dependency.eql(dep1, dep2));\n    try std.testing.expect(!Dependency.eql(dep1, dep3));\n}\n\ntest \"Dependency JSON serialization with all fields\" {\n    const allocator = std.testing.allocator;\n\n    const dep = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = \"alice@example.com\",\n        .metadata = \"{\\\"key\\\":\\\"value\\\"}\",\n        .thread_id = \"thread-001\",\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(dep, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Dependency.eql(dep, parsed.value));\n}\n\ntest \"Dependency JSON serialization with null fields\" {\n    const allocator = std.testing.allocator;\n\n    const dep = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = .parent_child,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(dep, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Dependency.eql(dep, parsed.value));\n}\n\ntest \"Dependency JSON serialization roundtrip with custom dep_type\" {\n    const allocator = std.testing.allocator;\n\n    const dep = Dependency{\n        .issue_id = \"bd-abc123\",\n        .depends_on_id = \"bd-def456\",\n        .dep_type = DependencyType{ .custom = \"my_custom_relation\" },\n        .created_at = 1706540000,\n        .created_by = \"bob@example.com\",\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(dep, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Dependency, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expectEqualStrings(dep.issue_id, parsed.value.issue_id);\n    try std.testing.expectEqualStrings(dep.depends_on_id, parsed.value.depends_on_id);\n    try std.testing.expectEqual(dep.created_at, parsed.value.created_at);\n    switch (parsed.value.dep_type) {\n        .custom => |s| try std.testing.expectEqualStrings(\"my_custom_relation\", s),\n        else => return error.TestExpectedCustom,\n    }\n}\n\ntest \"Dependency JSON contains expected fields\" {\n    const allocator = std.testing.allocator;\n\n    const dep = Dependency{\n        .issue_id = \"bd-test\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1234567890,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(dep, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"issue_id\\\"\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"depends_on_id\\\"\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"dep_type\\\"\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"created_at\\\"\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"created_by\\\"\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"metadata\\\"\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_str, \"\\\"thread_id\\\"\") != null);\n}\n","numLines":524,"startLine":1,"totalLines":524}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019FU33UbcfeiPDzQC8nfQ6A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014XoaUNQwuvEr9r89nfZ7P4","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2288,"cache_read_input_tokens":39157,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2288},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"668ac3b4-e6f3-4004-aa45-1419c3e7a2fd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014XoaUNQwuvEr9r89nfZ7P4","type":"tool_result","content":"     1→//! Dependency management commands for beads_zig.\n     2→//!\n     3→//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n     4→//! `bz dep remove <child> <parent>` - Remove dependency\n     5→//! `bz dep list <id>` - List dependencies for an issue\n     6→//!\n     7→//! Manages relationships between issues.\n     8→\n     9→const std = @import(\"std\");\n    10→const models = @import(\"../models/mod.zig\");\n    11→const storage = @import(\"../storage/mod.zig\");\n    12→const common = @import(\"common.zig\");\n    13→const args = @import(\"args.zig\");\n    14→const test_util = @import(\"../test_util.zig\");\n    15→\n    16→const Dependency = models.Dependency;\n    17→const DependencyType = models.DependencyType;\n    18→const CommandContext = common.CommandContext;\n    19→const DependencyGraph = common.DependencyGraph;\n    20→const DependencyGraphError = storage.DependencyGraphError;\n    21→\n    22→pub const DepError = error{\n    23→    WorkspaceNotInitialized,\n    24→    IssueNotFound,\n    25→    CycleDetected,\n    26→    SelfDependency,\n    27→    StorageError,\n    28→    OutOfMemory,\n    29→};\n    30→\n    31→pub const DepResult = struct {\n    32→    success: bool,\n    33→    action: ?[]const u8 = null,\n    34→    child: ?[]const u8 = null,\n    35→    parent: ?[]const u8 = null,\n    36→    depends_on: ?[]const []const u8 = null,\n    37→    blocks: ?[]const []const u8 = null,\n    38→    message: ?[]const u8 = null,\n    39→};\n    40→\n    41→pub fn run(\n    42→    dep_args: args.DepArgs,\n    43→    global: args.GlobalOptions,\n    44→    allocator: std.mem.Allocator,\n    45→) !void {\n    46→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    47→        return DepError.WorkspaceNotInitialized;\n    48→    };\n    49→    defer ctx.deinit();\n    50→\n    51→    var graph = ctx.createGraph();\n    52→\n    53→    switch (dep_args.subcommand) {\n    54→        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n    55→        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n    56→        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n    57→        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n    58→        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    59→    }\n    60→}\n    61→\n    62→fn runAdd(\n    63→    graph: *DependencyGraph,\n    64→    ctx: *CommandContext,\n    65→    add_args: anytype,\n    66→    global: args.GlobalOptions,\n    67→    allocator: std.mem.Allocator,\n    68→) !void {\n    69→    const structured_output = global.isStructuredOutput();\n    70→    if (!try ctx.store.exists(add_args.child)) {\n    71→        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n    72→        return DepError.IssueNotFound;\n    73→    }\n    74→\n    75→    if (!try ctx.store.exists(add_args.parent)) {\n    76→        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n    77→        return DepError.IssueNotFound;\n    78→    }\n    79→\n    80→    const now = std.time.timestamp();\n    81→    const dep = Dependency{\n    82→        .issue_id = add_args.child,\n    83→        .depends_on_id = add_args.parent,\n    84→        .dep_type = DependencyType.fromString(add_args.dep_type),\n    85→        .created_at = now,\n    86→        .created_by = global.actor,\n    87→        .metadata = null,\n    88→        .thread_id = null,\n    89→    };\n    90→\n    91→    graph.addDependency(dep) catch |err| {\n    92→        const msg = switch (err) {\n    93→            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n    94→            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n    95→            DependencyGraphError.IssueNotFound => \"issue not found\",\n    96→            else => \"failed to add dependency\",\n    97→        };\n    98→        try outputError(&ctx.output, structured_output, msg);\n    99→\n   100→        return switch (err) {\n   101→            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n   102→            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n   103→            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n   104→            else => DepError.StorageError,\n   105→        };\n   106→    };\n   107→\n   108→    try ctx.saveIfAutoFlush();\n   109→\n   110→    if (structured_output) {\n   111→        try ctx.output.printJson(DepResult{\n   112→            .success = true,\n   113→            .action = \"added\",\n   114→            .child = add_args.child,\n   115→            .parent = add_args.parent,\n   116→        });\n   117→    } else if (!global.quiet) {\n   118→        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n   119→    }\n   120→}\n   121→\n   122→fn runRemove(\n   123→    graph: *DependencyGraph,\n   124→    ctx: *CommandContext,\n   125→    remove_args: anytype,\n   126→    global: args.GlobalOptions,\n   127→) !void {\n   128→    const structured_output = global.isStructuredOutput();\n   129→    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n   130→        const msg = if (err == DependencyGraphError.IssueNotFound)\n   131→            \"issue not found\"\n   132→        else\n   133→            \"failed to remove dependency\";\n   134→        try outputError(&ctx.output, structured_output, msg);\n   135→\n   136→        return if (err == DependencyGraphError.IssueNotFound)\n   137→            DepError.IssueNotFound\n   138→        else\n   139→            DepError.StorageError;\n   140→    };\n   141→\n   142→    try ctx.saveIfAutoFlush();\n   143→\n   144→    if (structured_output) {\n   145→        try ctx.output.printJson(DepResult{\n   146→            .success = true,\n   147→            .action = \"removed\",\n   148→            .child = remove_args.child,\n   149→            .parent = remove_args.parent,\n   150→        });\n   151→    } else if (!global.quiet) {\n   152→        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n   153→    }\n   154→}\n   155→\n   156→fn runList(\n   157→    graph: *DependencyGraph,\n   158→    output: *common.Output,\n   159→    list_args: anytype,\n   160→    global: args.GlobalOptions,\n   161→    allocator: std.mem.Allocator,\n   162→) !void {\n   163→    const deps = try graph.getDependencies(list_args.id);\n   164→    defer graph.freeDependencies(deps);\n   165→\n   166→    const dependents = try graph.getDependents(list_args.id);\n   167→    defer graph.freeDependencies(dependents);\n   168→\n   169→    if (global.isStructuredOutput()) {\n   170→        var depends_on_ids: ?[][]const u8 = null;\n   171→        var blocks_ids: ?[][]const u8 = null;\n   172→\n   173→        if (deps.len > 0) {\n   174→            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n   175→            for (deps, 0..) |dep, i| {\n   176→                depends_on_ids.?[i] = dep.depends_on_id;\n   177→            }\n   178→        }\n   179→\n   180→        if (dependents.len > 0) {\n   181→            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n   182→            for (dependents, 0..) |dep, i| {\n   183→                blocks_ids.?[i] = dep.issue_id;\n   184→            }\n   185→        }\n   186→\n   187→        defer {\n   188→            if (depends_on_ids) |ids| allocator.free(ids);\n   189→            if (blocks_ids) |ids| allocator.free(ids);\n   190→        }\n   191→\n   192→        try output.printJson(DepResult{\n   193→            .success = true,\n   194→            .depends_on = depends_on_ids,\n   195→            .blocks = blocks_ids,\n   196→        });\n   197→    } else {\n   198→        if (deps.len > 0) {\n   199→            try output.println(\"Depends on:\", .{});\n   200→            for (deps) |dep| {\n   201→                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n   202→            }\n   203→        } else {\n   204→            try output.println(\"Depends on: (none)\", .{});\n   205→        }\n   206→\n   207→        if (dependents.len > 0) {\n   208→            try output.println(\"Blocks:\", .{});\n   209→            for (dependents) |dep| {\n   210→                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n   211→            }\n   212→        } else {\n   213→            try output.println(\"Blocks: (none)\", .{});\n   214→        }\n   215→    }\n   216→}\n   217→\n   218→/// Tree node for JSON output.\n   219→const TreeNode = struct {\n   220→    id: []const u8,\n   221→    title: []const u8,\n   222→    status: []const u8,\n   223→    children: ?[]const TreeNode = null,\n   224→};\n   225→\n   226→fn runTree(\n   227→    graph: *DependencyGraph,\n   228→    ctx: *CommandContext,\n   229→    tree_args: anytype,\n   230→    global: args.GlobalOptions,\n   231→    allocator: std.mem.Allocator,\n   232→) !void {\n   233→    const id = tree_args.id;\n   234→\n   235→    // Check if issue exists\n   236→    const issue = try ctx.store.get(id);\n   237→    if (issue == null) {\n   238→        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n   239→        return DepError.IssueNotFound;\n   240→    }\n   241→    var i = issue.?;\n   242→    defer i.deinit(allocator);\n   243→\n   244→    if (global.isStructuredOutput()) {\n   245→        // Build tree structure for JSON output\n   246→        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n   247→        defer freeTreeNode(root, allocator);\n   248→\n   249→        try ctx.output.printJson(.{\n   250→            .success = true,\n   251→            .tree = root,\n   252→        });\n   253→    } else {\n   254→        // ASCII tree output\n   255→        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n   256→\n   257→        // Show what this issue depends on (upstream dependencies)\n   258→        const deps = try graph.getDependencies(id);\n   259→        defer graph.freeDependencies(deps);\n   260→\n   261→        if (deps.len > 0) {\n   262→            try ctx.output.println(\"Depends on:\", .{});\n   263→            var visited: std.StringHashMapUnmanaged(void) = .{};\n   264→            defer {\n   265→                var it = visited.keyIterator();\n   266→                while (it.next()) |key| allocator.free(key.*);\n   267→                visited.deinit(allocator);\n   268→            }\n   269→\n   270→            for (deps, 0..) |dep, idx| {\n   271→                const is_last = (idx == deps.len - 1);\n   272→                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n   273→            }\n   274→        }\n   275→\n   276→        // Show what depends on this issue (downstream dependents)\n   277→        const dependents = try graph.getDependents(id);\n   278→        defer graph.freeDependencies(dependents);\n   279→\n   280→        if (dependents.len > 0) {\n   281→            try ctx.output.print(\"\\n\", .{});\n   282→            try ctx.output.println(\"Blocked by this:\", .{});\n   283→            for (dependents, 0..) |dep, idx| {\n   284→                const is_last = (idx == dependents.len - 1);\n   285→                const prefix = if (is_last) \"`-- \" else \"|-- \";\n   286→                const dep_issue = try ctx.store.get(dep.issue_id);\n   287→                if (dep_issue) |di| {\n   288→                    var d = di;\n   289→                    defer d.deinit(allocator);\n   290→                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n   291→                } else {\n   292→                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n   293→                }\n   294→            }\n   295→        }\n   296→    }\n   297→}\n   298→\n   299→fn printTreeBranch(\n   300→    output: *common.Output,\n   301→    graph: *DependencyGraph,\n   302→    ctx: *CommandContext,\n   303→    id: []const u8,\n   304→    prefix: []const u8,\n   305→    is_last: bool,\n   306→    visited: *std.StringHashMapUnmanaged(void),\n   307→    allocator: std.mem.Allocator,\n   308→    depth: usize,\n   309→    max_depth: usize,\n   310→) !void {\n   311→    // Check for cycles\n   312→    if (visited.contains(id)) {\n   313→        const branch = if (is_last) \"`-- \" else \"|-- \";\n   314→        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n   315→        return;\n   316→    }\n   317→\n   318→    // Depth limit\n   319→    if (depth >= max_depth) {\n   320→        const branch = if (is_last) \"`-- \" else \"|-- \";\n   321→        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n   322→        return;\n   323→    }\n   324→\n   325→    // Mark as visited\n   326→    const id_copy = try allocator.dupe(u8, id);\n   327→    errdefer allocator.free(id_copy);\n   328→    try visited.put(allocator, id_copy, {});\n   329→\n   330→    // Get issue details\n   331→    const issue = try ctx.store.get(id);\n   332→    const branch = if (is_last) \"`-- \" else \"|-- \";\n   333→\n   334→    if (issue) |i| {\n   335→        var iss = i;\n   336→        defer iss.deinit(allocator);\n   337→        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n   338→    } else {\n   339→        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n   340→        return;\n   341→    }\n   342→\n   343→    // Get dependencies of this issue\n   344→    const deps = try graph.getDependencies(id);\n   345→    defer graph.freeDependencies(deps);\n   346→\n   347→    // Build new prefix for children\n   348→    var new_prefix_buf: [256]u8 = undefined;\n   349→    const extension = if (is_last) \"    \" else \"|   \";\n   350→    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n   351→\n   352→    for (deps, 0..) |dep, idx| {\n   353→        const child_is_last = (idx == deps.len - 1);\n   354→        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n   355→    }\n   356→}\n   357→\n   358→fn buildTreeNode(\n   359→    graph: *DependencyGraph,\n   360→    ctx: *CommandContext,\n   361→    id: []const u8,\n   362→    allocator: std.mem.Allocator,\n   363→    depth: usize,\n   364→    max_depth: usize,\n   365→) !TreeNode {\n   366→    const issue = try ctx.store.get(id);\n   367→    var title: []const u8 = \"(not found)\";\n   368→    var status: []const u8 = \"unknown\";\n   369→\n   370→    if (issue) |i| {\n   371→        var iss = i;\n   372→        defer iss.deinit(allocator);\n   373→        title = try allocator.dupe(u8, iss.title);\n   374→        status = iss.status.toString();\n   375→    }\n   376→\n   377→    if (depth >= max_depth) {\n   378→        return TreeNode{\n   379→            .id = try allocator.dupe(u8, id),\n   380→            .title = title,\n   381→            .status = try allocator.dupe(u8, status),\n   382→            .children = null,\n   383→        };\n   384→    }\n   385→\n   386→    const deps = try graph.getDependencies(id);\n   387→    defer graph.freeDependencies(deps);\n   388→\n   389→    var children: ?[]TreeNode = null;\n   390→    if (deps.len > 0) {\n   391→        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n   392→        for (deps, 0..) |dep, idx| {\n   393→            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n   394→        }\n   395→        children = child_nodes;\n   396→    }\n   397→\n   398→    return TreeNode{\n   399→        .id = try allocator.dupe(u8, id),\n   400→        .title = title,\n   401→        .status = try allocator.dupe(u8, status),\n   402→        .children = children,\n   403→    };\n   404→}\n   405→\n   406→fn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n   407→    allocator.free(node.id);\n   408→    allocator.free(node.title);\n   409→    allocator.free(node.status);\n   410→    if (node.children) |children| {\n   411→        for (children) |child| {\n   412→            freeTreeNode(child, allocator);\n   413→        }\n   414→        allocator.free(children);\n   415→    }\n   416→}\n   417→\n   418→fn runCycles(\n   419→    graph: *DependencyGraph,\n   420→    output: *common.Output,\n   421→    global: args.GlobalOptions,\n   422→    allocator: std.mem.Allocator,\n   423→) !void {\n   424→    const cycles = try graph.detectCycles();\n   425→    const structured_output = global.isStructuredOutput();\n   426→\n   427→    if (cycles) |c| {\n   428→        defer graph.freeCycles(c);\n   429→\n   430→        if (structured_output) {\n   431→            var cycle_strs = try allocator.alloc([]const u8, c.len);\n   432→            defer allocator.free(cycle_strs);\n   433→            for (c, 0..) |cycle, i| {\n   434→                cycle_strs[i] = cycle;\n   435→            }\n   436→            try output.printJson(.{\n   437→                .success = true,\n   438→                .cycles_found = true,\n   439→                .cycles = cycle_strs,\n   440→            });\n   441→        } else {\n   442→            try output.warn(\"Cycles detected:\", .{});\n   443→            for (c) |cycle| {\n   444→                try output.print(\"  {s}\\n\", .{cycle});\n   445→            }\n   446→        }\n   447→    } else {\n   448→        if (structured_output) {\n   449→            try output.printJson(.{\n   450→                .success = true,\n   451→                .cycles_found = false,\n   452→            });\n   453→        } else {\n   454→            try output.success(\"No cycles detected\", .{});\n   455→        }\n   456→    }\n   457→}\n   458→\n   459→fn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n   460→    if (json_mode) {\n   461→        try output.printJson(DepResult{\n   462→            .success = false,\n   463→            .message = message,\n   464→        });\n   465→    } else {\n   466→        try output.err(\"{s}\", .{message});\n   467→    }\n   468→}\n   469→\n   470→// --- Tests ---\n   471→\n   472→test \"DepError enum exists\" {\n   473→    const err: DepError = DepError.CycleDetected;\n   474→    try std.testing.expect(err == DepError.CycleDetected);\n   475→}\n   476→\n   477→test \"DepResult struct works\" {\n   478→    const result = DepResult{\n   479→        .success = true,\n   480→        .action = \"added\",\n   481→        .child = \"bd-child\",\n   482→        .parent = \"bd-parent\",\n   483→    };\n   484→    try std.testing.expect(result.success);\n   485→    try std.testing.expectEqualStrings(\"added\", result.action.?);\n   486→}\n   487→\n   488→test \"run detects uninitialized workspace\" {\n   489→    const allocator = std.testing.allocator;\n   490→\n   491→    const dep_args = args.DepArgs{\n   492→        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   493→    };\n   494→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   495→\n   496→    const result = run(dep_args, global, allocator);\n   497→    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n   498→}\n   499→\n   500→test \"runList returns empty for empty workspace\" {\n   501→    const allocator = std.testing.allocator;\n   502→\n   503→    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n   504→    defer allocator.free(tmp_dir_path);\n   505→    defer test_util.cleanupTestDir(tmp_dir_path);\n   506→\n   507→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   508→    defer allocator.free(data_path);\n   509→\n   510→    try std.fs.cwd().makeDir(data_path);\n   511→\n   512→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   513→    defer allocator.free(issues_path);\n   514→\n   515→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   516→    f.close();\n   517→\n   518→    const dep_args = args.DepArgs{\n   519→        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   520→    };\n   521→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   522→\n   523→    try run(dep_args, global, allocator);\n   524→}\n   525→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"edbb5e99-acb9-457d-a393-a97a64b0050a","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","content":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const deps = try graph.getDependencies(list_args.id);\n    defer graph.freeDependencies(deps);\n\n    const dependents = try graph.getDependents(list_args.id);\n    defer graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (deps.len > 0) {\n            try output.println(\"Depends on:\", .{});\n            for (deps) |dep| {\n                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n            }\n        } else {\n            try output.println(\"Depends on: (none)\", .{});\n        }\n\n        if (dependents.len > 0) {\n            try output.println(\"Blocks:\", .{});\n            for (dependents) |dep| {\n                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n            }\n        } else {\n            try output.println(\"Blocks: (none)\", .{});\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","numLines":525,"startLine":1,"totalLines":525}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019FU33UbcfeiPDzQC8nfQ6A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KZD4BmCyfJJ3FcgdMob7g4","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2288,"cache_read_input_tokens":39157,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2288},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"96311671-86ba-4389-9b19-e76cf925943a"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (28591 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01KZD4BmCyfJJ3FcgdMob7g4"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"0c31512a-4e95-4415-a178-0e8bca9e8990","tool_use_result":"Error: File content (28591 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017ANvnwjGNCzV6ssjZR5RXb","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the args.zig file in portions to understand the command structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15330,"cache_read_input_tokens":41445,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15330},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a2d6c867-a948-4b6f-919f-77a329643ebd"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017ANvnwjGNCzV6ssjZR5RXb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HhhGE5ekkzkAZQgwK7fn4u","name":"Grep","input":{"pattern":"DepArgs|DepSubcommand|dep_type","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15330,"cache_read_input_tokens":41445,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15330},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"57d1f12e-b307-405a-ba34-22e4c1fd17e4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HhhGE5ekkzkAZQgwK7fn4u","type":"tool_result","content":"67-    count: CountArgs,\n68-    defer_cmd: DeferArgs,\n69-    undefer: UndeferArgs,\n70-\n71-    // Dependencies\n72:    dep: DepArgs,\n73-    graph: GraphArgs,\n74-\n75-    // Epics\n76-    epic: EpicArgs,\n77-\n--\n346-pub const EpicArgs = struct {\n347-    subcommand: EpicSubcommand,\n348-};\n349-\n350-/// Dependency subcommand variants.\n351:pub const DepSubcommand = union(enum) {\n352-    add: struct {\n353-        child: []const u8,\n354-        parent: []const u8,\n355:        dep_type: []const u8 = \"blocks\",\n356-    },\n357-    remove: struct {\n358-        child: []const u8,\n359-        parent: []const u8,\n360-    },\n--\n366-    },\n367-    cycles: void,\n368-};\n369-\n370-/// Dependency command arguments.\n371:pub const DepArgs = struct {\n372:    subcommand: DepSubcommand,\n373-};\n374-\n375-/// Graph command output formats.\n376-pub const GraphFormat = enum {\n377-    ascii,\n--\n783-            return .{ .undefer = try self.parseUndeferArgs() };\n784-        }\n785-\n786-        // Dependencies\n787-        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n788:            return .{ .dep = try self.parseDepArgs() };\n789-        }\n790-        if (std.mem.eql(u8, cmd, \"graph\")) {\n791-            return .{ .graph = try self.parseGraphArgs() };\n792-        }\n793-\n--\n1267-    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n1268-        const id = self.next() orelse return error.MissingRequiredArgument;\n1269-        return UndeferArgs{ .id = id };\n1270-    }\n1271-\n1272:    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n1273-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1274-\n1275-        if (std.mem.eql(u8, subcmd, \"add\")) {\n1276-            const child = self.next() orelse return error.MissingRequiredArgument;\n1277-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1278:            var dep_type: []const u8 = \"blocks\";\n1279-            while (self.hasNext()) {\n1280-                if (self.consumeFlag(\"-t\", \"--type\")) {\n1281:                    dep_type = self.next() orelse return error.MissingFlagValue;\n1282-                } else break;\n1283-            }\n1284:            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n1285-        }\n1286-        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1287-            const child = self.next() orelse return error.MissingRequiredArgument;\n1288-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1289-            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n--\n2104-\n2105-    try std.testing.expect(result.command == .dep);\n2106-    const add = result.command.dep.subcommand.add;\n2107-    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n2108-    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n2109:    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n2110-}\n2111-\n2112-test \"parse dep add command with type\" {\n2113-    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n2114-    var parser = ArgParser.init(std.testing.allocator, &args);\n2115-    const result = try parser.parse();\n2116-\n2117-    const add = result.command.dep.subcommand.add;\n2118:    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n2119-}\n2120-\n2121-test \"parse dep remove command\" {\n2122-    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n2123-    var parser = ArgParser.init(std.testing.allocator, &args);"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"2f82c952-82a2-44ac-ad34-4aa6e0a7ca5d","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"67-    count: CountArgs,\n68-    defer_cmd: DeferArgs,\n69-    undefer: UndeferArgs,\n70-\n71-    // Dependencies\n72:    dep: DepArgs,\n73-    graph: GraphArgs,\n74-\n75-    // Epics\n76-    epic: EpicArgs,\n77-\n--\n346-pub const EpicArgs = struct {\n347-    subcommand: EpicSubcommand,\n348-};\n349-\n350-/// Dependency subcommand variants.\n351:pub const DepSubcommand = union(enum) {\n352-    add: struct {\n353-        child: []const u8,\n354-        parent: []const u8,\n355:        dep_type: []const u8 = \"blocks\",\n356-    },\n357-    remove: struct {\n358-        child: []const u8,\n359-        parent: []const u8,\n360-    },\n--\n366-    },\n367-    cycles: void,\n368-};\n369-\n370-/// Dependency command arguments.\n371:pub const DepArgs = struct {\n372:    subcommand: DepSubcommand,\n373-};\n374-\n375-/// Graph command output formats.\n376-pub const GraphFormat = enum {\n377-    ascii,\n--\n783-            return .{ .undefer = try self.parseUndeferArgs() };\n784-        }\n785-\n786-        // Dependencies\n787-        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n788:            return .{ .dep = try self.parseDepArgs() };\n789-        }\n790-        if (std.mem.eql(u8, cmd, \"graph\")) {\n791-            return .{ .graph = try self.parseGraphArgs() };\n792-        }\n793-\n--\n1267-    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n1268-        const id = self.next() orelse return error.MissingRequiredArgument;\n1269-        return UndeferArgs{ .id = id };\n1270-    }\n1271-\n1272:    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n1273-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1274-\n1275-        if (std.mem.eql(u8, subcmd, \"add\")) {\n1276-            const child = self.next() orelse return error.MissingRequiredArgument;\n1277-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1278:            var dep_type: []const u8 = \"blocks\";\n1279-            while (self.hasNext()) {\n1280-                if (self.consumeFlag(\"-t\", \"--type\")) {\n1281:                    dep_type = self.next() orelse return error.MissingFlagValue;\n1282-                } else break;\n1283-            }\n1284:            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n1285-        }\n1286-        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1287-            const child = self.next() orelse return error.MissingRequiredArgument;\n1288-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1289-            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n--\n2104-\n2105-    try std.testing.expect(result.command == .dep);\n2106-    const add = result.command.dep.subcommand.add;\n2107-    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n2108-    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n2109:    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n2110-}\n2111-\n2112-test \"parse dep add command with type\" {\n2113-    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n2114-    var parser = ArgParser.init(std.testing.allocator, &args);\n2115-    const result = try parser.parse();\n2116-\n2117-    const add = result.command.dep.subcommand.add;\n2118:    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n2119-}\n2120-\n2121-test \"parse dep remove command\" {\n2122-    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n2123-    var parser = ArgParser.init(std.testing.allocator, &args);","numLines":97}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017ANvnwjGNCzV6ssjZR5RXb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AzXZMFSCmxDZMigrhEkZHs","name":"Grep","input":{"pattern":"LabelArgs|LabelSubcommand","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15330,"cache_read_input_tokens":41445,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15330},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"ffa44b41-6e36-4ade-9f89-630a073960f1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AzXZMFSCmxDZMigrhEkZHs","type":"tool_result","content":"74-\n75-    // Epics\n76-    epic: EpicArgs,\n77-\n78-    // Labels\n79:    label: LabelArgs,\n80-\n81-    // Comments\n82-    comments: CommentsArgs,\n83-\n84-    // Audit\n--\n391-    format: GraphFormat = .ascii,\n392-    depth: ?u32 = null, // Max depth for tree traversal\n393-};\n394-\n395-/// Label subcommand variants.\n396:pub const LabelSubcommand = union(enum) {\n397-    add: struct {\n398-        id: []const u8,\n399-        labels: []const []const u8,\n400-    },\n401-    remove: struct {\n--\n407-    },\n408-    list_all: void,\n409-};\n410-\n411-/// Label command arguments.\n412:pub const LabelArgs = struct {\n413:    subcommand: LabelSubcommand,\n414-};\n415-\n416-/// Comments subcommand variants.\n417-pub const CommentsSubcommand = union(enum) {\n418-    add: struct {\n--\n796-            return .{ .epic = try self.parseEpicArgs() };\n797-        }\n798-\n799-        // Labels\n800-        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n801:            return .{ .label = try self.parseLabelArgs() };\n802-        }\n803-\n804-        // Comments\n805-        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n806-            return .{ .comments = try self.parseCommentsArgs() };\n--\n1360-            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n1361-        }\n1362-        return error.UnknownSubcommand;\n1363-    }\n1364-\n1365:    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n1366-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1367-\n1368-        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1369-            const is_add = std.mem.eql(u8, subcmd, \"add\");\n1370-            const id = self.next() orelse return error.MissingRequiredArgument;"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7626a130-2ec8-442a-8d07-800f3f928881","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"74-\n75-    // Epics\n76-    epic: EpicArgs,\n77-\n78-    // Labels\n79:    label: LabelArgs,\n80-\n81-    // Comments\n82-    comments: CommentsArgs,\n83-\n84-    // Audit\n--\n391-    format: GraphFormat = .ascii,\n392-    depth: ?u32 = null, // Max depth for tree traversal\n393-};\n394-\n395-/// Label subcommand variants.\n396:pub const LabelSubcommand = union(enum) {\n397-    add: struct {\n398-        id: []const u8,\n399-        labels: []const []const u8,\n400-    },\n401-    remove: struct {\n--\n407-    },\n408-    list_all: void,\n409-};\n410-\n411-/// Label command arguments.\n412:pub const LabelArgs = struct {\n413:    subcommand: LabelSubcommand,\n414-};\n415-\n416-/// Comments subcommand variants.\n417-pub const CommentsSubcommand = union(enum) {\n418-    add: struct {\n--\n796-            return .{ .epic = try self.parseEpicArgs() };\n797-        }\n798-\n799-        // Labels\n800-        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n801:            return .{ .label = try self.parseLabelArgs() };\n802-        }\n803-\n804-        // Comments\n805-        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n806-            return .{ .comments = try self.parseCommentsArgs() };\n--\n1360-            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n1361-        }\n1362-        return error.UnknownSubcommand;\n1363-    }\n1364-\n1365:    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n1366-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1367-\n1368-        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1369-            const is_add = std.mem.eql(u8, subcmd, \"add\");\n1370-            const id = self.next() orelse return error.MissingRequiredArgument;","numLines":60}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019UbA1sUTrgnV4MEnngvvAy","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the label.zig file and more of args.zig (the label parsing section)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2346,"cache_read_input_tokens":56775,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2346},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"abd6bc84-cfca-4310-8923-b73cdbdf6936"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019UbA1sUTrgnV4MEnngvvAy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NmKmicNNMhi7TunP7b7YLp","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2346,"cache_read_input_tokens":56775,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2346},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9f06d61f-c8cc-4649-9ce1-71b02e302f84"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NmKmicNNMhi7TunP7b7YLp","type":"tool_result","content":"     1→//! Label commands for beads_zig.\n     2→//!\n     3→//! `bz label add <id> <labels...>` - Add labels to an issue\n     4→//! `bz label remove <id> <labels...>` - Remove labels from an issue\n     5→//! `bz label list <id>` - List labels on an issue\n     6→//! `bz label list-all` - List all labels in the project\n     7→\n     8→const std = @import(\"std\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→\n    12→const CommandContext = common.CommandContext;\n    13→\n    14→pub const LabelError = error{\n    15→    WorkspaceNotInitialized,\n    16→    StorageError,\n    17→    IssueNotFound,\n    18→    OutOfMemory,\n    19→};\n    20→\n    21→pub const LabelResult = struct {\n    22→    success: bool,\n    23→    id: ?[]const u8 = null,\n    24→    labels: ?[]const []const u8 = null,\n    25→    added: ?[]const []const u8 = null,\n    26→    removed: ?[]const []const u8 = null,\n    27→    message: ?[]const u8 = null,\n    28→};\n    29→\n    30→pub fn run(\n    31→    label_args: args.LabelArgs,\n    32→    global: args.GlobalOptions,\n    33→    allocator: std.mem.Allocator,\n    34→) !void {\n    35→    switch (label_args.subcommand) {\n    36→        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n    37→        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n    38→        .list => |list| try runList(list.id, global, allocator),\n    39→        .list_all => try runListAll(global, allocator),\n    40→    }\n    41→}\n    42→\n    43→fn runAdd(\n    44→    id: []const u8,\n    45→    labels: []const []const u8,\n    46→    global: args.GlobalOptions,\n    47→    allocator: std.mem.Allocator,\n    48→) !void {\n    49→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    50→        return LabelError.WorkspaceNotInitialized;\n    51→    };\n    52→    defer ctx.deinit();\n    53→\n    54→    // Verify issue exists\n    55→    if (!try ctx.store.exists(id)) {\n    56→        if (global.isStructuredOutput()) {\n    57→            try ctx.output.printJson(LabelResult{\n    58→                .success = false,\n    59→                .id = id,\n    60→                .message = \"issue not found\",\n    61→            });\n    62→        } else {\n    63→            try ctx.output.err(\"issue not found: {s}\", .{id});\n    64→        }\n    65→        return LabelError.IssueNotFound;\n    66→    }\n    67→\n    68→    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    69→    defer added_labels.deinit(allocator);\n    70→\n    71→    for (labels) |label| {\n    72→        // Check if already has label\n    73→        const existing = try ctx.store.getLabels(id);\n    74→        defer {\n    75→            for (existing) |lbl| {\n    76→                allocator.free(lbl);\n    77→            }\n    78→            allocator.free(existing);\n    79→        }\n    80→\n    81→        var has_label = false;\n    82→        for (existing) |existing_label| {\n    83→            if (std.mem.eql(u8, existing_label, label)) {\n    84→                has_label = true;\n    85→                break;\n    86→            }\n    87→        }\n    88→\n    89→        if (!has_label) {\n    90→            try ctx.store.addLabel(id, label);\n    91→            try added_labels.append(allocator, label);\n    92→        }\n    93→    }\n    94→\n    95→    try ctx.saveIfAutoFlush();\n    96→\n    97→    if (global.isStructuredOutput()) {\n    98→        try ctx.output.printJson(LabelResult{\n    99→            .success = true,\n   100→            .id = id,\n   101→            .added = added_labels.items,\n   102→        });\n   103→    } else if (global.quiet) {\n   104→        for (added_labels.items) |label| {\n   105→            try ctx.output.print(\"{s}\\n\", .{label});\n   106→        }\n   107→    } else {\n   108→        if (added_labels.items.len > 0) {\n   109→            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n   110→        } else {\n   111→            try ctx.output.info(\"No new labels added (already present)\", .{});\n   112→        }\n   113→    }\n   114→}\n   115→\n   116→fn runRemove(\n   117→    id: []const u8,\n   118→    labels: []const []const u8,\n   119→    global: args.GlobalOptions,\n   120→    allocator: std.mem.Allocator,\n   121→) !void {\n   122→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   123→        return LabelError.WorkspaceNotInitialized;\n   124→    };\n   125→    defer ctx.deinit();\n   126→\n   127→    // Verify issue exists\n   128→    if (!try ctx.store.exists(id)) {\n   129→        if (global.isStructuredOutput()) {\n   130→            try ctx.output.printJson(LabelResult{\n   131→                .success = false,\n   132→                .id = id,\n   133→                .message = \"issue not found\",\n   134→            });\n   135→        } else {\n   136→            try ctx.output.err(\"issue not found: {s}\", .{id});\n   137→        }\n   138→        return LabelError.IssueNotFound;\n   139→    }\n   140→\n   141→    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n   142→    defer removed_labels.deinit(allocator);\n   143→\n   144→    for (labels) |label| {\n   145→        // Check if has label\n   146→        const existing = try ctx.store.getLabels(id);\n   147→        defer {\n   148→            for (existing) |lbl| {\n   149→                allocator.free(lbl);\n   150→            }\n   151→            allocator.free(existing);\n   152→        }\n   153→\n   154→        var has_label = false;\n   155→        for (existing) |existing_label| {\n   156→            if (std.mem.eql(u8, existing_label, label)) {\n   157→                has_label = true;\n   158→                break;\n   159→            }\n   160→        }\n   161→\n   162→        if (has_label) {\n   163→            try ctx.store.removeLabel(id, label);\n   164→            try removed_labels.append(allocator, label);\n   165→        }\n   166→    }\n   167→\n   168→    try ctx.saveIfAutoFlush();\n   169→\n   170→    if (global.isStructuredOutput()) {\n   171→        try ctx.output.printJson(LabelResult{\n   172→            .success = true,\n   173→            .id = id,\n   174→            .removed = removed_labels.items,\n   175→        });\n   176→    } else if (global.quiet) {\n   177→        for (removed_labels.items) |label| {\n   178→            try ctx.output.print(\"{s}\\n\", .{label});\n   179→        }\n   180→    } else {\n   181→        if (removed_labels.items.len > 0) {\n   182→            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n   183→        } else {\n   184→            try ctx.output.info(\"No labels removed (not present)\", .{});\n   185→        }\n   186→    }\n   187→}\n   188→\n   189→fn runList(\n   190→    id: []const u8,\n   191→    global: args.GlobalOptions,\n   192→    allocator: std.mem.Allocator,\n   193→) !void {\n   194→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   195→        return LabelError.WorkspaceNotInitialized;\n   196→    };\n   197→    defer ctx.deinit();\n   198→\n   199→    // Verify issue exists\n   200→    if (!try ctx.store.exists(id)) {\n   201→        if (global.isStructuredOutput()) {\n   202→            try ctx.output.printJson(LabelResult{\n   203→                .success = false,\n   204→                .id = id,\n   205→                .message = \"issue not found\",\n   206→            });\n   207→        } else {\n   208→            try ctx.output.err(\"issue not found: {s}\", .{id});\n   209→        }\n   210→        return LabelError.IssueNotFound;\n   211→    }\n   212→\n   213→    const label_list = try ctx.store.getLabels(id);\n   214→    defer {\n   215→        for (label_list) |lbl| {\n   216→            allocator.free(lbl);\n   217→        }\n   218→        allocator.free(label_list);\n   219→    }\n   220→\n   221→    if (global.isStructuredOutput()) {\n   222→        try ctx.output.printJson(LabelResult{\n   223→            .success = true,\n   224→            .id = id,\n   225→            .labels = label_list,\n   226→        });\n   227→    } else if (global.quiet) {\n   228→        for (label_list) |label| {\n   229→            try ctx.output.print(\"{s}\\n\", .{label});\n   230→        }\n   231→    } else {\n   232→        if (label_list.len == 0) {\n   233→            try ctx.output.info(\"No labels on {s}\", .{id});\n   234→        } else {\n   235→            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n   236→            for (label_list) |label| {\n   237→                try ctx.output.print(\"  {s}\\n\", .{label});\n   238→            }\n   239→        }\n   240→    }\n   241→}\n   242→\n   243→fn runListAll(\n   244→    global: args.GlobalOptions,\n   245→    allocator: std.mem.Allocator,\n   246→) !void {\n   247→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   248→        return LabelError.WorkspaceNotInitialized;\n   249→    };\n   250→    defer ctx.deinit();\n   251→\n   252→    // Collect all unique labels across all issues\n   253→    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n   254→    defer {\n   255→        var key_it = all_labels.keyIterator();\n   256→        while (key_it.next()) |key| {\n   257→            allocator.free(key.*);\n   258→        }\n   259→        all_labels.deinit(allocator);\n   260→    }\n   261→\n   262→    for (ctx.store.issues.items) |issue| {\n   263→        if (issue.status.eql(.tombstone)) continue;\n   264→\n   265→        for (issue.labels) |label| {\n   266→            if (!all_labels.contains(label)) {\n   267→                const label_copy = try allocator.dupe(u8, label);\n   268→                try all_labels.put(allocator, label_copy, {});\n   269→            }\n   270→        }\n   271→    }\n   272→\n   273→    // Convert to sorted slice\n   274→    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n   275→    defer label_list.deinit(allocator);\n   276→\n   277→    var key_it = all_labels.keyIterator();\n   278→    while (key_it.next()) |key| {\n   279→        try label_list.append(allocator, key.*);\n   280→    }\n   281→\n   282→    // Sort alphabetically\n   283→    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n   284→        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n   285→            return std.mem.lessThan(u8, a, b);\n   286→        }\n   287→    }.lessThan);\n   288→\n   289→    if (global.isStructuredOutput()) {\n   290→        try ctx.output.printJson(LabelResult{\n   291→            .success = true,\n   292→            .labels = label_list.items,\n   293→        });\n   294→    } else if (global.quiet) {\n   295→        for (label_list.items) |label| {\n   296→            try ctx.output.print(\"{s}\\n\", .{label});\n   297→        }\n   298→    } else {\n   299→        if (label_list.items.len == 0) {\n   300→            try ctx.output.info(\"No labels in project\", .{});\n   301→        } else {\n   302→            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n   303→            for (label_list.items) |label| {\n   304→                try ctx.output.print(\"  {s}\\n\", .{label});\n   305→            }\n   306→        }\n   307→    }\n   308→}\n   309→\n   310→// --- Tests ---\n   311→\n   312→test \"LabelError enum exists\" {\n   313→    const err: LabelError = LabelError.WorkspaceNotInitialized;\n   314→    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n   315→}\n   316→\n   317→test \"LabelResult struct works\" {\n   318→    const result = LabelResult{\n   319→        .success = true,\n   320→        .id = \"bd-test\",\n   321→    };\n   322→    try std.testing.expect(result.success);\n   323→    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n   324→}\n   325→\n   326→test \"runAdd detects uninitialized workspace\" {\n   327→    const allocator = std.testing.allocator;\n   328→    const labels = [_][]const u8{\"test\"};\n   329→\n   330→    const label_args = args.LabelArgs{\n   331→        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n   332→    };\n   333→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   334→\n   335→    const result = run(label_args, global, allocator);\n   336→    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   337→}\n   338→\n   339→test \"runList detects uninitialized workspace\" {\n   340→    const allocator = std.testing.allocator;\n   341→\n   342→    const label_args = args.LabelArgs{\n   343→        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   344→    };\n   345→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   346→\n   347→    const result = run(label_args, global, allocator);\n   348→    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   349→}\n   350→\n   351→test \"runListAll detects uninitialized workspace\" {\n   352→    const allocator = std.testing.allocator;\n   353→\n   354→    const label_args = args.LabelArgs{\n   355→        .subcommand = .{ .list_all = {} },\n   356→    };\n   357→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   358→\n   359→    const result = run(label_args, global, allocator);\n   360→    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   361→}\n   362→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a34c3b4d-c411-4cbc-950e-540ad413820e","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","content":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","numLines":362,"startLine":1,"totalLines":362}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019UbA1sUTrgnV4MEnngvvAy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q6f2NAxYJcU2kTuL38rQRP","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1360,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2346,"cache_read_input_tokens":56775,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2346},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"3404f4df-b657-4c9b-8dc6-af664101e09f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q6f2NAxYJcU2kTuL38rQRP","type":"tool_result","content":"  1360→            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n  1361→        }\n  1362→        return error.UnknownSubcommand;\n  1363→    }\n  1364→\n  1365→    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n  1366→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1367→\n  1368→        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1369→            const is_add = std.mem.eql(u8, subcmd, \"add\");\n  1370→            const id = self.next() orelse return error.MissingRequiredArgument;\n  1371→            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n  1372→\n  1373→            while (self.peekPositional()) |_| {\n  1374→                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n  1375→            }\n  1376→\n  1377→            if (labels.items.len == 0) return error.MissingRequiredArgument;\n  1378→\n  1379→            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1380→            if (is_add) {\n  1381→                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n  1382→            } else {\n  1383→                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n  1384→            }\n  1385→        }\n  1386→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1387→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1388→        }\n  1389→        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n  1390→            return .{ .subcommand = .{ .list_all = {} } };\n  1391→        }\n  1392→        return error.UnknownSubcommand;\n  1393→    }\n  1394→\n  1395→    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n  1396→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1397→\n  1398→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1399→            return .{ .subcommand = .{ .add = .{\n  1400→                .id = self.next() orelse return error.MissingRequiredArgument,\n  1401→                .text = self.next() orelse return error.MissingRequiredArgument,\n  1402→            } } };\n  1403→        }\n  1404→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1405→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1406→        }\n  1407→        return error.UnknownSubcommand;\n  1408→    }\n  1409→\n  1410→    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n  1411→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1412→        return .{ .id = id };\n  1413→    }\n  1414→\n  1415→    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n  1416→        var result = AuditArgs{};\n  1417→        while (self.hasNext()) {\n  1418→            if (try self.parseLimitFlag()) |limit| {\n  1419→                result.limit = limit;\n  1420→            } else break;\n  1421→        }\n  1422→        return result;\n  1423→    }\n  1424→\n  1425→    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n  1426→        var result = ChangelogArgs{};\n  1427→        while (self.hasNext()) {\n  1428→            if (self.consumeFlag(null, \"--since\")) {\n  1429→                result.since = self.next() orelse return error.MissingFlagValue;\n  1430→            } else if (self.consumeFlag(null, \"--until\")) {\n  1431→                result.until = self.next() orelse return error.MissingFlagValue;\n  1432→            } else if (try self.parseLimitFlag()) |limit| {\n  1433→                result.limit = limit;\n  1434→            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1435→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1436→            } else break;\n  1437→        }\n  1438→        return result;\n  1439→    }\n  1440→\n  1441→    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n  1442→        var result = SyncArgs{};\n  1443→        while (self.hasNext()) {\n  1444→            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n  1445→                result.flush_only = true;\n  1446→            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n  1447→                result.import_only = true;\n  1448→            } else break;\n  1449→        }\n  1450→        return result;\n  1451→    }\n  1452→\n  1453→    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n  1454→        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n  1455→        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n  1456→        return .{ .shell = shell };\n  1457→    }\n  1458→\n  1459→    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"0b5315c2-b2be-495a-b251-6bfd029025e2","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {","numLines":100,"startLine":1360,"totalLines":2495}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kv6U1aS9coKAARWpUkoY5N","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a clear picture of the codebase. Let me create a todo list and start implementing the tasks."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6783,"cache_read_input_tokens":59121,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6783},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d9b48f11-bd0a-4004-9919-e915083af55c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kv6U1aS9coKAARWpUkoY5N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TjsFBpi8LQ1uRXQNczLhiL","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"in_progress","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"pending","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"pending","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"pending","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"pending","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6783,"cache_read_input_tokens":59121,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6783},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"5b9c55ca-3021-4438-b2d1-df3584bc44ca"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TjsFBpi8LQ1uRXQNczLhiL","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"1383b531-56ad-495f-abeb-0b0b7f1896ab","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"in_progress","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"pending","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"pending","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"pending","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"pending","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01B7xLJWA3bfDpiaLFp2pKt8","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me start implementing Task 1. First, I'll add the `--metadata` flag to the dep add command."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":356,"cache_read_input_tokens":65904,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":356},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"1b1cf1e6-4e86-417e-9c4a-9b14e95de8d4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01B7xLJWA3bfDpiaLFp2pKt8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K8Rz1LPM8hubM6LJUzsMCz","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":350,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":356,"cache_read_input_tokens":65904,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":356},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7f94aa0d-cdff-4e96-ade0-4798e5d03aa9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K8Rz1LPM8hubM6LJUzsMCz","type":"tool_result","content":"   350→/// Dependency subcommand variants.\n   351→pub const DepSubcommand = union(enum) {\n   352→    add: struct {\n   353→        child: []const u8,\n   354→        parent: []const u8,\n   355→        dep_type: []const u8 = \"blocks\",\n   356→    },\n   357→    remove: struct {\n   358→        child: []const u8,\n   359→        parent: []const u8,\n   360→    },\n   361→    list: struct {\n   362→        id: []const u8,\n   363→    },\n   364→    tree: struct {\n   365→        id: []const u8,\n   366→    },\n   367→    cycles: void,\n   368→};\n   369→\n   370→/// Dependency command arguments.\n   371→pub const DepArgs = struct {\n   372→    subcommand: DepSubcommand,\n   373→};\n   374→\n   375→/// Graph command output formats.\n   376→pub const GraphFormat = enum {\n   377→    ascii,\n   378→    dot,\n   379→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"dcd032ef-7457-48ee-b23e-6ae0b409d4f3","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n","numLines":30,"startLine":350,"totalLines":2495}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019BsnBQzwDtdvNE3Jy5rzJr","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the DepSubcommand to add the new flags:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":508,"cache_read_input_tokens":66260,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":508},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a2319127-cc1b-40fb-aecd-5f56df8e70fc"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019BsnBQzwDtdvNE3Jy5rzJr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YNuxmktzUnmqG5MJ4pcwir","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};","new_string":"/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":508,"cache_read_input_tokens":66260,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":508},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"16fd52b0-0fe1-439e-bc20-cadb095680e4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YNuxmktzUnmqG5MJ4pcwir","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a46b6a8b-18ac-483e-b429-12f0e78d290f","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};","newString":"/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":347,"oldLines":12,"newStart":347,"newLines":39,"lines":["     subcommand: EpicSubcommand,"," };"," ","+/// Direction filter for dependency listing.","+pub const DepDirection = enum {","+    up, // What depends on this issue (dependents/blocked-by)","+    down, // What this issue depends on","+    both, // Both directions (default)","+","+    pub fn fromString(s: []const u8) ?DepDirection {","+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;","+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;","+        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;","+        return null;","+    }","+};","+","+/// Tree output formats for dep tree.","+pub const TreeFormat = enum {","+    ascii,","+    mermaid,","+","+    pub fn fromString(s: []const u8) ?TreeFormat {","+        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;","+        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;","+        return null;","+    }","+};","+"," /// Dependency subcommand variants."," pub const DepSubcommand = union(enum) {","     add: struct {","         child: []const u8,","         parent: []const u8,","         dep_type: []const u8 = \"blocks\",","+        metadata: ?[]const u8 = null,","     },","     remove: struct {","         child: []const u8,"]},{"oldStart":360,"oldLines":9,"newStart":387,"newLines":11,"lines":["     },","     list: struct {","         id: []const u8,","+        direction: DepDirection = .both,","     },","     tree: struct {","         id: []const u8,","+        format: TreeFormat = .ascii,","     },","     cycles: void,"," };"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015msqmT1oV3Tsnjsm7V6Hoe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FcfiordVbr5ZQNyfvs3NaW","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"in_progress","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"completed","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"in_progress","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"pending","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"pending","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":748,"cache_read_input_tokens":66768,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":748},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d645e0de-6184-482a-ae5c-69c411159f28"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FcfiordVbr5ZQNyfvs3NaW","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"88f2fd2a-d464-4cdb-9939-717f0aba1b39","tool_use_result":{"oldTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"in_progress","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"pending","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"pending","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"pending","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"pending","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}],"newTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"in_progress","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"completed","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"in_progress","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"pending","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"pending","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XfvXQGGdsfu8NAarKaHntp","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the parseDepArgs function to handle the new flags:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":333,"cache_read_input_tokens":67516,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":333},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d3a7fa02-8a9e-4865-8d2c-5d837277195b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XfvXQGGdsfu8NAarKaHntp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LjSJoWY9zuzVEVVur3wWNK","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1270,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":333,"cache_read_input_tokens":67516,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":333},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"16f25ac0-9334-4ca2-bbfb-143ec3708275"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LjSJoWY9zuzVEVVur3wWNK","type":"tool_result","content":"  1270→        return result;\n  1271→    }\n  1272→\n  1273→    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n  1274→        var result = CountArgs{};\n  1275→        while (self.hasNext()) {\n  1276→            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1277→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1278→            } else break;\n  1279→        }\n  1280→        return result;\n  1281→    }\n  1282→\n  1283→    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n  1284→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1285→        var result = DeferArgs{ .id = id };\n  1286→        while (self.hasNext()) {\n  1287→            if (self.consumeFlag(\"-u\", \"--until\")) {\n  1288→                result.until = self.next() orelse return error.MissingFlagValue;\n  1289→            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n  1290→                result.reason = self.next() orelse return error.MissingFlagValue;\n  1291→            } else break;\n  1292→        }\n  1293→        return result;\n  1294→    }\n  1295→\n  1296→    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n  1297→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1298→        return UndeferArgs{ .id = id };\n  1299→    }\n  1300→\n  1301→    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n  1302→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1303→\n  1304→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1305→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1306→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1307→            var dep_type: []const u8 = \"blocks\";\n  1308→            while (self.hasNext()) {\n  1309→                if (self.consumeFlag(\"-t\", \"--type\")) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"f44df07c-0531-4e62-956d-cedcd53b4c39","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {","numLines":40,"startLine":1270,"totalLines":2524}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MmvVeVSLddTbvd9NjfDbeE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ELxvyNkHDmBW1uPWhQwRmw","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1300,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":855,"cache_read_input_tokens":67849,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":855},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a93f2d3f-d641-4f08-9385-f33a79cdc46d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ELxvyNkHDmBW1uPWhQwRmw","type":"tool_result","content":"  1300→\n  1301→    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n  1302→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1303→\n  1304→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1305→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1306→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1307→            var dep_type: []const u8 = \"blocks\";\n  1308→            while (self.hasNext()) {\n  1309→                if (self.consumeFlag(\"-t\", \"--type\")) {\n  1310→                    dep_type = self.next() orelse return error.MissingFlagValue;\n  1311→                } else break;\n  1312→            }\n  1313→            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n  1314→        }\n  1315→        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1316→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1317→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1318→            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n  1319→        }\n  1320→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1321→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1322→        }\n  1323→        if (std.mem.eql(u8, subcmd, \"tree\")) {\n  1324→            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1325→        }\n  1326→        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n  1327→            return .{ .subcommand = .{ .cycles = {} } };\n  1328→        }\n  1329→        return error.UnknownSubcommand;\n  1330→    }\n  1331→\n  1332→    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n  1333→        var result = GraphArgs{};\n  1334→\n  1335→        while (self.hasNext()) {\n  1336→            if (self.consumeFlag(\"-f\", \"--format\")) {\n  1337→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n  1338→                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n  1339→            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n  1340→                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n  1341→            } else if (self.peekPositional()) |_| {\n  1342→                if (result.id == null) {\n  1343→                    result.id = self.next().?;\n  1344→                } else break;\n  1345→            } else break;\n  1346→        }\n  1347→\n  1348→        return result;\n  1349→    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"03f1cbee-8a1a-479a-a9d4-42e492a54d8b","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }","numLines":50,"startLine":1300,"totalLines":2524}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TBdCfKhQE33WeiHCF8L1WP","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll update the parseDepArgs function to handle the new flags:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1150,"cache_read_input_tokens":68704,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1150},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"846e7399-63d7-44d7-87db-f99fa9f09bff"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TBdCfKhQE33WeiHCF8L1WP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018T2rAPLCTAgM5EQ5kdZpTX","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }","new_string":"    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1150,"cache_read_input_tokens":68704,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1150},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"555248e8-633c-4606-a017-d1b9d478cd9f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018T2rAPLCTAgM5EQ5kdZpTX","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"244eb826-44d7-44b1-95ba-8382a3d4537c","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }","newString":"    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1305,"oldLines":12,"newStart":1305,"newLines":15,"lines":["             const child = self.next() orelse return error.MissingRequiredArgument;","             const parent = self.next() orelse return error.MissingRequiredArgument;","             var dep_type: []const u8 = \"blocks\";","+            var metadata: ?[]const u8 = null;","             while (self.hasNext()) {","                 if (self.consumeFlag(\"-t\", \"--type\")) {","                     dep_type = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {","+                    metadata = self.next() orelse return error.MissingFlagValue;","                 } else break;","             }","-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };","+            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };","         }","         if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {","             const child = self.next() orelse return error.MissingRequiredArgument;"]},{"oldStart":1318,"oldLines":10,"newStart":1321,"newLines":26,"lines":["             return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };","         }","         if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {","-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };","+            const id = self.next() orelse return error.MissingRequiredArgument;","+            var direction: DepDirection = .both;","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-d\", \"--direction\")) {","+                    const dir_str = self.next() orelse return error.MissingFlagValue;","+                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;","+                } else break;","+            }","+            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };","         }","         if (std.mem.eql(u8, subcmd, \"tree\")) {","-            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };","+            const id = self.next() orelse return error.MissingRequiredArgument;","+            var format: TreeFormat = .ascii;","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-f\", \"--format\")) {","+                    const fmt_str = self.next() orelse return error.MissingFlagValue;","+                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;","+                } else break;","+            }","+            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };","         }","         if (std.mem.eql(u8, subcmd, \"cycles\")) {","             return .{ .subcommand = .{ .cycles = {} } };"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SAojRfNZx6t4C7CUnQ1n2U","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the dep.zig file to use these new flags. First, I'll update the runAdd function to use metadata:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1527,"cache_read_input_tokens":69854,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1527},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"926bcd4d-2efb-4b45-8109-e5c9b69e7190"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SAojRfNZx6t4C7CUnQ1n2U","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01543WZTT7ptFmkzSM91QShA","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","old_string":"fn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = null,\n        .thread_id = null,\n    };","new_string":"fn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1527,"cache_read_input_tokens":69854,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1527},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"f660ae20-31a5-489e-a9c6-cb7ea89bbc08"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01543WZTT7ptFmkzSM91QShA","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/dep.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"cb65504e-f07b-468a-9218-b01a5834c05d","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","oldString":"fn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = null,\n        .thread_id = null,\n    };","newString":"fn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };","originalFile":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const deps = try graph.getDependencies(list_args.id);\n    defer graph.freeDependencies(deps);\n\n    const dependents = try graph.getDependents(list_args.id);\n    defer graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (deps.len > 0) {\n            try output.println(\"Depends on:\", .{});\n            for (deps) |dep| {\n                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n            }\n        } else {\n            try output.println(\"Depends on: (none)\", .{});\n        }\n\n        if (dependents.len > 0) {\n            try output.println(\"Blocks:\", .{});\n            for (dependents) |dep| {\n                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n            }\n        } else {\n            try output.println(\"Blocks: (none)\", .{});\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":84,"oldLines":7,"newStart":84,"newLines":7,"lines":["         .dep_type = DependencyType.fromString(add_args.dep_type),","         .created_at = now,","         .created_by = global.actor,","-        .metadata = null,","+        .metadata = add_args.metadata,","         .thread_id = null,","     };"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J5B9YWbsNfWMVQXyPNj6k5","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the runList function to handle direction filtering:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":829,"cache_read_input_tokens":71381,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":829},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"dcd0add1-6630-4392-a184-a202378e8ca2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J5B9YWbsNfWMVQXyPNj6k5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JuiMJPrSS4DtHev2zrzx9F","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","old_string":"fn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const deps = try graph.getDependencies(list_args.id);\n    defer graph.freeDependencies(deps);\n\n    const dependents = try graph.getDependents(list_args.id);\n    defer graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (deps.len > 0) {\n            try output.println(\"Depends on:\", .{});\n            for (deps) |dep| {\n                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n            }\n        } else {\n            try output.println(\"Depends on: (none)\", .{});\n        }\n\n        if (dependents.len > 0) {\n            try output.println(\"Blocks:\", .{});\n            for (dependents) |dep| {\n                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n            }\n        } else {\n            try output.println(\"Blocks: (none)\", .{});\n        }\n    }\n}","new_string":"fn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (show_down and deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (show_up and dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (show_down) {\n            if (deps.len > 0) {\n                try output.println(\"Depends on:\", .{});\n                for (deps) |dep| {\n                    if (dep.metadata) |meta| {\n                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n                    } else {\n                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n                    }\n                }\n            } else {\n                try output.println(\"Depends on: (none)\", .{});\n            }\n        }\n\n        if (show_up) {\n            if (dependents.len > 0) {\n                try output.println(\"Blocks:\", .{});\n                for (dependents) |dep| {\n                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n                }\n            } else {\n                try output.println(\"Blocks: (none)\", .{});\n            }\n        }\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":829,"cache_read_input_tokens":71381,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":829},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"98b6a3c8-1995-47ac-8753-2a2dca8a48f5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JuiMJPrSS4DtHev2zrzx9F","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/dep.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"402e7780-282d-43ae-bd1d-1583051de5d8","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","oldString":"fn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const deps = try graph.getDependencies(list_args.id);\n    defer graph.freeDependencies(deps);\n\n    const dependents = try graph.getDependents(list_args.id);\n    defer graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (deps.len > 0) {\n            try output.println(\"Depends on:\", .{});\n            for (deps) |dep| {\n                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n            }\n        } else {\n            try output.println(\"Depends on: (none)\", .{});\n        }\n\n        if (dependents.len > 0) {\n            try output.println(\"Blocks:\", .{});\n            for (dependents) |dep| {\n                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n            }\n        } else {\n            try output.println(\"Blocks: (none)\", .{});\n        }\n    }\n}","newString":"fn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (show_down and deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (show_up and dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (show_down) {\n            if (deps.len > 0) {\n                try output.println(\"Depends on:\", .{});\n                for (deps) |dep| {\n                    if (dep.metadata) |meta| {\n                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n                    } else {\n                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n                    }\n                }\n            } else {\n                try output.println(\"Depends on: (none)\", .{});\n            }\n        }\n\n        if (show_up) {\n            if (dependents.len > 0) {\n                try output.println(\"Blocks:\", .{});\n                for (dependents) |dep| {\n                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n                }\n            } else {\n                try output.println(\"Blocks: (none)\", .{});\n            }\n        }\n    }\n}","originalFile":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const deps = try graph.getDependencies(list_args.id);\n    defer graph.freeDependencies(deps);\n\n    const dependents = try graph.getDependents(list_args.id);\n    defer graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (deps.len > 0) {\n            try output.println(\"Depends on:\", .{});\n            for (deps) |dep| {\n                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n            }\n        } else {\n            try output.println(\"Depends on: (none)\", .{});\n        }\n\n        if (dependents.len > 0) {\n            try output.println(\"Blocks:\", .{});\n            for (dependents) |dep| {\n                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n            }\n        } else {\n            try output.println(\"Blocks: (none)\", .{});\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":160,"oldLines":24,"newStart":160,"newLines":35,"lines":["     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {","-    const deps = try graph.getDependencies(list_args.id);","-    defer graph.freeDependencies(deps);","+    const direction = list_args.direction;","+    const show_down = direction == .down or direction == .both;","+    const show_up = direction == .up or direction == .both;"," ","-    const dependents = try graph.getDependents(list_args.id);","-    defer graph.freeDependencies(dependents);","+    var deps: []const Dependency = &.{};","+    var dependents: []const Dependency = &.{};"," ","+    if (show_down) {","+        deps = try graph.getDependencies(list_args.id);","+    }","+    defer if (show_down) graph.freeDependencies(deps);","+","+    if (show_up) {","+        dependents = try graph.getDependents(list_args.id);","+    }","+    defer if (show_up) graph.freeDependencies(dependents);","+","     if (global.isStructuredOutput()) {","         var depends_on_ids: ?[][]const u8 = null;","         var blocks_ids: ?[][]const u8 = null;"," ","-        if (deps.len > 0) {","+        if (show_down and deps.len > 0) {","             depends_on_ids = try allocator.alloc([]const u8, deps.len);","             for (deps, 0..) |dep, i| {","                 depends_on_ids.?[i] = dep.depends_on_id;","             }","         }"," ","-        if (dependents.len > 0) {","+        if (show_up and dependents.len > 0) {","             blocks_ids = try allocator.alloc([]const u8, dependents.len);","             for (dependents, 0..) |dep, i| {","                 blocks_ids.?[i] = dep.issue_id;"]},{"oldStart":195,"oldLines":22,"newStart":206,"newLines":30,"lines":["             .blocks = blocks_ids,","         });","     } else {","-        if (deps.len > 0) {","-            try output.println(\"Depends on:\", .{});","-            for (deps) |dep| {","-                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });","+        if (show_down) {","+            if (deps.len > 0) {","+                try output.println(\"Depends on:\", .{});","+                for (deps) |dep| {","+                    if (dep.metadata) |meta| {","+                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });","+                    } else {","+                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });","+                    }","+                }","+            } else {","+                try output.println(\"Depends on: (none)\", .{});","             }","-        } else {","-            try output.println(\"Depends on: (none)\", .{});","         }"," ","-        if (dependents.len > 0) {","-            try output.println(\"Blocks:\", .{});","-            for (dependents) |dep| {","-                try output.print(\"  - {s}\\n\", .{dep.issue_id});","+        if (show_up) {","+            if (dependents.len > 0) {","+                try output.println(\"Blocks:\", .{});","+                for (dependents) |dep| {","+                    try output.print(\"  - {s}\\n\", .{dep.issue_id});","+                }","+            } else {","+                try output.println(\"Blocks: (none)\", .{});","             }","-        } else {","-            try output.println(\"Blocks: (none)\", .{});","         }","     }"," }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SnuMKHbq4sCuDxMA426i5W","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the runTree function to support Mermaid format:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1608,"cache_read_input_tokens":72210,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1608},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"fc4d08eb-d80f-428f-b8c2-9f00cb5a9985"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SnuMKHbq4sCuDxMA426i5W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WNMG3dCfv5Ay6D1Vo6McXw","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","old_string":"fn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}","new_string":"fn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n    const format = tree_args.format;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else if (format == .mermaid) {\n        // Mermaid flowchart output\n        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1608,"cache_read_input_tokens":72210,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1608},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"bc3d82c6-e9ac-4c5c-aa30-789d09e888c7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WNMG3dCfv5Ay6D1Vo6McXw","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/dep.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7438d83f-71ef-42cf-9a3c-acd7898587aa","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","oldString":"fn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}","newString":"fn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n    const format = tree_args.format;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else if (format == .mermaid) {\n        // Mermaid flowchart output\n        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}","originalFile":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (show_down and deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (show_up and dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (show_down) {\n            if (deps.len > 0) {\n                try output.println(\"Depends on:\", .{});\n                for (deps) |dep| {\n                    if (dep.metadata) |meta| {\n                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n                    } else {\n                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n                    }\n                }\n            } else {\n                try output.println(\"Depends on: (none)\", .{});\n            }\n        }\n\n        if (show_up) {\n            if (dependents.len > 0) {\n                try output.println(\"Blocks:\", .{});\n                for (dependents) |dep| {\n                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n                }\n            } else {\n                try output.println(\"Blocks: (none)\", .{});\n            }\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":250,"oldLines":6,"newStart":250,"newLines":7,"lines":["     allocator: std.mem.Allocator,"," ) !void {","     const id = tree_args.id;","+    const format = tree_args.format;"," ","     // Check if issue exists","     const issue = try ctx.store.get(id);"]},{"oldStart":269,"oldLines":6,"newStart":270,"newLines":9,"lines":["             .success = true,","             .tree = root,","         });","+    } else if (format == .mermaid) {","+        // Mermaid flowchart output","+        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);","     } else {","         // ASCII tree output","         try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HrDxEFA2Pv93ugUDJmpg3D","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the `printMermaidTree` function. Let me add it after the `printTreeBranch` function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2080,"cache_read_input_tokens":73818,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2080},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"f29cff0a-77c3-4293-8f64-fccd2b65b038"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HrDxEFA2Pv93ugUDJmpg3D","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BLCmaMBY6BVZHRi1Hasmow","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","offset":350,"limit":70}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2080,"cache_read_input_tokens":73818,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2080},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"261392da-eb2b-446e-9c3e-689c37a37288"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BLCmaMBY6BVZHRi1Hasmow","type":"tool_result","content":"   350→    errdefer allocator.free(id_copy);\n   351→    try visited.put(allocator, id_copy, {});\n   352→\n   353→    // Get issue details\n   354→    const issue = try ctx.store.get(id);\n   355→    const branch = if (is_last) \"`-- \" else \"|-- \";\n   356→\n   357→    if (issue) |i| {\n   358→        var iss = i;\n   359→        defer iss.deinit(allocator);\n   360→        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n   361→    } else {\n   362→        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n   363→        return;\n   364→    }\n   365→\n   366→    // Get dependencies of this issue\n   367→    const deps = try graph.getDependencies(id);\n   368→    defer graph.freeDependencies(deps);\n   369→\n   370→    // Build new prefix for children\n   371→    var new_prefix_buf: [256]u8 = undefined;\n   372→    const extension = if (is_last) \"    \" else \"|   \";\n   373→    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n   374→\n   375→    for (deps, 0..) |dep, idx| {\n   376→        const child_is_last = (idx == deps.len - 1);\n   377→        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n   378→    }\n   379→}\n   380→\n   381→fn buildTreeNode(\n   382→    graph: *DependencyGraph,\n   383→    ctx: *CommandContext,\n   384→    id: []const u8,\n   385→    allocator: std.mem.Allocator,\n   386→    depth: usize,\n   387→    max_depth: usize,\n   388→) !TreeNode {\n   389→    const issue = try ctx.store.get(id);\n   390→    var title: []const u8 = \"(not found)\";\n   391→    var status: []const u8 = \"unknown\";\n   392→\n   393→    if (issue) |i| {\n   394→        var iss = i;\n   395→        defer iss.deinit(allocator);\n   396→        title = try allocator.dupe(u8, iss.title);\n   397→        status = iss.status.toString();\n   398→    }\n   399→\n   400→    if (depth >= max_depth) {\n   401→        return TreeNode{\n   402→            .id = try allocator.dupe(u8, id),\n   403→            .title = title,\n   404→            .status = try allocator.dupe(u8, status),\n   405→            .children = null,\n   406→        };\n   407→    }\n   408→\n   409→    const deps = try graph.getDependencies(id);\n   410→    defer graph.freeDependencies(deps);\n   411→\n   412→    var children: ?[]TreeNode = null;\n   413→    if (deps.len > 0) {\n   414→        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n   415→        for (deps, 0..) |dep, idx| {\n   416→            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n   417→        }\n   418→        children = child_nodes;\n   419→    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"e7703159-efb6-4cc8-80fc-26af5878ca01","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","content":"    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }","numLines":70,"startLine":350,"totalLines":548}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Tpx9fRCb5e63HDcfvDkgMv","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll add the printMermaidTree function after the printTreeBranch function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1221,"cache_read_input_tokens":75898,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1221},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"91cb1827-0b99-4292-bd5b-3701950d930a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Tpx9fRCb5e63HDcfvDkgMv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LVtHFKdib1jwN8vkp9RRU4","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","old_string":"    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(","new_string":"    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn printMermaidTree(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    root_id: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    // Start Mermaid flowchart\n    try output.println(\"```mermaid\", .{});\n    try output.println(\"flowchart TD\", .{});\n\n    // Track visited nodes to avoid duplicates\n    var visited: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var it = visited.keyIterator();\n        while (it.next()) |key| allocator.free(key.*);\n        visited.deinit(allocator);\n    }\n\n    // Track emitted edges to avoid duplicates\n    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var edge_it = emitted_edges.keyIterator();\n        while (edge_it.next()) |key| allocator.free(key.*);\n        emitted_edges.deinit(allocator);\n    }\n\n    // Collect all nodes and edges starting from root\n    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n\n    try output.println(\"```\", .{});\n}\n\nfn collectMermaidNodes(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    visited: *std.StringHashMapUnmanaged(void),\n    emitted_edges: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Skip if already visited\n    if (visited.contains(id)) return;\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details for node label\n    const issue = try ctx.store.get(id);\n    const safe_id = try sanitizeMermaidId(id, allocator);\n    defer allocator.free(safe_id);\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n        defer allocator.free(safe_title);\n        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n    } else {\n        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n    }\n\n    if (depth >= max_depth) return;\n\n    // Get dependencies (what this issue depends on)\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    for (deps) |dep| {\n        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n        defer allocator.free(target_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            // Emit edge with dependency type as label\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n        }\n\n        // Recurse into dependency\n        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n\n    // Get dependents (what depends on this issue)\n    const dependents = try graph.getDependents(id);\n    defer graph.freeDependencies(dependents);\n\n    for (dependents) |dep| {\n        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n        defer allocator.free(source_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n        }\n\n        // Recurse into dependent\n        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n}\n\nfn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Replace characters that are invalid in Mermaid node IDs\n    var result = try allocator.alloc(u8, id.len);\n    for (id, 0..) |c, i| {\n        result[i] = if (c == '-' or c == '.') '_' else c;\n    }\n    return result;\n}\n\nfn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Escape special characters in Mermaid labels\n    var count: usize = 0;\n    for (label) |c| {\n        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n    }\n\n    var result = try allocator.alloc(u8, count);\n    var i: usize = 0;\n    for (label) |c| {\n        if (c == '\"') {\n            result[i] = '\\\\';\n            result[i + 1] = '\"';\n            i += 2;\n        } else if (c == '\\\\') {\n            result[i] = '\\\\';\n            result[i + 1] = '\\\\';\n            i += 2;\n        } else {\n            result[i] = c;\n            i += 1;\n        }\n    }\n    return result;\n}\n\nfn buildTreeNode("}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1221,"cache_read_input_tokens":75898,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1221},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"154cd0fa-071b-46c7-a306-bb5724b26e4a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LVtHFKdib1jwN8vkp9RRU4","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/dep.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"82383ef5-f214-4de3-9da0-2c6a2b342062","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","oldString":"    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(","newString":"    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn printMermaidTree(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    root_id: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    // Start Mermaid flowchart\n    try output.println(\"```mermaid\", .{});\n    try output.println(\"flowchart TD\", .{});\n\n    // Track visited nodes to avoid duplicates\n    var visited: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var it = visited.keyIterator();\n        while (it.next()) |key| allocator.free(key.*);\n        visited.deinit(allocator);\n    }\n\n    // Track emitted edges to avoid duplicates\n    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var edge_it = emitted_edges.keyIterator();\n        while (edge_it.next()) |key| allocator.free(key.*);\n        emitted_edges.deinit(allocator);\n    }\n\n    // Collect all nodes and edges starting from root\n    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n\n    try output.println(\"```\", .{});\n}\n\nfn collectMermaidNodes(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    visited: *std.StringHashMapUnmanaged(void),\n    emitted_edges: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Skip if already visited\n    if (visited.contains(id)) return;\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details for node label\n    const issue = try ctx.store.get(id);\n    const safe_id = try sanitizeMermaidId(id, allocator);\n    defer allocator.free(safe_id);\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n        defer allocator.free(safe_title);\n        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n    } else {\n        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n    }\n\n    if (depth >= max_depth) return;\n\n    // Get dependencies (what this issue depends on)\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    for (deps) |dep| {\n        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n        defer allocator.free(target_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            // Emit edge with dependency type as label\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n        }\n\n        // Recurse into dependency\n        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n\n    // Get dependents (what depends on this issue)\n    const dependents = try graph.getDependents(id);\n    defer graph.freeDependencies(dependents);\n\n    for (dependents) |dep| {\n        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n        defer allocator.free(source_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n        }\n\n        // Recurse into dependent\n        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n}\n\nfn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Replace characters that are invalid in Mermaid node IDs\n    var result = try allocator.alloc(u8, id.len);\n    for (id, 0..) |c, i| {\n        result[i] = if (c == '-' or c == '.') '_' else c;\n    }\n    return result;\n}\n\nfn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Escape special characters in Mermaid labels\n    var count: usize = 0;\n    for (label) |c| {\n        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n    }\n\n    var result = try allocator.alloc(u8, count);\n    var i: usize = 0;\n    for (label) |c| {\n        if (c == '\"') {\n            result[i] = '\\\\';\n            result[i + 1] = '\"';\n            i += 2;\n        } else if (c == '\\\\') {\n            result[i] = '\\\\';\n            result[i + 1] = '\\\\';\n            i += 2;\n        } else {\n            result[i] = c;\n            i += 1;\n        }\n    }\n    return result;\n}\n\nfn buildTreeNode(","originalFile":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (show_down and deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (show_up and dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (show_down) {\n            if (deps.len > 0) {\n                try output.println(\"Depends on:\", .{});\n                for (deps) |dep| {\n                    if (dep.metadata) |meta| {\n                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n                    } else {\n                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n                    }\n                }\n            } else {\n                try output.println(\"Depends on: (none)\", .{});\n            }\n        }\n\n        if (show_up) {\n            if (dependents.len > 0) {\n                try output.println(\"Blocks:\", .{});\n                for (dependents) |dep| {\n                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n                }\n            } else {\n                try output.println(\"Blocks: (none)\", .{});\n            }\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n    const format = tree_args.format;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else if (format == .mermaid) {\n        // Mermaid flowchart output\n        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":378,"oldLines":6,"newStart":378,"newLines":160,"lines":["     }"," }"," ","+fn printMermaidTree(","+    output: *common.Output,","+    graph: *DependencyGraph,","+    ctx: *CommandContext,","+    root_id: []const u8,","+    allocator: std.mem.Allocator,","+) !void {","+    // Start Mermaid flowchart","+    try output.println(\"```mermaid\", .{});","+    try output.println(\"flowchart TD\", .{});","+","+    // Track visited nodes to avoid duplicates","+    var visited: std.StringHashMapUnmanaged(void) = .{};","+    defer {","+        var it = visited.keyIterator();","+        while (it.next()) |key| allocator.free(key.*);","+        visited.deinit(allocator);","+    }","+","+    // Track emitted edges to avoid duplicates","+    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};","+    defer {","+        var edge_it = emitted_edges.keyIterator();","+        while (edge_it.next()) |key| allocator.free(key.*);","+        emitted_edges.deinit(allocator);","+    }","+","+    // Collect all nodes and edges starting from root","+    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);","+","+    try output.println(\"```\", .{});","+}","+","+fn collectMermaidNodes(","+    output: *common.Output,","+    graph: *DependencyGraph,","+    ctx: *CommandContext,","+    id: []const u8,","+    visited: *std.StringHashMapUnmanaged(void),","+    emitted_edges: *std.StringHashMapUnmanaged(void),","+    allocator: std.mem.Allocator,","+    depth: usize,","+    max_depth: usize,","+) !void {","+    // Skip if already visited","+    if (visited.contains(id)) return;","+","+    // Mark as visited","+    const id_copy = try allocator.dupe(u8, id);","+    errdefer allocator.free(id_copy);","+    try visited.put(allocator, id_copy, {});","+","+    // Get issue details for node label","+    const issue = try ctx.store.get(id);","+    const safe_id = try sanitizeMermaidId(id, allocator);","+    defer allocator.free(safe_id);","+","+    if (issue) |i| {","+        var iss = i;","+        defer iss.deinit(allocator);","+        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);","+        defer allocator.free(safe_title);","+        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });","+    } else {","+        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });","+    }","+","+    if (depth >= max_depth) return;","+","+    // Get dependencies (what this issue depends on)","+    const deps = try graph.getDependencies(id);","+    defer graph.freeDependencies(deps);","+","+    for (deps) |dep| {","+        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);","+        defer allocator.free(target_id);","+","+        // Create edge key for deduplication","+        var edge_buf: [256]u8 = undefined;","+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;","+","+        if (!emitted_edges.contains(edge_key)) {","+            const edge_copy = try allocator.dupe(u8, edge_key);","+            try emitted_edges.put(allocator, edge_copy, {});","+","+            // Emit edge with dependency type as label","+            const dep_type_str = dep.dep_type.toString();","+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });","+        }","+","+        // Recurse into dependency","+        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);","+    }","+","+    // Get dependents (what depends on this issue)","+    const dependents = try graph.getDependents(id);","+    defer graph.freeDependencies(dependents);","+","+    for (dependents) |dep| {","+        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);","+        defer allocator.free(source_id);","+","+        // Create edge key for deduplication","+        var edge_buf: [256]u8 = undefined;","+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;","+","+        if (!emitted_edges.contains(edge_key)) {","+            const edge_copy = try allocator.dupe(u8, edge_key);","+            try emitted_edges.put(allocator, edge_copy, {});","+","+            const dep_type_str = dep.dep_type.toString();","+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });","+        }","+","+        // Recurse into dependent","+        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);","+    }","+}","+","+fn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {","+    // Replace characters that are invalid in Mermaid node IDs","+    var result = try allocator.alloc(u8, id.len);","+    for (id, 0..) |c, i| {","+        result[i] = if (c == '-' or c == '.') '_' else c;","+    }","+    return result;","+}","+","+fn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {","+    // Escape special characters in Mermaid labels","+    var count: usize = 0;","+    for (label) |c| {","+        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);","+    }","+","+    var result = try allocator.alloc(u8, count);","+    var i: usize = 0;","+    for (label) |c| {","+        if (c == '\"') {","+            result[i] = '\\\\';","+            result[i + 1] = '\"';","+            i += 2;","+        } else if (c == '\\\\') {","+            result[i] = '\\\\';","+            result[i + 1] = '\\\\';","+            i += 2;","+        } else {","+            result[i] = c;","+            i += 1;","+        }","+    }","+    return result;","+}","+"," fn buildTreeNode(","     graph: *DependencyGraph,","     ctx: *CommandContext,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JuAadGwzX6SZT6S5rbFF5H","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Uj2PtPXxR5oX5BUtXyviCE","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"completed","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"completed","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"completed","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"in_progress","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2126,"cache_read_input_tokens":77119,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2126},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"1efc3543-54e7-42c7-8220-a86ac60066fa"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Uj2PtPXxR5oX5BUtXyviCE","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"38c07983-a202-449d-8439-5d97064a23da","tool_use_result":{"oldTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"in_progress","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"completed","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"in_progress","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"pending","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"pending","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}],"newTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"completed","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"completed","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"completed","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"in_progress","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YNuZikgZwe9BQa3ugHhQRV","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me implement Task 2: Add label rename subcommand. First, I need to update the LabelSubcommand in args.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":331,"cache_read_input_tokens":79245,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":331},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"378a08e3-3eb7-4869-9f84-0c81180d7955"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YNuZikgZwe9BQa3ugHhQRV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KgPPVm73nezb4VLW89tT9Q","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":418,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":331,"cache_read_input_tokens":79245,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":331},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"be936849-3268-4b25-9b15-c96799d797b7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KgPPVm73nezb4VLW89tT9Q","type":"tool_result","content":"   418→pub const GraphArgs = struct {\n   419→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   420→    format: GraphFormat = .ascii,\n   421→    depth: ?u32 = null, // Max depth for tree traversal\n   422→};\n   423→\n   424→/// Label subcommand variants.\n   425→pub const LabelSubcommand = union(enum) {\n   426→    add: struct {\n   427→        id: []const u8,\n   428→        labels: []const []const u8,\n   429→    },\n   430→    remove: struct {\n   431→        id: []const u8,\n   432→        labels: []const []const u8,\n   433→    },\n   434→    list: struct {\n   435→        id: []const u8,\n   436→    },\n   437→    list_all: void,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"5a9049e1-855d-49b9-9a1f-6f19c9c6f2fe","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"pub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,","numLines":20,"startLine":418,"totalLines":2543}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DWyPp6CUhj2wpqspRgnW9a","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GsMkgc857C8U3jVyKvWj5p","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,","new_string":"/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":463,"cache_read_input_tokens":79576,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":463},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"2cba19f9-426f-4579-9028-96a8e07fae3f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GsMkgc857C8U3jVyKvWj5p","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"82dce197-ef7f-4d9e-bec7-378f2258d592","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,","newString":"/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":435,"oldLines":6,"newStart":435,"newLines":10,"lines":["         id: []const u8,","     },","     list_all: void,","+    rename: struct {","+        old_name: []const u8,","+        new_name: []const u8,","+    },"," };"," "," /// Label command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxdLGwsXKQpi8ac5qPCTnZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the parseLabelArgs function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":410,"cache_read_input_tokens":80039,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":410},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"2d7dbd39-0edc-4567-b8c1-9ddd3fdc5635"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxdLGwsXKQpi8ac5qPCTnZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F87QQwMGkdismBUYpCLWrc","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {","new_string":"        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":410,"cache_read_input_tokens":80039,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":410},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"e0a8d067-9916-426e-9003-bc6cfe958d2d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F87QQwMGkdismBUYpCLWrc","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9e24702f-ee4d-4a3a-b11e-ad34207ff24b","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {","newString":"        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1441,"oldLines":6,"newStart":1441,"newLines":11,"lines":["         if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {","             return .{ .subcommand = .{ .list_all = {} } };","         }","+        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {","+            const old_name = self.next() orelse return error.MissingRequiredArgument;","+            const new_name = self.next() orelse return error.MissingRequiredArgument;","+            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };","+        }","         return error.UnknownSubcommand;","     }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WWCdMfi4EHQUhVZVZC5GAi","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the label.zig to handle the new rename subcommand:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":501,"cache_read_input_tokens":80449,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":501},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9902b566-531a-4f97-aa4f-eccbd04a80b7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WWCdMfi4EHQUhVZVZC5GAi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015Rzc4Mx6SyxzJi4C8L3Fgt","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig","old_string":"pub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};","new_string":"pub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":501,"cache_read_input_tokens":80449,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":501},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"e7e18e62-49e3-4f55-add0-e6eedb066aa8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015Rzc4Mx6SyxzJi4C8L3Fgt","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/label.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"09d45946-9417-4f77-a805-e517d0c4d892","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","oldString":"pub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};","newString":"pub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};","originalFile":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","structuredPatch":[{"oldStart":24,"oldLines":6,"newStart":24,"newLines":9,"lines":["     labels: ?[]const []const u8 = null,","     added: ?[]const []const u8 = null,","     removed: ?[]const []const u8 = null,","+    old_name: ?[]const u8 = null,","+    new_name: ?[]const u8 = null,","+    renamed_count: ?usize = null,","     message: ?[]const u8 = null,"," };"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Df9Nj1SshWsTVJcETfVL5j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WgmtxGxs2QmqRUVgmQb4c3","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig","old_string":"pub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n    }\n}","new_string":"pub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":404,"cache_read_input_tokens":80950,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":404},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"fce5b2a6-cffb-4868-a6c8-7ba0e2ce76b5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WgmtxGxs2QmqRUVgmQb4c3","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/label.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"54338480-22be-41f7-b996-a3e7f17d4e5e","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","oldString":"pub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n    }\n}","newString":"pub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    }\n}","originalFile":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","structuredPatch":[{"oldStart":40,"oldLines":6,"newStart":40,"newLines":7,"lines":["         .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),","         .list => |list| try runList(list.id, global, allocator),","         .list_all => try runListAll(global, allocator),","+        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),","     }"," }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FMPjSpu31utFJMRJk45HV1","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the runRename function before the tests section:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":497,"cache_read_input_tokens":81354,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":497},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"fbe65d1d-fbba-4d64-a6e6-747e566d2f35"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FMPjSpu31utFJMRJk45HV1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NbPfoMWrLZcSvdTq8dR6pR","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig","old_string":"// --- Tests ---\n\ntest \"LabelError enum exists\" {","new_string":"fn runRename(\n    old_name: []const u8,\n    new_name: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count how many issues have this label renamed\n    var renamed_count: usize = 0;\n\n    // Iterate through all issues\n    for (ctx.store.issues.items, 0..) |*issue, _| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }\n\n        if (has_old_label) {\n            // Check if it already has the new label (avoid duplicates)\n            var has_new_label = false;\n            for (issue.labels) |label| {\n                if (std.mem.eql(u8, label, new_name)) {\n                    has_new_label = true;\n                    break;\n                }\n            }\n\n            if (has_new_label) {\n                // Remove the old label (new label already exists)\n                try ctx.store.removeLabel(issue.id, old_name);\n            } else {\n                // Replace old label with new label in place\n                // First remove old, then add new\n                try ctx.store.removeLabel(issue.id, old_name);\n                try ctx.store.addLabel(issue.id, new_name);\n            }\n            renamed_count += 1;\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .old_name = old_name,\n            .new_name = new_name,\n            .renamed_count = renamed_count,\n        });\n    } else if (global.quiet) {\n        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n    } else {\n        if (renamed_count > 0) {\n            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n        } else {\n            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":497,"cache_read_input_tokens":81354,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":497},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"aa8c315d-e6b1-4da3-b0f6-2e6422572e53"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NbPfoMWrLZcSvdTq8dR6pR","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/label.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9ab3b9aa-62d9-4e1c-95e6-36c3e1d6c932","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","oldString":"// --- Tests ---\n\ntest \"LabelError enum exists\" {","newString":"fn runRename(\n    old_name: []const u8,\n    new_name: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count how many issues have this label renamed\n    var renamed_count: usize = 0;\n\n    // Iterate through all issues\n    for (ctx.store.issues.items, 0..) |*issue, _| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }\n\n        if (has_old_label) {\n            // Check if it already has the new label (avoid duplicates)\n            var has_new_label = false;\n            for (issue.labels) |label| {\n                if (std.mem.eql(u8, label, new_name)) {\n                    has_new_label = true;\n                    break;\n                }\n            }\n\n            if (has_new_label) {\n                // Remove the old label (new label already exists)\n                try ctx.store.removeLabel(issue.id, old_name);\n            } else {\n                // Replace old label with new label in place\n                // First remove old, then add new\n                try ctx.store.removeLabel(issue.id, old_name);\n                try ctx.store.addLabel(issue.id, new_name);\n            }\n            renamed_count += 1;\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .old_name = old_name,\n            .new_name = new_name,\n            .renamed_count = renamed_count,\n        });\n    } else if (global.quiet) {\n        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n    } else {\n        if (renamed_count > 0) {\n            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n        } else {\n            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {","originalFile":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","structuredPatch":[{"oldStart":311,"oldLines":6,"newStart":311,"newLines":78,"lines":["     }"," }"," ","+fn runRename(","+    old_name: []const u8,","+    new_name: []const u8,","+    global: args.GlobalOptions,","+    allocator: std.mem.Allocator,","+) !void {","+    var ctx = (try CommandContext.init(allocator, global)) orelse {","+        return LabelError.WorkspaceNotInitialized;","+    };","+    defer ctx.deinit();","+","+    // Count how many issues have this label renamed","+    var renamed_count: usize = 0;","+","+    // Iterate through all issues","+    for (ctx.store.issues.items, 0..) |*issue, _| {","+        if (issue.status.eql(.tombstone)) continue;","+","+        // Check if issue has the old label","+        var has_old_label = false;","+        var old_label_idx: usize = 0;","+        for (issue.labels, 0..) |label, idx| {","+            if (std.mem.eql(u8, label, old_name)) {","+                has_old_label = true;","+                old_label_idx = idx;","+                break;","+            }","+        }","+","+        if (has_old_label) {","+            // Check if it already has the new label (avoid duplicates)","+            var has_new_label = false;","+            for (issue.labels) |label| {","+                if (std.mem.eql(u8, label, new_name)) {","+                    has_new_label = true;","+                    break;","+                }","+            }","+","+            if (has_new_label) {","+                // Remove the old label (new label already exists)","+                try ctx.store.removeLabel(issue.id, old_name);","+            } else {","+                // Replace old label with new label in place","+                // First remove old, then add new","+                try ctx.store.removeLabel(issue.id, old_name);","+                try ctx.store.addLabel(issue.id, new_name);","+            }","+            renamed_count += 1;","+        }","+    }","+","+    try ctx.saveIfAutoFlush();","+","+    if (global.isStructuredOutput()) {","+        try ctx.output.printJson(LabelResult{","+            .success = true,","+            .old_name = old_name,","+            .new_name = new_name,","+            .renamed_count = renamed_count,","+        });","+    } else if (global.quiet) {","+        try ctx.output.print(\"{d}\\n\", .{renamed_count});","+    } else {","+        if (renamed_count > 0) {","+            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });","+        } else {","+            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});","+        }","+    }","+}","+"," // --- Tests ---"," "," test \"LabelError enum exists\" {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RDirQXnVkV7oSRqNAhNg2t","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fd643PoLysYhhqWZRWkpLy","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"in_progress","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1140,"cache_read_input_tokens":81851,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1140},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"759d0b0e-a8b0-4182-af4d-fe0d43631bbe"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fd643PoLysYhhqWZRWkpLy","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"4c0713dd-b632-401e-a023-3fa65c8c11a8","tool_use_result":{"oldTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Add --metadata flag to dep add command","status":"completed","activeForm":"Adding --metadata flag to dep add"},{"content":"Add --direction flag to dep list command","status":"completed","activeForm":"Adding --direction flag to dep list"},{"content":"Add --format mermaid to dep tree command","status":"completed","activeForm":"Adding --format mermaid to dep tree"},{"content":"Task 2: Add label rename subcommand","status":"in_progress","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"pending","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}],"newTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"in_progress","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01K8KjM4VaJks5snTPuFoEKV","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run the tests to verify the implementation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":228,"cache_read_input_tokens":82991,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":228},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d9211e97-c409-487d-8b7a-d8671cd788d7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01K8KjM4VaJks5snTPuFoEKV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018SBudeirzS5RcicCUgxz48","name":"Bash","input":{"command":"zig build test 2>&1 | head -100","description":"Run tests to verify implementation","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":228,"cache_read_input_tokens":82991,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":228},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"3ce2fef3-73da-4439-a402-f2f7abf12d36"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018SBudeirzS5RcicCUgxz48","type":"tool_result","content":"\u001b[2mtest\n\u001b(0mq\u001b(B run test\n   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 2 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/label.zig:329:48: \u001b[31merror: \u001b[0m\u001b[1mdiscard of unbounded counter\n\u001b[0m    for (ctx.store.issues.items, 0..) |*issue, _| {\n                                               \u001b[32m^\n\u001b[0m\u001b[1msrc/cli/dep.zig:173:49: \u001b[31merror: \u001b[0m\u001b[1mexpected type '[]models.dependency.Dependency', found '[]const models.dependency.Dependency'\n\u001b[0m    defer if (show_down) graph.freeDependencies(deps);\n                                                \u001b[32m^~~~\n\u001b[0m\u001b[1msrc/cli/dep.zig:173:49: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/storage/graph.zig:408:48: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n                                               \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/dep.zig:56:36\n    expectError__anon_85295: /opt/zig/lib/std/testing.zig:55:9\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 2 compilation errors:\n/opt/zig/zig test -ODebug --dep toon_zig -Mroot=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name test --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 0/3 steps succeeded; 1 failed\ntest\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B run test\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 2 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xcac74f79 -Z378cf58de6032cf5 test","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"47bd5700-d5a5-49a2-b591-a81c0b5c7c6a","tool_use_result":{"stdout":"\u001b[2mtest\n\u001b(0mq\u001b(B run test\n   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 2 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/label.zig:329:48: \u001b[31merror: \u001b[0m\u001b[1mdiscard of unbounded counter\n\u001b[0m    for (ctx.store.issues.items, 0..) |*issue, _| {\n                                               \u001b[32m^\n\u001b[0m\u001b[1msrc/cli/dep.zig:173:49: \u001b[31merror: \u001b[0m\u001b[1mexpected type '[]models.dependency.Dependency', found '[]const models.dependency.Dependency'\n\u001b[0m    defer if (show_down) graph.freeDependencies(deps);\n                                                \u001b[32m^~~~\n\u001b[0m\u001b[1msrc/cli/dep.zig:173:49: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/storage/graph.zig:408:48: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n                                               \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/dep.zig:56:36\n    expectError__anon_85295: /opt/zig/lib/std/testing.zig:55:9\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 2 compilation errors:\n/opt/zig/zig test -ODebug --dep toon_zig -Mroot=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name test --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 0/3 steps succeeded; 1 failed\ntest\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B run test\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 2 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xcac74f79 -Z378cf58de6032cf5 test","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SQgwN3vD1dzeq1n73wjxcK","type":"message","role":"assistant","content":[{"type":"text","text":"I have two errors to fix. Let me fix them:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":883,"cache_read_input_tokens":83219,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":883},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"5cd68475-1a72-4976-a1ac-2e9296264e38"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SQgwN3vD1dzeq1n73wjxcK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Lon7mpsW5cevA79TjeXkuD","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig","old_string":"    for (ctx.store.issues.items, 0..) |*issue, _| {","new_string":"    for (ctx.store.issues.items) |*issue| {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":883,"cache_read_input_tokens":83219,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":883},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b5f5c70d-9415-447c-b433-0c95470dcfe8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Lon7mpsW5cevA79TjeXkuD","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/label.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"44996a39-0425-465a-a338-c6c749c85e60","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","oldString":"    for (ctx.store.issues.items, 0..) |*issue, _| {","newString":"    for (ctx.store.issues.items) |*issue| {","originalFile":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runRename(\n    old_name: []const u8,\n    new_name: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count how many issues have this label renamed\n    var renamed_count: usize = 0;\n\n    // Iterate through all issues\n    for (ctx.store.issues.items, 0..) |*issue, _| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }\n\n        if (has_old_label) {\n            // Check if it already has the new label (avoid duplicates)\n            var has_new_label = false;\n            for (issue.labels) |label| {\n                if (std.mem.eql(u8, label, new_name)) {\n                    has_new_label = true;\n                    break;\n                }\n            }\n\n            if (has_new_label) {\n                // Remove the old label (new label already exists)\n                try ctx.store.removeLabel(issue.id, old_name);\n            } else {\n                // Replace old label with new label in place\n                // First remove old, then add new\n                try ctx.store.removeLabel(issue.id, old_name);\n                try ctx.store.addLabel(issue.id, new_name);\n            }\n            renamed_count += 1;\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .old_name = old_name,\n            .new_name = new_name,\n            .renamed_count = renamed_count,\n        });\n    } else if (global.quiet) {\n        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n    } else {\n        if (renamed_count > 0) {\n            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n        } else {\n            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","structuredPatch":[{"oldStart":326,"oldLines":7,"newStart":326,"newLines":7,"lines":["     var renamed_count: usize = 0;"," ","     // Iterate through all issues","-    for (ctx.store.issues.items, 0..) |*issue, _| {","+    for (ctx.store.issues.items) |*issue| {","         if (issue.status.eql(.tombstone)) continue;"," ","         // Check if issue has the old label"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019VoEwf2qiuF2e2rRsQrHDB","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me fix the const issue in dep.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":220,"cache_read_input_tokens":84102,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":220},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"98985d92-cfdd-4a09-ae79-a0dd6d076c27"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019VoEwf2qiuF2e2rRsQrHDB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ALPyn2fEZsS7qArKXoT4Rs","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","old_string":"    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);","new_string":"    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []Dependency = &.{};\n    var dependents: []Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":220,"cache_read_input_tokens":84102,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":220},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"32c74818-a54a-4e88-a400-528cf81cc935"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ALPyn2fEZsS7qArKXoT4Rs","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/dep.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"1bc7dbd8-5f30-4e81-9846-5e922b3d5117","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","oldString":"    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);","newString":"    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []Dependency = &.{};\n    var dependents: []Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);","originalFile":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []const Dependency = &.{};\n    var dependents: []const Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (show_down and deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (show_up and dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (show_down) {\n            if (deps.len > 0) {\n                try output.println(\"Depends on:\", .{});\n                for (deps) |dep| {\n                    if (dep.metadata) |meta| {\n                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n                    } else {\n                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n                    }\n                }\n            } else {\n                try output.println(\"Depends on: (none)\", .{});\n            }\n        }\n\n        if (show_up) {\n            if (dependents.len > 0) {\n                try output.println(\"Blocks:\", .{});\n                for (dependents) |dep| {\n                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n                }\n            } else {\n                try output.println(\"Blocks: (none)\", .{});\n            }\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n    const format = tree_args.format;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else if (format == .mermaid) {\n        // Mermaid flowchart output\n        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn printMermaidTree(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    root_id: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    // Start Mermaid flowchart\n    try output.println(\"```mermaid\", .{});\n    try output.println(\"flowchart TD\", .{});\n\n    // Track visited nodes to avoid duplicates\n    var visited: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var it = visited.keyIterator();\n        while (it.next()) |key| allocator.free(key.*);\n        visited.deinit(allocator);\n    }\n\n    // Track emitted edges to avoid duplicates\n    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var edge_it = emitted_edges.keyIterator();\n        while (edge_it.next()) |key| allocator.free(key.*);\n        emitted_edges.deinit(allocator);\n    }\n\n    // Collect all nodes and edges starting from root\n    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n\n    try output.println(\"```\", .{});\n}\n\nfn collectMermaidNodes(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    visited: *std.StringHashMapUnmanaged(void),\n    emitted_edges: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Skip if already visited\n    if (visited.contains(id)) return;\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details for node label\n    const issue = try ctx.store.get(id);\n    const safe_id = try sanitizeMermaidId(id, allocator);\n    defer allocator.free(safe_id);\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n        defer allocator.free(safe_title);\n        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n    } else {\n        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n    }\n\n    if (depth >= max_depth) return;\n\n    // Get dependencies (what this issue depends on)\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    for (deps) |dep| {\n        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n        defer allocator.free(target_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            // Emit edge with dependency type as label\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n        }\n\n        // Recurse into dependency\n        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n\n    // Get dependents (what depends on this issue)\n    const dependents = try graph.getDependents(id);\n    defer graph.freeDependencies(dependents);\n\n    for (dependents) |dep| {\n        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n        defer allocator.free(source_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n        }\n\n        // Recurse into dependent\n        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n}\n\nfn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Replace characters that are invalid in Mermaid node IDs\n    var result = try allocator.alloc(u8, id.len);\n    for (id, 0..) |c, i| {\n        result[i] = if (c == '-' or c == '.') '_' else c;\n    }\n    return result;\n}\n\nfn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Escape special characters in Mermaid labels\n    var count: usize = 0;\n    for (label) |c| {\n        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n    }\n\n    var result = try allocator.alloc(u8, count);\n    var i: usize = 0;\n    for (label) |c| {\n        if (c == '\"') {\n            result[i] = '\\\\';\n            result[i + 1] = '\"';\n            i += 2;\n        } else if (c == '\\\\') {\n            result[i] = '\\\\';\n            result[i + 1] = '\\\\';\n            i += 2;\n        } else {\n            result[i] = c;\n            i += 1;\n        }\n    }\n    return result;\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":164,"oldLines":8,"newStart":164,"newLines":8,"lines":["     const show_down = direction == .down or direction == .both;","     const show_up = direction == .up or direction == .both;"," ","-    var deps: []const Dependency = &.{};","-    var dependents: []const Dependency = &.{};","+    var deps: []Dependency = &.{};","+    var dependents: []Dependency = &.{};"," ","     if (show_down) {","         deps = try graph.getDependencies(list_args.id);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EHckWhgB5vMpEfuLB7hwEg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ri2vJy4J5SMfEiTTnpmR9E","name":"Bash","input":{"command":"zig build test 2>&1 | head -100","description":"Run tests to verify implementation","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":519,"cache_read_input_tokens":84322,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":519},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"5b795360-41ad-450c-bbc2-9d1270c9642f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ri2vJy4J5SMfEiTTnpmR9E","type":"tool_result","content":"1/663 root.test_0...OK\n2/663 cli.mod.test_0...OK\n3/663 storage.mod.test_0...OK\n4/663 models.mod.test_0...OK\n5/663 sync.mod.test_0...OK\n6/663 id.mod.test_0...OK\n7/663 config.mod.test_0...OK\n8/663 output.mod.test.OutputMode enum values...OK\n9/663 output.mod.test.Output.init with json option...OK\n10/663 output.mod.test.Output.init with toon option...OK\n11/663 output.mod.test.Output.init with quiet option...OK\n12/663 output.mod.test.Output.init with no_color option forces plain mode...OK\n13/663 output.mod.test.Output.init json overrides quiet...OK\n14/663 output.mod.test.Output.initWithMode sets explicit mode...OK\n15/663 output.mod.test.abbreviateStatus returns 4-char strings...OK\n16/663 output.mod.test.priorityIndicator returns 3-char strings...OK\n17/663 output.mod.test.getStatusColor returns valid ANSI codes...OK\n18/663 output.mod.test.getPriorityColor returns valid ANSI codes...OK\n19/663 output.mod.test.Color constants are valid ANSI escape sequences...OK\n20/663 output.mod.test.Output printIssueListQuiet writes IDs only...OK\n21/663 output.mod.test.Output printIssueListPlain writes formatted lines...OK\n22/663 output.mod.test.Output printIssueListRich includes ANSI codes...OK\n23/663 output.mod.test.Output printIssueListJson produces valid JSON array...OK\n24/663 output.mod.test.Output.err formats error messages correctly...OK\n25/663 output.mod.test.Output.warn formats warning messages correctly...OK\n26/663 output.mod.test.Output quiet mode suppresses print but not err...OK\n27/663 output.mod.test.Output.success uses green color in rich mode...OK\n28/663 output.mod.test.Output.printIssue in plain mode shows all fields...OK\n29/663 errors.test.ErrorCategory.toString returns correct strings...OK\n30/663 errors.test.BeadsError.workspaceNotInitialized...OK\n31/663 errors.test.BeadsError.issueNotFound...OK\n32/663 errors.test.BeadsError.dependencyCycle...OK\n33/663 errors.test.BeadsError.format...OK\n34/663 errors.test.BeadsError.format with details...OK\n35/663 errors.test.fromError converts common errors...OK\n36/663 errors.test.Result type works for success...OK\n37/663 errors.test.Result type works for error...OK\n38/663 errors.test.Result.unwrapOr returns default on error...OK\n39/663 errors.test.BeadsError JSON serialization...OK\n40/663 test_util.test.createTestDir creates directory...OK\n41/663 tests.mod.test_0...OK\n42/663 cli.args.test.parse no arguments shows help...OK\n43/663 cli.args.test.parse global flag --json...OK\n44/663 cli.args.test.parse global flag --toon...OK\n45/663 cli.args.test.parse global flag -q (quiet)...OK\n46/663 cli.args.test.parse global flag --quiet...OK\n47/663 cli.args.test.parse global flag -v (verbose)...OK\n48/663 cli.args.test.parse global flag -v multiple times...OK\n49/663 cli.args.test.parse global flag -vv (double verbose)...OK\n50/663 cli.args.test.parse global flag --no-color...OK\n51/663 cli.args.test.parse global flag --no-auto-flush...OK\n52/663 cli.args.test.parse global flag --no-auto-import...OK\n53/663 cli.args.test.parse global flag --data with value...OK\n54/663 cli.args.test.parse global flag --actor with value...OK\n55/663 cli.args.test.parse global flag --lock-timeout with value...OK\n56/663 cli.args.test.parse multiple global flags...OK\n57/663 cli.args.test.parse unknown command returns error...OK\n58/663 cli.args.test.parse help command...OK\n59/663 cli.args.test.parse help command with topic...OK\n60/663 cli.args.test.parse --help as help command...OK\n61/663 cli.args.test.parse -h as help command...OK\n62/663 cli.args.test.parse version command...OK\n63/663 cli.args.test.parse --version as version command...OK\n64/663 cli.args.test.parse -V as version command...OK\n65/663 cli.args.test.parse init command...OK\n66/663 cli.args.test.parse init command with prefix...OK\n67/663 cli.args.test.parse create command with title...OK\n68/663 cli.args.test.parse create command missing title returns error...OK\n69/663 cli.args.test.parse create command with all options...OK\n70/663 cli.args.test.parse q (quick) command...OK\n71/663 cli.args.test.parse show command...OK\n72/663 cli.args.test.parse show command missing id returns error...OK\n73/663 cli.args.test.parse update command...OK\n74/663 cli.args.test.parse close command...OK\n75/663 cli.args.test.parse close command with reason...OK\n76/663 cli.args.test.parse reopen command...OK\n77/663 cli.args.test.parse delete command...OK\n78/663 cli.args.test.parse delete command with flags...OK\n79/663 cli.args.test.parse delete command with from-file...OK\n80/663 cli.args.test.parse list command...OK\n81/663 cli.args.test.parse list command with filters...OK\n82/663 cli.args.test.parse list --all flag...OK\n83/663 cli.args.test.parse list --sort flag...OK\n84/663 cli.args.test.parse list --sort with --asc...OK\n85/663 cli.args.test.parse list --sort with --desc...OK\n86/663 cli.args.test.SortField.fromString...OK\n87/663 cli.args.test.parse ready command...OK\n88/663 cli.args.test.parse blocked command...OK\n89/663 cli.args.test.parse search command...OK\n90/663 cli.args.test.parse search command missing query returns error...OK\n91/663 cli.args.test.parse stale command...OK\n92/663 cli.args.test.parse stale command with days...OK\n93/663 cli.args.test.parse count command...OK\n94/663 cli.args.test.parse count command with group-by...OK\n95/663 cli.args.test.parse dep add command...OK\n96/663 cli.args.test.parse dep add command with type...OK\n97/663 cli.args.test.parse dep remove command...OK\n98/663 cli.args.test.parse dep list command...OK\n99/663 cli.args.test.parse dep tree command...OK\n100/663 cli.args.test.parse dep cycles command...OK","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"2957d700-cf02-41eb-9d74-61f8a209d7ed","tool_use_result":{"stdout":"1/663 root.test_0...OK\n2/663 cli.mod.test_0...OK\n3/663 storage.mod.test_0...OK\n4/663 models.mod.test_0...OK\n5/663 sync.mod.test_0...OK\n6/663 id.mod.test_0...OK\n7/663 config.mod.test_0...OK\n8/663 output.mod.test.OutputMode enum values...OK\n9/663 output.mod.test.Output.init with json option...OK\n10/663 output.mod.test.Output.init with toon option...OK\n11/663 output.mod.test.Output.init with quiet option...OK\n12/663 output.mod.test.Output.init with no_color option forces plain mode...OK\n13/663 output.mod.test.Output.init json overrides quiet...OK\n14/663 output.mod.test.Output.initWithMode sets explicit mode...OK\n15/663 output.mod.test.abbreviateStatus returns 4-char strings...OK\n16/663 output.mod.test.priorityIndicator returns 3-char strings...OK\n17/663 output.mod.test.getStatusColor returns valid ANSI codes...OK\n18/663 output.mod.test.getPriorityColor returns valid ANSI codes...OK\n19/663 output.mod.test.Color constants are valid ANSI escape sequences...OK\n20/663 output.mod.test.Output printIssueListQuiet writes IDs only...OK\n21/663 output.mod.test.Output printIssueListPlain writes formatted lines...OK\n22/663 output.mod.test.Output printIssueListRich includes ANSI codes...OK\n23/663 output.mod.test.Output printIssueListJson produces valid JSON array...OK\n24/663 output.mod.test.Output.err formats error messages correctly...OK\n25/663 output.mod.test.Output.warn formats warning messages correctly...OK\n26/663 output.mod.test.Output quiet mode suppresses print but not err...OK\n27/663 output.mod.test.Output.success uses green color in rich mode...OK\n28/663 output.mod.test.Output.printIssue in plain mode shows all fields...OK\n29/663 errors.test.ErrorCategory.toString returns correct strings...OK\n30/663 errors.test.BeadsError.workspaceNotInitialized...OK\n31/663 errors.test.BeadsError.issueNotFound...OK\n32/663 errors.test.BeadsError.dependencyCycle...OK\n33/663 errors.test.BeadsError.format...OK\n34/663 errors.test.BeadsError.format with details...OK\n35/663 errors.test.fromError converts common errors...OK\n36/663 errors.test.Result type works for success...OK\n37/663 errors.test.Result type works for error...OK\n38/663 errors.test.Result.unwrapOr returns default on error...OK\n39/663 errors.test.BeadsError JSON serialization...OK\n40/663 test_util.test.createTestDir creates directory...OK\n41/663 tests.mod.test_0...OK\n42/663 cli.args.test.parse no arguments shows help...OK\n43/663 cli.args.test.parse global flag --json...OK\n44/663 cli.args.test.parse global flag --toon...OK\n45/663 cli.args.test.parse global flag -q (quiet)...OK\n46/663 cli.args.test.parse global flag --quiet...OK\n47/663 cli.args.test.parse global flag -v (verbose)...OK\n48/663 cli.args.test.parse global flag -v multiple times...OK\n49/663 cli.args.test.parse global flag -vv (double verbose)...OK\n50/663 cli.args.test.parse global flag --no-color...OK\n51/663 cli.args.test.parse global flag --no-auto-flush...OK\n52/663 cli.args.test.parse global flag --no-auto-import...OK\n53/663 cli.args.test.parse global flag --data with value...OK\n54/663 cli.args.test.parse global flag --actor with value...OK\n55/663 cli.args.test.parse global flag --lock-timeout with value...OK\n56/663 cli.args.test.parse multiple global flags...OK\n57/663 cli.args.test.parse unknown command returns error...OK\n58/663 cli.args.test.parse help command...OK\n59/663 cli.args.test.parse help command with topic...OK\n60/663 cli.args.test.parse --help as help command...OK\n61/663 cli.args.test.parse -h as help command...OK\n62/663 cli.args.test.parse version command...OK\n63/663 cli.args.test.parse --version as version command...OK\n64/663 cli.args.test.parse -V as version command...OK\n65/663 cli.args.test.parse init command...OK\n66/663 cli.args.test.parse init command with prefix...OK\n67/663 cli.args.test.parse create command with title...OK\n68/663 cli.args.test.parse create command missing title returns error...OK\n69/663 cli.args.test.parse create command with all options...OK\n70/663 cli.args.test.parse q (quick) command...OK\n71/663 cli.args.test.parse show command...OK\n72/663 cli.args.test.parse show command missing id returns error...OK\n73/663 cli.args.test.parse update command...OK\n74/663 cli.args.test.parse close command...OK\n75/663 cli.args.test.parse close command with reason...OK\n76/663 cli.args.test.parse reopen command...OK\n77/663 cli.args.test.parse delete command...OK\n78/663 cli.args.test.parse delete command with flags...OK\n79/663 cli.args.test.parse delete command with from-file...OK\n80/663 cli.args.test.parse list command...OK\n81/663 cli.args.test.parse list command with filters...OK\n82/663 cli.args.test.parse list --all flag...OK\n83/663 cli.args.test.parse list --sort flag...OK\n84/663 cli.args.test.parse list --sort with --asc...OK\n85/663 cli.args.test.parse list --sort with --desc...OK\n86/663 cli.args.test.SortField.fromString...OK\n87/663 cli.args.test.parse ready command...OK\n88/663 cli.args.test.parse blocked command...OK\n89/663 cli.args.test.parse search command...OK\n90/663 cli.args.test.parse search command missing query returns error...OK\n91/663 cli.args.test.parse stale command...OK\n92/663 cli.args.test.parse stale command with days...OK\n93/663 cli.args.test.parse count command...OK\n94/663 cli.args.test.parse count command with group-by...OK\n95/663 cli.args.test.parse dep add command...OK\n96/663 cli.args.test.parse dep add command with type...OK\n97/663 cli.args.test.parse dep remove command...OK\n98/663 cli.args.test.parse dep list command...OK\n99/663 cli.args.test.parse dep tree command...OK\n100/663 cli.args.test.parse dep cycles command...OK","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XLauNNPqUMygqrCmRtYwye","type":"message","role":"assistant","content":[{"type":"text","text":"Tests are passing. Let me see if they all complete:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1987,"cache_read_input_tokens":84841,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1987},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"1edd4cfb-49d6-45b3-bc63-98bdb3f9940b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XLauNNPqUMygqrCmRtYwye","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0114ibBoXixSLc2MetbCheV2","name":"Bash","input":{"command":"zig build test 2>&1 | tail -30","description":"Check test completion","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1987,"cache_read_input_tokens":84841,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1987},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"f5de5a97-c020-4f2e-8d9f-c49da4ef9a03"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0114ibBoXixSLc2MetbCheV2","type":"tool_result","content":"642/663 tests.cli_test.test.bz create returns ID...OK\n643/663 tests.cli_test.test.bz q returns ID...OK\n644/663 tests.cli_test.test.bz list returns issues...OK\n645/663 tests.cli_test.test.bz list --json returns output...OK\n646/663 tests.cli_test.test.bz show displays issue...OK\n647/663 tests.cli_test.test.bz show not-found returns error...OK\n648/663 tests.cli_test.test.bz close marks issue as closed...OK\n649/663 tests.cli_test.test.bz reopen reopens closed issue...OK\n650/663 tests.cli_test.test.bz delete soft deletes issue...OK\n651/663 tests.cli_test.test.bz search finds matching issues...OK\n652/663 tests.cli_test.test.bz dep add creates dependency...OK\n653/663 tests.cli_test.test.bz dep add rejects cycles...OK\n654/663 tests.cli_test.test.bz ready shows unblocked issues...OK\n655/663 tests.cli_test.test.bz blocked shows blocked issues...OK\n656/663 tests.cli_test.test.bz unknown command returns error...OK\n657/663 tests.cli_test.test.bz without workspace shows error...OK\n658/663 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n659/663 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n660/663 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 73 issues created\nOK\n661/663 tests.stress_test.test.sequential writes: single thread baseline...OK\n662/663 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n663/663 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 663 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"bda37bcb-9eb5-4dfa-902a-72330fd6b849","tool_use_result":{"stdout":"642/663 tests.cli_test.test.bz create returns ID...OK\n643/663 tests.cli_test.test.bz q returns ID...OK\n644/663 tests.cli_test.test.bz list returns issues...OK\n645/663 tests.cli_test.test.bz list --json returns output...OK\n646/663 tests.cli_test.test.bz show displays issue...OK\n647/663 tests.cli_test.test.bz show not-found returns error...OK\n648/663 tests.cli_test.test.bz close marks issue as closed...OK\n649/663 tests.cli_test.test.bz reopen reopens closed issue...OK\n650/663 tests.cli_test.test.bz delete soft deletes issue...OK\n651/663 tests.cli_test.test.bz search finds matching issues...OK\n652/663 tests.cli_test.test.bz dep add creates dependency...OK\n653/663 tests.cli_test.test.bz dep add rejects cycles...OK\n654/663 tests.cli_test.test.bz ready shows unblocked issues...OK\n655/663 tests.cli_test.test.bz blocked shows blocked issues...OK\n656/663 tests.cli_test.test.bz unknown command returns error...OK\n657/663 tests.cli_test.test.bz without workspace shows error...OK\n658/663 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n659/663 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n660/663 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 73 issues created\nOK\n661/663 tests.stress_test.test.sequential writes: single thread baseline...OK\n662/663 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n663/663 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 663 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SYkkmEHZXfxBs1b2tekrXi","type":"message","role":"assistant","content":[{"type":"text","text":"All 663 tests passed. Now let me also add some tests for the new functionality. Let me first add tests for the args parsing:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":667,"cache_read_input_tokens":86828,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":667},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"758876b6-a286-4ebe-80e4-484f9f7159b6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SYkkmEHZXfxBs1b2tekrXi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016AhCnz7kGt9P1QSup98kdC","name":"Grep","input":{"pattern":"test \"parse dep add command with type\"","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":667,"cache_read_input_tokens":86828,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":667},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b9df85b4-b463-4d86-bb9e-4478d5c86eae"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016AhCnz7kGt9P1QSup98kdC","type":"tool_result","content":"2154-    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n2155-}\n2156-\n2157-test \"parse dep add command\" {\n2158-    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n2159-    var parser = ArgParser.init(std.testing.allocator, &args);\n2160-    const result = try parser.parse();\n2161-\n2162-    try std.testing.expect(result.command == .dep);\n2163-    const add = result.command.dep.subcommand.add;\n2164-    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n2165-    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n2166-    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n2167-}\n2168-\n2169:test \"parse dep add command with type\" {\n2170-    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n2171-    var parser = ArgParser.init(std.testing.allocator, &args);\n2172-    const result = try parser.parse();\n2173-\n2174-    const add = result.command.dep.subcommand.add;\n2175-    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n2176-}\n2177-\n2178-test \"parse dep remove command\" {\n2179-    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n2180-    var parser = ArgParser.init(std.testing.allocator, &args);\n2181-    const result = try parser.parse();\n2182-\n2183-    const remove = result.command.dep.subcommand.remove;\n2184-    try std.testing.expectEqualStrings(\"bd-child\", remove.child);"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"bc739c50-fbc3-4fc5-9e31-7fb470dc52ea","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"2154-    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n2155-}\n2156-\n2157-test \"parse dep add command\" {\n2158-    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n2159-    var parser = ArgParser.init(std.testing.allocator, &args);\n2160-    const result = try parser.parse();\n2161-\n2162-    try std.testing.expect(result.command == .dep);\n2163-    const add = result.command.dep.subcommand.add;\n2164-    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n2165-    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n2166-    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n2167-}\n2168-\n2169:test \"parse dep add command with type\" {\n2170-    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n2171-    var parser = ArgParser.init(std.testing.allocator, &args);\n2172-    const result = try parser.parse();\n2173-\n2174-    const add = result.command.dep.subcommand.add;\n2175-    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n2176-}\n2177-\n2178-test \"parse dep remove command\" {\n2179-    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n2180-    var parser = ArgParser.init(std.testing.allocator, &args);\n2181-    const result = try parser.parse();\n2182-\n2183-    const remove = result.command.dep.subcommand.remove;\n2184-    try std.testing.expectEqualStrings(\"bd-child\", remove.child);","numLines":31}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AgmmnpMjBm3VjrUfDvwbC5","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read more of the test section to find where to add new tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":882,"cache_read_input_tokens":87495,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":882},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"ee92aeef-8b5b-449d-a1c7-7041c761cd9f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AgmmnpMjBm3VjrUfDvwbC5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017axHjfFSPrX9W17XnBg6nj","name":"Grep","input":{"pattern":"test \"parse dep tree command\"","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":882,"cache_read_input_tokens":87495,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":882},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"2504f1fd-482e-4934-91f1-7cd73e50e544"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017axHjfFSPrX9W17XnBg6nj","type":"tool_result","content":"2176-}\n2177-\n2178-test \"parse dep remove command\" {\n2179-    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n2180-    var parser = ArgParser.init(std.testing.allocator, &args);\n2181-    const result = try parser.parse();\n2182-\n2183-    const remove = result.command.dep.subcommand.remove;\n2184-    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n2185-    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n2186-}\n2187-\n2188-test \"parse dep list command\" {\n2189-    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n2190-    var parser = ArgParser.init(std.testing.allocator, &args);\n2191-    const result = try parser.parse();\n2192-\n2193-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n2194-}\n2195-\n2196:test \"parse dep tree command\" {\n2197-    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n2198-    var parser = ArgParser.init(std.testing.allocator, &args);\n2199-    const result = try parser.parse();\n2200-\n2201-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n2202-}\n2203-\n2204-test \"parse dep cycles command\" {\n2205-    const args = [_][]const u8{ \"dep\", \"cycles\" };\n2206-    var parser = ArgParser.init(std.testing.allocator, &args);\n2207-    const result = try parser.parse();\n2208-\n2209-    try std.testing.expect(result.command.dep.subcommand == .cycles);\n2210-}\n2211-\n2212-test \"parse label add command\" {\n2213-    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n2214-    var parser = ArgParser.init(std.testing.allocator, &args);\n2215-    const result = try parser.parse();\n2216-    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"64df7ba5-66d7-4604-b6e2-40fa4daa83ca","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"2176-}\n2177-\n2178-test \"parse dep remove command\" {\n2179-    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n2180-    var parser = ArgParser.init(std.testing.allocator, &args);\n2181-    const result = try parser.parse();\n2182-\n2183-    const remove = result.command.dep.subcommand.remove;\n2184-    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n2185-    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n2186-}\n2187-\n2188-test \"parse dep list command\" {\n2189-    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n2190-    var parser = ArgParser.init(std.testing.allocator, &args);\n2191-    const result = try parser.parse();\n2192-\n2193-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n2194-}\n2195-\n2196:test \"parse dep tree command\" {\n2197-    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n2198-    var parser = ArgParser.init(std.testing.allocator, &args);\n2199-    const result = try parser.parse();\n2200-\n2201-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n2202-}\n2203-\n2204-test \"parse dep cycles command\" {\n2205-    const args = [_][]const u8{ \"dep\", \"cycles\" };\n2206-    var parser = ArgParser.init(std.testing.allocator, &args);\n2207-    const result = try parser.parse();\n2208-\n2209-    try std.testing.expect(result.command.dep.subcommand == .cycles);\n2210-}\n2211-\n2212-test \"parse label add command\" {\n2213-    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n2214-    var parser = ArgParser.init(std.testing.allocator, &args);\n2215-    const result = try parser.parse();\n2216-    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);","numLines":41}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013m9oZ8babUP6oVTcQA2bZA","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add tests for the new flags. I'll add them after the existing dep tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":803,"cache_read_input_tokens":88377,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":803},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9bc6d481-33d1-4238-9cce-20c97455eba3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013m9oZ8babUP6oVTcQA2bZA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NW832LfcQ2b7BohEWEcE8F","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":2200,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":803,"cache_read_input_tokens":88377,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":803},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"99799de3-b8bf-4535-9ec0-1b1beab68004"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NW832LfcQ2b7BohEWEcE8F","type":"tool_result","content":"  2200→\n  2201→    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n  2202→}\n  2203→\n  2204→test \"parse dep cycles command\" {\n  2205→    const args = [_][]const u8{ \"dep\", \"cycles\" };\n  2206→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2207→    const result = try parser.parse();\n  2208→\n  2209→    try std.testing.expect(result.command.dep.subcommand == .cycles);\n  2210→}\n  2211→\n  2212→test \"parse label add command\" {\n  2213→    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n  2214→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2215→    const result = try parser.parse();\n  2216→    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n  2217→\n  2218→    const add = result.command.label.subcommand.add;\n  2219→    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n  2220→    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n  2221→    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n  2222→    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n  2223→}\n  2224→\n  2225→test \"parse label remove command\" {\n  2226→    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n  2227→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2228→    const result = try parser.parse();\n  2229→    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n  2230→\n  2231→    const remove = result.command.label.subcommand.remove;\n  2232→    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n  2233→    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n  2234→    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n  2235→}\n  2236→\n  2237→test \"parse label list command\" {\n  2238→    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n  2239→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2240→    const result = try parser.parse();\n  2241→\n  2242→    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n  2243→}\n  2244→\n  2245→test \"parse label list-all command\" {\n  2246→    const args = [_][]const u8{ \"label\", \"list-all\" };\n  2247→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2248→    const result = try parser.parse();\n  2249→\n  2250→    try std.testing.expect(result.command.label.subcommand == .list_all);\n  2251→}\n  2252→\n  2253→test \"parse comments add command\" {\n  2254→    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n  2255→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2256→    const result = try parser.parse();\n  2257→\n  2258→    const add = result.command.comments.subcommand.add;\n  2259→    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n  2260→    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n  2261→}\n  2262→\n  2263→test \"parse comments list command\" {\n  2264→    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n  2265→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2266→    const result = try parser.parse();\n  2267→\n  2268→    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n  2269→}\n  2270→\n  2271→test \"parse history command\" {\n  2272→    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n  2273→    var parser = ArgParser.init(std.testing.allocator, &args);\n  2274→    const result = try parser.parse();\n  2275→\n  2276→    try std.testing.expect(result.command == .history);\n  2277→    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n  2278→}\n  2279→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"85adad1f-8bb1-480e-b5e0-ea809fab7e36","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n","numLines":80,"startLine":2200,"totalLines":2552}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MGKjN2XVkrTuVYsFyaa2vA","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the new tests for the enhanced dep and label commands:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1590,"cache_read_input_tokens":89180,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1590},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"e62a0dde-6334-417f-ba81-92e61580f7bd"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MGKjN2XVkrTuVYsFyaa2vA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Tjit6RdAUjbjTEiX8prtkQ","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"test \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {","new_string":"test \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1590,"cache_read_input_tokens":89180,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1590},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"a26f6bdc-5152-4662-8301-d39880146d9c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Tjit6RdAUjbjTEiX8prtkQ","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"37a1da8b-7e7c-436b-b95e-eef702716c03","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"test \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {","newString":"test \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":2209,"oldLines":6,"newStart":2209,"newLines":47,"lines":["     try std.testing.expect(result.command.dep.subcommand == .cycles);"," }"," ","+test \"parse dep add command with metadata\" {","+    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };","+    var parser = ArgParser.init(std.testing.allocator, &input);","+    const result = try parser.parse();","+","+    const add = result.command.dep.subcommand.add;","+    try std.testing.expectEqualStrings(\"bd-child\", add.child);","+    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);","+    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);","+    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);","+}","+","+test \"parse dep list command with direction down\" {","+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };","+    var parser = ArgParser.init(std.testing.allocator, &input);","+    const result = try parser.parse();","+","+    const list = result.command.dep.subcommand.list;","+    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);","+    try std.testing.expectEqual(DepDirection.down, list.direction);","+}","+","+test \"parse dep list command with direction up\" {","+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };","+    var parser = ArgParser.init(std.testing.allocator, &input);","+    const result = try parser.parse();","+","+    const list = result.command.dep.subcommand.list;","+    try std.testing.expectEqual(DepDirection.up, list.direction);","+}","+","+test \"parse dep tree command with format mermaid\" {","+    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };","+    var parser = ArgParser.init(std.testing.allocator, &input);","+    const result = try parser.parse();","+","+    const tree = result.command.dep.subcommand.tree;","+    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);","+    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);","+}","+"," test \"parse label add command\" {","     const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };","     var parser = ArgParser.init(std.testing.allocator, &args);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SM1i2aoUc2TiQKvQbSt59h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X2MprKm4CaUsni7G5m5u4m","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"test \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {","new_string":"test \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":953,"cache_read_input_tokens":90770,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":953},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"f1b9684c-7cfe-45be-9d6d-cf368408947d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X2MprKm4CaUsni7G5m5u4m","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"99158684-1cf3-48e9-88b9-3135038247f7","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"test \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {","newString":"test \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":2291,"oldLines":6,"newStart":2291,"newLines":26,"lines":["     try std.testing.expect(result.command.label.subcommand == .list_all);"," }"," ","+test \"parse label rename command\" {","+    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };","+    var parser = ArgParser.init(std.testing.allocator, &input);","+    const result = try parser.parse();","+","+    const rename = result.command.label.subcommand.rename;","+    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);","+    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);","+}","+","+test \"parse label mv command (alias for rename)\" {","+    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };","+    var parser = ArgParser.init(std.testing.allocator, &input);","+    const result = try parser.parse();","+","+    const rename = result.command.label.subcommand.rename;","+    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);","+    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);","+}","+"," test \"parse comments add command\" {","     const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };","     var parser = ArgParser.init(std.testing.allocator, &args);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016TUSUuRWDkEouiz2VEufwh","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run the tests again to make sure all the new tests pass:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":635,"cache_read_input_tokens":91723,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":635},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"8831a569-2fc5-4918-8660-4eb3a086bc5c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016TUSUuRWDkEouiz2VEufwh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PrfcVoD9p8CgGqXg86soWe","name":"Bash","input":{"command":"zig build test 2>&1 | tail -40","description":"Run tests to verify new tests pass","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":635,"cache_read_input_tokens":91723,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":635},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"ae47c93b-8271-4807-b0b6-db4ccf2ca7dc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PrfcVoD9p8CgGqXg86soWe","type":"tool_result","content":"638/669 config.yaml.test.parse quoted values...OK\n639/669 config.yaml.test.parse empty value...OK\n640/669 config.yaml.test.get returns null for missing key...OK\n641/669 config.yaml.test.parse handles Windows line endings...OK\n642/669 config.yaml.test.parse ignores blank lines...OK\n643/669 tests.cli_test.test.bz version shows version info...OK\n644/669 tests.cli_test.test.bz help shows usage...OK\n645/669 tests.cli_test.test.bz --help shows usage...OK\n646/669 tests.cli_test.test.bz init creates workspace...OK\n647/669 tests.cli_test.test.bz init fails when already initialized...OK\n648/669 tests.cli_test.test.bz create returns ID...OK\n649/669 tests.cli_test.test.bz q returns ID...OK\n650/669 tests.cli_test.test.bz list returns issues...OK\n651/669 tests.cli_test.test.bz list --json returns output...OK\n652/669 tests.cli_test.test.bz show displays issue...OK\n653/669 tests.cli_test.test.bz show not-found returns error...OK\n654/669 tests.cli_test.test.bz close marks issue as closed...OK\n655/669 tests.cli_test.test.bz reopen reopens closed issue...OK\n656/669 tests.cli_test.test.bz delete soft deletes issue...OK\n657/669 tests.cli_test.test.bz search finds matching issues...OK\n658/669 tests.cli_test.test.bz dep add creates dependency...OK\n659/669 tests.cli_test.test.bz dep add rejects cycles...OK\n660/669 tests.cli_test.test.bz ready shows unblocked issues...OK\n661/669 tests.cli_test.test.bz blocked shows blocked issues...OK\n662/669 tests.cli_test.test.bz unknown command returns error...OK\n663/669 tests.cli_test.test.bz without workspace shows error...OK\n664/669 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n665/669 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n666/669 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n667/669 tests.stress_test.test.sequential writes: single thread baseline...OK\n668/669 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n669/669 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 669 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b75b0bfe-65a8-4d14-89f9-734f198c1934","tool_use_result":{"stdout":"638/669 config.yaml.test.parse quoted values...OK\n639/669 config.yaml.test.parse empty value...OK\n640/669 config.yaml.test.get returns null for missing key...OK\n641/669 config.yaml.test.parse handles Windows line endings...OK\n642/669 config.yaml.test.parse ignores blank lines...OK\n643/669 tests.cli_test.test.bz version shows version info...OK\n644/669 tests.cli_test.test.bz help shows usage...OK\n645/669 tests.cli_test.test.bz --help shows usage...OK\n646/669 tests.cli_test.test.bz init creates workspace...OK\n647/669 tests.cli_test.test.bz init fails when already initialized...OK\n648/669 tests.cli_test.test.bz create returns ID...OK\n649/669 tests.cli_test.test.bz q returns ID...OK\n650/669 tests.cli_test.test.bz list returns issues...OK\n651/669 tests.cli_test.test.bz list --json returns output...OK\n652/669 tests.cli_test.test.bz show displays issue...OK\n653/669 tests.cli_test.test.bz show not-found returns error...OK\n654/669 tests.cli_test.test.bz close marks issue as closed...OK\n655/669 tests.cli_test.test.bz reopen reopens closed issue...OK\n656/669 tests.cli_test.test.bz delete soft deletes issue...OK\n657/669 tests.cli_test.test.bz search finds matching issues...OK\n658/669 tests.cli_test.test.bz dep add creates dependency...OK\n659/669 tests.cli_test.test.bz dep add rejects cycles...OK\n660/669 tests.cli_test.test.bz ready shows unblocked issues...OK\n661/669 tests.cli_test.test.bz blocked shows blocked issues...OK\n662/669 tests.cli_test.test.bz unknown command returns error...OK\n663/669 tests.cli_test.test.bz without workspace shows error...OK\n664/669 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n665/669 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n666/669 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n667/669 tests.stress_test.test.sequential writes: single thread baseline...OK\n668/669 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n669/669 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 669 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QatnqTiAvqG9E8HQpqvDs8","type":"message","role":"assistant","content":[{"type":"text","text":"All 669 tests passed (6 new tests added). Now let me do a quick manual test in the sandbox to verify the new functionality works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":866,"cache_read_input_tokens":92358,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":866},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"065e9b19-019b-4d75-a470-d1fb7b1ea67c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QatnqTiAvqG9E8HQpqvDs8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PbgmqqcPuEN8gueoiU2Fha","name":"Bash","input":{"command":"zig build 2>&1","description":"Build the project","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":866,"cache_read_input_tokens":92358,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":866},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7b7f8bc3-83ae-4b6d-9052-9c3aadf54573"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PbgmqqcPuEN8gueoiU2Fha","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"12b5a7b8-363f-47ac-b072-ae344d1bb7c3","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018oEYUKduyP1PagGeUNyEES","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Va6WZyDFTMD6xzvMzgYxwv","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig/sandbox && rm -rf .beads && ../zig-out/bin/bz init && ../zig-out/bin/bz create \"First issue\" && ../zig-out/bin/bz create \"Second issue\" 2>&1","description":"Initialize sandbox and create test issues","timeout":30000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":320,"cache_read_input_tokens":93224,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":320},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"8ba8c0ff-2c39-46b5-8512-72d338555e36"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Va6WZyDFTMD6xzvMzgYxwv","type":"tool_result","content":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-tmm\nCreated issue bd-2hd","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"6d2e450f-3480-48e1-876a-6e1b3269873d","tool_use_result":{"stdout":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-tmm\nCreated issue bd-2hd","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RYmze7uqduRcXjMezRzXH5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NnrkYTLd52fmofPrJ6ewZ5","name":"Bash","input":{"command":"../zig-out/bin/bz dep add bd-tmm bd-2hd --type blocks --metadata '{\"reason\":\"needs API first\"}' 2>&1","description":"Test dep add with metadata","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":218,"cache_read_input_tokens":93544,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":218},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"ac5930ac-ee14-48b3-89b4-b1f1b44c86d3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NnrkYTLd52fmofPrJ6ewZ5","type":"tool_result","content":"Added dependency: bd-tmm depends on bd-2hd","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b4be2d8f-bc6e-49db-a977-82c7e6b6d851","tool_use_result":{"stdout":"Added dependency: bd-tmm depends on bd-2hd","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UDANt6BiF3kHkP6rBJSc39","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LH9Gu2Udba4wNgRvEAnHhC","name":"Bash","input":{"command":"../zig-out/bin/bz dep list bd-tmm && echo \"---\" && ../zig-out/bin/bz dep list bd-tmm --direction down && echo \"---\" && ../zig-out/bin/bz dep list bd-tmm --direction up 2>&1","description":"Test dep list with direction flag","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":155,"cache_read_input_tokens":93762,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":155},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"281a591b-f12c-4391-84a1-893806d7437a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LH9Gu2Udba4wNgRvEAnHhC","type":"tool_result","content":"Depends on:\n  - bd-2hd (blocks) [{\"reason\":\"needs API first\"}]\nBlocks: (none)\n---\nDepends on:\n  - bd-2hd (blocks) [{\"reason\":\"needs API first\"}]\n---\nBlocks: (none)","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"2a4f5278-b951-4fd7-900b-454ae1d78886","tool_use_result":{"stdout":"Depends on:\n  - bd-2hd (blocks) [{\"reason\":\"needs API first\"}]\nBlocks: (none)\n---\nDepends on:\n  - bd-2hd (blocks) [{\"reason\":\"needs API first\"}]\n---\nBlocks: (none)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KmMnSBzp5Xif6382hw2bzh","type":"message","role":"assistant","content":[{"type":"text","text":"The metadata is being displayed. Let me test the mermaid format:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":239,"cache_read_input_tokens":93917,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":239},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"77a75a0d-7cfa-4970-b1aa-5b327a1e79cc"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KmMnSBzp5Xif6382hw2bzh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0158ahN5KQ2wnUVrijooJPNw","name":"Bash","input":{"command":"../zig-out/bin/bz dep tree bd-tmm --format mermaid 2>&1","description":"Test dep tree with mermaid format","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":239,"cache_read_input_tokens":93917,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":239},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d17e1dc8-14c8-4d53-a27e-552a273b373d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0158ahN5KQ2wnUVrijooJPNw","type":"tool_result","content":"```mermaid\nflowchart TD\n    bd_tmm[\"bd-tmm: First issue\"]\n    bd_tmm -->|blocks| bd_2hd\n    bd_2hd[\"bd-2hd: Second issue\"]\n```","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"3129dec4-16c7-4573-89c1-164518a47284","tool_use_result":{"stdout":"```mermaid\nflowchart TD\n    bd_tmm[\"bd-tmm: First issue\"]\n    bd_tmm -->|blocks| bd_2hd\n    bd_2hd[\"bd-2hd: Second issue\"]\n```","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011rqzF63fc2zkBx455fMcGP","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me test the label rename command:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":204,"cache_read_input_tokens":94156,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":204},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"e09d49f6-63a7-4801-aa50-28a714a710c2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011rqzF63fc2zkBx455fMcGP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ALvmrAmRaQFE5ax5NYEbE5","name":"Bash","input":{"command":"../zig-out/bin/bz label add bd-tmm backend urgent && ../zig-out/bin/bz label add bd-2hd backend frontend && ../zig-out/bin/bz label list-all 2>&1","description":"Add labels to test issues","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":204,"cache_read_input_tokens":94156,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":204},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"996025eb-4e21-4f9a-b7e5-c64655c0f21e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ALvmrAmRaQFE5ax5NYEbE5","type":"tool_result","content":"Added 2 label(s) to bd-tmm\nAdded 2 label(s) to bd-2hd\nLabels (3):\n  backend\n  frontend\n  urgent","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"cf0aabec-b370-42c4-9159-764b586c7f22","tool_use_result":{"stdout":"Added 2 label(s) to bd-tmm\nAdded 2 label(s) to bd-2hd\nLabels (3):\n  backend\n  frontend\n  urgent","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YZ7v6XvphMTdpsxqAcKToF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019YsrRSANpRBd19NMfBLG6x","name":"Bash","input":{"command":"../zig-out/bin/bz label rename backend api && ../zig-out/bin/bz label list-all 2>&1","description":"Test label rename","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":211,"cache_read_input_tokens":94360,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":211},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b9d6bffd-4962-4f9e-ac9f-4ed6f45a6f8c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019YsrRSANpRBd19NMfBLG6x","type":"tool_result","content":"Renamed label 'backend' to 'api' on 2 issue(s)\nLabels (3):\n  api\n  frontend\n  urgent","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"9fdc89e3-686b-4e34-8372-8bdcb8937abd","tool_use_result":{"stdout":"Renamed label 'backend' to 'api' on 2 issue(s)\nLabels (3):\n  api\n  frontend\n  urgent","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016b3jvoUA7Jx5VGvDS6nrV6","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent. All new features are working. Let me also test the JSON output:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":167,"cache_read_input_tokens":94571,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":167},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d7750eaa-29d2-4add-9efe-2df7cd57f14a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016b3jvoUA7Jx5VGvDS6nrV6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CGDbzR7N2zrboWxSNeJnK9","name":"Bash","input":{"command":"../zig-out/bin/bz dep list bd-tmm --json && echo && ../zig-out/bin/bz label rename api backend --json 2>&1","description":"Test JSON output for new commands","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":167,"cache_read_input_tokens":94571,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":167},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"49ddf5b4-bb9c-4ece-b9e4-bf4e52f123ec"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CGDbzR7N2zrboWxSNeJnK9","type":"tool_result","content":"Depends on:\n  - bd-2hd (blocks) [{\"reason\":\"needs API first\"}]\nBlocks: (none)\n\nRenamed label 'api' to 'backend' on 2 issue(s)","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"51b52788-d43c-4a9d-b197-8ab7a5c19823","tool_use_result":{"stdout":"Depends on:\n  - bd-2hd (blocks) [{\"reason\":\"needs API first\"}]\nBlocks: (none)\n\nRenamed label 'api' to 'backend' on 2 issue(s)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KEvmBVeEGutMrGhjKqo9sq","type":"message","role":"assistant","content":[{"type":"text","text":"I see the --json flag isn't being picked up. Let me check if it's a global flag issue:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":397,"cache_read_input_tokens":94738,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":397},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"3eb12d34-4ef2-4673-aa20-3b6d288f3611"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KEvmBVeEGutMrGhjKqo9sq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Awm23mVgRCMw8CtxicFHzB","name":"Bash","input":{"command":"../zig-out/bin/bz --json dep list bd-tmm && echo && ../zig-out/bin/bz --json label rename backend api 2>&1","description":"Test JSON output with flag at correct position","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":397,"cache_read_input_tokens":94738,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":397},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"3ec6db75-50dd-4e4b-b263-9d8d2e2da699"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Awm23mVgRCMw8CtxicFHzB","type":"tool_result","content":"{\"success\":true,\"action\":null,\"child\":null,\"parent\":null,\"depends_on\":[\"bd-2hd\"],\"blocks\":null,\"message\":null}\n\n{\"success\":true,\"id\":null,\"labels\":null,\"added\":null,\"removed\":null,\"old_name\":\"backend\",\"new_name\":\"api\",\"renamed_count\":2,\"message\":null}","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"6e8c8f71-a6cb-4962-902f-f12cbef660f9","tool_use_result":{"stdout":"{\"success\":true,\"action\":null,\"child\":null,\"parent\":null,\"depends_on\":[\"bd-2hd\"],\"blocks\":null,\"message\":null}\n\n{\"success\":true,\"id\":null,\"labels\":null,\"added\":null,\"removed\":null,\"old_name\":\"backend\",\"new_name\":\"api\",\"renamed_count\":2,\"message\":null}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018mq9L7QzvhxGCeNxXgoNrz","type":"message","role":"assistant","content":[{"type":"text","text":"JSON output works when the flag is in the right position. Now let me update the todo list and create the commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":250,"cache_read_input_tokens":95135,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":250},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"c3f55d17-5e93-4c6b-b25f-7daa06659c7a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018mq9L7QzvhxGCeNxXgoNrz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YTz4GGv45ZgUW87QAef5JR","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"in_progress","activeForm":"Creating git commit"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":250,"cache_read_input_tokens":95135,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":250},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d8512be0-3467-4ba6-8de8-5d44ca0f8bcb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YTz4GGv45ZgUW87QAef5JR","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"6d79dc55-1c9d-46d6-82a5-0b36a4e683ce","tool_use_result":{"oldTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"in_progress","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"pending","activeForm":"Creating git commit"}],"newTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"in_progress","activeForm":"Creating git commit"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WXH7PZNMUQHLz3zfwtRJXj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FLwCMphRTGz69zqTUy1z8W","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && git status","description":"Check git status","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":253,"cache_read_input_tokens":95385,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"55358d5a-c956-44bc-92c2-b6598c53af34"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FLwCMphRTGz69zqTUy1z8W","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 25 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/dep.zig\n\tmodified:   src/cli/label.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"8da0e2a1-3e17-45a6-96dd-a424a209ade8","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 25 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/dep.zig\n\tmodified:   src/cli/label.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WpkuMrfMikH7djtEbfdLfz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JfE4H79bCPsizmcteLZu9f","name":"Bash","input":{"command":"git diff src/cli/args.zig | head -100","description":"Review args.zig changes","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":292,"cache_read_input_tokens":95638,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":292},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"113091d7-b26b-472c-9fb2-d3324c2327ab"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JfE4H79bCPsizmcteLZu9f","type":"tool_result","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex cb056f1..2de3b21 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -347,12 +347,39 @@ pub const EpicArgs = struct {\n     subcommand: EpicSubcommand,\n };\n \n+/// Direction filter for dependency listing.\n+pub const DepDirection = enum {\n+    up, // What depends on this issue (dependents/blocked-by)\n+    down, // What this issue depends on\n+    both, // Both directions (default)\n+\n+    pub fn fromString(s: []const u8) ?DepDirection {\n+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n+        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n+        return null;\n+    }\n+};\n+\n+/// Tree output formats for dep tree.\n+pub const TreeFormat = enum {\n+    ascii,\n+    mermaid,\n+\n+    pub fn fromString(s: []const u8) ?TreeFormat {\n+        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n+        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n+        return null;\n+    }\n+};\n+\n /// Dependency subcommand variants.\n pub const DepSubcommand = union(enum) {\n     add: struct {\n         child: []const u8,\n         parent: []const u8,\n         dep_type: []const u8 = \"blocks\",\n+        metadata: ?[]const u8 = null,\n     },\n     remove: struct {\n         child: []const u8,\n@@ -360,9 +387,11 @@ pub const DepSubcommand = union(enum) {\n     },\n     list: struct {\n         id: []const u8,\n+        direction: DepDirection = .both,\n     },\n     tree: struct {\n         id: []const u8,\n+        format: TreeFormat = .ascii,\n     },\n     cycles: void,\n };\n@@ -406,6 +435,10 @@ pub const LabelSubcommand = union(enum) {\n         id: []const u8,\n     },\n     list_all: void,\n+    rename: struct {\n+        old_name: []const u8,\n+        new_name: []const u8,\n+    },\n };\n \n /// Label command arguments.\n@@ -1276,12 +1309,15 @@ pub const ArgParser = struct {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n             const parent = self.next() orelse return error.MissingRequiredArgument;\n             var dep_type: []const u8 = \"blocks\";\n+            var metadata: ?[]const u8 = null;\n             while (self.hasNext()) {\n                 if (self.consumeFlag(\"-t\", \"--type\")) {\n                     dep_type = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n+                    metadata = self.next() orelse return error.MissingFlagValue;\n                 } else break;\n             }\n-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n+            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n@@ -1289,10 +1325,26 @@ pub const ArgParser = struct {\n             return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n+            const id = self.next() orelse return error.MissingRequiredArgument;\n+            var direction: DepDirection = .both;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-d\", \"--direction\")) {\n+                    const dir_str = self.next() orelse return error.MissingFlagValue;\n+                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"tree\")) {","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"d8f83d45-7efc-4d82-a9f2-3c6a1dce1399","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex cb056f1..2de3b21 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -347,12 +347,39 @@ pub const EpicArgs = struct {\n     subcommand: EpicSubcommand,\n };\n \n+/// Direction filter for dependency listing.\n+pub const DepDirection = enum {\n+    up, // What depends on this issue (dependents/blocked-by)\n+    down, // What this issue depends on\n+    both, // Both directions (default)\n+\n+    pub fn fromString(s: []const u8) ?DepDirection {\n+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n+        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n+        return null;\n+    }\n+};\n+\n+/// Tree output formats for dep tree.\n+pub const TreeFormat = enum {\n+    ascii,\n+    mermaid,\n+\n+    pub fn fromString(s: []const u8) ?TreeFormat {\n+        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n+        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n+        return null;\n+    }\n+};\n+\n /// Dependency subcommand variants.\n pub const DepSubcommand = union(enum) {\n     add: struct {\n         child: []const u8,\n         parent: []const u8,\n         dep_type: []const u8 = \"blocks\",\n+        metadata: ?[]const u8 = null,\n     },\n     remove: struct {\n         child: []const u8,\n@@ -360,9 +387,11 @@ pub const DepSubcommand = union(enum) {\n     },\n     list: struct {\n         id: []const u8,\n+        direction: DepDirection = .both,\n     },\n     tree: struct {\n         id: []const u8,\n+        format: TreeFormat = .ascii,\n     },\n     cycles: void,\n };\n@@ -406,6 +435,10 @@ pub const LabelSubcommand = union(enum) {\n         id: []const u8,\n     },\n     list_all: void,\n+    rename: struct {\n+        old_name: []const u8,\n+        new_name: []const u8,\n+    },\n };\n \n /// Label command arguments.\n@@ -1276,12 +1309,15 @@ pub const ArgParser = struct {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n             const parent = self.next() orelse return error.MissingRequiredArgument;\n             var dep_type: []const u8 = \"blocks\";\n+            var metadata: ?[]const u8 = null;\n             while (self.hasNext()) {\n                 if (self.consumeFlag(\"-t\", \"--type\")) {\n                     dep_type = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n+                    metadata = self.next() orelse return error.MissingFlagValue;\n                 } else break;\n             }\n-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n+            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n@@ -1289,10 +1325,26 @@ pub const ArgParser = struct {\n             return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n+            const id = self.next() orelse return error.MissingRequiredArgument;\n+            var direction: DepDirection = .both;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-d\", \"--direction\")) {\n+                    const dir_str = self.next() orelse return error.MissingFlagValue;\n+                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"tree\")) {","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DsX4oUCYe8qUZ4E5xUBAxW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SvivQCMmGCoBWEMpwfvtN9","name":"Bash","input":{"command":"git diff src/cli/dep.zig | head -150","description":"Review dep.zig changes","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1460,"cache_read_input_tokens":95930,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1460},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"80c05925-0e84-4d62-8848-33a92d1fb84d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SvivQCMmGCoBWEMpwfvtN9","type":"tool_result","content":"diff --git a/src/cli/dep.zig b/src/cli/dep.zig\nindex 376b809..aea0996 100644\n--- a/src/cli/dep.zig\n+++ b/src/cli/dep.zig\n@@ -84,7 +84,7 @@ fn runAdd(\n         .dep_type = DependencyType.fromString(add_args.dep_type),\n         .created_at = now,\n         .created_by = global.actor,\n-        .metadata = null,\n+        .metadata = add_args.metadata,\n         .thread_id = null,\n     };\n \n@@ -160,24 +160,35 @@ fn runList(\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n-    const deps = try graph.getDependencies(list_args.id);\n-    defer graph.freeDependencies(deps);\n+    const direction = list_args.direction;\n+    const show_down = direction == .down or direction == .both;\n+    const show_up = direction == .up or direction == .both;\n \n-    const dependents = try graph.getDependents(list_args.id);\n-    defer graph.freeDependencies(dependents);\n+    var deps: []Dependency = &.{};\n+    var dependents: []Dependency = &.{};\n+\n+    if (show_down) {\n+        deps = try graph.getDependencies(list_args.id);\n+    }\n+    defer if (show_down) graph.freeDependencies(deps);\n+\n+    if (show_up) {\n+        dependents = try graph.getDependents(list_args.id);\n+    }\n+    defer if (show_up) graph.freeDependencies(dependents);\n \n     if (global.isStructuredOutput()) {\n         var depends_on_ids: ?[][]const u8 = null;\n         var blocks_ids: ?[][]const u8 = null;\n \n-        if (deps.len > 0) {\n+        if (show_down and deps.len > 0) {\n             depends_on_ids = try allocator.alloc([]const u8, deps.len);\n             for (deps, 0..) |dep, i| {\n                 depends_on_ids.?[i] = dep.depends_on_id;\n             }\n         }\n \n-        if (dependents.len > 0) {\n+        if (show_up and dependents.len > 0) {\n             blocks_ids = try allocator.alloc([]const u8, dependents.len);\n             for (dependents, 0..) |dep, i| {\n                 blocks_ids.?[i] = dep.issue_id;\n@@ -195,22 +206,30 @@ fn runList(\n             .blocks = blocks_ids,\n         });\n     } else {\n-        if (deps.len > 0) {\n-            try output.println(\"Depends on:\", .{});\n-            for (deps) |dep| {\n-                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+        if (show_down) {\n+            if (deps.len > 0) {\n+                try output.println(\"Depends on:\", .{});\n+                for (deps) |dep| {\n+                    if (dep.metadata) |meta| {\n+                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n+                    } else {\n+                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+                    }\n+                }\n+            } else {\n+                try output.println(\"Depends on: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Depends on: (none)\", .{});\n         }\n \n-        if (dependents.len > 0) {\n-            try output.println(\"Blocks:\", .{});\n-            for (dependents) |dep| {\n-                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+        if (show_up) {\n+            if (dependents.len > 0) {\n+                try output.println(\"Blocks:\", .{});\n+                for (dependents) |dep| {\n+                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+                }\n+            } else {\n+                try output.println(\"Blocks: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Blocks: (none)\", .{});\n         }\n     }\n }\n@@ -231,6 +250,7 @@ fn runTree(\n     allocator: std.mem.Allocator,\n ) !void {\n     const id = tree_args.id;\n+    const format = tree_args.format;\n \n     // Check if issue exists\n     const issue = try ctx.store.get(id);\n@@ -250,6 +270,9 @@ fn runTree(\n             .success = true,\n             .tree = root,\n         });\n+    } else if (format == .mermaid) {\n+        // Mermaid flowchart output\n+        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n     } else {\n         // ASCII tree output\n         try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n@@ -355,6 +378,160 @@ fn printTreeBranch(\n     }\n }\n \n+fn printMermaidTree(\n+    output: *common.Output,\n+    graph: *DependencyGraph,\n+    ctx: *CommandContext,\n+    root_id: []const u8,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    // Start Mermaid flowchart\n+    try output.println(\"```mermaid\", .{});\n+    try output.println(\"flowchart TD\", .{});\n+\n+    // Track visited nodes to avoid duplicates\n+    var visited: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var it = visited.keyIterator();\n+        while (it.next()) |key| allocator.free(key.*);\n+        visited.deinit(allocator);\n+    }\n+\n+    // Track emitted edges to avoid duplicates\n+    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var edge_it = emitted_edges.keyIterator();\n+        while (edge_it.next()) |key| allocator.free(key.*);\n+        emitted_edges.deinit(allocator);\n+    }\n+\n+    // Collect all nodes and edges starting from root\n+    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n+","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"bc78ff1c-e3df-457d-a6f4-5254b5415bc9","tool_use_result":{"stdout":"diff --git a/src/cli/dep.zig b/src/cli/dep.zig\nindex 376b809..aea0996 100644\n--- a/src/cli/dep.zig\n+++ b/src/cli/dep.zig\n@@ -84,7 +84,7 @@ fn runAdd(\n         .dep_type = DependencyType.fromString(add_args.dep_type),\n         .created_at = now,\n         .created_by = global.actor,\n-        .metadata = null,\n+        .metadata = add_args.metadata,\n         .thread_id = null,\n     };\n \n@@ -160,24 +160,35 @@ fn runList(\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n-    const deps = try graph.getDependencies(list_args.id);\n-    defer graph.freeDependencies(deps);\n+    const direction = list_args.direction;\n+    const show_down = direction == .down or direction == .both;\n+    const show_up = direction == .up or direction == .both;\n \n-    const dependents = try graph.getDependents(list_args.id);\n-    defer graph.freeDependencies(dependents);\n+    var deps: []Dependency = &.{};\n+    var dependents: []Dependency = &.{};\n+\n+    if (show_down) {\n+        deps = try graph.getDependencies(list_args.id);\n+    }\n+    defer if (show_down) graph.freeDependencies(deps);\n+\n+    if (show_up) {\n+        dependents = try graph.getDependents(list_args.id);\n+    }\n+    defer if (show_up) graph.freeDependencies(dependents);\n \n     if (global.isStructuredOutput()) {\n         var depends_on_ids: ?[][]const u8 = null;\n         var blocks_ids: ?[][]const u8 = null;\n \n-        if (deps.len > 0) {\n+        if (show_down and deps.len > 0) {\n             depends_on_ids = try allocator.alloc([]const u8, deps.len);\n             for (deps, 0..) |dep, i| {\n                 depends_on_ids.?[i] = dep.depends_on_id;\n             }\n         }\n \n-        if (dependents.len > 0) {\n+        if (show_up and dependents.len > 0) {\n             blocks_ids = try allocator.alloc([]const u8, dependents.len);\n             for (dependents, 0..) |dep, i| {\n                 blocks_ids.?[i] = dep.issue_id;\n@@ -195,22 +206,30 @@ fn runList(\n             .blocks = blocks_ids,\n         });\n     } else {\n-        if (deps.len > 0) {\n-            try output.println(\"Depends on:\", .{});\n-            for (deps) |dep| {\n-                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+        if (show_down) {\n+            if (deps.len > 0) {\n+                try output.println(\"Depends on:\", .{});\n+                for (deps) |dep| {\n+                    if (dep.metadata) |meta| {\n+                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n+                    } else {\n+                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+                    }\n+                }\n+            } else {\n+                try output.println(\"Depends on: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Depends on: (none)\", .{});\n         }\n \n-        if (dependents.len > 0) {\n-            try output.println(\"Blocks:\", .{});\n-            for (dependents) |dep| {\n-                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+        if (show_up) {\n+            if (dependents.len > 0) {\n+                try output.println(\"Blocks:\", .{});\n+                for (dependents) |dep| {\n+                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+                }\n+            } else {\n+                try output.println(\"Blocks: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Blocks: (none)\", .{});\n         }\n     }\n }\n@@ -231,6 +250,7 @@ fn runTree(\n     allocator: std.mem.Allocator,\n ) !void {\n     const id = tree_args.id;\n+    const format = tree_args.format;\n \n     // Check if issue exists\n     const issue = try ctx.store.get(id);\n@@ -250,6 +270,9 @@ fn runTree(\n             .success = true,\n             .tree = root,\n         });\n+    } else if (format == .mermaid) {\n+        // Mermaid flowchart output\n+        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n     } else {\n         // ASCII tree output\n         try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n@@ -355,6 +378,160 @@ fn printTreeBranch(\n     }\n }\n \n+fn printMermaidTree(\n+    output: *common.Output,\n+    graph: *DependencyGraph,\n+    ctx: *CommandContext,\n+    root_id: []const u8,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    // Start Mermaid flowchart\n+    try output.println(\"```mermaid\", .{});\n+    try output.println(\"flowchart TD\", .{});\n+\n+    // Track visited nodes to avoid duplicates\n+    var visited: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var it = visited.keyIterator();\n+        while (it.next()) |key| allocator.free(key.*);\n+        visited.deinit(allocator);\n+    }\n+\n+    // Track emitted edges to avoid duplicates\n+    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var edge_it = emitted_edges.keyIterator();\n+        while (edge_it.next()) |key| allocator.free(key.*);\n+        emitted_edges.deinit(allocator);\n+    }\n+\n+    // Collect all nodes and edges starting from root\n+    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n+","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012QMXWeGhVLtg9UyhbsAwuZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PXGXUwhnPB23LznBg8ZBd1","name":"Bash","input":{"command":"git diff src/cli/label.zig | head -100","description":"Review label.zig changes","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1950,"cache_read_input_tokens":97390,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1950},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"fe58177f-6ef7-4b47-b78d-dad8f1f2f863"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PXGXUwhnPB23LznBg8ZBd1","type":"tool_result","content":"diff --git a/src/cli/label.zig b/src/cli/label.zig\nindex 942b031..a123004 100644\n--- a/src/cli/label.zig\n+++ b/src/cli/label.zig\n@@ -24,6 +24,9 @@ pub const LabelResult = struct {\n     labels: ?[]const []const u8 = null,\n     added: ?[]const []const u8 = null,\n     removed: ?[]const []const u8 = null,\n+    old_name: ?[]const u8 = null,\n+    new_name: ?[]const u8 = null,\n+    renamed_count: ?usize = null,\n     message: ?[]const u8 = null,\n };\n \n@@ -37,6 +40,7 @@ pub fn run(\n         .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n         .list => |list| try runList(list.id, global, allocator),\n         .list_all => try runListAll(global, allocator),\n+        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n     }\n }\n \n@@ -307,6 +311,78 @@ fn runListAll(\n     }\n }\n \n+fn runRename(\n+    old_name: []const u8,\n+    new_name: []const u8,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return LabelError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Count how many issues have this label renamed\n+    var renamed_count: usize = 0;\n+\n+    // Iterate through all issues\n+    for (ctx.store.issues.items) |*issue| {\n+        if (issue.status.eql(.tombstone)) continue;\n+\n+        // Check if issue has the old label\n+        var has_old_label = false;\n+        var old_label_idx: usize = 0;\n+        for (issue.labels, 0..) |label, idx| {\n+            if (std.mem.eql(u8, label, old_name)) {\n+                has_old_label = true;\n+                old_label_idx = idx;\n+                break;\n+            }\n+        }\n+\n+        if (has_old_label) {\n+            // Check if it already has the new label (avoid duplicates)\n+            var has_new_label = false;\n+            for (issue.labels) |label| {\n+                if (std.mem.eql(u8, label, new_name)) {\n+                    has_new_label = true;\n+                    break;\n+                }\n+            }\n+\n+            if (has_new_label) {\n+                // Remove the old label (new label already exists)\n+                try ctx.store.removeLabel(issue.id, old_name);\n+            } else {\n+                // Replace old label with new label in place\n+                // First remove old, then add new\n+                try ctx.store.removeLabel(issue.id, old_name);\n+                try ctx.store.addLabel(issue.id, new_name);\n+            }\n+            renamed_count += 1;\n+        }\n+    }\n+\n+    try ctx.saveIfAutoFlush();\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(LabelResult{\n+            .success = true,\n+            .old_name = old_name,\n+            .new_name = new_name,\n+            .renamed_count = renamed_count,\n+        });\n+    } else if (global.quiet) {\n+        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n+    } else {\n+        if (renamed_count > 0) {\n+            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n+        } else {\n+            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n+        }\n+    }\n+}\n+\n // --- Tests ---","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"635bd6cf-2d9c-4a8e-a3a9-7c1c2698b191","tool_use_result":{"stdout":"diff --git a/src/cli/label.zig b/src/cli/label.zig\nindex 942b031..a123004 100644\n--- a/src/cli/label.zig\n+++ b/src/cli/label.zig\n@@ -24,6 +24,9 @@ pub const LabelResult = struct {\n     labels: ?[]const []const u8 = null,\n     added: ?[]const []const u8 = null,\n     removed: ?[]const []const u8 = null,\n+    old_name: ?[]const u8 = null,\n+    new_name: ?[]const u8 = null,\n+    renamed_count: ?usize = null,\n     message: ?[]const u8 = null,\n };\n \n@@ -37,6 +40,7 @@ pub fn run(\n         .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n         .list => |list| try runList(list.id, global, allocator),\n         .list_all => try runListAll(global, allocator),\n+        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n     }\n }\n \n@@ -307,6 +311,78 @@ fn runListAll(\n     }\n }\n \n+fn runRename(\n+    old_name: []const u8,\n+    new_name: []const u8,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return LabelError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Count how many issues have this label renamed\n+    var renamed_count: usize = 0;\n+\n+    // Iterate through all issues\n+    for (ctx.store.issues.items) |*issue| {\n+        if (issue.status.eql(.tombstone)) continue;\n+\n+        // Check if issue has the old label\n+        var has_old_label = false;\n+        var old_label_idx: usize = 0;\n+        for (issue.labels, 0..) |label, idx| {\n+            if (std.mem.eql(u8, label, old_name)) {\n+                has_old_label = true;\n+                old_label_idx = idx;\n+                break;\n+            }\n+        }\n+\n+        if (has_old_label) {\n+            // Check if it already has the new label (avoid duplicates)\n+            var has_new_label = false;\n+            for (issue.labels) |label| {\n+                if (std.mem.eql(u8, label, new_name)) {\n+                    has_new_label = true;\n+                    break;\n+                }\n+            }\n+\n+            if (has_new_label) {\n+                // Remove the old label (new label already exists)\n+                try ctx.store.removeLabel(issue.id, old_name);\n+            } else {\n+                // Replace old label with new label in place\n+                // First remove old, then add new\n+                try ctx.store.removeLabel(issue.id, old_name);\n+                try ctx.store.addLabel(issue.id, new_name);\n+            }\n+            renamed_count += 1;\n+        }\n+    }\n+\n+    try ctx.saveIfAutoFlush();\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(LabelResult{\n+            .success = true,\n+            .old_name = old_name,\n+            .new_name = new_name,\n+            .renamed_count = renamed_count,\n+        });\n+    } else if (global.quiet) {\n+        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n+    } else {\n+        if (renamed_count > 0) {\n+            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n+        } else {\n+            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n+        }\n+    }\n+}\n+\n // --- Tests ---","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XjUpc2eeqeJdKsN7QARVF3","type":"message","role":"assistant","content":[{"type":"text","text":"All changes look good. Now let me add all the source files and create the commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1239,"cache_read_input_tokens":99340,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1239},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"295eff8a-233a-45a0-82ee-f12dd4bccfaf"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XjUpc2eeqeJdKsN7QARVF3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018MvoV23xMYrTg2PGPvge5T","name":"Bash","input":{"command":"git add src/cli/args.zig src/cli/dep.zig src/cli/label.zig","description":"Stage changed source files","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1239,"cache_read_input_tokens":99340,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1239},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"df88ab4a-0a4a-4aeb-aefc-343a83d07304"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018MvoV23xMYrTg2PGPvge5T","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"eb93f063-3e7a-4d08-aeed-581ceab66861","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M5KMHPj6GSnYaPfqoqFnT7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QWQ7J5TSkJ5KWtdZwMA8PK","name":"Bash","input":{"command":"git diff --cached --stat","description":"Show staged changes summary","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":160,"cache_read_input_tokens":100579,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":160},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7b490d88-7098-4155-86e9-c8e09698e935"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QWQ7J5TSkJ5KWtdZwMA8PK","type":"tool_result","content":" src/cli/args.zig  | 124 ++++++++++++++++++++++++++++++-\n src/cli/dep.zig   | 215 +++++++++++++++++++++++++++++++++++++++++++++++++-----\n src/cli/label.zig |  76 +++++++++++++++++++\n 3 files changed, 393 insertions(+), 22 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"b353985c-6075-4c7e-8c93-f7c218a52d22","tool_use_result":{"stdout":" src/cli/args.zig  | 124 ++++++++++++++++++++++++++++++-\n src/cli/dep.zig   | 215 +++++++++++++++++++++++++++++++++++++++++++++++++-----\n src/cli/label.zig |  76 +++++++++++++++++++\n 3 files changed, 393 insertions(+), 22 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DmGUwV4uyF8nDECEJFFfkW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WPnHDgVA5UdpaR64vS2xde","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nfeat(cli): add dep enhancements and label rename command\n\nDependency enhancements:\n- Add --metadata flag to `dep add` for attaching JSON metadata\n- Add --direction flag to `dep list` (up/down/both) for filtering\n- Add --format mermaid to `dep tree` for Mermaid diagram export\n- Display metadata in `dep list` output when present\n\nLabel enhancements:\n- Add `label rename old-name new-name` subcommand\n- Renames label across all issues in a single operation\n- Handles duplicate label collision (removes old if new exists)\n- Supports --json output and quiet mode\n\nTests:\n- Add 6 new arg parsing tests for new flags\n- All 669 tests pass\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Create commit with all changes","timeout":10000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":206,"cache_read_input_tokens":100739,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":206},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"61b135d8-5f18-40c4-ab05-730af16a4795"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WPnHDgVA5UdpaR64vS2xde","type":"tool_result","content":"[dev-hotschmoe c83e1d7] feat(cli): add dep enhancements and label rename command\n 3 files changed, 393 insertions(+), 22 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"59dfea8c-72c5-45c6-bf83-1e959d9eac95","tool_use_result":{"stdout":"[dev-hotschmoe c83e1d7] feat(cli): add dep enhancements and label rename command\n 3 files changed, 393 insertions(+), 22 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xn7e7uweCwSBLe2U5uJMPC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N24vipEUF3j5CApjBW9DPu","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"completed","activeForm":"Creating git commit"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":362,"cache_read_input_tokens":100945,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":362},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"7204ab0c-8dfc-4181-ad0a-71caead6f2cd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01N24vipEUF3j5CApjBW9DPu","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"eea04b7c-98d2-4e4e-9166-677b46f8ca10","tool_use_result":{"oldTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"in_progress","activeForm":"Creating git commit"}],"newTodos":[{"content":"Task 1: Add dependency enhancements (--metadata, --direction, mermaid)","status":"completed","activeForm":"Adding dependency enhancements"},{"content":"Task 2: Add label rename subcommand","status":"completed","activeForm":"Adding label rename subcommand"},{"content":"Run tests and verify implementation","status":"completed","activeForm":"Running tests and verifying implementation"},{"content":"Create git commit with all changes","status":"completed","activeForm":"Creating git commit"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qvohu9jDwZqrBwJpSyFkSs","type":"message","role":"assistant","content":[{"type":"text","text":"## Summary\n\nBoth tasks have been completed successfully.\n\n### Task 1: Add dependency enhancements (bd-1y3) - SUCCESS\n\nImplemented the following enhancements to the `dep` command:\n\n| Enhancement | Details |\n|-------------|---------|\n| `--metadata` flag | Added to `dep add` - attaches JSON metadata to dependencies |\n| `--direction` flag | Added to `dep list` - filter by `up`/`down`/`both` directions |\n| `--format mermaid` | Added to `dep tree` - exports dependency graph as Mermaid flowchart |\n| Metadata display | Dependencies with metadata now show it in `dep list` output |\n\nNote: All dependency types mentioned in the task spec (conditional_blocks, waits_for, discovered_from, replies_to, supersedes, caused_by) were already present in `src/models/dependency.zig:10-22`.\n\nExample usage:\n```bash\nbz dep add bd-1 bd-2 --type blocks --metadata '{\"reason\": \"needs API first\"}'\nbz dep list bd-1 --direction down  # What bd-1 depends on\nbz dep list bd-1 --direction up    # What depends on bd-1\nbz dep tree bd-1 --format mermaid\n```\n\n### Task 2: Add label rename subcommand (bd-82t) - SUCCESS\n\nImplemented `label rename` subcommand:\n- Renames a label across all issues in a single operation\n- Handles duplicate label collision (if target label exists, removes old label only)\n- Supports JSON output and quiet mode\n- Added `mv` alias for consistency\n\nExample usage:\n```bash\nbz label rename old-name new-name\nbz label mv backend api  # alias\n```\n\n### Changes Made\n- `src/cli/args.zig`: Added `DepDirection`, `TreeFormat` enums, extended `DepSubcommand` and `LabelSubcommand`, updated parsers (+124 lines)\n- `src/cli/dep.zig`: Added metadata support, direction filtering, Mermaid output (+215 lines)\n- `src/cli/label.zig`: Added `runRename` function and updated result struct (+76 lines)\n\n### Verification\n- All 669 tests pass (6 new tests added)\n- Manual testing confirmed all new features work correctly\n- Commit created: `c83e1d7`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":226,"cache_read_input_tokens":101307,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":226},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","uuid":"5eb515ba-8084-4f74-960c-e1f339476d95"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":408398,"duration_api_ms":420710,"num_turns":58,"result":"## Summary\n\nBoth tasks have been completed successfully.\n\n### Task 1: Add dependency enhancements (bd-1y3) - SUCCESS\n\nImplemented the following enhancements to the `dep` command:\n\n| Enhancement | Details |\n|-------------|---------|\n| `--metadata` flag | Added to `dep add` - attaches JSON metadata to dependencies |\n| `--direction` flag | Added to `dep list` - filter by `up`/`down`/`both` directions |\n| `--format mermaid` | Added to `dep tree` - exports dependency graph as Mermaid flowchart |\n| Metadata display | Dependencies with metadata now show it in `dep list` output |\n\nNote: All dependency types mentioned in the task spec (conditional_blocks, waits_for, discovered_from, replies_to, supersedes, caused_by) were already present in `src/models/dependency.zig:10-22`.\n\nExample usage:\n```bash\nbz dep add bd-1 bd-2 --type blocks --metadata '{\"reason\": \"needs API first\"}'\nbz dep list bd-1 --direction down  # What bd-1 depends on\nbz dep list bd-1 --direction up    # What depends on bd-1\nbz dep tree bd-1 --format mermaid\n```\n\n### Task 2: Add label rename subcommand (bd-82t) - SUCCESS\n\nImplemented `label rename` subcommand:\n- Renames a label across all issues in a single operation\n- Handles duplicate label collision (if target label exists, removes old label only)\n- Supports JSON output and quiet mode\n- Added `mv` alias for consistency\n\nExample usage:\n```bash\nbz label rename old-name new-name\nbz label mv backend api  # alias\n```\n\n### Changes Made\n- `src/cli/args.zig`: Added `DepDirection`, `TreeFormat` enums, extended `DepSubcommand` and `LabelSubcommand`, updated parsers (+124 lines)\n- `src/cli/dep.zig`: Added metadata support, direction filtering, Mermaid output (+215 lines)\n- `src/cli/label.zig`: Added `runRename` function and updated result struct (+76 lines)\n\n### Verification\n- All 669 tests pass (6 new tests added)\n- Manual testing confirmed all new features work correctly\n- Commit created: `c83e1d7`","session_id":"9de7026f-8184-4b0b-b1ad-b00957d395f6","total_cost_usd":3.3495448,"usage":{"input_tokens":2,"cache_creation_input_tokens":83557,"cache_read_input_tokens":4402085,"output_tokens":20068,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":83557,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":20068,"cacheReadInputTokens":4402085,"cacheCreationInputTokens":83557,"webSearchRequests":0,"costUSD":3.2249837500000003,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":42119,"outputTokens":4025,"cacheReadInputTokens":130783,"cacheCreationInputTokens":39391,"webSearchRequests":0,"costUSD":0.12456104999999998,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"bb0da202-a40c-4564-af91-99d82a501e01"}
