{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"e5ef6001-41bb-4e8e-adce-d93fd14b4561"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDDJfMCYShPUjGTzxjarNx","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement these two tasks in order. Let me start by exploring the codebase structure to understand how sync and commands are organized."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21102,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21102},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b292ece1-11ed-4e11-8cc4-bb5705b6230d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDDJfMCYShPUjGTzxjarNx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","name":"Task","input":{"description":"Explore sync and CLI structure","prompt":"Explore the beads_zig codebase to understand:\n1. How the sync command is currently implemented (find the sync.zig file in cli/)\n2. How command arguments are parsed (args.zig)\n3. What the current sync command flags are\n4. How other commands handle similar policy-style flags\n\nFocus on:\n- src/cli/sync.zig\n- src/cli/args.zig\n- Any related files for understanding the pattern\n\nReport back with file paths, key structures, and how flags are defined and used.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21102,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21102},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c8590af4-4845-4634-80f9-85da925fb04d"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Explore the beads_zig codebase to understand:\n1. How the sync command is currently implemented (find the sync.zig file in cli/)\n2. How command arguments are parsed (args.zig)\n3. What the current sync command flags are\n4. How other commands handle similar policy-style flags\n\nFocus on:\n- src/cli/sync.zig\n- src/cli/args.zig\n- Any related files for understanding the pattern\n\nReport back with file paths, key structures, and how flags are defined and used."}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"9fc60fc4-8c26-4be3-af5d-a01f34fdf696"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RXWhsocvGgQQuGKBm7NCEr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KJu8xvrdZ5x9VmgRyZYQe8","name":"Glob","input":{"pattern":"src/cli/sync.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3933,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3933},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"52b39c96-04c7-4a32-918c-775be14dc0db"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RXWhsocvGgQQuGKBm7NCEr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BAxqBc4qY4YbxQ3M6af68s","name":"Glob","input":{"pattern":"src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3933,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3933},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a3a1bacf-6620-43d9-bee2-96c532fd5d45"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KJu8xvrdZ5x9VmgRyZYQe8","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/sync.zig"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e512c86e-9962-4ac8-bc9a-d34d7efbc653"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BAxqBc4qY4YbxQ3M6af68s","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/args.zig"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5776fedd-5184-47f1-b9d9-4b19a31c89ae"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RXWhsocvGgQQuGKBm7NCEr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TbxNbvSxhi3BZTjmb6VRUE","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig/src/cli -type f -name \"*.zig\" | head -20","description":"List CLI command files to see available patterns"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3933,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3933},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ff07eedb-2eff-41ef-b948-f8f7a32367dc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TbxNbvSxhi3BZTjmb6VRUE","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/upgrade.zig\n/home/hotschmoe/beads_zig/src/cli/label.zig\n/home/hotschmoe/beads_zig/src/cli/close.zig\n/home/hotschmoe/beads_zig/src/cli/update.zig\n/home/hotschmoe/beads_zig/src/cli/help.zig\n/home/hotschmoe/beads_zig/src/cli/mod.zig\n/home/hotschmoe/beads_zig/src/cli/version.zig\n/home/hotschmoe/beads_zig/src/cli/delete.zig\n/home/hotschmoe/beads_zig/src/cli/audit.zig\n/home/hotschmoe/beads_zig/src/cli/common.zig\n/home/hotschmoe/beads_zig/src/cli/schema.zig\n/home/hotschmoe/beads_zig/src/cli/comments.zig\n/home/hotschmoe/beads_zig/src/cli/batch.zig\n/home/hotschmoe/beads_zig/src/cli/list.zig\n/home/hotschmoe/beads_zig/src/cli/args.zig\n/home/hotschmoe/beads_zig/src/cli/stats.zig\n/home/hotschmoe/beads_zig/src/cli/sync.zig\n/home/hotschmoe/beads_zig/src/cli/show.zig\n/home/hotschmoe/beads_zig/src/cli/orphans.zig\n/home/hotschmoe/beads_zig/src/cli/metrics.zig","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"dede1411-8057-439b-bf16-098cd5d2ccc0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01J8yDVqZ2RKFArm7kNFc8jH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Wjsc4pjKEZDyuRmktNVAfj","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":843,"cache_read_input_tokens":13149,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":843},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8dbb111f-93c8-4081-8257-76e4a0860b80"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Wjsc4pjKEZDyuRmktNVAfj","type":"tool_result","content":"     1→//! Sync command for beads_zig.\n     2→//!\n     3→//! `bz sync` - Bidirectional sync with JSONL file\n     4→//! `bz sync --flush-only` - Export to JSONL only\n     5→//! `bz sync --import-only` - Import from JSONL only\n     6→//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n     7→//!\n     8→//! Handles synchronization between in-memory state and JSONL file.\n     9→\n    10→const std = @import(\"std\");\n    11→const models = @import(\"../models/mod.zig\");\n    12→const storage = @import(\"../storage/mod.zig\");\n    13→const common = @import(\"common.zig\");\n    14→const args = @import(\"args.zig\");\n    15→const test_util = @import(\"../test_util.zig\");\n    16→\n    17→const Issue = models.Issue;\n    18→const IssueStore = common.IssueStore;\n    19→const CommandContext = common.CommandContext;\n    20→\n    21→pub const SyncError = error{\n    22→    WorkspaceNotInitialized,\n    23→    MergeConflictDetected,\n    24→    ImportError,\n    25→    ExportError,\n    26→    OutOfMemory,\n    27→};\n    28→\n    29→pub const SyncResult = struct {\n    30→    success: bool,\n    31→    action: ?[]const u8 = null,\n    32→    issues_exported: ?usize = null,\n    33→    issues_imported: ?usize = null,\n    34→    issues_updated: ?usize = null,\n    35→    issues_added: ?usize = null,\n    36→    message: ?[]const u8 = null,\n    37→    // Status-specific fields\n    38→    db_count: ?usize = null,\n    39→    jsonl_count: ?usize = null,\n    40→    pending_export: ?usize = null,\n    41→    // Manifest-specific fields\n    42→    manifest_path: ?[]const u8 = null,\n    43→};\n    44→\n    45→pub fn run(\n    46→    sync_args: args.SyncArgs,\n    47→    global: args.GlobalOptions,\n    48→    allocator: std.mem.Allocator,\n    49→) !void {\n    50→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    51→        return SyncError.WorkspaceNotInitialized;\n    52→    };\n    53→    defer ctx.deinit();\n    54→\n    55→    const structured_output = global.isStructuredOutput();\n    56→\n    57→    if (sync_args.status) {\n    58→        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    59→    } else if (sync_args.flush_only) {\n    60→        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    61→    } else if (sync_args.import_only) {\n    62→        try runImport(&ctx, structured_output, global.quiet, allocator);\n    63→    } else if (sync_args.merge) {\n    64→        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    65→    } else {\n    66→        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    67→    }\n    68→}\n    69→\n    70→fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    71→    const count = ctx.store.issues.items.len;\n    72→\n    73→    ctx.store.saveToFile() catch {\n    74→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n    75→        return SyncError.ExportError;\n    76→    };\n    77→\n    78→    // Write manifest if requested\n    79→    var manifest_path: ?[]const u8 = null;\n    80→    if (write_manifest) {\n    81→        manifest_path = try writeManifest(ctx, count, allocator);\n    82→    }\n    83→    defer if (manifest_path) |path| allocator.free(path);\n    84→\n    85→    if (structured_output) {\n    86→        try ctx.output.printJson(SyncResult{\n    87→            .success = true,\n    88→            .action = \"flush\",\n    89→            .issues_exported = count,\n    90→            .manifest_path = manifest_path,\n    91→        });\n    92→    } else if (!quiet) {\n    93→        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n    94→        if (manifest_path) |path| {\n    95→            try ctx.output.info(\"Manifest written to {s}\", .{path});\n    96→        }\n    97→    }\n    98→}\n    99→\n   100→fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   101→    // Check for merge conflict markers in the JSONL file\n   102→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   103→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   104→        return SyncError.MergeConflictDetected;\n   105→    }\n   106→\n   107→    // Reload from file (this replaces in-memory state)\n   108→    const old_count = ctx.store.issues.items.len;\n   109→\n   110→    // Deinit existing issues\n   111→    for (ctx.store.issues.items) |*issue| {\n   112→        issue.deinit(allocator);\n   113→    }\n   114→    ctx.store.issues.clearRetainingCapacity();\n   115→\n   116→    // Clear and rebuild index\n   117→    var id_it = ctx.store.id_index.keyIterator();\n   118→    while (id_it.next()) |key| {\n   119→        allocator.free(key.*);\n   120→    }\n   121→    ctx.store.id_index.clearRetainingCapacity();\n   122→\n   123→    // Reload from file\n   124→    ctx.store.loadFromFile() catch {\n   125→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n   126→        return SyncError.ImportError;\n   127→    };\n   128→\n   129→    const new_count = ctx.store.issues.items.len;\n   130→\n   131→    if (structured_output) {\n   132→        try ctx.output.printJson(SyncResult{\n   133→            .success = true,\n   134→            .action = \"import\",\n   135→            .issues_imported = new_count,\n   136→        });\n   137→    } else if (!quiet) {\n   138→        if (new_count > old_count) {\n   139→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n   140→        } else if (new_count < old_count) {\n   141→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n   142→        } else {\n   143→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n   144→        }\n   145→    }\n   146→}\n   147→\n   148→fn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   149→    // Check for merge conflict markers\n   150→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   151→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   152→        return SyncError.MergeConflictDetected;\n   153→    }\n   154→\n   155→    // For bidirectional sync, we export the current state\n   156→    // A full bidirectional merge would require content hashing which is complex\n   157→    const count = ctx.store.issues.items.len;\n   158→\n   159→    if (ctx.store.dirty) {\n   160→        ctx.store.saveToFile() catch {\n   161→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n   162→            return SyncError.ExportError;\n   163→        };\n   164→\n   165→        if (structured_output) {\n   166→            try ctx.output.printJson(SyncResult{\n   167→                .success = true,\n   168→                .action = \"sync\",\n   169→                .issues_exported = count,\n   170→            });\n   171→        } else if (!quiet) {\n   172→            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n   173→        }\n   174→    } else {\n   175→        if (structured_output) {\n   176→            try ctx.output.printJson(SyncResult{\n   177→                .success = true,\n   178→                .action = \"sync\",\n   179→                .message = \"no changes to sync\",\n   180→            });\n   181→        } else if (!quiet) {\n   182→            try ctx.output.info(\"No changes to sync\", .{});\n   183→        }\n   184→    }\n   185→}\n   186→\n   187→/// Perform 3-way merge of local DB and remote JSONL.\n   188→/// For each issue:\n   189→/// - If only in local: keep\n   190→/// - If only in remote: add\n   191→/// - If in both: keep the one with newer updated_at timestamp\n   192→fn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   193→    // Check for merge conflict markers\n   194→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   195→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   196→        return SyncError.MergeConflictDetected;\n   197→    }\n   198→\n   199→    // Load remote issues from JSONL file directly (without replacing store)\n   200→    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n   201→    defer remote_store.deinit();\n   202→\n   203→    remote_store.loadFromFile() catch |err| {\n   204→        if (err != error.FileNotFound) {\n   205→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n   206→            return SyncError.ImportError;\n   207→        }\n   208→    };\n   209→\n   210→    var added: usize = 0;\n   211→    var updated: usize = 0;\n   212→\n   213→    // Iterate through remote issues and merge into local store\n   214→    for (remote_store.issues.items) |remote_issue| {\n   215→        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n   216→            // Issue exists in both - compare updated_at timestamps\n   217→            const local_ts = local_issue.updated_at.value;\n   218→            const remote_ts = remote_issue.updated_at.value;\n   219→\n   220→            if (remote_ts > local_ts) {\n   221→                // Remote is newer - update local with remote data\n   222→                // We need to copy the remote issue's data\n   223→                const update = storage.IssueStore.IssueUpdate{\n   224→                    .title = remote_issue.title,\n   225→                    .description = remote_issue.description,\n   226→                    .design = remote_issue.design,\n   227→                    .acceptance_criteria = remote_issue.acceptance_criteria,\n   228→                    .notes = remote_issue.notes,\n   229→                    .status = remote_issue.status,\n   230→                    .priority = remote_issue.priority,\n   231→                    .issue_type = remote_issue.issue_type,\n   232→                    .assignee = remote_issue.assignee,\n   233→                    .owner = remote_issue.owner,\n   234→                    .estimated_minutes = remote_issue.estimated_minutes,\n   235→                    .closed_at = remote_issue.closed_at.value,\n   236→                    .close_reason = remote_issue.close_reason,\n   237→                    .due_at = remote_issue.due_at.value,\n   238→                    .defer_until = remote_issue.defer_until.value,\n   239→                    .external_ref = remote_issue.external_ref,\n   240→                    .source_system = remote_issue.source_system,\n   241→                    .pinned = remote_issue.pinned,\n   242→                    .is_template = remote_issue.is_template,\n   243→                };\n   244→\n   245→                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n   246→                updated += 1;\n   247→            }\n   248→            // If local is newer or equal, keep local (no action needed)\n   249→        } else {\n   250→            // Issue only in remote - add to local\n   251→            // Clone the remote issue for insertion\n   252→            var cloned = try remote_issue.clone(allocator);\n   253→            ctx.store.insert(cloned) catch {\n   254→                cloned.deinit(allocator);\n   255→                continue;\n   256→            };\n   257→            added += 1;\n   258→        }\n   259→    }\n   260→\n   261→    // Save merged state if any changes were made\n   262→    if (added > 0 or updated > 0 or ctx.store.dirty) {\n   263→        ctx.store.saveToFile() catch {\n   264→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n   265→            return SyncError.ExportError;\n   266→        };\n   267→    }\n   268→\n   269→    const total = ctx.store.issues.items.len;\n   270→\n   271→    if (structured_output) {\n   272→        try ctx.output.printJson(SyncResult{\n   273→            .success = true,\n   274→            .action = \"merge\",\n   275→            .issues_added = added,\n   276→            .issues_updated = updated,\n   277→            .issues_exported = total,\n   278→        });\n   279→    } else if (!quiet) {\n   280→        if (added == 0 and updated == 0) {\n   281→            try ctx.output.info(\"No changes to merge\", .{});\n   282→        } else {\n   283→            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n   284→        }\n   285→    }\n   286→}\n   287→\n   288→/// Show sync status without making changes.\n   289→/// Reports: DB issue count, JSONL issue count, pending export count.\n   290→fn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   291→    const db_count = ctx.store.issues.items.len;\n   292→\n   293→    // Count issues in JSONL file (without loading into store)\n   294→    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n   295→        error.FileNotFound => 0,\n   296→        else => return err,\n   297→    };\n   298→\n   299→    // Count pending exports (dirty issues)\n   300→    const pending_export = ctx.store.dirty_ids.count();\n   301→\n   302→    if (structured_output) {\n   303→        try ctx.output.printJson(SyncResult{\n   304→            .success = true,\n   305→            .action = \"status\",\n   306→            .db_count = db_count,\n   307→            .jsonl_count = jsonl_count,\n   308→            .pending_export = pending_export,\n   309→        });\n   310→    } else if (!quiet) {\n   311→        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n   312→        if (pending_export > 0) {\n   313→            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n   314→        } else {\n   315→            try ctx.output.info(\"No pending changes\", .{});\n   316→        }\n   317→    }\n   318→}\n   319→\n   320→/// Count the number of issues in a JSONL file without fully parsing them.\n   321→fn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n   322→    const file = try std.fs.cwd().openFile(path, .{});\n   323→    defer file.close();\n   324→\n   325→    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n   326→    defer allocator.free(content);\n   327→\n   328→    var count: usize = 0;\n   329→    var lines = std.mem.splitScalar(u8, content, '\\n');\n   330→    while (lines.next()) |line| {\n   331→        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n   332→        if (trimmed.len > 0 and trimmed[0] == '{') {\n   333→            count += 1;\n   334→        }\n   335→    }\n   336→    return count;\n   337→}\n   338→\n   339→/// Write a manifest file with export metadata.\n   340→fn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n   341→    // Derive manifest path from jsonl_path\n   342→    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n   343→    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n   344→    errdefer allocator.free(manifest_path);\n   345→\n   346→    const timestamp = std.time.timestamp();\n   347→\n   348→    // Build manifest JSON\n   349→    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n   350→    defer json_buf.deinit(allocator);\n   351→\n   352→    const writer = json_buf.writer(allocator);\n   353→    try writer.writeAll(\"{\\n\");\n   354→    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n   355→    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n   356→    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n   357→    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n   358→    try writer.writeAll(\"}\\n\");\n   359→\n   360→    // Write to file\n   361→    const file = try std.fs.cwd().createFile(manifest_path, .{});\n   362→    defer file.close();\n   363→    try file.writeAll(json_buf.items);\n   364→\n   365→    return manifest_path;\n   366→}\n   367→\n   368→/// Check if the JSONL file contains git merge conflict markers\n   369→fn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n   370→    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n   371→        error.FileNotFound => return false,\n   372→        else => return err,\n   373→    };\n   374→    defer file.close();\n   375→\n   376→    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n   377→    defer allocator.free(content);\n   378→\n   379→    // Check for common merge conflict markers\n   380→    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n   381→    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n   382→    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n   383→\n   384→    return false;\n   385→}\n   386→\n   387→// --- Tests ---\n   388→\n   389→test \"SyncError enum exists\" {\n   390→    const err: SyncError = SyncError.MergeConflictDetected;\n   391→    try std.testing.expect(err == SyncError.MergeConflictDetected);\n   392→}\n   393→\n   394→test \"SyncResult struct works\" {\n   395→    const result = SyncResult{\n   396→        .success = true,\n   397→        .action = \"flush\",\n   398→        .issues_exported = 5,\n   399→    };\n   400→    try std.testing.expect(result.success);\n   401→    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n   402→    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n   403→}\n   404→\n   405→test \"run detects uninitialized workspace\" {\n   406→    const allocator = std.testing.allocator;\n   407→\n   408→    const sync_args = args.SyncArgs{};\n   409→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   410→\n   411→    const result = run(sync_args, global, allocator);\n   412→    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n   413→}\n   414→\n   415→test \"hasMergeConflicts returns false for clean file\" {\n   416→    const allocator = std.testing.allocator;\n   417→    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n   418→    defer allocator.free(test_dir);\n   419→    defer test_util.cleanupTestDir(test_dir);\n   420→\n   421→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n   422→    defer allocator.free(test_path);\n   423→\n   424→    const file = try std.fs.cwd().createFile(test_path, .{});\n   425→    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n   426→    file.close();\n   427→\n   428→    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n   429→    try std.testing.expect(!has_conflicts);\n   430→}\n   431→\n   432→test \"hasMergeConflicts returns true for conflicted file\" {\n   433→    const allocator = std.testing.allocator;\n   434→    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n   435→    defer allocator.free(test_dir);\n   436→    defer test_util.cleanupTestDir(test_dir);\n   437→\n   438→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n   439→    defer allocator.free(test_path);\n   440→\n   441→    const file = try std.fs.cwd().createFile(test_path, .{});\n   442→    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n   443→    file.close();\n   444→\n   445→    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n   446→    try std.testing.expect(has_conflicts);\n   447→}\n   448→\n   449→test \"hasMergeConflicts returns false for missing file\" {\n   450→    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n   451→    try std.testing.expect(!has_conflicts);\n   452→}\n   453→\n   454→test \"countJsonlIssues counts valid JSON lines\" {\n   455→    const allocator = std.testing.allocator;\n   456→    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n   457→    defer allocator.free(test_dir);\n   458→    defer test_util.cleanupTestDir(test_dir);\n   459→\n   460→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n   461→    defer allocator.free(test_path);\n   462→\n   463→    const file = try std.fs.cwd().createFile(test_path, .{});\n   464→    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n   465→    file.close();\n   466→\n   467→    const count = try countJsonlIssues(test_path, allocator);\n   468→    try std.testing.expectEqual(@as(usize, 3), count);\n   469→}\n   470→\n   471→test \"countJsonlIssues handles empty lines\" {\n   472→    const allocator = std.testing.allocator;\n   473→    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n   474→    defer allocator.free(test_dir);\n   475→    defer test_util.cleanupTestDir(test_dir);\n   476→\n   477→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n   478→    defer allocator.free(test_path);\n   479→\n   480→    const file = try std.fs.cwd().createFile(test_path, .{});\n   481→    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n   482→    file.close();\n   483→\n   484→    const count = try countJsonlIssues(test_path, allocator);\n   485→    try std.testing.expectEqual(@as(usize, 3), count);\n   486→}\n   487→\n   488→test \"SyncResult with status fields\" {\n   489→    const result = SyncResult{\n   490→        .success = true,\n   491→        .action = \"status\",\n   492→        .db_count = 45,\n   493→        .jsonl_count = 43,\n   494→        .pending_export = 2,\n   495→    };\n   496→    try std.testing.expect(result.success);\n   497→    try std.testing.expectEqualStrings(\"status\", result.action.?);\n   498→    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n   499→    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n   500→    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n   501→}\n   502→\n   503→test \"SyncArgs parses status flag\" {\n   504→    const sync_args = args.SyncArgs{ .status = true };\n   505→    try std.testing.expect(sync_args.status);\n   506→    try std.testing.expect(!sync_args.flush_only);\n   507→}\n   508→\n   509→test \"SyncArgs parses manifest flag\" {\n   510→    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n   511→    try std.testing.expect(sync_args.manifest);\n   512→    try std.testing.expect(sync_args.flush_only);\n   513→}\n   514→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"796de1af-5e4a-41b2-849b-5c573d1609a6"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01J8yDVqZ2RKFArm7kNFc8jH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AF2n1T2aAhCWPXcZrnUibN","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":843,"cache_read_input_tokens":13149,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":843},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ffe06499-3761-454a-a11d-f793079f1b31"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01J8yDVqZ2RKFArm7kNFc8jH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LJyRPc23ohyCdCvrLGPgfR","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/common.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":843,"cache_read_input_tokens":13149,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":843},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8a323b09-d153-41f4-bcaf-a359ee4c5e38"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LJyRPc23ohyCdCvrLGPgfR","type":"tool_result","content":"     1→//! Common CLI utilities shared across commands.\n     2→//!\n     3→//! Provides workspace loading, error handling, and shared result types\n     4→//! to reduce duplication across command implementations.\n     5→\n     6→const std = @import(\"std\");\n     7→const storage = @import(\"../storage/mod.zig\");\n     8→const output_mod = @import(\"../output/mod.zig\");\n     9→const args = @import(\"args.zig\");\n    10→\n    11→pub const Output = output_mod.Output;\n    12→pub const OutputOptions = output_mod.OutputOptions;\n    13→pub const IssueStore = storage.IssueStore;\n    14→pub const IssueStoreError = storage.IssueStoreError;\n    15→pub const DependencyGraph = storage.DependencyGraph;\n    16→pub const EventStore = storage.EventStore;\n    17→pub const StoreLoadResult = storage.StoreLoadResult;\n    18→\n    19→/// Common errors shared across CLI commands.\n    20→pub const CommandError = error{\n    21→    WorkspaceNotInitialized,\n    22→    StorageError,\n    23→    OutOfMemory,\n    24→};\n    25→\n    26→/// Context for executing a CLI command with an initialized workspace.\n    27→pub const CommandContext = struct {\n    28→    allocator: std.mem.Allocator,\n    29→    output: Output,\n    30→    store: IssueStore,\n    31→    event_store: EventStore,\n    32→    beads_dir: []const u8,\n    33→    issues_path: []const u8,\n    34→    events_path: []const u8,\n    35→    global: args.GlobalOptions,\n    36→    /// Number of corrupt entries skipped during load.\n    37→    corruption_count: usize = 0,\n    38→    /// Line numbers of corrupt JSONL entries (owned memory).\n    39→    corrupt_lines: []const usize = &.{},\n    40→    /// Number of WAL entries replayed during load.\n    41→    wal_entries_replayed: usize = 0,\n    42→\n    43→    /// Initialize a command context by loading the workspace.\n    44→    /// Returns null and outputs an error if workspace is not initialized.\n    45→    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    46→    /// Replays WAL entries after loading main file for consistency.\n    47→    pub fn init(\n    48→        allocator: std.mem.Allocator,\n    49→        global: args.GlobalOptions,\n    50→    ) CommandError!?CommandContext {\n    51→        var output = Output.init(allocator, .{\n    52→            .json = global.json,\n    53→            .toon = global.toon,\n    54→            .robot = global.robot,\n    55→            .quiet = global.quiet,\n    56→            .silent = global.silent,\n    57→            .no_color = global.no_color,\n    58→            .wrap = global.wrap,\n    59→            .stats = global.stats,\n    60→        });\n    61→\n    62→        const beads_dir_str = global.data_path orelse \".beads\";\n    63→        const beads_dir = allocator.dupe(u8, beads_dir_str) catch {\n    64→            return CommandError.OutOfMemory;\n    65→        };\n    66→        const issues_path = std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" }) catch {\n    67→            allocator.free(beads_dir);\n    68→            return CommandError.OutOfMemory;\n    69→        };\n    70→        const events_path = std.fs.path.join(allocator, &.{ beads_dir, \"events.jsonl\" }) catch {\n    71→            allocator.free(issues_path);\n    72→            allocator.free(beads_dir);\n    73→            return CommandError.OutOfMemory;\n    74→        };\n    75→\n    76→        std.fs.cwd().access(issues_path, .{}) catch |err| {\n    77→            if (err == error.FileNotFound) {\n    78→                outputErrorGeneric(&output, global.isStructuredOutput(), \"workspace not initialized. Run 'bz init' first.\") catch {};\n    79→                allocator.free(issues_path);\n    80→                allocator.free(events_path);\n    81→                allocator.free(beads_dir);\n    82→                return null;\n    83→            }\n    84→            outputErrorGeneric(&output, global.isStructuredOutput(), \"cannot access workspace\") catch {};\n    85→            allocator.free(issues_path);\n    86→            allocator.free(events_path);\n    87→            allocator.free(beads_dir);\n    88→            return CommandError.StorageError;\n    89→        };\n    90→\n    91→        var store = IssueStore.init(allocator, issues_path);\n    92→        var corruption_count: usize = 0;\n    93→        var corrupt_lines: []const usize = &.{};\n    94→\n    95→        // Use recovery mode: log and skip corrupt entries instead of failing\n    96→        const load_result = store.loadFromFileWithRecovery() catch |err| {\n    97→            if (err != error.FileNotFound) {\n    98→                outputErrorGeneric(&output, global.isStructuredOutput(), \"failed to load issues\") catch {};\n    99→                store.deinit();\n   100→                allocator.free(issues_path);\n   101→                allocator.free(events_path);\n   102→                allocator.free(beads_dir);\n   103→                return CommandError.StorageError;\n   104→            }\n   105→            // File not found is OK - empty workspace\n   106→            var event_store_empty = EventStore.init(allocator, events_path);\n   107→            event_store_empty.loadNextId() catch {};\n   108→            return CommandContext{\n   109→                .allocator = allocator,\n   110→                .output = output,\n   111→                .store = store,\n   112→                .event_store = event_store_empty,\n   113→                .beads_dir = beads_dir,\n   114→                .issues_path = issues_path,\n   115→                .events_path = events_path,\n   116→                .global = global,\n   117→                .corruption_count = 0,\n   118→                .corrupt_lines = &.{},\n   119→                .wal_entries_replayed = 0,\n   120→            };\n   121→        };\n   122→\n   123→        corruption_count = load_result.jsonl_corruption_count;\n   124→        corrupt_lines = load_result.jsonl_corrupt_lines;\n   125→\n   126→        // Replay WAL entries onto the store for consistency\n   127→        var wal_entries_replayed: usize = 0;\n   128→        wal_replay: {\n   129→            var wal_obj = storage.Wal.init(beads_dir, allocator) catch {\n   130→                break :wal_replay;\n   131→            };\n   132→            defer wal_obj.deinit();\n   133→\n   134→            var replay_stats = wal_obj.replay(&store) catch {\n   135→                break :wal_replay;\n   136→            };\n   137→            defer replay_stats.deinit(allocator);\n   138→            wal_entries_replayed = replay_stats.applied;\n   139→        }\n   140→\n   141→        // Warn user about corruption (unless quiet/silent mode)\n   142→        if (corruption_count > 0 and !global.quiet and !global.silent and !global.isStructuredOutput()) {\n   143→            output.print(\"warning: {d} corrupt entries skipped during load\\n\", .{corruption_count}) catch {};\n   144→            output.print(\"         Run 'bz doctor' for details, 'bz compact' to rebuild.\\n\", .{}) catch {};\n   145→        }\n   146→\n   147→        // Initialize event store and load next ID\n   148→        var event_store = EventStore.init(allocator, events_path);\n   149→        event_store.loadNextId() catch {}; // OK if events file doesn't exist\n   150→\n   151→        return CommandContext{\n   152→            .allocator = allocator,\n   153→            .output = output,\n   154→            .store = store,\n   155→            .event_store = event_store,\n   156→            .beads_dir = beads_dir,\n   157→            .issues_path = issues_path,\n   158→            .events_path = events_path,\n   159→            .global = global,\n   160→            .corruption_count = corruption_count,\n   161→            .corrupt_lines = corrupt_lines,\n   162→            .wal_entries_replayed = wal_entries_replayed,\n   163→        };\n   164→    }\n   165→\n   166→    /// Clean up resources.\n   167→    pub fn deinit(self: *CommandContext) void {\n   168→        self.store.deinit();\n   169→        self.allocator.free(self.beads_dir);\n   170→        self.allocator.free(self.issues_path);\n   171→        self.allocator.free(self.events_path);\n   172→        if (self.corrupt_lines.len > 0) {\n   173→            self.allocator.free(self.corrupt_lines);\n   174→        }\n   175→    }\n   176→\n   177→    /// Check if corruption was detected during load.\n   178→    pub fn hasCorruption(self: *const CommandContext) bool {\n   179→        return self.corruption_count > 0;\n   180→    }\n   181→\n   182→    /// Save the store to file if auto-flush is enabled.\n   183→    /// Note: For single-issue writes, prefer appendToWal() for better performance.\n   184→    pub fn saveIfAutoFlush(self: *CommandContext) CommandError!void {\n   185→        if (!self.global.no_auto_flush) {\n   186→            self.store.saveToFile() catch {\n   187→                outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to save issues\") catch {};\n   188→                return CommandError.StorageError;\n   189→            };\n   190→        }\n   191→    }\n   192→\n   193→    /// Append an issue to the WAL for fast persistence.\n   194→    /// Use this for single-issue creates/updates instead of saveToFile().\n   195→    pub fn appendToWal(self: *CommandContext, issue: @import(\"../models/issue.zig\").Issue, op: storage.WalOp) CommandError!void {\n   196→        if (self.global.no_auto_flush) return;\n   197→\n   198→        var wal_obj = storage.Wal.init(self.beads_dir, self.allocator) catch {\n   199→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to initialize WAL\") catch {};\n   200→            return CommandError.StorageError;\n   201→        };\n   202→        defer wal_obj.deinit();\n   203→\n   204→        wal_obj.appendEntry(.{\n   205→            .op = op,\n   206→            .ts = std.time.timestamp(),\n   207→            .id = issue.id,\n   208→            .data = issue,\n   209→        }) catch {\n   210→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to write to WAL\") catch {};\n   211→            return CommandError.StorageError;\n   212→        };\n   213→    }\n   214→\n   215→    /// Create a dependency graph from the store.\n   216→    pub fn createGraph(self: *CommandContext) DependencyGraph {\n   217→        return DependencyGraph.init(&self.store, self.allocator);\n   218→    }\n   219→\n   220→    /// Record an audit event. Silently ignores errors (audit is best-effort).\n   221→    pub fn recordEvent(self: *CommandContext, event: @import(\"../models/event.zig\").Event) void {\n   222→        _ = self.event_store.append(event) catch {};\n   223→    }\n   224→};\n   225→\n   226→/// Output a generic error message in the appropriate format.\n   227→pub fn outputErrorGeneric(output: *Output, json_mode: bool, message: []const u8) !void {\n   228→    if (json_mode) {\n   229→        try output.printJson(.{\n   230→            .success = false,\n   231→            .message = message,\n   232→        });\n   233→    } else {\n   234→        try output.err(\"{s}\", .{message});\n   235→    }\n   236→}\n   237→\n   238→/// Output an error with a specific result type for JSON mode.\n   239→pub fn outputErrorTyped(\n   240→    comptime T: type,\n   241→    output: *Output,\n   242→    json_mode: bool,\n   243→    message: []const u8,\n   244→) !void {\n   245→    if (json_mode) {\n   246→        const result = T{ .success = false, .message = message };\n   247→        try output.printJson(result);\n   248→    } else {\n   249→        try output.err(\"{s}\", .{message});\n   250→    }\n   251→}\n   252→\n   253→/// Output a \"not found\" error for an issue.\n   254→pub fn outputNotFoundError(\n   255→    comptime T: type,\n   256→    output: *Output,\n   257→    json_mode: bool,\n   258→    id: []const u8,\n   259→    allocator: std.mem.Allocator,\n   260→) !void {\n   261→    const msg = try std.fmt.allocPrint(allocator, \"issue not found: {s}\", .{id});\n   262→    defer allocator.free(msg);\n   263→    try outputErrorTyped(T, output, json_mode, msg);\n   264→}\n   265→\n   266→/// Initialize just the output without loading workspace.\n   267→/// Useful for commands that do their own workspace handling.\n   268→pub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Output {\n   269→    return Output.init(allocator, .{\n   270→        .json = global.json,\n   271→        .toon = global.toon,\n   272→        .robot = global.robot,\n   273→        .quiet = global.quiet,\n   274→        .silent = global.silent,\n   275→        .no_color = global.no_color,\n   276→        .wrap = global.wrap,\n   277→        .stats = global.stats,\n   278→    });\n   279→}\n   280→\n   281→/// Get the default actor name from environment.\n   282→pub fn getDefaultActor() ?[]const u8 {\n   283→    const builtin = @import(\"builtin\");\n   284→    if (builtin.os.tag == .windows) return null;\n   285→    return std.posix.getenv(\"USER\") orelse std.posix.getenv(\"USERNAME\");\n   286→}\n   287→\n   288→/// Read the ID prefix from config.yaml, defaulting to \"bd\".\n   289→pub fn getConfigPrefix(allocator: std.mem.Allocator, beads_dir: []const u8) ![]u8 {\n   290→    const config_path = try std.fs.path.join(allocator, &.{ beads_dir, \"config.yaml\" });\n   291→    defer allocator.free(config_path);\n   292→\n   293→    const file = std.fs.cwd().openFile(config_path, .{}) catch {\n   294→        return try allocator.dupe(u8, \"bd\");\n   295→    };\n   296→    defer file.close();\n   297→\n   298→    const content = file.readToEndAlloc(allocator, 4096) catch {\n   299→        return try allocator.dupe(u8, \"bd\");\n   300→    };\n   301→    defer allocator.free(content);\n   302→\n   303→    if (std.mem.indexOf(u8, content, \"prefix:\")) |prefix_pos| {\n   304→        const after_prefix = content[prefix_pos + 7 ..];\n   305→        var i: usize = 0;\n   306→        while (i < after_prefix.len and (after_prefix[i] == ' ' or after_prefix[i] == '\\t')) {\n   307→            i += 1;\n   308→        }\n   309→\n   310→        if (i < after_prefix.len) {\n   311→            if (after_prefix[i] == '\"') {\n   312→                i += 1;\n   313→                const start = i;\n   314→                while (i < after_prefix.len and after_prefix[i] != '\"' and after_prefix[i] != '\\n') {\n   315→                    i += 1;\n   316→                }\n   317→                if (i > start) {\n   318→                    return try allocator.dupe(u8, after_prefix[start..i]);\n   319→                }\n   320→            } else {\n   321→                const start = i;\n   322→                while (i < after_prefix.len and after_prefix[i] != '\\n' and after_prefix[i] != ' ' and after_prefix[i] != '\\t') {\n   323→                    i += 1;\n   324→                }\n   325→                if (i > start) {\n   326→                    return try allocator.dupe(u8, after_prefix[start..i]);\n   327→                }\n   328→            }\n   329→        }\n   330→    }\n   331→\n   332→    return try allocator.dupe(u8, \"bd\");\n   333→}\n   334→\n   335→// --- Tests ---\n   336→\n   337→test \"CommandContext returns null for uninitialized workspace\" {\n   338→    const allocator = std.testing.allocator;\n   339→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   340→\n   341→    const ctx = try CommandContext.init(allocator, global);\n   342→    try std.testing.expect(ctx == null);\n   343→}\n   344→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4576d5bb-7525-4ca9-9432-00cb09c58e2b"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (30452 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01AF2n1T2aAhCWPXcZrnUibN"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b5579f3a-5c67-4bc8-b4b1-0f747f378f85","tool_use_result":"Error: File content (30452 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FwR1HNAQzp9w6LZYZTcuRV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X45s7aQCb81sghr4yZVHwH","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4878,"cache_creation_input_tokens":8089,"cache_read_input_tokens":13992,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8089},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ac9dced1-8beb-44cb-a665-ef18b8f61e66"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X45s7aQCb81sghr4yZVHwH","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    robot: bool = false, // Line-oriented machine-readable output for scripting\n    13→    quiet: bool = false,\n    14→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    15→    verbose: u8 = 0,\n    16→    no_color: bool = false,\n    17→    wrap: bool = false, // Wrap long lines in plain text output\n    18→    stats: bool = false, // Show token savings stats for TOON output\n    19→    data_path: ?[]const u8 = null,\n    20→    actor: ?[]const u8 = null,\n    21→    lock_timeout: u32 = 5000,\n    22→    no_auto_flush: bool = false,\n    23→    no_auto_import: bool = false,\n    24→\n    25→    /// Returns true if structured output (JSON or TOON) is enabled.\n    26→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    27→        return self.json or self.toon;\n    28→    }\n    29→\n    30→    /// Returns true if any machine-readable output is enabled.\n    31→    pub fn isMachineOutput(self: GlobalOptions) bool {\n    32→        return self.json or self.toon or self.robot;\n    33→    }\n    34→};\n    35→\n    36→/// All available subcommands.\n    37→pub const Command = union(enum) {\n    38→    // Workspace\n    39→    init: InitArgs,\n    40→    info: void,\n    41→    stats: void,\n    42→    doctor: void,\n    43→    config: ConfigArgs,\n    44→    orphans: OrphansArgs,\n    45→    lint: LintArgs,\n    46→    where: void,\n    47→\n    48→    // Issue CRUD\n    49→    create: CreateArgs,\n    50→    q: QuickArgs,\n    51→    show: ShowArgs,\n    52→    update: UpdateArgs,\n    53→    close: CloseArgs,\n    54→    reopen: ReopenArgs,\n    55→    delete: DeleteArgs,\n    56→\n    57→    // Batch Operations\n    58→    add_batch: AddBatchArgs,\n    59→    import_cmd: ImportArgs,\n    60→\n    61→    // Query\n    62→    list: ListArgs,\n    63→    ready: ReadyArgs,\n    64→    blocked: BlockedArgs,\n    65→    search: SearchArgs,\n    66→    stale: StaleArgs,\n    67→    count: CountArgs,\n    68→    defer_cmd: DeferArgs,\n    69→    undefer: UndeferArgs,\n    70→\n    71→    // Dependencies\n    72→    dep: DepArgs,\n    73→    graph: GraphArgs,\n    74→\n    75→    // Epics\n    76→    epic: EpicArgs,\n    77→\n    78→    // Labels\n    79→    label: LabelArgs,\n    80→\n    81→    // Comments\n    82→    comments: CommentsArgs,\n    83→\n    84→    // Audit\n    85→    history: HistoryArgs,\n    86→    audit: AuditArgs,\n    87→\n    88→    // Changelog\n    89→    changelog: ChangelogArgs,\n    90→\n    91→    // Sync\n    92→    sync: SyncArgs,\n    93→\n    94→    // System\n    95→    version: void,\n    96→    schema: void,\n    97→    completions: CompletionsArgs,\n    98→    metrics: MetricsArgs,\n    99→\n   100→    // Saved Queries\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6ab076d9-68fe-47b3-9e16-283c71ad155a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FwR1HNAQzp9w6LZYZTcuRV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CjyFwkRzntZtddfmKynwTG","name":"Grep","input":{"pattern":"SyncArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4878,"cache_creation_input_tokens":8089,"cache_read_input_tokens":13992,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8089},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"88c40de1-385a-4698-957b-81993b34dc82"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CjyFwkRzntZtddfmKynwTG","type":"tool_result","content":"82-    comments: CommentsArgs,\n83-\n84-    // Audit\n85-    history: HistoryArgs,\n86-    audit: AuditArgs,\n87-\n88-    // Changelog\n89-    changelog: ChangelogArgs,\n90-\n91-    // Sync\n92:    sync: SyncArgs,\n93-\n94-    // System\n95-    version: void,\n96-    schema: void,\n97-    completions: CompletionsArgs,\n98-    metrics: MetricsArgs,\n99-\n100-    // Saved Queries\n101-    query: QueryArgs,\n102-\n--\n478-\n479-/// Changelog command arguments.\n480-pub const ChangelogArgs = struct {\n481-    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n482-    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n483-    limit: ?u32 = null,\n484-    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n485-};\n486-\n487-/// Sync command arguments.\n488:pub const SyncArgs = struct {\n489-    flush_only: bool = false,\n490-    import_only: bool = false,\n491-    merge: bool = false,\n492-    status: bool = false,\n493-    manifest: bool = false,\n494-};\n495-\n496-/// Shell completion types.\n497-pub const Shell = enum {\n498-    bash,\n--\n854-            return .{ .audit = try self.parseAuditArgs() };\n855-        }\n856-\n857-        // Changelog\n858-        if (std.mem.eql(u8, cmd, \"changelog\")) {\n859-            return .{ .changelog = try self.parseChangelogArgs() };\n860-        }\n861-\n862-        // Sync\n863-        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n864:            return .{ .sync = try self.parseSyncArgs() };\n865-        }\n866-\n867-        // System\n868-        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n869-            return .{ .version = {} };\n870-        }\n871-        if (std.mem.eql(u8, cmd, \"schema\")) {\n872-            return .{ .schema = {} };\n873-        }\n874-        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n--\n1507-                result.until = self.next() orelse return error.MissingFlagValue;\n1508-            } else if (try self.parseLimitFlag()) |limit| {\n1509-                result.limit = limit;\n1510-            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n1511-                result.group_by = self.next() orelse return error.MissingFlagValue;\n1512-            } else break;\n1513-        }\n1514-        return result;\n1515-    }\n1516-\n1517:    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n1518:        var result = SyncArgs{};\n1519-        while (self.hasNext()) {\n1520-            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n1521-                result.flush_only = true;\n1522-            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n1523-                result.import_only = true;\n1524-            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n1525-                result.merge = true;\n1526-            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n1527-                result.status = true;\n1528-            } else if (self.consumeFlag(null, \"--manifest\")) {"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a6975de4-74cd-4d31-8f6a-caff5dc3eecd"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GNkHQmAG2QFgwATpoK8xWc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0166nUrP2qbmdWSSRHSQ7GvQ","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1517,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7505,"cache_read_input_tokens":22081,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7505},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f9c9088c-0b14-42ee-905f-f27feef3da9e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0166nUrP2qbmdWSSRHSQ7GvQ","type":"tool_result","content":"  1517→    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n  1518→        var result = SyncArgs{};\n  1519→        while (self.hasNext()) {\n  1520→            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n  1521→                result.flush_only = true;\n  1522→            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n  1523→                result.import_only = true;\n  1524→            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n  1525→                result.merge = true;\n  1526→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n  1527→                result.status = true;\n  1528→            } else if (self.consumeFlag(null, \"--manifest\")) {\n  1529→                result.manifest = true;\n  1530→            } else break;\n  1531→        }\n  1532→        return result;\n  1533→    }\n  1534→\n  1535→    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n  1536→        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n  1537→        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n  1538→        return .{ .shell = shell };\n  1539→    }\n  1540→\n  1541→    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n  1542→        var result = MetricsArgs{};\n  1543→        while (self.hasNext()) {\n  1544→            if (self.consumeFlag(\"-r\", \"--reset\")) {\n  1545→                result.reset = true;\n  1546→            } else break;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"73e337fc-6d4a-4d4c-a141-78775b896c3a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GNkHQmAG2QFgwATpoK8xWc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018QqK5QmEwKFw1zS3NcnHAN","name":"Grep","input":{"pattern":"--manifest","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7505,"cache_read_input_tokens":22081,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7505},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"df8f2c6c-fb90-4da3-910c-e91197b1e92d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018QqK5QmEwKFw1zS3NcnHAN","type":"tool_result","content":"1523-                result.import_only = true;\n1524-            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n1525-                result.merge = true;\n1526-            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n1527-                result.status = true;\n1528:            } else if (self.consumeFlag(null, \"--manifest\")) {\n1529-                result.manifest = true;\n1530-            } else break;\n1531-        }\n1532-        return result;\n1533-    }"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"93eac327-ba72-489b-b95c-5789faa59c16"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JvEmP9wRycHpiaeZksGmGL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Lf6qntHoLkLDvVtyBefj7","name":"Grep","input":{"pattern":"pub const \\w+Args = struct \\{[\\s\\S]*?\\};","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":3,"head_limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1018,"cache_read_input_tokens":29586,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1018},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3ac656c8-7591-4bb1-bb47-690613c74fee"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Lf6qntHoLkLDvVtyBefj7","type":"tool_result","content":"No matches found\n\n[Showing results with pagination = limit: 50, offset: 0]"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"af9f211d-020b-4bab-9602-71e7745102df"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KM6JSBqWX4CPkYVzAwf3Kw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PtQNq4vVFEakKn8PAc6msq","name":"Grep","input":{"pattern":"pub const (ListArgs|DeleteArgs|UpdateArgs)","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":8}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":262,"cache_read_input_tokens":30604,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b2599ab3-e871-4ac9-863c-ddbf9f4e4c5e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PtQNq4vVFEakKn8PAc6msq","type":"tool_result","content":"139-/// Show command arguments.\n140-pub const ShowArgs = struct {\n141-    id: []const u8,\n142-    with_comments: bool = true,\n143-    with_history: bool = false,\n144-};\n145-\n146-/// Update command arguments.\n147:pub const UpdateArgs = struct {\n148-    id: []const u8,\n149-    title: ?[]const u8 = null,\n150-    description: ?[]const u8 = null,\n151-    issue_type: ?[]const u8 = null,\n152-    priority: ?[]const u8 = null,\n153-    assignee: ?[]const u8 = null,\n154-    owner: ?[]const u8 = null,\n155-    design: ?[]const u8 = null,\n--\n170-};\n171-\n172-/// Reopen command arguments.\n173-pub const ReopenArgs = struct {\n174-    id: []const u8,\n175-};\n176-\n177-/// Delete command arguments.\n178:pub const DeleteArgs = struct {\n179-    /// Single issue ID to delete (mutually exclusive with from_file).\n180-    id: ?[]const u8 = null,\n181-    /// Path to file containing issue IDs to delete (one per line).\n182-    from_file: ?[]const u8 = null,\n183-    /// Delete issue and all its dependents recursively.\n184-    cascade: bool = false,\n185-    /// Prune from database immediately instead of marking as tombstone.\n186-    hard: bool = false,\n--\n238-        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n239-        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n240-        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n241-        return null;\n242-    }\n243-};\n244-\n245-/// List command arguments.\n246:pub const ListArgs = struct {\n247-    status: ?[]const u8 = null,\n248-    priority: ?[]const u8 = null,\n249-    priority_min: ?[]const u8 = null,\n250-    priority_max: ?[]const u8 = null,\n251-    issue_type: ?[]const u8 = null,\n252-    assignee: ?[]const u8 = null,\n253-    label: ?[]const u8 = null,\n254-    label_any: []const []const u8 = &[_][]const u8{},"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f947f7a7-789a-4c5f-b3b8-096c79d384a1"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01W6zwHrcv3Q9CqEZUobhTEm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016aKtGpJdsc9rirWy368JBT","name":"Bash","input":{"command":"grep -n \"consumeFlag\" /home/hotschmoe/beads_zig/src/cli/args.zig | head -30","description":"Show consumeFlag usage patterns"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":872,"cache_read_input_tokens":30866,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":872},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"88e5641b-5ce3-4d6c-8e0f-67631807881a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016aKtGpJdsc9rirWy368JBT","type":"tool_result","content":"902:            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n918:            if (self.consumeFlag(\"-d\", \"--description\")) {\n920:            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n922:            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n924:            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n926:            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n928:            } else if (self.consumeFlag(null, \"--design\")) {\n930:            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n932:            } else if (self.consumeFlag(null, \"--external-ref\")) {\n934:            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n936:            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n938:            } else if (self.consumeFlag(null, \"--due\")) {\n940:            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n943:            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n970:            if (self.consumeFlag(\"-p\", \"--priority\")) {\n989:            if (self.consumeFlag(null, \"--no-comments\")) {\n991:            } else if (self.consumeFlag(null, \"--with-history\")) {\n1010:            if (self.consumeFlag(null, \"--title\")) {\n1012:            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n1014:            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n1016:            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n1018:            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n1020:            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n1022:            } else if (self.consumeFlag(null, \"--design\")) {\n1024:            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n1026:            } else if (self.consumeFlag(null, \"--external-ref\")) {\n1028:            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n1030:            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n1033:            } else if (self.consumeFlag(null, \"--claim\")) {\n1052:            if (self.consumeFlag(\"-r\", \"--reason\")) {","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"094cdd04-1524-4a2b-b82b-237c7f328749"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01LK75gRJ89RGWmMAp7eJxri","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DsFgBso32ejcDcWou7tfK2","name":"Grep","input":{"pattern":"fn consumeFlag","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":794,"cache_read_input_tokens":31738,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":794},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c5dc2ace-2967-42a4-8fea-0b57e3df3d41"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DsFgBso32ejcDcWou7tfK2","type":"tool_result","content":"1655-    fn next(self: *Self) ?[]const u8 {\n1656-        if (self.index >= self.args.len) return null;\n1657-        const arg = self.args[self.index];\n1658-        self.index += 1;\n1659-        return arg;\n1660-    }\n1661-\n1662-    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n1663-    fn skip(self: *Self) void {\n1664-        if (self.index < self.args.len) {\n1665-            self.index += 1;\n1666-        }\n1667-    }\n1668-\n1669-    /// Check if current arg matches a flag, and if so consume it and return true.\n1670:    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n1671-        const arg = self.peek() orelse return false;\n1672-        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n1673-            self.skip();\n1674-            return true;\n1675-        }\n1676-        return false;\n1677-    }\n1678-\n1679-    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n1680-    fn consumeU32(self: *Self) ParseError!?u32 {\n1681-        const val = self.next() orelse return error.MissingFlagValue;\n1682-        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n1683-    }\n1684-\n1685-    /// Parse an optional --limit/-n flag, returning the value if present."}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5d8365f4-70a7-4228-9500-bd208712b247"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ky3cYtpy99mUBs1JjkhhMm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011Z8zKNpVf7cn316sd4ALgG","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig/src/cli -name \"*.zig\" -type f | xargs grep -l \"policy\\|strategy\\|mode\" | head -5","description":"Find CLI commands that might use policy-like flags"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":757,"cache_read_input_tokens":32532,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":757},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f328cce6-3cb1-48ef-878b-c1c2e96f2edb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011Z8zKNpVf7cn316sd4ALgG","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/close.zig\n/home/hotschmoe/beads_zig/src/cli/update.zig\n/home/hotschmoe/beads_zig/src/cli/delete.zig\n/home/hotschmoe/beads_zig/src/cli/common.zig\n/home/hotschmoe/beads_zig/src/cli/schema.zig","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e571a903-d885-4c8f-844a-e04b48aaa76a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DmNfbsu8RSy2Up2ZtzogJt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CA5CbQxLWYuiQPwS13uKoH","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/delete.zig","limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":306,"cache_read_input_tokens":33289,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":306},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"eaa266d9-ab39-4f28-b731-838436db548d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CA5CbQxLWYuiQPwS13uKoH","type":"tool_result","content":"     1→//! Delete command for beads_zig.\n     2→//!\n     3→//! `bz delete <id>` - Soft delete an issue (set status to tombstone)\n     4→//! `bz delete --from-file <path>` - Delete multiple issues from a file\n     5→//! `bz delete <id> --cascade` - Delete issue and all its dependents\n     6→//! `bz delete <id> --hard` - Permanently remove from database\n     7→//! `bz delete <id> --dry-run` - Preview what would be deleted\n     8→//!\n     9→//! By default, this is a soft delete - the issue is marked as tombstone but remains\n    10→//! in the database for audit purposes. Use `bz list --all` to see tombstoned issues.\n    11→\n    12→const std = @import(\"std\");\n    13→const models = @import(\"../models/mod.zig\");\n    14→const storage = @import(\"../storage/mod.zig\");\n    15→const common = @import(\"common.zig\");\n    16→const args = @import(\"args.zig\");\n    17→const test_util = @import(\"../test_util.zig\");\n    18→\n    19→const Status = models.Status;\n    20→const Issue = models.Issue;\n    21→const IssueStore = common.IssueStore;\n    22→const CommandContext = common.CommandContext;\n    23→const DependencyGraph = common.DependencyGraph;\n    24→const Wal = storage.Wal;\n    25→const Output = @import(\"../output/mod.zig\").Output;\n    26→\n    27→/// Output a list of IDs, one per line (used for quiet/robot output).\n    28→fn outputIdList(output: *Output, ids: []const []const u8) !void {\n    29→    for (ids) |id| {\n    30→        try output.raw(id);\n    31→        try output.raw(\"\\n\");\n    32→    }\n    33→}\n    34→\n    35→/// Create a slice of IDs from the ArrayList (for JSON output).\n    36→fn createIdSlice(allocator: std.mem.Allocator, ids: std.ArrayListUnmanaged([]const u8)) ![]const []const u8 {\n    37→    const id_slice = try allocator.alloc([]const u8, ids.items.len);\n    38→    for (ids.items, 0..) |id, i| {\n    39→        id_slice[i] = id;\n    40→    }\n    41→    return id_slice;\n    42→}\n    43→\n    44→/// Truncate the WAL after hard delete to prevent deleted issues from reappearing.\n    45→fn truncateWalIfNeeded(hard: bool, deleted_count: usize, beads_dir: []const u8, allocator: std.mem.Allocator) void {\n    46→    if (!hard or deleted_count == 0) return;\n    47→\n    48→    var wal_obj = Wal.init(beads_dir, allocator) catch return;\n    49→    defer wal_obj.deinit();\n    50→    wal_obj.truncate() catch {};\n    51→}\n    52→\n    53→pub const DeleteError = error{\n    54→    WorkspaceNotInitialized,\n    55→    IssueNotFound,\n    56→    AlreadyDeleted,\n    57→    StorageError,\n    58→    OutOfMemory,\n    59→    FileReadError,\n    60→    InvalidInput,\n    61→};\n    62→\n    63→pub const DeleteResult = struct {\n    64→    success: bool,\n    65→    ids: ?[]const []const u8 = null,\n    66→    deleted_count: ?usize = null,\n    67→    message: ?[]const u8 = null,\n    68→    dry_run: bool = false,\n    69→};\n    70→\n    71→pub fn run(\n    72→    delete_args: args.DeleteArgs,\n    73→    global: args.GlobalOptions,\n    74→    allocator: std.mem.Allocator,\n    75→) !void {\n    76→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    77→        return DeleteError.WorkspaceNotInitialized;\n    78→    };\n    79→    defer ctx.deinit();\n    80→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"38320ac5-397f-44df-83e2-16c4391cf4db"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DmNfbsu8RSy2Up2ZtzogJt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013rzX5NvpfMmQksJ5LEF5Fs","name":"Bash","input":{"command":"grep -A 30 \"fn parseDeleteArgs\" /home/hotschmoe/beads_zig/src/cli/args.zig","description":"Show how delete command parses its args with cascade/hard flags"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":306,"cache_read_input_tokens":33289,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":306},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2cfcf39d-d3f9-42ac-869c-d8fbedaee456"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013rzX5NvpfMmQksJ5LEF5Fs","type":"tool_result","content":"    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4172376d-6d96-4c94-bca1-d44707c4aa43"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Awmg5HHwMbqJYa8My8ssEJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B9VXKTfiRvQRiex3wq2qw2","name":"Bash","input":{"command":"grep -n \"pub const.*= enum\" /home/hotschmoe/beads_zig/src/cli/args.zig | head -20","description":"Find enum definitions in args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1832,"cache_read_input_tokens":33595,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1832},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e78f24ec-69a9-4f7e-aff6-d8078d04976b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B9VXKTfiRvQRiex3wq2qw2","type":"tool_result","content":"199:pub const BatchFormat = enum {\n220:pub const OutputFormat = enum {\n232:pub const SortField = enum {\n355:pub const DepDirection = enum {\n369:pub const TreeFormat = enum {\n409:pub const GraphFormat = enum {\n497:pub const Shell = enum {","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"fb04a8c6-b83e-4112-b36a-be6a1d5528c6"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HNFRPXR4wmkzzzMaDL6uAa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KzFT2x3swan6W8NGPF4Cte","name":"Grep","input":{"pattern":"BatchFormat|AddBatchArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":10,"head_limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":252,"cache_read_input_tokens":35427,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":252},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f8f1cfc2-82bf-4d63-8da5-1c06314de5ab"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KzFT2x3swan6W8NGPF4Cte","type":"tool_result","content":"48-    // Issue CRUD\n49-    create: CreateArgs,\n50-    q: QuickArgs,\n51-    show: ShowArgs,\n52-    update: UpdateArgs,\n53-    close: CloseArgs,\n54-    reopen: ReopenArgs,\n55-    delete: DeleteArgs,\n56-\n57-    // Batch Operations\n58:    add_batch: AddBatchArgs,\n59-    import_cmd: ImportArgs,\n60-\n61-    // Query\n62-    list: ListArgs,\n63-    ready: ReadyArgs,\n64-    blocked: BlockedArgs,\n65-    search: SearchArgs,\n66-    stale: StaleArgs,\n67-    count: CountArgs,\n68-    defer_cmd: DeferArgs,\n--\n183-    /// Delete issue and all its dependents recursively.\n184-    cascade: bool = false,\n185-    /// Prune from database immediately instead of marking as tombstone.\n186-    hard: bool = false,\n187-    /// Preview what would be deleted without making changes.\n188-    dry_run: bool = false,\n189-};\n190-\n191-/// Add-batch command arguments.\n192-/// Creates multiple issues from stdin or a file with single lock acquisition.\n193:pub const AddBatchArgs = struct {\n194-    file: ?[]const u8 = null, // Read from file instead of stdin\n195:    format: BatchFormat = .titles, // Input format\n196-};\n197-\n198-/// Batch input format.\n199:pub const BatchFormat = enum {\n200-    titles, // One title per line\n201-    jsonl, // Full JSONL format (one issue per line)\n202-\n203:    pub fn fromString(s: []const u8) ?BatchFormat {\n204-        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n205-        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n206-        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n207-        return null;\n208-    }\n209-};\n210-\n211-/// Import command arguments.\n212-/// Imports issues from a JSONL file with single lock acquisition.\n213-pub const ImportArgs = struct {\n--\n784-        }\n785-        if (std.mem.eql(u8, cmd, \"reopen\")) {\n786-            return .{ .reopen = try self.parseReopenArgs() };\n787-        }\n788-        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n789-            return .{ .delete = try self.parseDeleteArgs() };\n\n[Showing results with pagination = limit: 60, offset: 0]"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"31bb8c3c-1584-4bf5-9e99-41458e0c4960"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DRyxnrZs9SGqezgobTh8EX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017XAkooPGmPRpFyCSXDg4yA","name":"Bash","input":{"command":"grep -A 20 \"fn parseAddBatchArgs\" /home/hotschmoe/beads_zig/src/cli/args.zig","description":"Show add_batch args parsing with enum-based format"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":920,"cache_read_input_tokens":35679,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":920},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6325db39-7dfb-4a03-a9c7-b020c1794800"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017XAkooPGmPRpFyCSXDg4yA","type":"tool_result","content":"    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"9c909b37-2443-4fcd-a626-445a53cc5756"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TukJyk49ZCDzsqzCsgbsDM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WSbAkeDmQTJH465XMnyPdu","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":543,"cache_read_input_tokens":36599,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":543},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"0ab96600-5695-49f5-804c-32cdd17a8fe5"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"EISDIR: illegal operation on a directory, read","is_error":true,"tool_use_id":"toolu_01WSbAkeDmQTJH465XMnyPdu"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"acbe108e-0a17-4f84-bdca-231641d68cbd","tool_use_result":"Error: EISDIR: illegal operation on a directory, read"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Tv1hXP4N4Yv2B8zqmmkG4L","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014VvQE47oNokjPDr49yUXGx","name":"Bash","input":{"command":"grep -A 40 '\"sync\"' /home/hotschmoe/beads_zig/src/cli/help.zig | head -60","description":"Find sync command help text"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":148,"cache_read_input_tokens":37142,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":148},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c9965f60-d16f-4c1b-8504-eba16af5ddb2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014VvQE47oNokjPDr49yUXGx","type":"tool_result","content":"        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },\n    },\n    .{\n        .name = \"orphans\",\n        .summary = \"Find issues with missing parent references\",\n        .usage = \"bz orphans [--limit N] [--hierarchy-only] [--deps-only]\",\n        .description = \"Identifies issues that reference non-existent parent issues or dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results to show\" },\n            .{ .short = null, .long = \"--hierarchy-only\", .description = \"Only check hierarchical parent refs\" },\n            .{ .short = null, .long = \"--deps-only\", .description = \"Only check dependency refs\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz orphans\", .description = \"Find all orphaned references\" },\n            .{ .command = \"bz orphans --limit 10\", .description = \"Show at most 10 orphans\" },\n        },\n    },\n    .{\n        .name = \"lint\",\n        .summary = \"Validate database consistency\",\n        .usage = \"bz lint [--limit N]\",\n        .description = \"Checks for data quality issues: empty titles, invalid priorities, \" ++\n--\n        .see_also = &[_][]const u8{ \"sync\", \"add-batch\" },\n    },\n\n    // Query commands\n    .{\n        .name = \"list\",\n        .aliases = &[_][]const u8{\"ls\"},\n        .summary = \"List issues with filters\",\n        .usage = \"bz list [options]\",\n        .description = \"Lists issues matching optional filters. By default shows only open issues. \" ++\n            \"Use --all to include closed/deleted issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"Filter by status\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Filter by priority\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Filter by issue type\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Filter by assignee\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Filter by label\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },","is_error":false}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7b86ff87-f75e-4451-b52d-ad599b18edd7"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01ALmEHQpRw4Cc8XJYut6NK1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UV895FW7dTKao4WuZ5p9j8","name":"Grep","input":{"pattern":"pub const CreateArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1243,"cache_read_input_tokens":37290,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1243},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4c6f150b-c8e4-4381-b3ed-09ebd16d787b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UV895FW7dTKao4WuZ5p9j8","type":"tool_result","content":"96-    schema: void,\n97-    completions: CompletionsArgs,\n98-    metrics: MetricsArgs,\n99-\n100-    // Saved Queries\n101-    query: QueryArgs,\n102-\n103-    // Self-upgrade\n104-    upgrade: UpgradeArgs,\n105-\n106-    // Help\n107-    help: HelpArgs,\n108-};\n109-\n110-/// Init command arguments.\n111-pub const InitArgs = struct {\n112-    prefix: []const u8 = \"bd\",\n113-};\n114-\n115-/// Create command arguments.\n116:pub const CreateArgs = struct {\n117-    title: []const u8,\n118-    description: ?[]const u8 = null,\n119-    issue_type: ?[]const u8 = null,\n120-    priority: ?[]const u8 = null,\n121-    assignee: ?[]const u8 = null,\n122-    owner: ?[]const u8 = null,\n123-    design: ?[]const u8 = null,\n124-    acceptance_criteria: ?[]const u8 = null,\n125-    external_ref: ?[]const u8 = null,\n126-    labels: []const []const u8 = &[_][]const u8{},\n127-    deps: []const []const u8 = &[_][]const u8{},\n128-    due: ?[]const u8 = null,\n129-    estimate: ?i32 = null,\n130-    ephemeral: bool = false, // Local-only, not written to JSONL\n131-};\n132-\n133-/// Quick capture command arguments.\n134-pub const QuickArgs = struct {\n135-    title: []const u8,\n136-    priority: ?[]const u8 = null,"}]},"parent_tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ee79247f-55e0-4ebb-94df-186eeecc9d89"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U5Fq6cSd5FS6G647W6xoj5","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me create a comprehensive report:\n\n## Exploration Report: beads_zig Sync Command & Flag Architecture\n\nI've completed a thorough exploration of the beads_zig codebase focusing on the sync command implementation and flag handling patterns. Here are my findings:\n\n---\n\n### 1. Current Sync Command Implementation\n\n**File:** `/home/hotschmoe/beads_zig/src/cli/sync.zig` (514 lines)\n\n**Current SyncArgs Structure** (lines 488-494):\n```zig\npub const SyncArgs = struct {\n    flush_only: bool = false,      // Export only\n    import_only: bool = false,     // Import only\n    merge: bool = false,           // 3-way merge mode\n    status: bool = false,          // Show status without changes\n    manifest: bool = false,        // Write manifest.json during export\n};\n```\n\n**Current Sync Modes:**\n- **Bidirectional** (default): `run()` checks dirty flag and exports if needed\n- **Flush/Export**: `--flush-only` - writes all issues to JSONL\n- **Import**: `--import-only` - replaces in-memory state from JSONL\n- **Merge**: `-m/--merge` - 3-way merge with remote JSONL based on `updated_at` timestamps\n- **Status**: `-s/--status` - reports counts without making changes\n- **Manifest**: `--manifest` - writes metadata JSON during flush\n\n**Current Command Dispatch** (lines 57-67):\n```zig\nif (sync_args.status) {\n    try runStatus(&ctx, structured_output, global.quiet, allocator);\n} else if (sync_args.flush_only) {\n    try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n} else if (sync_args.import_only) {\n    try runImport(&ctx, structured_output, global.quiet, allocator);\n} else if (sync_args.merge) {\n    try runMerge(&ctx, structured_output, global.quiet, allocator);\n} else {\n    try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n}\n```\n\n---\n\n### 2. How Flags Are Parsed in args.zig\n\n**File:** `/home/hotschmoe/beads_zig/src/cli/args.zig` (1770+ lines)\n\n**parseSyncArgs Function** (lines 1517-1533):\n```zig\nfn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n    var result = SyncArgs{};\n    while (self.hasNext()) {\n        if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n            result.flush_only = true;\n        } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n            result.import_only = true;\n        } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n            result.merge = true;\n        } else if (self.consumeFlag(\"-s\", \"--status\")) {\n            result.status = true;\n        } else if (self.consumeFlag(null, \"--manifest\")) {\n            result.manifest = true;\n        } else break;\n    }\n    return result;\n}\n```\n\n**consumeFlag Helper** (lines 1670-1677):\n```zig\nfn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n    const arg = self.peek() orelse return false;\n    if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n        self.skip();\n        return true;\n    }\n    return false;\n}\n```\n\n**Key Pattern:**\n- Flags accept both short and long forms: `consumeFlag(\"--export\", \"--flush-only\")`\n- Pass `null` for short form if only long form exists\n- Loop consumes flags until no more recognized flags found\n- Boolean flags set struct fields to `true` when consumed\n\n---\n\n### 3. Flag Definition Patterns in Help System\n\n**File:** `/home/hotschmoe/beads_zig/src/cli/help.zig`\n\nCurrent sync help output shows:\n```\n.flags = &[_]FlagHelp{\n    .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n    .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n    .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n    .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n    .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n},\n```\n\n---\n\n### 4. Related Commands with Similar Patterns\n\n**Delete Command** - Multiple boolean policy-like flags:\n- File: `/home/hotschmoe/beads_zig/src/cli/delete.zig`\n- Args: `cascade` (bool), `hard` (bool), `dry_run` (bool)\n- Pattern: Boolean flags can be combined\n\n**Enum-Based Policy Example - Add Batch Command:**\n- File: `/home/hotschmoe/beads_zig/src/cli/args.zig` (lines 193-209)\n- Uses enum for format choices:\n\n```zig\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null,\n    format: BatchFormat = .titles,  // Default enum value\n};\n\npub const BatchFormat = enum {\n    titles,  // One title per line\n    jsonl,   // Full JSONL format\n    \n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n```\n\n**Parsing enum-based flags** (lines 1130-1143):\n```zig\nfn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n    var result = AddBatchArgs{};\n    while (self.hasNext()) {\n        if (self.consumeFlag(\"-f\", \"--file\")) {\n            result.file = self.next() orelse return error.MissingFlagValue;\n        } else if (self.consumeFlag(null, \"--format\")) {\n            const fmt_str = self.next() orelse return error.MissingFlagValue;\n            result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n        } else if (self.peekPositional()) |_| {\n            if (result.file == null) {\n                result.file = self.next().?;\n            } else break;\n        } else break;\n    }\n    return result;\n}\n```\n\n---\n\n### 5. Other Commands with Multiple Optional String Fields\n\n**Create Command** - Extensive optional field pattern:\n- File: `/home/hotschmoe/beads_zig/src/cli/args.zig` (lines 116-131)\n\n```zig\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false,\n};\n```\n\n---\n\n### 6. Key Architectural Insights\n\n**Boolean Flag Approach (Current):**\n- Mutually exclusive modes checked with if/else chains\n- Clear and explicit\n- No ambiguity about which mode is active\n- Works well for small number of modes\n\n**Enum-Based Approach (Alternative):**\n- Could use enum like `SyncMode = enum { bidirectional, flush, import, merge, status }`\n- Enforces single mode selection at type level\n- Cleaner dispatch logic\n- Better for policy-style flags\n\n**Pattern for Multiple Optional Parameters:**\n- Use `?[]const u8 = null` for optional string parameters\n- Set to `null` by default\n- Check in command handler if present\n\n---\n\n### 7. File Paths Summary\n\n| File | Purpose | Key Structures |\n|------|---------|-----------------|\n| `/home/hotschmoe/beads_zig/src/cli/sync.zig` | Sync implementation | `SyncArgs`, `SyncResult`, 5 run functions |\n| `/home/hotschmoe/beads_zig/src/cli/args.zig` | Argument parsing | `parseSyncArgs()`, `consumeFlag()` |\n| `/home/hotschmoe/beads_zig/src/cli/common.zig` | Shared utilities | `CommandContext`, error handling |\n| `/home/hotschmoe/beads_zig/src/cli/help.zig` | Help system | Sync flag definitions |\n| `/home/hotschmoe/beads_zig/src/cli/delete.zig` | Delete impl (reference) | Similar boolean policy flags |\n\n---\n\n### 8. Recommended Patterns for New Features\n\n**For Conflict Resolution Policy:**\n1. **Enum approach** (recommended for mutually-exclusive policies):\n   ```zig\n   pub const ConflictPolicy = enum {\n       keep_local,     // or first\n       keep_remote,    // or remote\n       keep_newest,    // timestamp-based\n       manual,         // mark for manual resolution\n       \n       pub fn fromString(s: []const u8) ?ConflictPolicy { ... }\n   };\n   \n   pub const SyncArgs = struct {\n       flush_only: bool = false,\n       import_only: bool = false,\n       merge: bool = false,\n       status: bool = false,\n       manifest: bool = false,\n       conflict_policy: ConflictPolicy = .keep_newest,  // Add here\n   };\n   ```\n\n2. **Parsing in args.zig**:\n   ```zig\n   } else if (self.consumeFlag(null, \"--conflict\")) {\n       const policy_str = self.next() orelse return error.MissingFlagValue;\n       result.conflict_policy = ConflictPolicy.fromString(policy_str) \n           orelse return error.InvalidArgument;\n   }\n   ```\n\n3. **Usage in sync.zig**:\n   ```zig\n   if (remote_ts > local_ts) {\n       switch (sync_args.conflict_policy) {\n           .keep_local => {},  // no action\n           .keep_remote => ctx.store.update(...),\n           .keep_newest => ctx.store.update(...),\n           .manual => try markForManualResolution(...),\n       }\n   }\n   ```"},{"type":"text","text":"agentId: a12ab2a (for resuming to continue this agent's work if needed)"}]}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b7ecb5b3-4e78-4cde-b106-e82690b2d93e","tool_use_result":{"status":"completed","prompt":"Explore the beads_zig codebase to understand:\n1. How the sync command is currently implemented (find the sync.zig file in cli/)\n2. How command arguments are parsed (args.zig)\n3. What the current sync command flags are\n4. How other commands handle similar policy-style flags\n\nFocus on:\n- src/cli/sync.zig\n- src/cli/args.zig\n- Any related files for understanding the pattern\n\nReport back with file paths, key structures, and how flags are defined and used.","agentId":"a12ab2a","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me create a comprehensive report:\n\n## Exploration Report: beads_zig Sync Command & Flag Architecture\n\nI've completed a thorough exploration of the beads_zig codebase focusing on the sync command implementation and flag handling patterns. Here are my findings:\n\n---\n\n### 1. Current Sync Command Implementation\n\n**File:** `/home/hotschmoe/beads_zig/src/cli/sync.zig` (514 lines)\n\n**Current SyncArgs Structure** (lines 488-494):\n```zig\npub const SyncArgs = struct {\n    flush_only: bool = false,      // Export only\n    import_only: bool = false,     // Import only\n    merge: bool = false,           // 3-way merge mode\n    status: bool = false,          // Show status without changes\n    manifest: bool = false,        // Write manifest.json during export\n};\n```\n\n**Current Sync Modes:**\n- **Bidirectional** (default): `run()` checks dirty flag and exports if needed\n- **Flush/Export**: `--flush-only` - writes all issues to JSONL\n- **Import**: `--import-only` - replaces in-memory state from JSONL\n- **Merge**: `-m/--merge` - 3-way merge with remote JSONL based on `updated_at` timestamps\n- **Status**: `-s/--status` - reports counts without making changes\n- **Manifest**: `--manifest` - writes metadata JSON during flush\n\n**Current Command Dispatch** (lines 57-67):\n```zig\nif (sync_args.status) {\n    try runStatus(&ctx, structured_output, global.quiet, allocator);\n} else if (sync_args.flush_only) {\n    try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n} else if (sync_args.import_only) {\n    try runImport(&ctx, structured_output, global.quiet, allocator);\n} else if (sync_args.merge) {\n    try runMerge(&ctx, structured_output, global.quiet, allocator);\n} else {\n    try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n}\n```\n\n---\n\n### 2. How Flags Are Parsed in args.zig\n\n**File:** `/home/hotschmoe/beads_zig/src/cli/args.zig` (1770+ lines)\n\n**parseSyncArgs Function** (lines 1517-1533):\n```zig\nfn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n    var result = SyncArgs{};\n    while (self.hasNext()) {\n        if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n            result.flush_only = true;\n        } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n            result.import_only = true;\n        } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n            result.merge = true;\n        } else if (self.consumeFlag(\"-s\", \"--status\")) {\n            result.status = true;\n        } else if (self.consumeFlag(null, \"--manifest\")) {\n            result.manifest = true;\n        } else break;\n    }\n    return result;\n}\n```\n\n**consumeFlag Helper** (lines 1670-1677):\n```zig\nfn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n    const arg = self.peek() orelse return false;\n    if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n        self.skip();\n        return true;\n    }\n    return false;\n}\n```\n\n**Key Pattern:**\n- Flags accept both short and long forms: `consumeFlag(\"--export\", \"--flush-only\")`\n- Pass `null` for short form if only long form exists\n- Loop consumes flags until no more recognized flags found\n- Boolean flags set struct fields to `true` when consumed\n\n---\n\n### 3. Flag Definition Patterns in Help System\n\n**File:** `/home/hotschmoe/beads_zig/src/cli/help.zig`\n\nCurrent sync help output shows:\n```\n.flags = &[_]FlagHelp{\n    .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n    .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n    .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n    .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n    .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n},\n```\n\n---\n\n### 4. Related Commands with Similar Patterns\n\n**Delete Command** - Multiple boolean policy-like flags:\n- File: `/home/hotschmoe/beads_zig/src/cli/delete.zig`\n- Args: `cascade` (bool), `hard` (bool), `dry_run` (bool)\n- Pattern: Boolean flags can be combined\n\n**Enum-Based Policy Example - Add Batch Command:**\n- File: `/home/hotschmoe/beads_zig/src/cli/args.zig` (lines 193-209)\n- Uses enum for format choices:\n\n```zig\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null,\n    format: BatchFormat = .titles,  // Default enum value\n};\n\npub const BatchFormat = enum {\n    titles,  // One title per line\n    jsonl,   // Full JSONL format\n    \n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n```\n\n**Parsing enum-based flags** (lines 1130-1143):\n```zig\nfn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n    var result = AddBatchArgs{};\n    while (self.hasNext()) {\n        if (self.consumeFlag(\"-f\", \"--file\")) {\n            result.file = self.next() orelse return error.MissingFlagValue;\n        } else if (self.consumeFlag(null, \"--format\")) {\n            const fmt_str = self.next() orelse return error.MissingFlagValue;\n            result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n        } else if (self.peekPositional()) |_| {\n            if (result.file == null) {\n                result.file = self.next().?;\n            } else break;\n        } else break;\n    }\n    return result;\n}\n```\n\n---\n\n### 5. Other Commands with Multiple Optional String Fields\n\n**Create Command** - Extensive optional field pattern:\n- File: `/home/hotschmoe/beads_zig/src/cli/args.zig` (lines 116-131)\n\n```zig\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false,\n};\n```\n\n---\n\n### 6. Key Architectural Insights\n\n**Boolean Flag Approach (Current):**\n- Mutually exclusive modes checked with if/else chains\n- Clear and explicit\n- No ambiguity about which mode is active\n- Works well for small number of modes\n\n**Enum-Based Approach (Alternative):**\n- Could use enum like `SyncMode = enum { bidirectional, flush, import, merge, status }`\n- Enforces single mode selection at type level\n- Cleaner dispatch logic\n- Better for policy-style flags\n\n**Pattern for Multiple Optional Parameters:**\n- Use `?[]const u8 = null` for optional string parameters\n- Set to `null` by default\n- Check in command handler if present\n\n---\n\n### 7. File Paths Summary\n\n| File | Purpose | Key Structures |\n|------|---------|-----------------|\n| `/home/hotschmoe/beads_zig/src/cli/sync.zig` | Sync implementation | `SyncArgs`, `SyncResult`, 5 run functions |\n| `/home/hotschmoe/beads_zig/src/cli/args.zig` | Argument parsing | `parseSyncArgs()`, `consumeFlag()` |\n| `/home/hotschmoe/beads_zig/src/cli/common.zig` | Shared utilities | `CommandContext`, error handling |\n| `/home/hotschmoe/beads_zig/src/cli/help.zig` | Help system | Sync flag definitions |\n| `/home/hotschmoe/beads_zig/src/cli/delete.zig` | Delete impl (reference) | Similar boolean policy flags |\n\n---\n\n### 8. Recommended Patterns for New Features\n\n**For Conflict Resolution Policy:**\n1. **Enum approach** (recommended for mutually-exclusive policies):\n   ```zig\n   pub const ConflictPolicy = enum {\n       keep_local,     // or first\n       keep_remote,    // or remote\n       keep_newest,    // timestamp-based\n       manual,         // mark for manual resolution\n       \n       pub fn fromString(s: []const u8) ?ConflictPolicy { ... }\n   };\n   \n   pub const SyncArgs = struct {\n       flush_only: bool = false,\n       import_only: bool = false,\n       merge: bool = false,\n       status: bool = false,\n       manifest: bool = false,\n       conflict_policy: ConflictPolicy = .keep_newest,  // Add here\n   };\n   ```\n\n2. **Parsing in args.zig**:\n   ```zig\n   } else if (self.consumeFlag(null, \"--conflict\")) {\n       const policy_str = self.next() orelse return error.MissingFlagValue;\n       result.conflict_policy = ConflictPolicy.fromString(policy_str) \n           orelse return error.InvalidArgument;\n   }\n   ```\n\n3. **Usage in sync.zig**:\n   ```zig\n   if (remote_ts > local_ts) {\n       switch (sync_args.conflict_policy) {\n           .keep_local => {},  // no action\n           .keep_remote => ctx.store.update(...),\n           .keep_newest => ctx.store.update(...),\n           .manual => try markForManualResolution(...),\n       }\n   }\n   ```"}],"totalDurationMs":63854,"totalTokens":39189,"totalToolUseCount":23,"usage":{"input_tokens":0,"cache_creation_input_tokens":655,"cache_read_input_tokens":38533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":655},"output_tokens":1,"service_tier":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FFyrQNNuDSyfMTU2oZRiqs","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase structure. Let me read the specific files to implement the changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3124,"cache_read_input_tokens":39078,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3124},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2a56db4d-3d40-44a8-bfc1-0a40b9f79c97"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FFyrQNNuDSyfMTU2oZRiqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QzPWr4osx9ALAsyS4gTYps","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3124,"cache_read_input_tokens":39078,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3124},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3260fdc5-0470-4867-a80d-914510b27d3e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QzPWr4osx9ALAsyS4gTYps","type":"tool_result","content":"     1→//! Sync command for beads_zig.\n     2→//!\n     3→//! `bz sync` - Bidirectional sync with JSONL file\n     4→//! `bz sync --flush-only` - Export to JSONL only\n     5→//! `bz sync --import-only` - Import from JSONL only\n     6→//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n     7→//!\n     8→//! Handles synchronization between in-memory state and JSONL file.\n     9→\n    10→const std = @import(\"std\");\n    11→const models = @import(\"../models/mod.zig\");\n    12→const storage = @import(\"../storage/mod.zig\");\n    13→const common = @import(\"common.zig\");\n    14→const args = @import(\"args.zig\");\n    15→const test_util = @import(\"../test_util.zig\");\n    16→\n    17→const Issue = models.Issue;\n    18→const IssueStore = common.IssueStore;\n    19→const CommandContext = common.CommandContext;\n    20→\n    21→pub const SyncError = error{\n    22→    WorkspaceNotInitialized,\n    23→    MergeConflictDetected,\n    24→    ImportError,\n    25→    ExportError,\n    26→    OutOfMemory,\n    27→};\n    28→\n    29→pub const SyncResult = struct {\n    30→    success: bool,\n    31→    action: ?[]const u8 = null,\n    32→    issues_exported: ?usize = null,\n    33→    issues_imported: ?usize = null,\n    34→    issues_updated: ?usize = null,\n    35→    issues_added: ?usize = null,\n    36→    message: ?[]const u8 = null,\n    37→    // Status-specific fields\n    38→    db_count: ?usize = null,\n    39→    jsonl_count: ?usize = null,\n    40→    pending_export: ?usize = null,\n    41→    // Manifest-specific fields\n    42→    manifest_path: ?[]const u8 = null,\n    43→};\n    44→\n    45→pub fn run(\n    46→    sync_args: args.SyncArgs,\n    47→    global: args.GlobalOptions,\n    48→    allocator: std.mem.Allocator,\n    49→) !void {\n    50→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    51→        return SyncError.WorkspaceNotInitialized;\n    52→    };\n    53→    defer ctx.deinit();\n    54→\n    55→    const structured_output = global.isStructuredOutput();\n    56→\n    57→    if (sync_args.status) {\n    58→        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    59→    } else if (sync_args.flush_only) {\n    60→        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    61→    } else if (sync_args.import_only) {\n    62→        try runImport(&ctx, structured_output, global.quiet, allocator);\n    63→    } else if (sync_args.merge) {\n    64→        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    65→    } else {\n    66→        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    67→    }\n    68→}\n    69→\n    70→fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    71→    const count = ctx.store.issues.items.len;\n    72→\n    73→    ctx.store.saveToFile() catch {\n    74→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n    75→        return SyncError.ExportError;\n    76→    };\n    77→\n    78→    // Write manifest if requested\n    79→    var manifest_path: ?[]const u8 = null;\n    80→    if (write_manifest) {\n    81→        manifest_path = try writeManifest(ctx, count, allocator);\n    82→    }\n    83→    defer if (manifest_path) |path| allocator.free(path);\n    84→\n    85→    if (structured_output) {\n    86→        try ctx.output.printJson(SyncResult{\n    87→            .success = true,\n    88→            .action = \"flush\",\n    89→            .issues_exported = count,\n    90→            .manifest_path = manifest_path,\n    91→        });\n    92→    } else if (!quiet) {\n    93→        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n    94→        if (manifest_path) |path| {\n    95→            try ctx.output.info(\"Manifest written to {s}\", .{path});\n    96→        }\n    97→    }\n    98→}\n    99→\n   100→fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   101→    // Check for merge conflict markers in the JSONL file\n   102→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   103→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   104→        return SyncError.MergeConflictDetected;\n   105→    }\n   106→\n   107→    // Reload from file (this replaces in-memory state)\n   108→    const old_count = ctx.store.issues.items.len;\n   109→\n   110→    // Deinit existing issues\n   111→    for (ctx.store.issues.items) |*issue| {\n   112→        issue.deinit(allocator);\n   113→    }\n   114→    ctx.store.issues.clearRetainingCapacity();\n   115→\n   116→    // Clear and rebuild index\n   117→    var id_it = ctx.store.id_index.keyIterator();\n   118→    while (id_it.next()) |key| {\n   119→        allocator.free(key.*);\n   120→    }\n   121→    ctx.store.id_index.clearRetainingCapacity();\n   122→\n   123→    // Reload from file\n   124→    ctx.store.loadFromFile() catch {\n   125→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n   126→        return SyncError.ImportError;\n   127→    };\n   128→\n   129→    const new_count = ctx.store.issues.items.len;\n   130→\n   131→    if (structured_output) {\n   132→        try ctx.output.printJson(SyncResult{\n   133→            .success = true,\n   134→            .action = \"import\",\n   135→            .issues_imported = new_count,\n   136→        });\n   137→    } else if (!quiet) {\n   138→        if (new_count > old_count) {\n   139→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n   140→        } else if (new_count < old_count) {\n   141→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n   142→        } else {\n   143→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n   144→        }\n   145→    }\n   146→}\n   147→\n   148→fn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   149→    // Check for merge conflict markers\n   150→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   151→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   152→        return SyncError.MergeConflictDetected;\n   153→    }\n   154→\n   155→    // For bidirectional sync, we export the current state\n   156→    // A full bidirectional merge would require content hashing which is complex\n   157→    const count = ctx.store.issues.items.len;\n   158→\n   159→    if (ctx.store.dirty) {\n   160→        ctx.store.saveToFile() catch {\n   161→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n   162→            return SyncError.ExportError;\n   163→        };\n   164→\n   165→        if (structured_output) {\n   166→            try ctx.output.printJson(SyncResult{\n   167→                .success = true,\n   168→                .action = \"sync\",\n   169→                .issues_exported = count,\n   170→            });\n   171→        } else if (!quiet) {\n   172→            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n   173→        }\n   174→    } else {\n   175→        if (structured_output) {\n   176→            try ctx.output.printJson(SyncResult{\n   177→                .success = true,\n   178→                .action = \"sync\",\n   179→                .message = \"no changes to sync\",\n   180→            });\n   181→        } else if (!quiet) {\n   182→            try ctx.output.info(\"No changes to sync\", .{});\n   183→        }\n   184→    }\n   185→}\n   186→\n   187→/// Perform 3-way merge of local DB and remote JSONL.\n   188→/// For each issue:\n   189→/// - If only in local: keep\n   190→/// - If only in remote: add\n   191→/// - If in both: keep the one with newer updated_at timestamp\n   192→fn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   193→    // Check for merge conflict markers\n   194→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   195→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   196→        return SyncError.MergeConflictDetected;\n   197→    }\n   198→\n   199→    // Load remote issues from JSONL file directly (without replacing store)\n   200→    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n   201→    defer remote_store.deinit();\n   202→\n   203→    remote_store.loadFromFile() catch |err| {\n   204→        if (err != error.FileNotFound) {\n   205→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n   206→            return SyncError.ImportError;\n   207→        }\n   208→    };\n   209→\n   210→    var added: usize = 0;\n   211→    var updated: usize = 0;\n   212→\n   213→    // Iterate through remote issues and merge into local store\n   214→    for (remote_store.issues.items) |remote_issue| {\n   215→        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n   216→            // Issue exists in both - compare updated_at timestamps\n   217→            const local_ts = local_issue.updated_at.value;\n   218→            const remote_ts = remote_issue.updated_at.value;\n   219→\n   220→            if (remote_ts > local_ts) {\n   221→                // Remote is newer - update local with remote data\n   222→                // We need to copy the remote issue's data\n   223→                const update = storage.IssueStore.IssueUpdate{\n   224→                    .title = remote_issue.title,\n   225→                    .description = remote_issue.description,\n   226→                    .design = remote_issue.design,\n   227→                    .acceptance_criteria = remote_issue.acceptance_criteria,\n   228→                    .notes = remote_issue.notes,\n   229→                    .status = remote_issue.status,\n   230→                    .priority = remote_issue.priority,\n   231→                    .issue_type = remote_issue.issue_type,\n   232→                    .assignee = remote_issue.assignee,\n   233→                    .owner = remote_issue.owner,\n   234→                    .estimated_minutes = remote_issue.estimated_minutes,\n   235→                    .closed_at = remote_issue.closed_at.value,\n   236→                    .close_reason = remote_issue.close_reason,\n   237→                    .due_at = remote_issue.due_at.value,\n   238→                    .defer_until = remote_issue.defer_until.value,\n   239→                    .external_ref = remote_issue.external_ref,\n   240→                    .source_system = remote_issue.source_system,\n   241→                    .pinned = remote_issue.pinned,\n   242→                    .is_template = remote_issue.is_template,\n   243→                };\n   244→\n   245→                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n   246→                updated += 1;\n   247→            }\n   248→            // If local is newer or equal, keep local (no action needed)\n   249→        } else {\n   250→            // Issue only in remote - add to local\n   251→            // Clone the remote issue for insertion\n   252→            var cloned = try remote_issue.clone(allocator);\n   253→            ctx.store.insert(cloned) catch {\n   254→                cloned.deinit(allocator);\n   255→                continue;\n   256→            };\n   257→            added += 1;\n   258→        }\n   259→    }\n   260→\n   261→    // Save merged state if any changes were made\n   262→    if (added > 0 or updated > 0 or ctx.store.dirty) {\n   263→        ctx.store.saveToFile() catch {\n   264→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n   265→            return SyncError.ExportError;\n   266→        };\n   267→    }\n   268→\n   269→    const total = ctx.store.issues.items.len;\n   270→\n   271→    if (structured_output) {\n   272→        try ctx.output.printJson(SyncResult{\n   273→            .success = true,\n   274→            .action = \"merge\",\n   275→            .issues_added = added,\n   276→            .issues_updated = updated,\n   277→            .issues_exported = total,\n   278→        });\n   279→    } else if (!quiet) {\n   280→        if (added == 0 and updated == 0) {\n   281→            try ctx.output.info(\"No changes to merge\", .{});\n   282→        } else {\n   283→            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n   284→        }\n   285→    }\n   286→}\n   287→\n   288→/// Show sync status without making changes.\n   289→/// Reports: DB issue count, JSONL issue count, pending export count.\n   290→fn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   291→    const db_count = ctx.store.issues.items.len;\n   292→\n   293→    // Count issues in JSONL file (without loading into store)\n   294→    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n   295→        error.FileNotFound => 0,\n   296→        else => return err,\n   297→    };\n   298→\n   299→    // Count pending exports (dirty issues)\n   300→    const pending_export = ctx.store.dirty_ids.count();\n   301→\n   302→    if (structured_output) {\n   303→        try ctx.output.printJson(SyncResult{\n   304→            .success = true,\n   305→            .action = \"status\",\n   306→            .db_count = db_count,\n   307→            .jsonl_count = jsonl_count,\n   308→            .pending_export = pending_export,\n   309→        });\n   310→    } else if (!quiet) {\n   311→        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n   312→        if (pending_export > 0) {\n   313→            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n   314→        } else {\n   315→            try ctx.output.info(\"No pending changes\", .{});\n   316→        }\n   317→    }\n   318→}\n   319→\n   320→/// Count the number of issues in a JSONL file without fully parsing them.\n   321→fn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n   322→    const file = try std.fs.cwd().openFile(path, .{});\n   323→    defer file.close();\n   324→\n   325→    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n   326→    defer allocator.free(content);\n   327→\n   328→    var count: usize = 0;\n   329→    var lines = std.mem.splitScalar(u8, content, '\\n');\n   330→    while (lines.next()) |line| {\n   331→        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n   332→        if (trimmed.len > 0 and trimmed[0] == '{') {\n   333→            count += 1;\n   334→        }\n   335→    }\n   336→    return count;\n   337→}\n   338→\n   339→/// Write a manifest file with export metadata.\n   340→fn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n   341→    // Derive manifest path from jsonl_path\n   342→    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n   343→    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n   344→    errdefer allocator.free(manifest_path);\n   345→\n   346→    const timestamp = std.time.timestamp();\n   347→\n   348→    // Build manifest JSON\n   349→    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n   350→    defer json_buf.deinit(allocator);\n   351→\n   352→    const writer = json_buf.writer(allocator);\n   353→    try writer.writeAll(\"{\\n\");\n   354→    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n   355→    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n   356→    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n   357→    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n   358→    try writer.writeAll(\"}\\n\");\n   359→\n   360→    // Write to file\n   361→    const file = try std.fs.cwd().createFile(manifest_path, .{});\n   362→    defer file.close();\n   363→    try file.writeAll(json_buf.items);\n   364→\n   365→    return manifest_path;\n   366→}\n   367→\n   368→/// Check if the JSONL file contains git merge conflict markers\n   369→fn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n   370→    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n   371→        error.FileNotFound => return false,\n   372→        else => return err,\n   373→    };\n   374→    defer file.close();\n   375→\n   376→    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n   377→    defer allocator.free(content);\n   378→\n   379→    // Check for common merge conflict markers\n   380→    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n   381→    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n   382→    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n   383→\n   384→    return false;\n   385→}\n   386→\n   387→// --- Tests ---\n   388→\n   389→test \"SyncError enum exists\" {\n   390→    const err: SyncError = SyncError.MergeConflictDetected;\n   391→    try std.testing.expect(err == SyncError.MergeConflictDetected);\n   392→}\n   393→\n   394→test \"SyncResult struct works\" {\n   395→    const result = SyncResult{\n   396→        .success = true,\n   397→        .action = \"flush\",\n   398→        .issues_exported = 5,\n   399→    };\n   400→    try std.testing.expect(result.success);\n   401→    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n   402→    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n   403→}\n   404→\n   405→test \"run detects uninitialized workspace\" {\n   406→    const allocator = std.testing.allocator;\n   407→\n   408→    const sync_args = args.SyncArgs{};\n   409→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   410→\n   411→    const result = run(sync_args, global, allocator);\n   412→    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n   413→}\n   414→\n   415→test \"hasMergeConflicts returns false for clean file\" {\n   416→    const allocator = std.testing.allocator;\n   417→    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n   418→    defer allocator.free(test_dir);\n   419→    defer test_util.cleanupTestDir(test_dir);\n   420→\n   421→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n   422→    defer allocator.free(test_path);\n   423→\n   424→    const file = try std.fs.cwd().createFile(test_path, .{});\n   425→    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n   426→    file.close();\n   427→\n   428→    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n   429→    try std.testing.expect(!has_conflicts);\n   430→}\n   431→\n   432→test \"hasMergeConflicts returns true for conflicted file\" {\n   433→    const allocator = std.testing.allocator;\n   434→    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n   435→    defer allocator.free(test_dir);\n   436→    defer test_util.cleanupTestDir(test_dir);\n   437→\n   438→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n   439→    defer allocator.free(test_path);\n   440→\n   441→    const file = try std.fs.cwd().createFile(test_path, .{});\n   442→    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n   443→    file.close();\n   444→\n   445→    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n   446→    try std.testing.expect(has_conflicts);\n   447→}\n   448→\n   449→test \"hasMergeConflicts returns false for missing file\" {\n   450→    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n   451→    try std.testing.expect(!has_conflicts);\n   452→}\n   453→\n   454→test \"countJsonlIssues counts valid JSON lines\" {\n   455→    const allocator = std.testing.allocator;\n   456→    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n   457→    defer allocator.free(test_dir);\n   458→    defer test_util.cleanupTestDir(test_dir);\n   459→\n   460→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n   461→    defer allocator.free(test_path);\n   462→\n   463→    const file = try std.fs.cwd().createFile(test_path, .{});\n   464→    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n   465→    file.close();\n   466→\n   467→    const count = try countJsonlIssues(test_path, allocator);\n   468→    try std.testing.expectEqual(@as(usize, 3), count);\n   469→}\n   470→\n   471→test \"countJsonlIssues handles empty lines\" {\n   472→    const allocator = std.testing.allocator;\n   473→    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n   474→    defer allocator.free(test_dir);\n   475→    defer test_util.cleanupTestDir(test_dir);\n   476→\n   477→    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n   478→    defer allocator.free(test_path);\n   479→\n   480→    const file = try std.fs.cwd().createFile(test_path, .{});\n   481→    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n   482→    file.close();\n   483→\n   484→    const count = try countJsonlIssues(test_path, allocator);\n   485→    try std.testing.expectEqual(@as(usize, 3), count);\n   486→}\n   487→\n   488→test \"SyncResult with status fields\" {\n   489→    const result = SyncResult{\n   490→        .success = true,\n   491→        .action = \"status\",\n   492→        .db_count = 45,\n   493→        .jsonl_count = 43,\n   494→        .pending_export = 2,\n   495→    };\n   496→    try std.testing.expect(result.success);\n   497→    try std.testing.expectEqualStrings(\"status\", result.action.?);\n   498→    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n   499→    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n   500→    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n   501→}\n   502→\n   503→test \"SyncArgs parses status flag\" {\n   504→    const sync_args = args.SyncArgs{ .status = true };\n   505→    try std.testing.expect(sync_args.status);\n   506→    try std.testing.expect(!sync_args.flush_only);\n   507→}\n   508→\n   509→test \"SyncArgs parses manifest flag\" {\n   510→    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n   511→    try std.testing.expect(sync_args.manifest);\n   512→    try std.testing.expect(sync_args.flush_only);\n   513→}\n   514→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3ae469c3-1120-4a67-9631-7f5bc28d0cb4","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","content":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n\n    ctx.store.saveToFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n        return SyncError.ExportError;\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"flush\",\n            .issues_exported = count,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","numLines":514,"startLine":1,"totalLines":514}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FFyrQNNuDSyfMTU2oZRiqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HtU2CEcutspjfYXbnRYoHP","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3124,"cache_read_input_tokens":39078,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3124},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e9240259-e91d-4513-a692-9ffebcf729de"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (30452 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01HtU2CEcutspjfYXbnRYoHP"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"0604b0aa-cc52-4fde-a6a6-1ca6eb6595e6","tool_use_result":"Error: File content (30452 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FFyrQNNuDSyfMTU2oZRiqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GiEQYRYNrSgS4W4e9ARWzn","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3124,"cache_read_input_tokens":39078,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3124},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d4aef81f-3cca-40e5-aef9-2f077014e048"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01GiEQYRYNrSgS4W4e9ARWzn"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e5cfbe4b-ceec-4f00-ae15-04218b046989","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Dg8iPetguvftSuM6W5R4Zh","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the args.zig and help.zig files in sections."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8103,"cache_read_input_tokens":42202,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8103},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"faa0e01a-091f-42d0-a5ad-d85b8df44a01"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Dg8iPetguvftSuM6W5R4Zh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019XwP4ipFyNvS6uRC3Cgd1J","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8103,"cache_read_input_tokens":42202,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8103},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8bd70a0b-72ec-4317-9580-c65ee11e39e0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019XwP4ipFyNvS6uRC3Cgd1J","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    robot: bool = false, // Line-oriented machine-readable output for scripting\n    13→    quiet: bool = false,\n    14→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    15→    verbose: u8 = 0,\n    16→    no_color: bool = false,\n    17→    wrap: bool = false, // Wrap long lines in plain text output\n    18→    stats: bool = false, // Show token savings stats for TOON output\n    19→    data_path: ?[]const u8 = null,\n    20→    actor: ?[]const u8 = null,\n    21→    lock_timeout: u32 = 5000,\n    22→    no_auto_flush: bool = false,\n    23→    no_auto_import: bool = false,\n    24→\n    25→    /// Returns true if structured output (JSON or TOON) is enabled.\n    26→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    27→        return self.json or self.toon;\n    28→    }\n    29→\n    30→    /// Returns true if any machine-readable output is enabled.\n    31→    pub fn isMachineOutput(self: GlobalOptions) bool {\n    32→        return self.json or self.toon or self.robot;\n    33→    }\n    34→};\n    35→\n    36→/// All available subcommands.\n    37→pub const Command = union(enum) {\n    38→    // Workspace\n    39→    init: InitArgs,\n    40→    info: void,\n    41→    stats: void,\n    42→    doctor: void,\n    43→    config: ConfigArgs,\n    44→    orphans: OrphansArgs,\n    45→    lint: LintArgs,\n    46→    where: void,\n    47→\n    48→    // Issue CRUD\n    49→    create: CreateArgs,\n    50→    q: QuickArgs,\n    51→    show: ShowArgs,\n    52→    update: UpdateArgs,\n    53→    close: CloseArgs,\n    54→    reopen: ReopenArgs,\n    55→    delete: DeleteArgs,\n    56→\n    57→    // Batch Operations\n    58→    add_batch: AddBatchArgs,\n    59→    import_cmd: ImportArgs,\n    60→\n    61→    // Query\n    62→    list: ListArgs,\n    63→    ready: ReadyArgs,\n    64→    blocked: BlockedArgs,\n    65→    search: SearchArgs,\n    66→    stale: StaleArgs,\n    67→    count: CountArgs,\n    68→    defer_cmd: DeferArgs,\n    69→    undefer: UndeferArgs,\n    70→\n    71→    // Dependencies\n    72→    dep: DepArgs,\n    73→    graph: GraphArgs,\n    74→\n    75→    // Epics\n    76→    epic: EpicArgs,\n    77→\n    78→    // Labels\n    79→    label: LabelArgs,\n    80→\n    81→    // Comments\n    82→    comments: CommentsArgs,\n    83→\n    84→    // Audit\n    85→    history: HistoryArgs,\n    86→    audit: AuditArgs,\n    87→\n    88→    // Changelog\n    89→    changelog: ChangelogArgs,\n    90→\n    91→    // Sync\n    92→    sync: SyncArgs,\n    93→\n    94→    // System\n    95→    version: void,\n    96→    schema: void,\n    97→    completions: CompletionsArgs,\n    98→    metrics: MetricsArgs,\n    99→\n   100→    // Saved Queries\n   101→    query: QueryArgs,\n   102→\n   103→    // Self-upgrade\n   104→    upgrade: UpgradeArgs,\n   105→\n   106→    // Help\n   107→    help: HelpArgs,\n   108→};\n   109→\n   110→/// Init command arguments.\n   111→pub const InitArgs = struct {\n   112→    prefix: []const u8 = \"bd\",\n   113→};\n   114→\n   115→/// Create command arguments.\n   116→pub const CreateArgs = struct {\n   117→    title: []const u8,\n   118→    description: ?[]const u8 = null,\n   119→    issue_type: ?[]const u8 = null,\n   120→    priority: ?[]const u8 = null,\n   121→    assignee: ?[]const u8 = null,\n   122→    owner: ?[]const u8 = null,\n   123→    design: ?[]const u8 = null,\n   124→    acceptance_criteria: ?[]const u8 = null,\n   125→    external_ref: ?[]const u8 = null,\n   126→    labels: []const []const u8 = &[_][]const u8{},\n   127→    deps: []const []const u8 = &[_][]const u8{},\n   128→    due: ?[]const u8 = null,\n   129→    estimate: ?i32 = null,\n   130→    ephemeral: bool = false, // Local-only, not written to JSONL\n   131→};\n   132→\n   133→/// Quick capture command arguments.\n   134→pub const QuickArgs = struct {\n   135→    title: []const u8,\n   136→    priority: ?[]const u8 = null,\n   137→};\n   138→\n   139→/// Show command arguments.\n   140→pub const ShowArgs = struct {\n   141→    id: []const u8,\n   142→    with_comments: bool = true,\n   143→    with_history: bool = false,\n   144→};\n   145→\n   146→/// Update command arguments.\n   147→pub const UpdateArgs = struct {\n   148→    id: []const u8,\n   149→    title: ?[]const u8 = null,\n   150→    description: ?[]const u8 = null,\n   151→    issue_type: ?[]const u8 = null,\n   152→    priority: ?[]const u8 = null,\n   153→    assignee: ?[]const u8 = null,\n   154→    owner: ?[]const u8 = null,\n   155→    design: ?[]const u8 = null,\n   156→    acceptance_criteria: ?[]const u8 = null,\n   157→    external_ref: ?[]const u8 = null,\n   158→    status: ?[]const u8 = null,\n   159→    /// Expected version for optimistic locking (compare-and-swap).\n   160→    expected_version: ?u64 = null,\n   161→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   162→    claim: bool = false,\n   163→};\n   164→\n   165→/// Close command arguments.\n   166→pub const CloseArgs = struct {\n   167→    id: []const u8,\n   168→    reason: ?[]const u8 = null,\n   169→    session: ?[]const u8 = null,\n   170→};\n   171→\n   172→/// Reopen command arguments.\n   173→pub const ReopenArgs = struct {\n   174→    id: []const u8,\n   175→};\n   176→\n   177→/// Delete command arguments.\n   178→pub const DeleteArgs = struct {\n   179→    /// Single issue ID to delete (mutually exclusive with from_file).\n   180→    id: ?[]const u8 = null,\n   181→    /// Path to file containing issue IDs to delete (one per line).\n   182→    from_file: ?[]const u8 = null,\n   183→    /// Delete issue and all its dependents recursively.\n   184→    cascade: bool = false,\n   185→    /// Prune from database immediately instead of marking as tombstone.\n   186→    hard: bool = false,\n   187→    /// Preview what would be deleted without making changes.\n   188→    dry_run: bool = false,\n   189→};\n   190→\n   191→/// Add-batch command arguments.\n   192→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   193→pub const AddBatchArgs = struct {\n   194→    file: ?[]const u8 = null, // Read from file instead of stdin\n   195→    format: BatchFormat = .titles, // Input format\n   196→};\n   197→\n   198→/// Batch input format.\n   199→pub const BatchFormat = enum {\n   200→    titles, // One title per line\n   201→    jsonl, // Full JSONL format (one issue per line)\n   202→\n   203→    pub fn fromString(s: []const u8) ?BatchFormat {\n   204→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   205→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   206→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   207→        return null;\n   208→    }\n   209→};\n   210→\n   211→/// Import command arguments.\n   212→/// Imports issues from a JSONL file with single lock acquisition.\n   213→pub const ImportArgs = struct {\n   214→    file: []const u8, // Path to JSONL file (required)\n   215→    merge: bool = false, // Merge instead of replace\n   216→    dry_run: bool = false, // Show what would be imported without importing\n   217→};\n   218→\n   219→/// Output format for list/ready commands.\n   220→pub const OutputFormat = enum {\n   221→    default,\n   222→    csv,\n   223→\n   224→    pub fn fromString(s: []const u8) ?OutputFormat {\n   225→        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n   226→        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n   227→        return null;\n   228→    }\n   229→};\n   230→\n   231→/// Sort field options for list command.\n   232→pub const SortField = enum {\n   233→    created_at,\n   234→    updated_at,\n   235→    priority,\n   236→\n   237→    pub fn fromString(s: []const u8) ?SortField {\n   238→        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n   239→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   240→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   241→        return null;\n   242→    }\n   243→};\n   244→\n   245→/// List command arguments.\n   246→pub const ListArgs = struct {\n   247→    status: ?[]const u8 = null,\n   248→    priority: ?[]const u8 = null,\n   249→    priority_min: ?[]const u8 = null,\n   250→    priority_max: ?[]const u8 = null,\n   251→    issue_type: ?[]const u8 = null,\n   252→    assignee: ?[]const u8 = null,\n   253→    label: ?[]const u8 = null,\n   254→    label_any: []const []const u8 = &[_][]const u8{},\n   255→    title_contains: ?[]const u8 = null,\n   256→    desc_contains: ?[]const u8 = null,\n   257→    notes_contains: ?[]const u8 = null,\n   258→    limit: ?u32 = null,\n   259→    all: bool = false,\n   260→    overdue: bool = false,\n   261→    include_deferred: bool = false,\n   262→    sort: SortField = .created_at,\n   263→    sort_desc: bool = true,\n   264→    parent: ?[]const u8 = null,\n   265→    recursive: bool = false,\n   266→    format: OutputFormat = .default,\n   267→    fields: ?[]const u8 = null,\n   268→};\n   269→\n   270→/// Ready command arguments.\n   271→pub const ReadyArgs = struct {\n   272→    limit: ?u32 = null,\n   273→    priority_min: ?[]const u8 = null,\n   274→    priority_max: ?[]const u8 = null,\n   275→    title_contains: ?[]const u8 = null,\n   276→    desc_contains: ?[]const u8 = null,\n   277→    notes_contains: ?[]const u8 = null,\n   278→    overdue: bool = false,\n   279→    include_deferred: bool = false,\n   280→    parent: ?[]const u8 = null,\n   281→    recursive: bool = false,\n   282→    format: OutputFormat = .default,\n   283→    fields: ?[]const u8 = null,\n   284→};\n   285→\n   286→/// Blocked command arguments.\n   287→pub const BlockedArgs = struct {\n   288→    limit: ?u32 = null,\n   289→    priority_min: ?[]const u8 = null,\n   290→    priority_max: ?[]const u8 = null,\n   291→    title_contains: ?[]const u8 = null,\n   292→    desc_contains: ?[]const u8 = null,\n   293→    notes_contains: ?[]const u8 = null,\n   294→};\n   295→\n   296→/// Search command arguments.\n   297→pub const SearchArgs = struct {\n   298→    query: []const u8,\n   299→    limit: ?u32 = null,\n   300→};\n   301→\n   302→/// Stale command arguments.\n   303→pub const StaleArgs = struct {\n   304→    days: u32 = 30,\n   305→    limit: ?u32 = null,\n   306→};\n   307→\n   308→/// Count command arguments.\n   309→pub const CountArgs = struct {\n   310→    group_by: ?[]const u8 = null,\n   311→};\n   312→\n   313→/// Defer command arguments.\n   314→pub const DeferArgs = struct {\n   315→    id: []const u8,\n   316→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   317→    reason: ?[]const u8 = null,\n   318→};\n   319→\n   320→/// Undefer command arguments.\n   321→pub const UndeferArgs = struct {\n   322→    id: []const u8,\n   323→};\n   324→\n   325→/// Epic subcommand variants.\n   326→pub const EpicSubcommand = union(enum) {\n   327→    create: struct {\n   328→        title: []const u8,\n   329→        description: ?[]const u8 = null,\n   330→        priority: ?[]const u8 = null,\n   331→    },\n   332→    add: struct {\n   333→        epic_id: []const u8,\n   334→        issue_id: []const u8,\n   335→    },\n   336→    remove: struct {\n   337→        epic_id: []const u8,\n   338→        issue_id: []const u8,\n   339→    },\n   340→    list: struct {\n   341→        epic_id: []const u8,\n   342→    },\n   343→    status: void,\n   344→    close_eligible: struct {\n   345→        dry_run: bool = false,\n   346→    },\n   347→};\n   348→\n   349→/// Epic command arguments.\n   350→pub const EpicArgs = struct {\n   351→    subcommand: EpicSubcommand,\n   352→};\n   353→\n   354→/// Direction filter for dependency listing.\n   355→pub const DepDirection = enum {\n   356→    up, // What depends on this issue (dependents/blocked-by)\n   357→    down, // What this issue depends on\n   358→    both, // Both directions (default)\n   359→\n   360→    pub fn fromString(s: []const u8) ?DepDirection {\n   361→        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n   362→        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n   363→        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n   364→        return null;\n   365→    }\n   366→};\n   367→\n   368→/// Tree output formats for dep tree.\n   369→pub const TreeFormat = enum {\n   370→    ascii,\n   371→    mermaid,\n   372→\n   373→    pub fn fromString(s: []const u8) ?TreeFormat {\n   374→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   375→        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n   376→        return null;\n   377→    }\n   378→};\n   379→\n   380→/// Dependency subcommand variants.\n   381→pub const DepSubcommand = union(enum) {\n   382→    add: struct {\n   383→        child: []const u8,\n   384→        parent: []const u8,\n   385→        dep_type: []const u8 = \"blocks\",\n   386→        metadata: ?[]const u8 = null,\n   387→    },\n   388→    remove: struct {\n   389→        child: []const u8,\n   390→        parent: []const u8,\n   391→    },\n   392→    list: struct {\n   393→        id: []const u8,\n   394→        direction: DepDirection = .both,\n   395→    },\n   396→    tree: struct {\n   397→        id: []const u8,\n   398→        format: TreeFormat = .ascii,\n   399→    },\n   400→    cycles: void,\n   401→};\n   402→\n   403→/// Dependency command arguments.\n   404→pub const DepArgs = struct {\n   405→    subcommand: DepSubcommand,\n   406→};\n   407→\n   408→/// Graph command output formats.\n   409→pub const GraphFormat = enum {\n   410→    ascii,\n   411→    dot,\n   412→\n   413→    pub fn fromString(s: []const u8) ?GraphFormat {\n   414→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   415→        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n   416→        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n   417→        return null;\n   418→    }\n   419→};\n   420→\n   421→/// Graph command arguments.\n   422→pub const GraphArgs = struct {\n   423→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   424→    format: GraphFormat = .ascii,\n   425→    depth: ?u32 = null, // Max depth for tree traversal\n   426→};\n   427→\n   428→/// Label subcommand variants.\n   429→pub const LabelSubcommand = union(enum) {\n   430→    add: struct {\n   431→        id: []const u8,\n   432→        labels: []const []const u8,\n   433→    },\n   434→    remove: struct {\n   435→        id: []const u8,\n   436→        labels: []const []const u8,\n   437→    },\n   438→    list: struct {\n   439→        id: []const u8,\n   440→    },\n   441→    list_all: void,\n   442→    rename: struct {\n   443→        old_name: []const u8,\n   444→        new_name: []const u8,\n   445→    },\n   446→};\n   447→\n   448→/// Label command arguments.\n   449→pub const LabelArgs = struct {\n   450→    subcommand: LabelSubcommand,\n   451→};\n   452→\n   453→/// Comments subcommand variants.\n   454→pub const CommentsSubcommand = union(enum) {\n   455→    add: struct {\n   456→        id: []const u8,\n   457→        text: []const u8,\n   458→    },\n   459→    list: struct {\n   460→        id: []const u8,\n   461→    },\n   462→};\n   463→\n   464→/// Comments command arguments.\n   465→pub const CommentsArgs = struct {\n   466→    subcommand: CommentsSubcommand,\n   467→};\n   468→\n   469→/// History command arguments.\n   470→pub const HistoryArgs = struct {\n   471→    id: []const u8,\n   472→};\n   473→\n   474→/// Audit command arguments.\n   475→pub const AuditArgs = struct {\n   476→    limit: ?u32 = null,\n   477→};\n   478→\n   479→/// Changelog command arguments.\n   480→pub const ChangelogArgs = struct {\n   481→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   482→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   483→    limit: ?u32 = null,\n   484→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   485→};\n   486→\n   487→/// Sync command arguments.\n   488→pub const SyncArgs = struct {\n   489→    flush_only: bool = false,\n   490→    import_only: bool = false,\n   491→    merge: bool = false,\n   492→    status: bool = false,\n   493→    manifest: bool = false,\n   494→};\n   495→\n   496→/// Shell completion types.\n   497→pub const Shell = enum {\n   498→    bash,\n   499→    zsh,\n   500→    fish,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a79aaa06-76a2-4ce2-8a3c-93ef3cb91a14","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,","numLines":500,"startLine":1,"totalLines":2638}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Dg8iPetguvftSuM6W5R4Zh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DpdPfMrw7FakXURevNZYEg","name":"Grep","input":{"pattern":"SyncArgs|parseSyncArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8103,"cache_read_input_tokens":42202,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8103},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"72b10d13-a66f-4560-bc4b-d1a66cd67eb8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DpdPfMrw7FakXURevNZYEg","type":"tool_result","content":"87-\n88-    // Changelog\n89-    changelog: ChangelogArgs,\n90-\n91-    // Sync\n92:    sync: SyncArgs,\n93-\n94-    // System\n95-    version: void,\n96-    schema: void,\n97-    completions: CompletionsArgs,\n--\n483-    limit: ?u32 = null,\n484-    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n485-};\n486-\n487-/// Sync command arguments.\n488:pub const SyncArgs = struct {\n489-    flush_only: bool = false,\n490-    import_only: bool = false,\n491-    merge: bool = false,\n492-    status: bool = false,\n493-    manifest: bool = false,\n--\n859-            return .{ .changelog = try self.parseChangelogArgs() };\n860-        }\n861-\n862-        // Sync\n863-        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n864:            return .{ .sync = try self.parseSyncArgs() };\n865-        }\n866-\n867-        // System\n868-        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n869-            return .{ .version = {} };\n--\n1512-            } else break;\n1513-        }\n1514-        return result;\n1515-    }\n1516-\n1517:    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n1518:        var result = SyncArgs{};\n1519-        while (self.hasNext()) {\n1520-            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n1521-                result.flush_only = true;\n1522-            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n1523-                result.import_only = true;"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7ddf2237-85bb-47c0-a5e5-650b394cbc61","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"87-\n88-    // Changelog\n89-    changelog: ChangelogArgs,\n90-\n91-    // Sync\n92:    sync: SyncArgs,\n93-\n94-    // System\n95-    version: void,\n96-    schema: void,\n97-    completions: CompletionsArgs,\n--\n483-    limit: ?u32 = null,\n484-    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n485-};\n486-\n487-/// Sync command arguments.\n488:pub const SyncArgs = struct {\n489-    flush_only: bool = false,\n490-    import_only: bool = false,\n491-    merge: bool = false,\n492-    status: bool = false,\n493-    manifest: bool = false,\n--\n859-            return .{ .changelog = try self.parseChangelogArgs() };\n860-        }\n861-\n862-        // Sync\n863-        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n864:            return .{ .sync = try self.parseSyncArgs() };\n865-        }\n866-\n867-        // System\n868-        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n869-            return .{ .version = {} };\n--\n1512-            } else break;\n1513-        }\n1514-        return result;\n1515-    }\n1516-\n1517:    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n1518:        var result = SyncArgs{};\n1519-        while (self.hasNext()) {\n1520-            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n1521-                result.flush_only = true;\n1522-            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n1523-                result.import_only = true;","numLines":48}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XBqdRKrtJ9jA6Ppn8d3i3o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015mxbp9ApxSckaEr9R7NgcY","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1510,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6769,"cache_read_input_tokens":50305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6769},"output_tokens":18,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"1034cefb-fad6-49ac-8e3d-f9911cff43c1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015mxbp9ApxSckaEr9R7NgcY","type":"tool_result","content":"  1510→            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1511→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1512→            } else break;\n  1513→        }\n  1514→        return result;\n  1515→    }\n  1516→\n  1517→    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n  1518→        var result = SyncArgs{};\n  1519→        while (self.hasNext()) {\n  1520→            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n  1521→                result.flush_only = true;\n  1522→            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n  1523→                result.import_only = true;\n  1524→            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n  1525→                result.merge = true;\n  1526→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n  1527→                result.status = true;\n  1528→            } else if (self.consumeFlag(null, \"--manifest\")) {\n  1529→                result.manifest = true;\n  1530→            } else break;\n  1531→        }\n  1532→        return result;\n  1533→    }\n  1534→\n  1535→    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n  1536→        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n  1537→        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n  1538→        return .{ .shell = shell };\n  1539→    }\n  1540→\n  1541→    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n  1542→        var result = MetricsArgs{};\n  1543→        while (self.hasNext()) {\n  1544→            if (self.consumeFlag(\"-r\", \"--reset\")) {\n  1545→                result.reset = true;\n  1546→            } else break;\n  1547→        }\n  1548→        return result;\n  1549→    }\n  1550→\n  1551→    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n  1552→        return .{ .topic = self.next() };\n  1553→    }\n  1554→\n  1555→    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n  1556→        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n  1557→\n  1558→        if (std.mem.eql(u8, subcmd, \"get\")) {\n  1559→            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n  1560→        }\n  1561→        if (std.mem.eql(u8, subcmd, \"set\")) {\n  1562→            return .{ .subcommand = .{ .set = .{\n  1563→                .key = self.next() orelse return error.MissingRequiredArgument,\n  1564→                .value = self.next() orelse return error.MissingRequiredArgument,\n  1565→            } } };\n  1566→        }\n  1567→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1568→            return .{ .subcommand = .{ .list = {} } };\n  1569→        }\n  1570→        return error.UnknownSubcommand;\n  1571→    }\n  1572→\n  1573→    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n  1574→        var result = OrphansArgs{};\n  1575→        while (self.hasNext()) {\n  1576→            if (try self.parseLimitFlag()) |limit| {\n  1577→                result.limit = limit;\n  1578→            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n  1579→                result.hierarchy_only = true;\n  1580→            } else if (self.consumeFlag(null, \"--deps-only\")) {\n  1581→                result.deps_only = true;\n  1582→            } else break;\n  1583→        }\n  1584→        return result;\n  1585→    }\n  1586→\n  1587→    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n  1588→        var result = LintArgs{};\n  1589→        while (self.hasNext()) {\n  1590→            if (try self.parseLimitFlag()) |limit| {\n  1591→                result.limit = limit;\n  1592→            } else break;\n  1593→        }\n  1594→        return result;\n  1595→    }\n  1596→\n  1597→    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n  1598→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1599→\n  1600→        if (std.mem.eql(u8, subcmd, \"save\")) {\n  1601→            const name = self.next() orelse return error.MissingRequiredArgument;\n  1602→            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n  1603→\n  1604→            while (self.hasNext()) {\n  1605→                if (self.consumeFlag(\"-s\", \"--status\")) {\n  1606→                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n  1607→                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1608→                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n  1609→                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b8daecd7-bbd4-4b27-b251-0dd125d7a098","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {","numLines":100,"startLine":1510,"totalLines":2638}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XBqdRKrtJ9jA6Ppn8d3i3o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YaM5XQ7C9vMoBgz9t5cxmE","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6769,"cache_read_input_tokens":50305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6769},"output_tokens":18,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"61b7726b-7112-4890-8dd3-ecd5ae77db82"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YaM5XQ7C9vMoBgz9t5cxmE","type":"tool_result","content":"     1→//! Help command for beads_zig.\n     2→//!\n     3→//! Provides detailed per-command help with usage examples and flag references.\n     4→\n     5→const std = @import(\"std\");\n     6→\n     7→pub const HelpError = error{\n     8→    WriteError,\n     9→    OutOfMemory,\n    10→};\n    11→\n    12→pub const HelpResult = struct {\n    13→    success: bool,\n    14→    topic: ?[]const u8 = null,\n    15→    message: ?[]const u8 = null,\n    16→};\n    17→\n    18→/// Command metadata for generating help text.\n    19→const CommandHelp = struct {\n    20→    name: []const u8,\n    21→    aliases: []const []const u8 = &[_][]const u8{},\n    22→    summary: []const u8,\n    23→    usage: []const u8,\n    24→    description: []const u8 = \"\",\n    25→    arguments: []const ArgHelp = &[_]ArgHelp{},\n    26→    flags: []const FlagHelp = &[_]FlagHelp{},\n    27→    examples: []const ExampleHelp = &[_]ExampleHelp{},\n    28→    see_also: []const []const u8 = &[_][]const u8{},\n    29→};\n    30→\n    31→const ArgHelp = struct {\n    32→    name: []const u8,\n    33→    description: []const u8,\n    34→    required: bool = true,\n    35→};\n    36→\n    37→const FlagHelp = struct {\n    38→    short: ?[]const u8,\n    39→    long: []const u8,\n    40→    arg: ?[]const u8 = null,\n    41→    description: []const u8,\n    42→};\n    43→\n    44→const ExampleHelp = struct {\n    45→    command: []const u8,\n    46→    description: []const u8,\n    47→};\n    48→\n    49→/// All command help definitions.\n    50→const commands = [_]CommandHelp{\n    51→    // Workspace commands\n    52→    .{\n    53→        .name = \"init\",\n    54→        .summary = \"Initialize a .beads/ workspace\",\n    55→        .usage = \"bz init [--prefix PREFIX]\",\n    56→        .description = \"Creates the .beads/ directory structure for issue tracking. \" ++\n    57→            \"This command must be run before using any other beads commands.\",\n    58→        .flags = &[_]FlagHelp{\n    59→            .{ .short = \"-p\", .long = \"--prefix\", .arg = \"PREFIX\", .description = \"Issue ID prefix (default: bd)\" },\n    60→        },\n    61→        .examples = &[_]ExampleHelp{\n    62→            .{ .command = \"bz init\", .description = \"Initialize with default prefix 'bd'\" },\n    63→            .{ .command = \"bz init --prefix proj\", .description = \"Use 'proj' as ID prefix (e.g., proj-abc123)\" },\n    64→        },\n    65→    },\n    66→    .{\n    67→        .name = \"info\",\n    68→        .summary = \"Show workspace information\",\n    69→        .usage = \"bz info\",\n    70→        .description = \"Displays current workspace configuration, file locations, and basic status.\",\n    71→        .examples = &[_]ExampleHelp{\n    72→            .{ .command = \"bz info\", .description = \"Show workspace details\" },\n    73→            .{ .command = \"bz info --json\", .description = \"Output as JSON for scripting\" },\n    74→        },\n    75→    },\n    76→    .{\n    77→        .name = \"stats\",\n    78→        .summary = \"Show project statistics\",\n    79→        .usage = \"bz stats\",\n    80→        .description = \"Shows aggregate statistics about issues: counts by status, priority, type, etc.\",\n    81→        .examples = &[_]ExampleHelp{\n    82→            .{ .command = \"bz stats\", .description = \"Show issue statistics\" },\n    83→            .{ .command = \"bz stats --json\", .description = \"Output as JSON for dashboards\" },\n    84→        },\n    85→    },\n    86→    .{\n    87→        .name = \"doctor\",\n    88→        .summary = \"Run diagnostic checks\",\n    89→        .usage = \"bz doctor\",\n    90→        .description = \"Checks workspace integrity: validates JSONL format, detects orphaned references, \" ++\n    91→            \"and reports any data consistency issues.\",\n    92→        .examples = &[_]ExampleHelp{\n    93→            .{ .command = \"bz doctor\", .description = \"Run all diagnostic checks\" },\n    94→        },\n    95→    },\n    96→    .{\n    97→        .name = \"config\",\n    98→        .summary = \"Manage configuration\",\n    99→        .usage = \"bz config [get|set|list] [KEY] [VALUE]\",\n   100→        .description = \"View or modify project configuration settings.\",\n   101→        .arguments = &[_]ArgHelp{\n   102→            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\n   103→            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n   104→            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n   105→        },\n   106→        .examples = &[_]ExampleHelp{\n   107→            .{ .command = \"bz config\", .description = \"List all configuration\" },\n   108→            .{ .command = \"bz config list\", .description = \"Same as above\" },\n   109→            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n   110→            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n   111→        },\n   112→    },\n   113→    .{\n   114→        .name = \"sync\",\n   115→        .summary = \"Sync with JSONL file\",\n   116→        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",\n   117→        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n   118→            \"bidirectional sync. Use flags to limit to export or import only.\",\n   119→        .flags = &[_]FlagHelp{\n   120→            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n   121→            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n   122→            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n   123→            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n   124→            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n   125→        },\n   126→        .examples = &[_]ExampleHelp{\n   127→            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n   128→            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n   129→            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n   130→            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n   131→            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n   132→        },\n   133→        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },\n   134→    },\n   135→    .{\n   136→        .name = \"orphans\",\n   137→        .summary = \"Find issues with missing parent references\",\n   138→        .usage = \"bz orphans [--limit N] [--hierarchy-only] [--deps-only]\",\n   139→        .description = \"Identifies issues that reference non-existent parent issues or dependencies.\",\n   140→        .flags = &[_]FlagHelp{\n   141→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results to show\" },\n   142→            .{ .short = null, .long = \"--hierarchy-only\", .description = \"Only check hierarchical parent refs\" },\n   143→            .{ .short = null, .long = \"--deps-only\", .description = \"Only check dependency refs\" },\n   144→        },\n   145→        .examples = &[_]ExampleHelp{\n   146→            .{ .command = \"bz orphans\", .description = \"Find all orphaned references\" },\n   147→            .{ .command = \"bz orphans --limit 10\", .description = \"Show at most 10 orphans\" },\n   148→        },\n   149→    },\n   150→    .{\n   151→        .name = \"lint\",\n   152→        .summary = \"Validate database consistency\",\n   153→        .usage = \"bz lint [--limit N]\",\n   154→        .description = \"Checks for data quality issues: empty titles, invalid priorities, \" ++\n   155→            \"malformed IDs, and other consistency problems.\",\n   156→        .flags = &[_]FlagHelp{\n   157→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum issues to report\" },\n   158→        },\n   159→        .examples = &[_]ExampleHelp{\n   160→            .{ .command = \"bz lint\", .description = \"Run all lint checks\" },\n   161→        },\n   162→    },\n   163→\n   164→    // Issue CRUD commands\n   165→    .{\n   166→        .name = \"create\",\n   167→        .aliases = &[_][]const u8{ \"add\", \"new\" },\n   168→        .summary = \"Create a new issue\",\n   169→        .usage = \"bz create <title> [options]\",\n   170→        .description = \"Creates a new issue with the given title. The issue is assigned a \" ++\n   171→            \"unique ID and added to the database. Use flags to set optional fields.\",\n   172→        .arguments = &[_]ArgHelp{\n   173→            .{ .name = \"title\", .description = \"Issue title (1-500 characters)\" },\n   174→        },\n   175→        .flags = &[_]FlagHelp{\n   176→            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"Detailed description\" },\n   177→            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Issue type (task, bug, feature, epic, chore, docs, question)\" },\n   178→            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority (critical, high, medium, low, backlog, or 0-4)\" },\n   179→            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Assignee name or email\" },\n   180→            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Add label (can be repeated)\" },\n   181→            .{ .short = null, .long = \"--depends-on\", .arg = \"ID\", .description = \"Add dependency (can be repeated)\" },\n   182→            .{ .short = null, .long = \"--due\", .arg = \"DATE\", .description = \"Due date (YYYY-MM-DD)\" },\n   183→            .{ .short = \"-e\", .long = \"--estimate\", .arg = \"MINS\", .description = \"Estimate in minutes\" },\n   184→        },\n   185→        .examples = &[_]ExampleHelp{\n   186→            .{ .command = \"bz create \\\"Fix login bug\\\"\", .description = \"Create a simple issue\" },\n   187→            .{ .command = \"bz create \\\"Add OAuth\\\" -t feature -p high\", .description = \"Create a high-priority feature\" },\n   188→            .{ .command = \"bz create \\\"Bug fix\\\" -l urgent -l backend\", .description = \"Create with multiple labels\" },\n   189→            .{ .command = \"bz create \\\"Task\\\" --depends-on bd-abc123\", .description = \"Create with dependency\" },\n   190→        },\n   191→        .see_also = &[_][]const u8{ \"q\", \"show\", \"update\" },\n   192→    },\n   193→    .{\n   194→        .name = \"q\",\n   195→        .aliases = &[_][]const u8{\"quick\"},\n   196→        .summary = \"Quick capture (create + print ID only)\",\n   197→        .usage = \"bz q <title> [-p PRIORITY]\",\n   198→        .description = \"Creates a new issue and prints only the ID. Optimized for scripting \" ++\n   199→            \"and quick capture workflows.\",\n   200→        .arguments = &[_]ArgHelp{\n   201→            .{ .name = \"title\", .description = \"Issue title\" },\n   202→        },\n   203→        .flags = &[_]FlagHelp{\n   204→            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority level\" },\n   205→        },\n   206→        .examples = &[_]ExampleHelp{\n   207→            .{ .command = \"bz q \\\"Quick thought\\\"\", .description = \"Capture idea, get ID back\" },\n   208→            .{ .command = \"ID=$(bz q \\\"Task\\\"); echo $ID\", .description = \"Capture ID in shell variable\" },\n   209→            .{ .command = \"bz q \\\"Urgent fix\\\" -p critical\", .description = \"Quick capture with priority\" },\n   210→        },\n   211→        .see_also = &[_][]const u8{ \"create\", \"add-batch\" },\n   212→    },\n   213→    .{\n   214→        .name = \"show\",\n   215→        .aliases = &[_][]const u8{ \"get\", \"view\" },\n   216→        .summary = \"Show issue details\",\n   217→        .usage = \"bz show <id> [--no-comments] [--with-history]\",\n   218→        .description = \"Displays full details of an issue including description, status, \" ++\n   219→            \"dependencies, labels, and comments.\",\n   220→        .arguments = &[_]ArgHelp{\n   221→            .{ .name = \"id\", .description = \"Issue ID (e.g., bd-abc123)\" },\n   222→        },\n   223→        .flags = &[_]FlagHelp{\n   224→            .{ .short = null, .long = \"--no-comments\", .description = \"Hide comments\" },\n   225→            .{ .short = null, .long = \"--with-history\", .description = \"Include change history\" },\n   226→        },\n   227→        .examples = &[_]ExampleHelp{\n   228→            .{ .command = \"bz show bd-abc123\", .description = \"Show issue details\" },\n   229→            .{ .command = \"bz show bd-abc --json\", .description = \"Get issue as JSON\" },\n   230→            .{ .command = \"bz show bd-abc --with-history\", .description = \"Include change history\" },\n   231→        },\n   232→        .see_also = &[_][]const u8{ \"update\", \"history\" },\n   233→    },\n   234→    .{\n   235→        .name = \"update\",\n   236→        .aliases = &[_][]const u8{\"edit\"},\n   237→        .summary = \"Update issue fields\",\n   238→        .usage = \"bz update <id> [options]\",\n   239→        .description = \"Modifies one or more fields of an existing issue. Only specified \" ++\n   240→            \"fields are changed; others remain unchanged.\",\n   241→        .arguments = &[_]ArgHelp{\n   242→            .{ .name = \"id\", .description = \"Issue ID to update\" },\n   243→        },\n   244→        .flags = &[_]FlagHelp{\n   245→            .{ .short = null, .long = \"--title\", .arg = \"TEXT\", .description = \"New title\" },\n   246→            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"New description\" },\n   247→            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"New issue type\" },\n   248→            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"New priority\" },\n   249→            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"New assignee\" },\n   250→            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"New status (open, in_progress, blocked, deferred, closed)\" },\n   251→            .{ .short = \"-v\", .long = \"--version\", .arg = \"NUM\", .description = \"Expected version for optimistic locking (fails if issue was modified)\" },\n   252→        },\n   253→        .examples = &[_]ExampleHelp{\n   254→            .{ .command = \"bz update bd-abc --title \\\"New title\\\"\", .description = \"Update title\" },\n   255→            .{ .command = \"bz update bd-abc -p critical -a alice\", .description = \"Update priority and assignee\" },\n   256→            .{ .command = \"bz update bd-abc -s in_progress\", .description = \"Change status to in_progress\" },\n   257→            .{ .command = \"bz update bd-abc -v 3 --title \\\"Safe update\\\"\", .description = \"Update only if version is 3 (optimistic lock)\" },\n   258→        },\n   259→        .see_also = &[_][]const u8{ \"show\", \"close\" },\n   260→    },\n   261→    .{\n   262→        .name = \"close\",\n   263→        .aliases = &[_][]const u8{ \"done\", \"finish\" },\n   264→        .summary = \"Close an issue\",\n   265→        .usage = \"bz close <id> [-r REASON]\",\n   266→        .description = \"Marks an issue as closed. Optionally provide a close reason.\",\n   267→        .arguments = &[_]ArgHelp{\n   268→            .{ .name = \"id\", .description = \"Issue ID to close\" },\n   269→        },\n   270→        .flags = &[_]FlagHelp{\n   271→            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Close reason (e.g., \\\"Fixed in PR #42\\\")\" },\n   272→        },\n   273→        .examples = &[_]ExampleHelp{\n   274→            .{ .command = \"bz close bd-abc123\", .description = \"Close an issue\" },\n   275→            .{ .command = \"bz close bd-abc -r \\\"Duplicate of bd-xyz\\\"\", .description = \"Close with reason\" },\n   276→            .{ .command = \"bz done bd-abc\", .description = \"Close using alias\" },\n   277→        },\n   278→        .see_also = &[_][]const u8{ \"reopen\", \"delete\" },\n   279→    },\n   280→    .{\n   281→        .name = \"reopen\",\n   282→        .summary = \"Reopen a closed issue\",\n   283→        .usage = \"bz reopen <id>\",\n   284→        .description = \"Changes a closed issue's status back to open.\",\n   285→        .arguments = &[_]ArgHelp{\n   286→            .{ .name = \"id\", .description = \"Issue ID to reopen\" },\n   287→        },\n   288→        .examples = &[_]ExampleHelp{\n   289→            .{ .command = \"bz reopen bd-abc123\", .description = \"Reopen a closed issue\" },\n   290→        },\n   291→        .see_also = &[_][]const u8{ \"close\", \"update\" },\n   292→    },\n   293→    .{\n   294→        .name = \"delete\",\n   295→        .aliases = &[_][]const u8{ \"rm\", \"remove\" },\n   296→        .summary = \"Soft delete an issue (tombstone)\",\n   297→        .usage = \"bz delete <id>\",\n   298→        .description = \"Marks an issue as deleted (tombstone status). The issue remains in \" ++\n   299→            \"the database but is hidden from normal queries. Can be restored via update.\",\n   300→        .arguments = &[_]ArgHelp{\n   301→            .{ .name = \"id\", .description = \"Issue ID to delete\" },\n   302→        },\n   303→        .examples = &[_]ExampleHelp{\n   304→            .{ .command = \"bz delete bd-abc123\", .description = \"Soft delete an issue\" },\n   305→            .{ .command = \"bz rm bd-abc\", .description = \"Delete using alias\" },\n   306→        },\n   307→        .see_also = &[_][]const u8{\"close\"},\n   308→    },\n   309→    .{\n   310→        .name = \"defer\",\n   311→        .summary = \"Defer an issue\",\n   312→        .usage = \"bz defer <id> [--until DATE] [-r REASON]\",\n   313→        .description = \"Marks an issue as deferred, optionally until a specific date.\",\n   314→        .arguments = &[_]ArgHelp{\n   315→            .{ .name = \"id\", .description = \"Issue ID to defer\" },\n   316→        },\n   317→        .flags = &[_]FlagHelp{\n   318→            .{ .short = \"-u\", .long = \"--until\", .arg = \"DATE\", .description = \"Date to resurface (YYYY-MM-DD or +7d)\" },\n   319→            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Reason for deferral\" },\n   320→        },\n   321→        .examples = &[_]ExampleHelp{\n   322→            .{ .command = \"bz defer bd-abc\", .description = \"Defer indefinitely\" },\n   323→            .{ .command = \"bz defer bd-abc --until 2024-03-01\", .description = \"Defer until specific date\" },\n   324→            .{ .command = \"bz defer bd-abc --until +7d\", .description = \"Defer for 7 days\" },\n   325→        },\n   326→        .see_also = &[_][]const u8{\"undefer\"},\n   327→    },\n   328→    .{\n   329→        .name = \"undefer\",\n   330→        .summary = \"Remove deferral from an issue\",\n   331→        .usage = \"bz undefer <id>\",\n   332→        .description = \"Clears the deferred status and defer_until date from an issue.\",\n   333→        .arguments = &[_]ArgHelp{\n   334→            .{ .name = \"id\", .description = \"Issue ID to undefer\" },\n   335→        },\n   336→        .examples = &[_]ExampleHelp{\n   337→            .{ .command = \"bz undefer bd-abc123\", .description = \"Remove deferral\" },\n   338→        },\n   339→        .see_also = &[_][]const u8{\"defer\"},\n   340→    },\n   341→\n   342→    // Batch operations\n   343→    .{\n   344→        .name = \"add-batch\",\n   345→        .aliases = &[_][]const u8{ \"batch-add\", \"batch\" },\n   346→        .summary = \"Create issues from stdin/file (single lock)\",\n   347→        .usage = \"bz add-batch [-f FILE] [--format FORMAT]\",\n   348→        .description = \"Creates multiple issues efficiently with a single lock acquisition. \" ++\n   349→            \"Reads from stdin or a file. Supports plain titles (one per line) or JSONL format.\",\n   350→        .flags = &[_]FlagHelp{\n   351→            .{ .short = \"-f\", .long = \"--file\", .arg = \"FILE\", .description = \"Read from file instead of stdin\" },\n   352→            .{ .short = null, .long = \"--format\", .arg = \"FMT\", .description = \"Input format: titles (default) or jsonl\" },\n   353→        },\n   354→        .examples = &[_]ExampleHelp{\n   355→            .{ .command = \"echo -e \\\"Task 1\\\\nTask 2\\\" | bz add-batch\", .description = \"Create from stdin\" },\n   356→            .{ .command = \"bz add-batch -f tasks.txt\", .description = \"Create from file (one title per line)\" },\n   357→            .{ .command = \"bz add-batch -f issues.jsonl --format jsonl\", .description = \"Create from JSONL file\" },\n   358→        },\n   359→        .see_also = &[_][]const u8{ \"create\", \"import\" },\n   360→    },\n   361→    .{\n   362→        .name = \"import\",\n   363→        .summary = \"Import issues from JSONL file\",\n   364→        .usage = \"bz import <file> [-m] [-n]\",\n   365→        .description = \"Imports issues from a JSONL file. Handles deduplication via content hash \" ++\n   366→            \"and external_ref matching.\",\n   367→        .arguments = &[_]ArgHelp{\n   368→            .{ .name = \"file\", .description = \"Path to JSONL file\" },\n   369→        },\n   370→        .flags = &[_]FlagHelp{\n   371→            .{ .short = \"-m\", .long = \"--merge\", .description = \"Merge with existing issues (update if exists)\" },\n   372→            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be imported without importing\" },\n   373→        },\n   374→        .examples = &[_]ExampleHelp{\n   375→            .{ .command = \"bz import backup.jsonl\", .description = \"Import from backup\" },\n   376→            .{ .command = \"bz import external.jsonl --merge\", .description = \"Merge external issues\" },\n   377→            .{ .command = \"bz import data.jsonl --dry-run\", .description = \"Preview import\" },\n   378→        },\n   379→        .see_also = &[_][]const u8{ \"sync\", \"add-batch\" },\n   380→    },\n   381→\n   382→    // Query commands\n   383→    .{\n   384→        .name = \"list\",\n   385→        .aliases = &[_][]const u8{\"ls\"},\n   386→        .summary = \"List issues with filters\",\n   387→        .usage = \"bz list [options]\",\n   388→        .description = \"Lists issues matching optional filters. By default shows only open issues. \" ++\n   389→            \"Use --all to include closed/deleted issues.\",\n   390→        .flags = &[_]FlagHelp{\n   391→            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"Filter by status\" },\n   392→            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Filter by priority\" },\n   393→            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Filter by issue type\" },\n   394→            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Filter by assignee\" },\n   395→            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Filter by label\" },\n   396→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n   397→            .{ .short = \"-A\", .long = \"--all\", .description = \"Include all statuses (not just open)\" },\n   398→            .{ .short = null, .long = \"--sort\", .arg = \"FIELD\", .description = \"Sort by: created, updated, or priority\" },\n   399→            .{ .short = null, .long = \"--asc\", .description = \"Sort ascending\" },\n   400→            .{ .short = null, .long = \"--desc\", .description = \"Sort descending (default)\" },\n   401→        },\n   402→        .examples = &[_]ExampleHelp{\n   403→            .{ .command = \"bz list\", .description = \"List open issues\" },\n   404→            .{ .command = \"bz list --all\", .description = \"List all issues\" },\n   405→            .{ .command = \"bz list -p high -t bug\", .description = \"High priority bugs\" },\n   406→            .{ .command = \"bz list --sort priority --asc\", .description = \"Sort by priority ascending\" },\n   407→            .{ .command = \"bz list -l backend -n 5\", .description = \"Top 5 issues with 'backend' label\" },\n   408→        },\n   409→        .see_also = &[_][]const u8{ \"ready\", \"blocked\", \"search\" },\n   410→    },\n   411→    .{\n   412→        .name = \"ready\",\n   413→        .summary = \"Show actionable issues (unblocked)\",\n   414→        .usage = \"bz ready [--limit N]\",\n   415→        .description = \"Lists open issues that have no unresolved blocking dependencies. \" ++\n   416→            \"These are issues ready to be worked on.\",\n   417→        .flags = &[_]FlagHelp{\n   418→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n   419→        },\n   420→        .examples = &[_]ExampleHelp{\n   421→            .{ .command = \"bz ready\", .description = \"Show all ready issues\" },\n   422→            .{ .command = \"bz ready -n 5\", .description = \"Show top 5 ready issues\" },\n   423→            .{ .command = \"bz ready --json\", .description = \"Get ready work as JSON (for agents)\" },\n   424→        },\n   425→        .see_also = &[_][]const u8{ \"blocked\", \"list\" },\n   426→    },\n   427→    .{\n   428→        .name = \"blocked\",\n   429→        .summary = \"Show blocked issues\",\n   430→        .usage = \"bz blocked [--limit N]\",\n   431→        .description = \"Lists open issues that have unresolved blocking dependencies.\",\n   432→        .flags = &[_]FlagHelp{\n   433→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n   434→        },\n   435→        .examples = &[_]ExampleHelp{\n   436→            .{ .command = \"bz blocked\", .description = \"Show all blocked issues\" },\n   437→            .{ .command = \"bz blocked --json\", .description = \"Get blocked issues as JSON\" },\n   438→        },\n   439→        .see_also = &[_][]const u8{ \"ready\", \"dep\" },\n   440→    },\n   441→    .{\n   442→        .name = \"search\",\n   443→        .aliases = &[_][]const u8{\"find\"},\n   444→        .summary = \"Full-text search\",\n   445→        .usage = \"bz search <query> [--limit N]\",\n   446→        .description = \"Searches issue titles and descriptions for the given query string.\",\n   447→        .arguments = &[_]ArgHelp{\n   448→            .{ .name = \"query\", .description = \"Search string\" },\n   449→        },\n   450→        .flags = &[_]FlagHelp{\n   451→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n   452→        },\n   453→        .examples = &[_]ExampleHelp{\n   454→            .{ .command = \"bz search login\", .description = \"Find issues mentioning 'login'\" },\n   455→            .{ .command = \"bz search \\\"OAuth flow\\\" -n 10\", .description = \"Search with limit\" },\n   456→        },\n   457→        .see_also = &[_][]const u8{\"list\"},\n   458→    },\n   459→    .{\n   460→        .name = \"stale\",\n   461→        .summary = \"Find issues not updated recently\",\n   462→        .usage = \"bz stale [--days N] [--limit N]\",\n   463→        .description = \"Lists open issues that haven't been updated within the specified \" ++\n   464→            \"number of days (default: 30).\",\n   465→        .flags = &[_]FlagHelp{\n   466→            .{ .short = \"-d\", .long = \"--days\", .arg = \"N\", .description = \"Days threshold (default: 30)\" },\n   467→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n   468→        },\n   469→        .examples = &[_]ExampleHelp{\n   470→            .{ .command = \"bz stale\", .description = \"Issues untouched for 30+ days\" },\n   471→            .{ .command = \"bz stale --days 7\", .description = \"Issues untouched for 7+ days\" },\n   472→        },\n   473→        .see_also = &[_][]const u8{\"list\"},\n   474→    },\n   475→    .{\n   476→        .name = \"count\",\n   477→        .summary = \"Count issues by group\",\n   478→        .usage = \"bz count [--group-by FIELD]\",\n   479→        .description = \"Counts issues, optionally grouped by a field.\",\n   480→        .flags = &[_]FlagHelp{\n   481→            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by: status, priority, type, assignee\" },\n   482→        },\n   483→        .examples = &[_]ExampleHelp{\n   484→            .{ .command = \"bz count\", .description = \"Total issue count\" },\n   485→            .{ .command = \"bz count --group-by status\", .description = \"Count by status\" },\n   486→            .{ .command = \"bz count -g priority\", .description = \"Count by priority\" },\n   487→        },\n   488→        .see_also = &[_][]const u8{ \"list\", \"stats\" },\n   489→    },\n   490→\n   491→    // Dependency commands\n   492→    .{\n   493→        .name = \"dep\",\n   494→        .aliases = &[_][]const u8{ \"deps\", \"dependency\" },\n   495→        .summary = \"Manage issue dependencies\",\n   496→        .usage = \"bz dep <subcommand> [args]\",\n   497→        .description = \"Add, remove, or query dependencies between issues. \" ++\n   498→            \"Dependencies are directional: A depends-on B means A is blocked by B.\",\n   499→        .arguments = &[_]ArgHelp{\n   500→            .{ .name = \"subcommand\", .description = \"add, remove, list, tree, or cycles\" },\n   501→        },\n   502→        .examples = &[_]ExampleHelp{\n   503→            .{ .command = \"bz dep add bd-child bd-parent\", .description = \"child depends on parent\" },\n   504→            .{ .command = \"bz dep add bd-a bd-b --type relates_to\", .description = \"Add non-blocking relation\" },\n   505→            .{ .command = \"bz dep remove bd-child bd-parent\", .description = \"Remove dependency\" },\n   506→            .{ .command = \"bz dep list bd-abc\", .description = \"List dependencies of an issue\" },\n   507→            .{ .command = \"bz dep tree bd-abc\", .description = \"Show dependency tree\" },\n   508→            .{ .command = \"bz dep cycles\", .description = \"Detect circular dependencies\" },\n   509→        },\n   510→        .see_also = &[_][]const u8{ \"graph\", \"ready\", \"blocked\" },\n   511→    },\n   512→    .{\n   513→        .name = \"graph\",\n   514→        .summary = \"Show dependency graph\",\n   515→        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n   516→        .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n   517→            \"With an ID, shows that issue's dependency subgraph.\",\n   518→        .arguments = &[_]ArgHelp{\n   519→            .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n   520→        },\n   521→        .flags = &[_]FlagHelp{\n   522→            .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n   523→            .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n   524→        },\n   525→        .examples = &[_]ExampleHelp{\n   526→            .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n   527→            .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n   528→            .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n   529→        },\n   530→        .see_also = &[_][]const u8{\"dep\"},\n   531→    },\n   532→\n   533→    // Epic commands\n   534→    .{\n   535→        .name = \"epic\",\n   536→        .aliases = &[_][]const u8{\"epics\"},\n   537→        .summary = \"Manage epics\",\n   538→        .usage = \"bz epic <subcommand> [args]\",\n   539→        .description = \"Epics are special issues that group related work. Use epic commands \" ++\n   540→            \"to create epics and manage their child issues.\",\n   541→        .arguments = &[_]ArgHelp{\n   542→            .{ .name = \"subcommand\", .description = \"create, add, remove, or list\" },\n   543→        },\n   544→        .examples = &[_]ExampleHelp{\n   545→            .{ .command = \"bz epic create \\\"Q1 Goals\\\"\", .description = \"Create a new epic\" },\n   546→            .{ .command = \"bz epic create \\\"Auth Overhaul\\\" -p high\", .description = \"Create with priority\" },\n   547→            .{ .command = \"bz epic add bd-epic bd-task\", .description = \"Add issue to epic\" },\n   548→            .{ .command = \"bz epic remove bd-epic bd-task\", .description = \"Remove issue from epic\" },\n   549→            .{ .command = \"bz epic list bd-epic\", .description = \"List issues in epic\" },\n   550→        },\n   551→        .see_also = &[_][]const u8{ \"create\", \"dep\" },\n   552→    },\n   553→\n   554→    // Label commands\n   555→    .{\n   556→        .name = \"label\",\n   557→        .aliases = &[_][]const u8{ \"labels\", \"tag\" },\n   558→        .summary = \"Manage issue labels\",\n   559→        .usage = \"bz label <subcommand> [args]\",\n   560→        .description = \"Add, remove, or list labels on issues.\",\n   561→        .arguments = &[_]ArgHelp{\n   562→            .{ .name = \"subcommand\", .description = \"add, remove, list, or list-all\" },\n   563→        },\n   564→        .examples = &[_]ExampleHelp{\n   565→            .{ .command = \"bz label add bd-abc urgent backend\", .description = \"Add multiple labels\" },\n   566→            .{ .command = \"bz label remove bd-abc old-label\", .description = \"Remove a label\" },\n   567→            .{ .command = \"bz label list bd-abc\", .description = \"List labels on issue\" },\n   568→            .{ .command = \"bz label list-all\", .description = \"List all labels in project\" },\n   569→        },\n   570→        .see_also = &[_][]const u8{ \"list\", \"create\" },\n   571→    },\n   572→\n   573→    // Comment commands\n   574→    .{\n   575→        .name = \"comments\",\n   576→        .aliases = &[_][]const u8{ \"comment\", \"note\" },\n   577→        .summary = \"Manage issue comments\",\n   578→        .usage = \"bz comments <subcommand> <id> [text]\",\n   579→        .description = \"Add or list comments on issues.\",\n   580→        .arguments = &[_]ArgHelp{\n   581→            .{ .name = \"subcommand\", .description = \"add or list\" },\n   582→            .{ .name = \"id\", .description = \"Issue ID\" },\n   583→            .{ .name = \"text\", .description = \"Comment text (for add)\", .required = false },\n   584→        },\n   585→        .examples = &[_]ExampleHelp{\n   586→            .{ .command = \"bz comments add bd-abc \\\"Working on this\\\"\", .description = \"Add a comment\" },\n   587→            .{ .command = \"bz comments list bd-abc\", .description = \"List comments\" },\n   588→        },\n   589→        .see_also = &[_][]const u8{ \"show\", \"history\" },\n   590→    },\n   591→\n   592→    // Audit commands\n   593→    .{\n   594→        .name = \"history\",\n   595→        .aliases = &[_][]const u8{\"log\"},\n   596→        .summary = \"Show issue history\",\n   597→        .usage = \"bz history <id>\",\n   598→        .description = \"Displays the change history for a specific issue.\",\n   599→        .arguments = &[_]ArgHelp{\n   600→            .{ .name = \"id\", .description = \"Issue ID\" },\n   601→        },\n   602→        .examples = &[_]ExampleHelp{\n   603→            .{ .command = \"bz history bd-abc123\", .description = \"Show change history\" },\n   604→        },\n   605→        .see_also = &[_][]const u8{ \"show\", \"audit\" },\n   606→    },\n   607→    .{\n   608→        .name = \"audit\",\n   609→        .summary = \"Project-wide audit log\",\n   610→        .usage = \"bz audit [--limit N]\",\n   611→        .description = \"Shows recent events across all issues.\",\n   612→        .flags = &[_]FlagHelp{\n   613→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum events\" },\n   614→        },\n   615→        .examples = &[_]ExampleHelp{\n   616→            .{ .command = \"bz audit\", .description = \"Show recent events\" },\n   617→            .{ .command = \"bz audit --limit 100\", .description = \"Show last 100 events\" },\n   618→        },\n   619→        .see_also = &[_][]const u8{ \"history\", \"changelog\" },\n   620→    },\n   621→    .{\n   622→        .name = \"changelog\",\n   623→        .summary = \"Generate changelog from closed issues\",\n   624→        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n   625→        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n   626→            \"by date range and grouped by type.\",\n   627→        .flags = &[_]FlagHelp{\n   628→            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n   629→            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n   630→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n   631→            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n   632→        },\n   633→        .examples = &[_]ExampleHelp{\n   634→            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n   635→            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n   636→            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n   637→        },\n   638→        .see_also = &[_][]const u8{\"audit\"},\n   639→    },\n   640→\n   641→    // System commands\n   642→    .{\n   643→        .name = \"version\",\n   644→        .summary = \"Show version\",\n   645→        .usage = \"bz version\",\n   646→        .description = \"Displays the beads_zig version and build information.\",\n   647→        .examples = &[_]ExampleHelp{\n   648→            .{ .command = \"bz version\", .description = \"Show version\" },\n   649→            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n   650→        },\n   651→    },\n   652→    .{\n   653→        .name = \"schema\",\n   654→        .summary = \"Show data schema\",\n   655→        .usage = \"bz schema\",\n   656→        .description = \"Displays the JSONL data schema for issues and related types.\",\n   657→        .examples = &[_]ExampleHelp{\n   658→            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n   659→        },\n   660→    },\n   661→    .{\n   662→        .name = \"completions\",\n   663→        .aliases = &[_][]const u8{\"completion\"},\n   664→        .summary = \"Generate shell completions\",\n   665→        .usage = \"bz completions <shell>\",\n   666→        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n   667→        .arguments = &[_]ArgHelp{\n   668→            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n   669→        },\n   670→        .examples = &[_]ExampleHelp{\n   671→            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n   672→            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n   673→            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },\n   674→        },\n   675→    },\n   676→    .{\n   677→        .name = \"help\",\n   678→        .summary = \"Show help\",\n   679→        .usage = \"bz help [command]\",\n   680→        .description = \"Shows general help or detailed help for a specific command.\",\n   681→        .arguments = &[_]ArgHelp{\n   682→            .{ .name = \"command\", .description = \"Command to get help for\", .required = false },\n   683→        },\n   684→        .examples = &[_]ExampleHelp{\n   685→            .{ .command = \"bz help\", .description = \"Show general help\" },\n   686→            .{ .command = \"bz help create\", .description = \"Show help for create command\" },\n   687→            .{ .command = \"bz --help\", .description = \"Same as bz help\" },\n   688→        },\n   689→    },\n   690→};\n   691→\n   692→/// Find help for a specific command (including aliases).\n   693→fn findCommand(name: []const u8) ?*const CommandHelp {\n   694→    for (&commands) |*cmd| {\n   695→        if (std.mem.eql(u8, cmd.name, name)) {\n   696→            return cmd;\n   697→        }\n   698→        for (cmd.aliases) |alias| {\n   699→            if (std.mem.eql(u8, alias, name)) {\n   700→                return cmd;\n   701→            }\n   702→        }\n   703→    }\n   704→    return null;\n   705→}\n   706→\n   707→/// Run the help command.\n   708→pub fn run(topic: ?[]const u8, allocator: std.mem.Allocator) !void {\n   709→    const stdout = std.fs.File.stdout();\n   710→    if (topic) |t| {\n   711→        try showCommandHelp(t, stdout, allocator);\n   712→    } else {\n   713→        try showGeneralHelp(stdout);\n   714→    }\n   715→}\n   716→\n   717→fn showGeneralHelp(file: std.fs.File) !void {\n   718→    try file.writeAll(\n   719→        \\\\bz - beads_zig issue tracker\n   720→        \\\\\n   721→        \\\\USAGE:\n   722→        \\\\  bz <command> [options]\n   723→        \\\\\n   724→        \\\\COMMANDS:\n   725→        \\\\  Workspace:\n   726→        \\\\    init              Initialize .beads/ workspace\n   727→        \\\\    info              Show workspace information\n   728→        \\\\    stats             Show project statistics\n   729→        \\\\    doctor            Run diagnostic checks\n   730→        \\\\    config            Manage configuration\n   731→        \\\\    sync              Sync with JSONL file\n   732→        \\\\    orphans           Find issues with missing parent refs\n   733→        \\\\    lint              Validate database consistency\n   734→        \\\\\n   735→        \\\\  Issue Management:\n   736→        \\\\    create <title>    Create new issue\n   737→        \\\\    q <title>         Quick capture (create + print ID only)\n   738→        \\\\    show <id>         Show issue details\n   739→        \\\\    update <id>       Update issue fields\n   740→        \\\\    close <id>        Close an issue\n   741→        \\\\    reopen <id>       Reopen a closed issue\n   742→        \\\\    delete <id>       Soft delete (tombstone)\n   743→        \\\\    defer <id>        Defer an issue\n   744→        \\\\    undefer <id>      Remove deferral from an issue\n   745→        \\\\\n   746→        \\\\  Batch Operations:\n   747→        \\\\    add-batch         Create issues from stdin/file (single lock)\n   748→        \\\\    import <file>     Import issues from JSONL file\n   749→        \\\\\n   750→        \\\\  Queries:\n   751→        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n   752→        \\\\    ready             Show actionable issues (unblocked)\n   753→        \\\\    blocked           Show blocked issues\n   754→        \\\\    search <query>    Full-text search\n   755→        \\\\    stale [--days N]  Find issues not updated recently\n   756→        \\\\    count [--group-by] Count issues by group\n   757→        \\\\\n   758→        \\\\  Dependencies:\n   759→        \\\\    dep add <a> <b>   Make issue A depend on B\n   760→        \\\\    dep remove <a> <b> Remove dependency\n   761→        \\\\    dep list <id>     List dependencies\n   762→        \\\\    dep tree <id>     Show dependency tree (ASCII)\n   763→        \\\\    dep cycles        Detect dependency cycles\n   764→        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n   765→        \\\\\n   766→        \\\\  Epics:\n   767→        \\\\    epic create <title>       Create a new epic\n   768→        \\\\    epic add <epic> <issue>   Add issue to epic\n   769→        \\\\    epic remove <epic> <issue> Remove issue from epic\n   770→        \\\\    epic list <epic>          List issues in epic\n   771→        \\\\\n   772→        \\\\  Labels:\n   773→        \\\\    label add <id> <labels...>    Add labels to an issue\n   774→        \\\\    label remove <id> <labels...> Remove labels from an issue\n   775→        \\\\    label list <id>               List labels on an issue\n   776→        \\\\    label list-all                List all labels in project\n   777→        \\\\\n   778→        \\\\  Comments:\n   779→        \\\\    comments add <id> <text>  Add comment to an issue\n   780→        \\\\    comments list <id>        List comments on an issue\n   781→        \\\\\n   782→        \\\\  Audit:\n   783→        \\\\    history <id>      Show issue history\n   784→        \\\\    audit             Project-wide audit log\n   785→        \\\\    changelog         Generate changelog from closed issues\n   786→        \\\\\n   787→        \\\\  System:\n   788→        \\\\    help              Show this help\n   789→        \\\\    version           Show version\n   790→        \\\\    schema            Show data schema\n   791→        \\\\    completions <shell>  Generate shell completions\n   792→        \\\\\n   793→        \\\\GLOBAL OPTIONS:\n   794→        \\\\  --json            Output in JSON format\n   795→        \\\\  --toon            Output in TOON format (LLM-optimized)\n   796→        \\\\  -q, --quiet       Suppress non-essential output\n   797→        \\\\  -v, --verbose     Increase verbosity\n   798→        \\\\  --no-color        Disable colors\n   799→        \\\\  --data <path>     Override .beads/ directory\n   800→        \\\\  --actor <name>    Override actor name for audit\n   801→        \\\\  --no-auto-flush   Skip automatic JSONL export\n   802→        \\\\  --no-auto-import  Skip JSONL freshness check\n   803→        \\\\\n   804→        \\\\Run 'bz help <command>' for command-specific help.\n   805→        \\\\\n   806→    );\n   807→}\n   808→\n   809→fn showCommandHelp(name: []const u8, file: std.fs.File, allocator: std.mem.Allocator) !void {\n   810→    const cmd = findCommand(name) orelse {\n   811→        const msg = try std.fmt.allocPrint(allocator, \"Unknown command: {s}\\n\\n\", .{name});\n   812→        defer allocator.free(msg);\n   813→        try file.writeAll(msg);\n   814→        try file.writeAll(\"Run 'bz help' for a list of available commands.\\n\");\n   815→        return;\n   816→    };\n   817→\n   818→    // Command name and aliases\n   819→    try file.writeAll(cmd.name);\n   820→    if (cmd.aliases.len > 0) {\n   821→        try file.writeAll(\" (\");\n   822→        for (cmd.aliases, 0..) |alias, i| {\n   823→            if (i > 0) try file.writeAll(\", \");\n   824→            try file.writeAll(alias);\n   825→        }\n   826→        try file.writeAll(\")\");\n   827→    }\n   828→    try file.writeAll(\"\\n\");\n   829→\n   830→    // Summary\n   831→    try file.writeAll(\"\\n\");\n   832→    try file.writeAll(cmd.summary);\n   833→    try file.writeAll(\"\\n\");\n   834→\n   835→    // Usage\n   836→    try file.writeAll(\"\\nUSAGE:\\n  \");\n   837→    try file.writeAll(cmd.usage);\n   838→    try file.writeAll(\"\\n\");\n   839→\n   840→    // Description\n   841→    if (cmd.description.len > 0) {\n   842→        try file.writeAll(\"\\nDESCRIPTION:\\n\");\n   843→        try writeWrapped(file, cmd.description, 2, 78, allocator);\n   844→    }\n   845→\n   846→    // Arguments\n   847→    if (cmd.arguments.len > 0) {\n   848→        try file.writeAll(\"\\nARGUMENTS:\\n\");\n   849→        for (cmd.arguments) |arg| {\n   850→            const req = if (arg.required) \" (required)\" else \" (optional)\";\n   851→            const line = try std.fmt.allocPrint(allocator, \"  {s}{s}\\n\", .{ arg.name, req });\n   852→            defer allocator.free(line);\n   853→            try file.writeAll(line);\n   854→            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{arg.description});\n   855→            defer allocator.free(desc);\n   856→            try file.writeAll(desc);\n   857→        }\n   858→    }\n   859→\n   860→    // Flags\n   861→    if (cmd.flags.len > 0) {\n   862→        try file.writeAll(\"\\nFLAGS:\\n\");\n   863→        for (cmd.flags) |flag| {\n   864→            if (flag.short) |short| {\n   865→                const line = try std.fmt.allocPrint(allocator, \"  {s}, {s}\", .{ short, flag.long });\n   866→                defer allocator.free(line);\n   867→                try file.writeAll(line);\n   868→            } else {\n   869→                const line = try std.fmt.allocPrint(allocator, \"      {s}\", .{flag.long});\n   870→                defer allocator.free(line);\n   871→                try file.writeAll(line);\n   872→            }\n   873→            if (flag.arg) |arg| {\n   874→                const argline = try std.fmt.allocPrint(allocator, \" <{s}>\", .{arg});\n   875→                defer allocator.free(argline);\n   876→                try file.writeAll(argline);\n   877→            }\n   878→            try file.writeAll(\"\\n\");\n   879→            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{flag.description});\n   880→            defer allocator.free(desc);\n   881→            try file.writeAll(desc);\n   882→        }\n   883→    }\n   884→\n   885→    // Examples\n   886→    if (cmd.examples.len > 0) {\n   887→        try file.writeAll(\"\\nEXAMPLES:\\n\");\n   888→        for (cmd.examples) |ex| {\n   889→            const cmd_line = try std.fmt.allocPrint(allocator, \"  $ {s}\\n\", .{ex.command});\n   890→            defer allocator.free(cmd_line);\n   891→            try file.writeAll(cmd_line);\n   892→            const desc_line = try std.fmt.allocPrint(allocator, \"    {s}\\n\\n\", .{ex.description});\n   893→            defer allocator.free(desc_line);\n   894→            try file.writeAll(desc_line);\n   895→        }\n   896→    }\n   897→\n   898→    // See also\n   899→    if (cmd.see_also.len > 0) {\n   900→        try file.writeAll(\"SEE ALSO:\\n  \");\n   901→        for (cmd.see_also, 0..) |ref, i| {\n   902→            if (i > 0) try file.writeAll(\", \");\n   903→            try file.writeAll(ref);\n   904→        }\n   905→        try file.writeAll(\"\\n\");\n   906→    }\n   907→}\n   908→\n   909→/// Write text with word wrapping.\n   910→fn writeWrapped(file: std.fs.File, text: []const u8, indent: usize, max_width: usize, allocator: std.mem.Allocator) !void {\n   911→    const effective_width = max_width - indent;\n   912→\n   913→    // Pre-allocate indent string\n   914→    const indent_str = try allocator.alloc(u8, indent);\n   915→    defer allocator.free(indent_str);\n   916→    @memset(indent_str, ' ');\n   917→\n   918→    var line_start: usize = 0;\n   919→    var last_space: ?usize = null;\n   920→    var col: usize = 0;\n   921→\n   922→    for (text, 0..) |c, i| {\n   923→        if (c == ' ') {\n   924→            last_space = i;\n   925→        }\n   926→        col += 1;\n   927→\n   928→        if (col >= effective_width) {\n   929→            const break_at = last_space orelse i;\n   930→            try file.writeAll(indent_str);\n   931→            try file.writeAll(text[line_start..break_at]);\n   932→            try file.writeAll(\"\\n\");\n   933→\n   934→            line_start = break_at + 1;\n   935→            col = i - break_at;\n   936→            last_space = null;\n   937→        }\n   938→    }\n   939→\n   940→    if (line_start < text.len) {\n   941→        try file.writeAll(indent_str);\n   942→        try file.writeAll(text[line_start..]);\n   943→        try file.writeAll(\"\\n\");\n   944→    }\n   945→}\n   946→\n   947→// Tests\n   948→\n   949→test \"findCommand finds by name\" {\n   950→    const cmd = findCommand(\"create\");\n   951→    try std.testing.expect(cmd != null);\n   952→    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n   953→}\n   954→\n   955→test \"findCommand finds by alias\" {\n   956→    const cmd = findCommand(\"add\");\n   957→    try std.testing.expect(cmd != null);\n   958→    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n   959→}\n   960→\n   961→test \"findCommand returns null for unknown\" {\n   962→    const cmd = findCommand(\"nonexistent\");\n   963→    try std.testing.expect(cmd == null);\n   964→}\n   965→\n   966→test \"findCommand finds all main commands\" {\n   967→    // Verify a sampling of commands can be found\n   968→    try std.testing.expect(findCommand(\"init\") != null);\n   969→    try std.testing.expect(findCommand(\"list\") != null);\n   970→    try std.testing.expect(findCommand(\"show\") != null);\n   971→    try std.testing.expect(findCommand(\"update\") != null);\n   972→    try std.testing.expect(findCommand(\"close\") != null);\n   973→    try std.testing.expect(findCommand(\"dep\") != null);\n   974→    try std.testing.expect(findCommand(\"help\") != null);\n   975→}\n   976→\n   977→test \"findCommand finds aliases\" {\n   978→    // Test common aliases\n   979→    try std.testing.expect(findCommand(\"ls\") != null);\n   980→    try std.testing.expectEqualStrings(\"list\", findCommand(\"ls\").?.name);\n   981→\n   982→    try std.testing.expect(findCommand(\"rm\") != null);\n   983→    try std.testing.expectEqualStrings(\"delete\", findCommand(\"rm\").?.name);\n   984→\n   985→    try std.testing.expect(findCommand(\"done\") != null);\n   986→    try std.testing.expectEqualStrings(\"close\", findCommand(\"done\").?.name);\n   987→}\n   988→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"71b67ef5-fd79-4556-8a28-a5f39b599878","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/help.zig","content":"//! Help command for beads_zig.\n//!\n//! Provides detailed per-command help with usage examples and flag references.\n\nconst std = @import(\"std\");\n\npub const HelpError = error{\n    WriteError,\n    OutOfMemory,\n};\n\npub const HelpResult = struct {\n    success: bool,\n    topic: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Command metadata for generating help text.\nconst CommandHelp = struct {\n    name: []const u8,\n    aliases: []const []const u8 = &[_][]const u8{},\n    summary: []const u8,\n    usage: []const u8,\n    description: []const u8 = \"\",\n    arguments: []const ArgHelp = &[_]ArgHelp{},\n    flags: []const FlagHelp = &[_]FlagHelp{},\n    examples: []const ExampleHelp = &[_]ExampleHelp{},\n    see_also: []const []const u8 = &[_][]const u8{},\n};\n\nconst ArgHelp = struct {\n    name: []const u8,\n    description: []const u8,\n    required: bool = true,\n};\n\nconst FlagHelp = struct {\n    short: ?[]const u8,\n    long: []const u8,\n    arg: ?[]const u8 = null,\n    description: []const u8,\n};\n\nconst ExampleHelp = struct {\n    command: []const u8,\n    description: []const u8,\n};\n\n/// All command help definitions.\nconst commands = [_]CommandHelp{\n    // Workspace commands\n    .{\n        .name = \"init\",\n        .summary = \"Initialize a .beads/ workspace\",\n        .usage = \"bz init [--prefix PREFIX]\",\n        .description = \"Creates the .beads/ directory structure for issue tracking. \" ++\n            \"This command must be run before using any other beads commands.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--prefix\", .arg = \"PREFIX\", .description = \"Issue ID prefix (default: bd)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz init\", .description = \"Initialize with default prefix 'bd'\" },\n            .{ .command = \"bz init --prefix proj\", .description = \"Use 'proj' as ID prefix (e.g., proj-abc123)\" },\n        },\n    },\n    .{\n        .name = \"info\",\n        .summary = \"Show workspace information\",\n        .usage = \"bz info\",\n        .description = \"Displays current workspace configuration, file locations, and basic status.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz info\", .description = \"Show workspace details\" },\n            .{ .command = \"bz info --json\", .description = \"Output as JSON for scripting\" },\n        },\n    },\n    .{\n        .name = \"stats\",\n        .summary = \"Show project statistics\",\n        .usage = \"bz stats\",\n        .description = \"Shows aggregate statistics about issues: counts by status, priority, type, etc.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stats\", .description = \"Show issue statistics\" },\n            .{ .command = \"bz stats --json\", .description = \"Output as JSON for dashboards\" },\n        },\n    },\n    .{\n        .name = \"doctor\",\n        .summary = \"Run diagnostic checks\",\n        .usage = \"bz doctor\",\n        .description = \"Checks workspace integrity: validates JSONL format, detects orphaned references, \" ++\n            \"and reports any data consistency issues.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz doctor\", .description = \"Run all diagnostic checks\" },\n        },\n    },\n    .{\n        .name = \"config\",\n        .summary = \"Manage configuration\",\n        .usage = \"bz config [get|set|list] [KEY] [VALUE]\",\n        .description = \"View or modify project configuration settings.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\n            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz config\", .description = \"List all configuration\" },\n            .{ .command = \"bz config list\", .description = \"Same as above\" },\n            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n        },\n    },\n    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },\n    },\n    .{\n        .name = \"orphans\",\n        .summary = \"Find issues with missing parent references\",\n        .usage = \"bz orphans [--limit N] [--hierarchy-only] [--deps-only]\",\n        .description = \"Identifies issues that reference non-existent parent issues or dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results to show\" },\n            .{ .short = null, .long = \"--hierarchy-only\", .description = \"Only check hierarchical parent refs\" },\n            .{ .short = null, .long = \"--deps-only\", .description = \"Only check dependency refs\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz orphans\", .description = \"Find all orphaned references\" },\n            .{ .command = \"bz orphans --limit 10\", .description = \"Show at most 10 orphans\" },\n        },\n    },\n    .{\n        .name = \"lint\",\n        .summary = \"Validate database consistency\",\n        .usage = \"bz lint [--limit N]\",\n        .description = \"Checks for data quality issues: empty titles, invalid priorities, \" ++\n            \"malformed IDs, and other consistency problems.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum issues to report\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz lint\", .description = \"Run all lint checks\" },\n        },\n    },\n\n    // Issue CRUD commands\n    .{\n        .name = \"create\",\n        .aliases = &[_][]const u8{ \"add\", \"new\" },\n        .summary = \"Create a new issue\",\n        .usage = \"bz create <title> [options]\",\n        .description = \"Creates a new issue with the given title. The issue is assigned a \" ++\n            \"unique ID and added to the database. Use flags to set optional fields.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title (1-500 characters)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"Detailed description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Issue type (task, bug, feature, epic, chore, docs, question)\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority (critical, high, medium, low, backlog, or 0-4)\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Assignee name or email\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Add label (can be repeated)\" },\n            .{ .short = null, .long = \"--depends-on\", .arg = \"ID\", .description = \"Add dependency (can be repeated)\" },\n            .{ .short = null, .long = \"--due\", .arg = \"DATE\", .description = \"Due date (YYYY-MM-DD)\" },\n            .{ .short = \"-e\", .long = \"--estimate\", .arg = \"MINS\", .description = \"Estimate in minutes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz create \\\"Fix login bug\\\"\", .description = \"Create a simple issue\" },\n            .{ .command = \"bz create \\\"Add OAuth\\\" -t feature -p high\", .description = \"Create a high-priority feature\" },\n            .{ .command = \"bz create \\\"Bug fix\\\" -l urgent -l backend\", .description = \"Create with multiple labels\" },\n            .{ .command = \"bz create \\\"Task\\\" --depends-on bd-abc123\", .description = \"Create with dependency\" },\n        },\n        .see_also = &[_][]const u8{ \"q\", \"show\", \"update\" },\n    },\n    .{\n        .name = \"q\",\n        .aliases = &[_][]const u8{\"quick\"},\n        .summary = \"Quick capture (create + print ID only)\",\n        .usage = \"bz q <title> [-p PRIORITY]\",\n        .description = \"Creates a new issue and prints only the ID. Optimized for scripting \" ++\n            \"and quick capture workflows.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority level\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz q \\\"Quick thought\\\"\", .description = \"Capture idea, get ID back\" },\n            .{ .command = \"ID=$(bz q \\\"Task\\\"); echo $ID\", .description = \"Capture ID in shell variable\" },\n            .{ .command = \"bz q \\\"Urgent fix\\\" -p critical\", .description = \"Quick capture with priority\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"add-batch\" },\n    },\n    .{\n        .name = \"show\",\n        .aliases = &[_][]const u8{ \"get\", \"view\" },\n        .summary = \"Show issue details\",\n        .usage = \"bz show <id> [--no-comments] [--with-history]\",\n        .description = \"Displays full details of an issue including description, status, \" ++\n            \"dependencies, labels, and comments.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (e.g., bd-abc123)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--no-comments\", .description = \"Hide comments\" },\n            .{ .short = null, .long = \"--with-history\", .description = \"Include change history\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz show bd-abc123\", .description = \"Show issue details\" },\n            .{ .command = \"bz show bd-abc --json\", .description = \"Get issue as JSON\" },\n            .{ .command = \"bz show bd-abc --with-history\", .description = \"Include change history\" },\n        },\n        .see_also = &[_][]const u8{ \"update\", \"history\" },\n    },\n    .{\n        .name = \"update\",\n        .aliases = &[_][]const u8{\"edit\"},\n        .summary = \"Update issue fields\",\n        .usage = \"bz update <id> [options]\",\n        .description = \"Modifies one or more fields of an existing issue. Only specified \" ++\n            \"fields are changed; others remain unchanged.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to update\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--title\", .arg = \"TEXT\", .description = \"New title\" },\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"New description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"New issue type\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"New priority\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"New assignee\" },\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"New status (open, in_progress, blocked, deferred, closed)\" },\n            .{ .short = \"-v\", .long = \"--version\", .arg = \"NUM\", .description = \"Expected version for optimistic locking (fails if issue was modified)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz update bd-abc --title \\\"New title\\\"\", .description = \"Update title\" },\n            .{ .command = \"bz update bd-abc -p critical -a alice\", .description = \"Update priority and assignee\" },\n            .{ .command = \"bz update bd-abc -s in_progress\", .description = \"Change status to in_progress\" },\n            .{ .command = \"bz update bd-abc -v 3 --title \\\"Safe update\\\"\", .description = \"Update only if version is 3 (optimistic lock)\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"close\" },\n    },\n    .{\n        .name = \"close\",\n        .aliases = &[_][]const u8{ \"done\", \"finish\" },\n        .summary = \"Close an issue\",\n        .usage = \"bz close <id> [-r REASON]\",\n        .description = \"Marks an issue as closed. Optionally provide a close reason.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to close\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Close reason (e.g., \\\"Fixed in PR #42\\\")\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz close bd-abc123\", .description = \"Close an issue\" },\n            .{ .command = \"bz close bd-abc -r \\\"Duplicate of bd-xyz\\\"\", .description = \"Close with reason\" },\n            .{ .command = \"bz done bd-abc\", .description = \"Close using alias\" },\n        },\n        .see_also = &[_][]const u8{ \"reopen\", \"delete\" },\n    },\n    .{\n        .name = \"reopen\",\n        .summary = \"Reopen a closed issue\",\n        .usage = \"bz reopen <id>\",\n        .description = \"Changes a closed issue's status back to open.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to reopen\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz reopen bd-abc123\", .description = \"Reopen a closed issue\" },\n        },\n        .see_also = &[_][]const u8{ \"close\", \"update\" },\n    },\n    .{\n        .name = \"delete\",\n        .aliases = &[_][]const u8{ \"rm\", \"remove\" },\n        .summary = \"Soft delete an issue (tombstone)\",\n        .usage = \"bz delete <id>\",\n        .description = \"Marks an issue as deleted (tombstone status). The issue remains in \" ++\n            \"the database but is hidden from normal queries. Can be restored via update.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to delete\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz delete bd-abc123\", .description = \"Soft delete an issue\" },\n            .{ .command = \"bz rm bd-abc\", .description = \"Delete using alias\" },\n        },\n        .see_also = &[_][]const u8{\"close\"},\n    },\n    .{\n        .name = \"defer\",\n        .summary = \"Defer an issue\",\n        .usage = \"bz defer <id> [--until DATE] [-r REASON]\",\n        .description = \"Marks an issue as deferred, optionally until a specific date.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to defer\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-u\", .long = \"--until\", .arg = \"DATE\", .description = \"Date to resurface (YYYY-MM-DD or +7d)\" },\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Reason for deferral\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz defer bd-abc\", .description = \"Defer indefinitely\" },\n            .{ .command = \"bz defer bd-abc --until 2024-03-01\", .description = \"Defer until specific date\" },\n            .{ .command = \"bz defer bd-abc --until +7d\", .description = \"Defer for 7 days\" },\n        },\n        .see_also = &[_][]const u8{\"undefer\"},\n    },\n    .{\n        .name = \"undefer\",\n        .summary = \"Remove deferral from an issue\",\n        .usage = \"bz undefer <id>\",\n        .description = \"Clears the deferred status and defer_until date from an issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to undefer\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz undefer bd-abc123\", .description = \"Remove deferral\" },\n        },\n        .see_also = &[_][]const u8{\"defer\"},\n    },\n\n    // Batch operations\n    .{\n        .name = \"add-batch\",\n        .aliases = &[_][]const u8{ \"batch-add\", \"batch\" },\n        .summary = \"Create issues from stdin/file (single lock)\",\n        .usage = \"bz add-batch [-f FILE] [--format FORMAT]\",\n        .description = \"Creates multiple issues efficiently with a single lock acquisition. \" ++\n            \"Reads from stdin or a file. Supports plain titles (one per line) or JSONL format.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--file\", .arg = \"FILE\", .description = \"Read from file instead of stdin\" },\n            .{ .short = null, .long = \"--format\", .arg = \"FMT\", .description = \"Input format: titles (default) or jsonl\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"echo -e \\\"Task 1\\\\nTask 2\\\" | bz add-batch\", .description = \"Create from stdin\" },\n            .{ .command = \"bz add-batch -f tasks.txt\", .description = \"Create from file (one title per line)\" },\n            .{ .command = \"bz add-batch -f issues.jsonl --format jsonl\", .description = \"Create from JSONL file\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"import\" },\n    },\n    .{\n        .name = \"import\",\n        .summary = \"Import issues from JSONL file\",\n        .usage = \"bz import <file> [-m] [-n]\",\n        .description = \"Imports issues from a JSONL file. Handles deduplication via content hash \" ++\n            \"and external_ref matching.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"file\", .description = \"Path to JSONL file\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"Merge with existing issues (update if exists)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be imported without importing\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz import backup.jsonl\", .description = \"Import from backup\" },\n            .{ .command = \"bz import external.jsonl --merge\", .description = \"Merge external issues\" },\n            .{ .command = \"bz import data.jsonl --dry-run\", .description = \"Preview import\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"add-batch\" },\n    },\n\n    // Query commands\n    .{\n        .name = \"list\",\n        .aliases = &[_][]const u8{\"ls\"},\n        .summary = \"List issues with filters\",\n        .usage = \"bz list [options]\",\n        .description = \"Lists issues matching optional filters. By default shows only open issues. \" ++\n            \"Use --all to include closed/deleted issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"Filter by status\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Filter by priority\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Filter by issue type\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Filter by assignee\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Filter by label\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n            .{ .short = \"-A\", .long = \"--all\", .description = \"Include all statuses (not just open)\" },\n            .{ .short = null, .long = \"--sort\", .arg = \"FIELD\", .description = \"Sort by: created, updated, or priority\" },\n            .{ .short = null, .long = \"--asc\", .description = \"Sort ascending\" },\n            .{ .short = null, .long = \"--desc\", .description = \"Sort descending (default)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz list\", .description = \"List open issues\" },\n            .{ .command = \"bz list --all\", .description = \"List all issues\" },\n            .{ .command = \"bz list -p high -t bug\", .description = \"High priority bugs\" },\n            .{ .command = \"bz list --sort priority --asc\", .description = \"Sort by priority ascending\" },\n            .{ .command = \"bz list -l backend -n 5\", .description = \"Top 5 issues with 'backend' label\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"blocked\", \"search\" },\n    },\n    .{\n        .name = \"ready\",\n        .summary = \"Show actionable issues (unblocked)\",\n        .usage = \"bz ready [--limit N]\",\n        .description = \"Lists open issues that have no unresolved blocking dependencies. \" ++\n            \"These are issues ready to be worked on.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz ready\", .description = \"Show all ready issues\" },\n            .{ .command = \"bz ready -n 5\", .description = \"Show top 5 ready issues\" },\n            .{ .command = \"bz ready --json\", .description = \"Get ready work as JSON (for agents)\" },\n        },\n        .see_also = &[_][]const u8{ \"blocked\", \"list\" },\n    },\n    .{\n        .name = \"blocked\",\n        .summary = \"Show blocked issues\",\n        .usage = \"bz blocked [--limit N]\",\n        .description = \"Lists open issues that have unresolved blocking dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz blocked\", .description = \"Show all blocked issues\" },\n            .{ .command = \"bz blocked --json\", .description = \"Get blocked issues as JSON\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"dep\" },\n    },\n    .{\n        .name = \"search\",\n        .aliases = &[_][]const u8{\"find\"},\n        .summary = \"Full-text search\",\n        .usage = \"bz search <query> [--limit N]\",\n        .description = \"Searches issue titles and descriptions for the given query string.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"query\", .description = \"Search string\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz search login\", .description = \"Find issues mentioning 'login'\" },\n            .{ .command = \"bz search \\\"OAuth flow\\\" -n 10\", .description = \"Search with limit\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"stale\",\n        .summary = \"Find issues not updated recently\",\n        .usage = \"bz stale [--days N] [--limit N]\",\n        .description = \"Lists open issues that haven't been updated within the specified \" ++\n            \"number of days (default: 30).\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--days\", .arg = \"N\", .description = \"Days threshold (default: 30)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stale\", .description = \"Issues untouched for 30+ days\" },\n            .{ .command = \"bz stale --days 7\", .description = \"Issues untouched for 7+ days\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"count\",\n        .summary = \"Count issues by group\",\n        .usage = \"bz count [--group-by FIELD]\",\n        .description = \"Counts issues, optionally grouped by a field.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by: status, priority, type, assignee\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz count\", .description = \"Total issue count\" },\n            .{ .command = \"bz count --group-by status\", .description = \"Count by status\" },\n            .{ .command = \"bz count -g priority\", .description = \"Count by priority\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"stats\" },\n    },\n\n    // Dependency commands\n    .{\n        .name = \"dep\",\n        .aliases = &[_][]const u8{ \"deps\", \"dependency\" },\n        .summary = \"Manage issue dependencies\",\n        .usage = \"bz dep <subcommand> [args]\",\n        .description = \"Add, remove, or query dependencies between issues. \" ++\n            \"Dependencies are directional: A depends-on B means A is blocked by B.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, tree, or cycles\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz dep add bd-child bd-parent\", .description = \"child depends on parent\" },\n            .{ .command = \"bz dep add bd-a bd-b --type relates_to\", .description = \"Add non-blocking relation\" },\n            .{ .command = \"bz dep remove bd-child bd-parent\", .description = \"Remove dependency\" },\n            .{ .command = \"bz dep list bd-abc\", .description = \"List dependencies of an issue\" },\n            .{ .command = \"bz dep tree bd-abc\", .description = \"Show dependency tree\" },\n            .{ .command = \"bz dep cycles\", .description = \"Detect circular dependencies\" },\n        },\n        .see_also = &[_][]const u8{ \"graph\", \"ready\", \"blocked\" },\n    },\n    .{\n        .name = \"graph\",\n        .summary = \"Show dependency graph\",\n        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n        .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n            \"With an ID, shows that issue's dependency subgraph.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n            .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n            .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n            .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n        },\n        .see_also = &[_][]const u8{\"dep\"},\n    },\n\n    // Epic commands\n    .{\n        .name = \"epic\",\n        .aliases = &[_][]const u8{\"epics\"},\n        .summary = \"Manage epics\",\n        .usage = \"bz epic <subcommand> [args]\",\n        .description = \"Epics are special issues that group related work. Use epic commands \" ++\n            \"to create epics and manage their child issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"create, add, remove, or list\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz epic create \\\"Q1 Goals\\\"\", .description = \"Create a new epic\" },\n            .{ .command = \"bz epic create \\\"Auth Overhaul\\\" -p high\", .description = \"Create with priority\" },\n            .{ .command = \"bz epic add bd-epic bd-task\", .description = \"Add issue to epic\" },\n            .{ .command = \"bz epic remove bd-epic bd-task\", .description = \"Remove issue from epic\" },\n            .{ .command = \"bz epic list bd-epic\", .description = \"List issues in epic\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"dep\" },\n    },\n\n    // Label commands\n    .{\n        .name = \"label\",\n        .aliases = &[_][]const u8{ \"labels\", \"tag\" },\n        .summary = \"Manage issue labels\",\n        .usage = \"bz label <subcommand> [args]\",\n        .description = \"Add, remove, or list labels on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, or list-all\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz label add bd-abc urgent backend\", .description = \"Add multiple labels\" },\n            .{ .command = \"bz label remove bd-abc old-label\", .description = \"Remove a label\" },\n            .{ .command = \"bz label list bd-abc\", .description = \"List labels on issue\" },\n            .{ .command = \"bz label list-all\", .description = \"List all labels in project\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"create\" },\n    },\n\n    // Comment commands\n    .{\n        .name = \"comments\",\n        .aliases = &[_][]const u8{ \"comment\", \"note\" },\n        .summary = \"Manage issue comments\",\n        .usage = \"bz comments <subcommand> <id> [text]\",\n        .description = \"Add or list comments on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add or list\" },\n            .{ .name = \"id\", .description = \"Issue ID\" },\n            .{ .name = \"text\", .description = \"Comment text (for add)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz comments add bd-abc \\\"Working on this\\\"\", .description = \"Add a comment\" },\n            .{ .command = \"bz comments list bd-abc\", .description = \"List comments\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"history\" },\n    },\n\n    // Audit commands\n    .{\n        .name = \"history\",\n        .aliases = &[_][]const u8{\"log\"},\n        .summary = \"Show issue history\",\n        .usage = \"bz history <id>\",\n        .description = \"Displays the change history for a specific issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz history bd-abc123\", .description = \"Show change history\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"audit\" },\n    },\n    .{\n        .name = \"audit\",\n        .summary = \"Project-wide audit log\",\n        .usage = \"bz audit [--limit N]\",\n        .description = \"Shows recent events across all issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum events\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz audit\", .description = \"Show recent events\" },\n            .{ .command = \"bz audit --limit 100\", .description = \"Show last 100 events\" },\n        },\n        .see_also = &[_][]const u8{ \"history\", \"changelog\" },\n    },\n    .{\n        .name = \"changelog\",\n        .summary = \"Generate changelog from closed issues\",\n        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n            \"by date range and grouped by type.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n        },\n        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // System commands\n    .{\n        .name = \"version\",\n        .summary = \"Show version\",\n        .usage = \"bz version\",\n        .description = \"Displays the beads_zig version and build information.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz version\", .description = \"Show version\" },\n            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n        },\n    },\n    .{\n        .name = \"schema\",\n        .summary = \"Show data schema\",\n        .usage = \"bz schema\",\n        .description = \"Displays the JSONL data schema for issues and related types.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n        },\n    },\n    .{\n        .name = \"completions\",\n        .aliases = &[_][]const u8{\"completion\"},\n        .summary = \"Generate shell completions\",\n        .usage = \"bz completions <shell>\",\n        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },\n        },\n    },\n    .{\n        .name = \"help\",\n        .summary = \"Show help\",\n        .usage = \"bz help [command]\",\n        .description = \"Shows general help or detailed help for a specific command.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"command\", .description = \"Command to get help for\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz help\", .description = \"Show general help\" },\n            .{ .command = \"bz help create\", .description = \"Show help for create command\" },\n            .{ .command = \"bz --help\", .description = \"Same as bz help\" },\n        },\n    },\n};\n\n/// Find help for a specific command (including aliases).\nfn findCommand(name: []const u8) ?*const CommandHelp {\n    for (&commands) |*cmd| {\n        if (std.mem.eql(u8, cmd.name, name)) {\n            return cmd;\n        }\n        for (cmd.aliases) |alias| {\n            if (std.mem.eql(u8, alias, name)) {\n                return cmd;\n            }\n        }\n    }\n    return null;\n}\n\n/// Run the help command.\npub fn run(topic: ?[]const u8, allocator: std.mem.Allocator) !void {\n    const stdout = std.fs.File.stdout();\n    if (topic) |t| {\n        try showCommandHelp(t, stdout, allocator);\n    } else {\n        try showGeneralHelp(stdout);\n    }\n}\n\nfn showGeneralHelp(file: std.fs.File) !void {\n    try file.writeAll(\n        \\\\bz - beads_zig issue tracker\n        \\\\\n        \\\\USAGE:\n        \\\\  bz <command> [options]\n        \\\\\n        \\\\COMMANDS:\n        \\\\  Workspace:\n        \\\\    init              Initialize .beads/ workspace\n        \\\\    info              Show workspace information\n        \\\\    stats             Show project statistics\n        \\\\    doctor            Run diagnostic checks\n        \\\\    config            Manage configuration\n        \\\\    sync              Sync with JSONL file\n        \\\\    orphans           Find issues with missing parent refs\n        \\\\    lint              Validate database consistency\n        \\\\\n        \\\\  Issue Management:\n        \\\\    create <title>    Create new issue\n        \\\\    q <title>         Quick capture (create + print ID only)\n        \\\\    show <id>         Show issue details\n        \\\\    update <id>       Update issue fields\n        \\\\    close <id>        Close an issue\n        \\\\    reopen <id>       Reopen a closed issue\n        \\\\    delete <id>       Soft delete (tombstone)\n        \\\\    defer <id>        Defer an issue\n        \\\\    undefer <id>      Remove deferral from an issue\n        \\\\\n        \\\\  Batch Operations:\n        \\\\    add-batch         Create issues from stdin/file (single lock)\n        \\\\    import <file>     Import issues from JSONL file\n        \\\\\n        \\\\  Queries:\n        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n        \\\\    ready             Show actionable issues (unblocked)\n        \\\\    blocked           Show blocked issues\n        \\\\    search <query>    Full-text search\n        \\\\    stale [--days N]  Find issues not updated recently\n        \\\\    count [--group-by] Count issues by group\n        \\\\\n        \\\\  Dependencies:\n        \\\\    dep add <a> <b>   Make issue A depend on B\n        \\\\    dep remove <a> <b> Remove dependency\n        \\\\    dep list <id>     List dependencies\n        \\\\    dep tree <id>     Show dependency tree (ASCII)\n        \\\\    dep cycles        Detect dependency cycles\n        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n        \\\\\n        \\\\  Epics:\n        \\\\    epic create <title>       Create a new epic\n        \\\\    epic add <epic> <issue>   Add issue to epic\n        \\\\    epic remove <epic> <issue> Remove issue from epic\n        \\\\    epic list <epic>          List issues in epic\n        \\\\\n        \\\\  Labels:\n        \\\\    label add <id> <labels...>    Add labels to an issue\n        \\\\    label remove <id> <labels...> Remove labels from an issue\n        \\\\    label list <id>               List labels on an issue\n        \\\\    label list-all                List all labels in project\n        \\\\\n        \\\\  Comments:\n        \\\\    comments add <id> <text>  Add comment to an issue\n        \\\\    comments list <id>        List comments on an issue\n        \\\\\n        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:\n        \\\\    help              Show this help\n        \\\\    version           Show version\n        \\\\    schema            Show data schema\n        \\\\    completions <shell>  Generate shell completions\n        \\\\\n        \\\\GLOBAL OPTIONS:\n        \\\\  --json            Output in JSON format\n        \\\\  --toon            Output in TOON format (LLM-optimized)\n        \\\\  -q, --quiet       Suppress non-essential output\n        \\\\  -v, --verbose     Increase verbosity\n        \\\\  --no-color        Disable colors\n        \\\\  --data <path>     Override .beads/ directory\n        \\\\  --actor <name>    Override actor name for audit\n        \\\\  --no-auto-flush   Skip automatic JSONL export\n        \\\\  --no-auto-import  Skip JSONL freshness check\n        \\\\\n        \\\\Run 'bz help <command>' for command-specific help.\n        \\\\\n    );\n}\n\nfn showCommandHelp(name: []const u8, file: std.fs.File, allocator: std.mem.Allocator) !void {\n    const cmd = findCommand(name) orelse {\n        const msg = try std.fmt.allocPrint(allocator, \"Unknown command: {s}\\n\\n\", .{name});\n        defer allocator.free(msg);\n        try file.writeAll(msg);\n        try file.writeAll(\"Run 'bz help' for a list of available commands.\\n\");\n        return;\n    };\n\n    // Command name and aliases\n    try file.writeAll(cmd.name);\n    if (cmd.aliases.len > 0) {\n        try file.writeAll(\" (\");\n        for (cmd.aliases, 0..) |alias, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(alias);\n        }\n        try file.writeAll(\")\");\n    }\n    try file.writeAll(\"\\n\");\n\n    // Summary\n    try file.writeAll(\"\\n\");\n    try file.writeAll(cmd.summary);\n    try file.writeAll(\"\\n\");\n\n    // Usage\n    try file.writeAll(\"\\nUSAGE:\\n  \");\n    try file.writeAll(cmd.usage);\n    try file.writeAll(\"\\n\");\n\n    // Description\n    if (cmd.description.len > 0) {\n        try file.writeAll(\"\\nDESCRIPTION:\\n\");\n        try writeWrapped(file, cmd.description, 2, 78, allocator);\n    }\n\n    // Arguments\n    if (cmd.arguments.len > 0) {\n        try file.writeAll(\"\\nARGUMENTS:\\n\");\n        for (cmd.arguments) |arg| {\n            const req = if (arg.required) \" (required)\" else \" (optional)\";\n            const line = try std.fmt.allocPrint(allocator, \"  {s}{s}\\n\", .{ arg.name, req });\n            defer allocator.free(line);\n            try file.writeAll(line);\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{arg.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Flags\n    if (cmd.flags.len > 0) {\n        try file.writeAll(\"\\nFLAGS:\\n\");\n        for (cmd.flags) |flag| {\n            if (flag.short) |short| {\n                const line = try std.fmt.allocPrint(allocator, \"  {s}, {s}\", .{ short, flag.long });\n                defer allocator.free(line);\n                try file.writeAll(line);\n            } else {\n                const line = try std.fmt.allocPrint(allocator, \"      {s}\", .{flag.long});\n                defer allocator.free(line);\n                try file.writeAll(line);\n            }\n            if (flag.arg) |arg| {\n                const argline = try std.fmt.allocPrint(allocator, \" <{s}>\", .{arg});\n                defer allocator.free(argline);\n                try file.writeAll(argline);\n            }\n            try file.writeAll(\"\\n\");\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{flag.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Examples\n    if (cmd.examples.len > 0) {\n        try file.writeAll(\"\\nEXAMPLES:\\n\");\n        for (cmd.examples) |ex| {\n            const cmd_line = try std.fmt.allocPrint(allocator, \"  $ {s}\\n\", .{ex.command});\n            defer allocator.free(cmd_line);\n            try file.writeAll(cmd_line);\n            const desc_line = try std.fmt.allocPrint(allocator, \"    {s}\\n\\n\", .{ex.description});\n            defer allocator.free(desc_line);\n            try file.writeAll(desc_line);\n        }\n    }\n\n    // See also\n    if (cmd.see_also.len > 0) {\n        try file.writeAll(\"SEE ALSO:\\n  \");\n        for (cmd.see_also, 0..) |ref, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(ref);\n        }\n        try file.writeAll(\"\\n\");\n    }\n}\n\n/// Write text with word wrapping.\nfn writeWrapped(file: std.fs.File, text: []const u8, indent: usize, max_width: usize, allocator: std.mem.Allocator) !void {\n    const effective_width = max_width - indent;\n\n    // Pre-allocate indent string\n    const indent_str = try allocator.alloc(u8, indent);\n    defer allocator.free(indent_str);\n    @memset(indent_str, ' ');\n\n    var line_start: usize = 0;\n    var last_space: ?usize = null;\n    var col: usize = 0;\n\n    for (text, 0..) |c, i| {\n        if (c == ' ') {\n            last_space = i;\n        }\n        col += 1;\n\n        if (col >= effective_width) {\n            const break_at = last_space orelse i;\n            try file.writeAll(indent_str);\n            try file.writeAll(text[line_start..break_at]);\n            try file.writeAll(\"\\n\");\n\n            line_start = break_at + 1;\n            col = i - break_at;\n            last_space = null;\n        }\n    }\n\n    if (line_start < text.len) {\n        try file.writeAll(indent_str);\n        try file.writeAll(text[line_start..]);\n        try file.writeAll(\"\\n\");\n    }\n}\n\n// Tests\n\ntest \"findCommand finds by name\" {\n    const cmd = findCommand(\"create\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand finds by alias\" {\n    const cmd = findCommand(\"add\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand returns null for unknown\" {\n    const cmd = findCommand(\"nonexistent\");\n    try std.testing.expect(cmd == null);\n}\n\ntest \"findCommand finds all main commands\" {\n    // Verify a sampling of commands can be found\n    try std.testing.expect(findCommand(\"init\") != null);\n    try std.testing.expect(findCommand(\"list\") != null);\n    try std.testing.expect(findCommand(\"show\") != null);\n    try std.testing.expect(findCommand(\"update\") != null);\n    try std.testing.expect(findCommand(\"close\") != null);\n    try std.testing.expect(findCommand(\"dep\") != null);\n    try std.testing.expect(findCommand(\"help\") != null);\n}\n\ntest \"findCommand finds aliases\" {\n    // Test common aliases\n    try std.testing.expect(findCommand(\"ls\") != null);\n    try std.testing.expectEqualStrings(\"list\", findCommand(\"ls\").?.name);\n\n    try std.testing.expect(findCommand(\"rm\") != null);\n    try std.testing.expectEqualStrings(\"delete\", findCommand(\"rm\").?.name);\n\n    try std.testing.expect(findCommand(\"done\") != null);\n    try std.testing.expectEqualStrings(\"close\", findCommand(\"done\").?.name);\n}\n","numLines":988,"startLine":1,"totalLines":988}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UuREimQKcJp3zxQ78jpxRu","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase. Let me create a todo list to track the implementation of both tasks."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":18868,"cache_read_input_tokens":57074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":18868},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"254da1c4-bf20-485b-9011-9c10f594d949"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UuREimQKcJp3zxQ78jpxRu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DrwqVVwirGkzT4L3vphVG9","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"pending","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"pending","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"pending","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"pending","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":18868,"cache_read_input_tokens":57074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":18868},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"70a11570-e8b7-49a1-9ddd-c582de4f5296"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DrwqVVwirGkzT4L3vphVG9","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2aa8a807-f9d1-47c2-9807-0d48c4eb5ffb","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"pending","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"pending","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"pending","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"pending","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Fj2SkTbWJQeUy2MJFECsyA","type":"message","role":"assistant","content":[{"type":"text","text":"Let me start with Task 1: Add sync policy options. First, I need to add the policy enums to args.zig."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":530,"cache_read_input_tokens":75942,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":530},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a504c9fe-64c8-4d21-b4f1-814c53b12b3c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Fj2SkTbWJQeUy2MJFECsyA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FZw9hwwJ1FwfJdPrCQz27u","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":485,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":530,"cache_read_input_tokens":75942,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":530},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2a2fc042-9a40-4394-8d8c-4f0649bfc37d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FZw9hwwJ1FwfJdPrCQz27u","type":"tool_result","content":"   485→};\n   486→\n   487→/// Sync command arguments.\n   488→pub const SyncArgs = struct {\n   489→    flush_only: bool = false,\n   490→    import_only: bool = false,\n   491→    merge: bool = false,\n   492→    status: bool = false,\n   493→    manifest: bool = false,\n   494→};\n   495→\n   496→/// Shell completion types.\n   497→pub const Shell = enum {\n   498→    bash,\n   499→    zsh,\n   500→    fish,\n   501→    powershell,\n   502→\n   503→    pub fn fromString(s: []const u8) ?Shell {\n   504→        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n   505→        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n   506→        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n   507→        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n   508→        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n   509→        return null;\n   510→    }\n   511→};\n   512→\n   513→/// Completions command arguments.\n   514→pub const CompletionsArgs = struct {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"36d2e119-bf13-42f6-8a17-cd64e75d479c","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {","numLines":30,"startLine":485,"totalLines":2638}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018ipAueor9MEKGQVd9vxuAW","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll add the new policy enums and update SyncArgs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":587,"cache_read_input_tokens":76472,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":587},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"299f5341-a28a-4807-a194-5d6ed1bd6175"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018ipAueor9MEKGQVd9vxuAW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EC8G74ej1GqRsZwEvcu2Wj","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n};","new_string":"/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":587,"cache_read_input_tokens":76472,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":587},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6c533b39-4c06-4b00-abb8-c666ffa6cd52"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EC8G74ej1GqRsZwEvcu2Wj","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"de01acd7-7b5a-46bf-afe0-a48dc1f887e3","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n};","newString":"/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":484,"oldLines":6,"newStart":484,"newLines":34,"lines":["     group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")"," };"," ","+/// Error policy for export operations.","+pub const ErrorPolicy = enum {","+    strict, // Fail on any error","+    best_effort, // Continue on errors, report at end","+    partial, // Export what we can, skip errors silently","+","+    pub fn fromString(s: []const u8) ?ErrorPolicy {","+        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;","+        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;","+        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;","+        return null;","+    }","+};","+","+/// Orphan handling policy for import operations.","+pub const OrphanPolicy = enum {","+    strict, // Fail if orphans detected","+    resurrect, // Create placeholder parents for orphans","+    skip, // Skip orphaned issues silently","+","+    pub fn fromString(s: []const u8) ?OrphanPolicy {","+        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;","+        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;","+        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;","+        return null;","+    }","+};","+"," /// Sync command arguments."," pub const SyncArgs = struct {","     flush_only: bool = false,"]},{"oldStart":491,"oldLines":6,"newStart":519,"newLines":9,"lines":["     merge: bool = false,","     status: bool = false,","     manifest: bool = false,","+    error_policy: ErrorPolicy = .strict,","+    orphan_policy: OrphanPolicy = .strict,","+    rename_prefix: bool = false,"," };"," "," /// Shell completion types."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018J9tzG4ypQ9miGmZYhdVAn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VXfpKkq86YPmos1fFPezn6","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"in_progress","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"pending","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":673,"cache_read_input_tokens":77059,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":673},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ebc33161-7993-4ca7-a164-a1deefbb6fe5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VXfpKkq86YPmos1fFPezn6","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a9dbab3b-0f3a-4979-8714-fd9f41e0e038","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"pending","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"pending","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"pending","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"pending","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"in_progress","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"pending","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0186Jq96cHGrvkoK16DAUytZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update parseSyncArgs to handle the new flags."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":505,"cache_read_input_tokens":77732,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":505},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e9cff85e-bec7-489a-8236-7b7bcea4e134"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0186Jq96cHGrvkoK16DAUytZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A9sWoDxmA1kcvdNugAZemA","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else break;\n        }\n        return result;\n    }","new_string":"    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":505,"cache_read_input_tokens":77732,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":505},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"434e7766-5b22-4a6e-b6b3-5b9b0ef1bf67"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A9sWoDxmA1kcvdNugAZemA","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6a89663b-a4e3-4a7c-85df-aa849aec3ef2","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else break;\n        }\n        return result;\n    }","newString":"    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1558,"oldLines":6,"newStart":1558,"newLines":14,"lines":["                 result.status = true;","             } else if (self.consumeFlag(null, \"--manifest\")) {","                 result.manifest = true;","+            } else if (self.consumeFlag(null, \"--error-policy\")) {","+                const policy_str = self.next() orelse return error.MissingFlagValue;","+                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;","+            } else if (self.consumeFlag(null, \"--orphans\")) {","+                const policy_str = self.next() orelse return error.MissingFlagValue;","+                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;","+            } else if (self.consumeFlag(null, \"--rename-prefix\")) {","+                result.rename_prefix = true;","             } else break;","         }","         return result;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Uj4VYjpCunMgshHWh3ysSx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FMmeBJ5gyi1P1zo5FbVY43","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"completed","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"in_progress","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":745,"cache_read_input_tokens":78237,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":745},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"1183b84e-4924-40d8-a205-6b005a4c4755"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FMmeBJ5gyi1P1zo5FbVY43","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4cab7a6b-5d6c-45ce-85ab-1a319e220530","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"in_progress","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"pending","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"completed","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"in_progress","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MydxDR2LhugbVoY4bxZQ4f","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the help.zig file to include the new sync flags."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":505,"cache_read_input_tokens":78982,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":505},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4f551ab5-701f-4662-8887-22eca4d9b81f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MydxDR2LhugbVoY4bxZQ4f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RvVtn3xyDmvjigB6dTCdMp","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig","old_string":"    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },\n    },","new_string":"    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n            .{ .short = null, .long = \"--error-policy\", .arg = \"POLICY\", .description = \"Export error handling: strict (default), best-effort, partial\" },\n            .{ .short = null, .long = \"--orphans\", .arg = \"POLICY\", .description = \"Import orphan handling: strict (default), resurrect, skip\" },\n            .{ .short = null, .long = \"--rename-prefix\", .description = \"Fix issues with wrong prefix during import\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n            .{ .command = \"bz sync --flush-only --error-policy best-effort\", .description = \"Export, continuing on errors\" },\n            .{ .command = \"bz sync --import-only --orphans resurrect\", .description = \"Import, creating placeholders for orphans\" },\n            .{ .command = \"bz sync --import-only --rename-prefix\", .description = \"Import and fix wrong ID prefixes\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\", \"backup\" },\n    },"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":505,"cache_read_input_tokens":78982,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":505},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3f618277-d6a2-4934-876e-7797dc1a927e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RvVtn3xyDmvjigB6dTCdMp","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/help.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c67ce643-8b94-4647-82ed-a9eef02ba5df","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/help.zig","oldString":"    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },\n    },","newString":"    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n            .{ .short = null, .long = \"--error-policy\", .arg = \"POLICY\", .description = \"Export error handling: strict (default), best-effort, partial\" },\n            .{ .short = null, .long = \"--orphans\", .arg = \"POLICY\", .description = \"Import orphan handling: strict (default), resurrect, skip\" },\n            .{ .short = null, .long = \"--rename-prefix\", .description = \"Fix issues with wrong prefix during import\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n            .{ .command = \"bz sync --flush-only --error-policy best-effort\", .description = \"Export, continuing on errors\" },\n            .{ .command = \"bz sync --import-only --orphans resurrect\", .description = \"Import, creating placeholders for orphans\" },\n            .{ .command = \"bz sync --import-only --rename-prefix\", .description = \"Import and fix wrong ID prefixes\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\", \"backup\" },\n    },","originalFile":"//! Help command for beads_zig.\n//!\n//! Provides detailed per-command help with usage examples and flag references.\n\nconst std = @import(\"std\");\n\npub const HelpError = error{\n    WriteError,\n    OutOfMemory,\n};\n\npub const HelpResult = struct {\n    success: bool,\n    topic: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Command metadata for generating help text.\nconst CommandHelp = struct {\n    name: []const u8,\n    aliases: []const []const u8 = &[_][]const u8{},\n    summary: []const u8,\n    usage: []const u8,\n    description: []const u8 = \"\",\n    arguments: []const ArgHelp = &[_]ArgHelp{},\n    flags: []const FlagHelp = &[_]FlagHelp{},\n    examples: []const ExampleHelp = &[_]ExampleHelp{},\n    see_also: []const []const u8 = &[_][]const u8{},\n};\n\nconst ArgHelp = struct {\n    name: []const u8,\n    description: []const u8,\n    required: bool = true,\n};\n\nconst FlagHelp = struct {\n    short: ?[]const u8,\n    long: []const u8,\n    arg: ?[]const u8 = null,\n    description: []const u8,\n};\n\nconst ExampleHelp = struct {\n    command: []const u8,\n    description: []const u8,\n};\n\n/// All command help definitions.\nconst commands = [_]CommandHelp{\n    // Workspace commands\n    .{\n        .name = \"init\",\n        .summary = \"Initialize a .beads/ workspace\",\n        .usage = \"bz init [--prefix PREFIX]\",\n        .description = \"Creates the .beads/ directory structure for issue tracking. \" ++\n            \"This command must be run before using any other beads commands.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--prefix\", .arg = \"PREFIX\", .description = \"Issue ID prefix (default: bd)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz init\", .description = \"Initialize with default prefix 'bd'\" },\n            .{ .command = \"bz init --prefix proj\", .description = \"Use 'proj' as ID prefix (e.g., proj-abc123)\" },\n        },\n    },\n    .{\n        .name = \"info\",\n        .summary = \"Show workspace information\",\n        .usage = \"bz info\",\n        .description = \"Displays current workspace configuration, file locations, and basic status.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz info\", .description = \"Show workspace details\" },\n            .{ .command = \"bz info --json\", .description = \"Output as JSON for scripting\" },\n        },\n    },\n    .{\n        .name = \"stats\",\n        .summary = \"Show project statistics\",\n        .usage = \"bz stats\",\n        .description = \"Shows aggregate statistics about issues: counts by status, priority, type, etc.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stats\", .description = \"Show issue statistics\" },\n            .{ .command = \"bz stats --json\", .description = \"Output as JSON for dashboards\" },\n        },\n    },\n    .{\n        .name = \"doctor\",\n        .summary = \"Run diagnostic checks\",\n        .usage = \"bz doctor\",\n        .description = \"Checks workspace integrity: validates JSONL format, detects orphaned references, \" ++\n            \"and reports any data consistency issues.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz doctor\", .description = \"Run all diagnostic checks\" },\n        },\n    },\n    .{\n        .name = \"config\",\n        .summary = \"Manage configuration\",\n        .usage = \"bz config [get|set|list] [KEY] [VALUE]\",\n        .description = \"View or modify project configuration settings.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\n            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz config\", .description = \"List all configuration\" },\n            .{ .command = \"bz config list\", .description = \"Same as above\" },\n            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n        },\n    },\n    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },\n    },\n    .{\n        .name = \"orphans\",\n        .summary = \"Find issues with missing parent references\",\n        .usage = \"bz orphans [--limit N] [--hierarchy-only] [--deps-only]\",\n        .description = \"Identifies issues that reference non-existent parent issues or dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results to show\" },\n            .{ .short = null, .long = \"--hierarchy-only\", .description = \"Only check hierarchical parent refs\" },\n            .{ .short = null, .long = \"--deps-only\", .description = \"Only check dependency refs\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz orphans\", .description = \"Find all orphaned references\" },\n            .{ .command = \"bz orphans --limit 10\", .description = \"Show at most 10 orphans\" },\n        },\n    },\n    .{\n        .name = \"lint\",\n        .summary = \"Validate database consistency\",\n        .usage = \"bz lint [--limit N]\",\n        .description = \"Checks for data quality issues: empty titles, invalid priorities, \" ++\n            \"malformed IDs, and other consistency problems.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum issues to report\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz lint\", .description = \"Run all lint checks\" },\n        },\n    },\n\n    // Issue CRUD commands\n    .{\n        .name = \"create\",\n        .aliases = &[_][]const u8{ \"add\", \"new\" },\n        .summary = \"Create a new issue\",\n        .usage = \"bz create <title> [options]\",\n        .description = \"Creates a new issue with the given title. The issue is assigned a \" ++\n            \"unique ID and added to the database. Use flags to set optional fields.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title (1-500 characters)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"Detailed description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Issue type (task, bug, feature, epic, chore, docs, question)\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority (critical, high, medium, low, backlog, or 0-4)\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Assignee name or email\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Add label (can be repeated)\" },\n            .{ .short = null, .long = \"--depends-on\", .arg = \"ID\", .description = \"Add dependency (can be repeated)\" },\n            .{ .short = null, .long = \"--due\", .arg = \"DATE\", .description = \"Due date (YYYY-MM-DD)\" },\n            .{ .short = \"-e\", .long = \"--estimate\", .arg = \"MINS\", .description = \"Estimate in minutes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz create \\\"Fix login bug\\\"\", .description = \"Create a simple issue\" },\n            .{ .command = \"bz create \\\"Add OAuth\\\" -t feature -p high\", .description = \"Create a high-priority feature\" },\n            .{ .command = \"bz create \\\"Bug fix\\\" -l urgent -l backend\", .description = \"Create with multiple labels\" },\n            .{ .command = \"bz create \\\"Task\\\" --depends-on bd-abc123\", .description = \"Create with dependency\" },\n        },\n        .see_also = &[_][]const u8{ \"q\", \"show\", \"update\" },\n    },\n    .{\n        .name = \"q\",\n        .aliases = &[_][]const u8{\"quick\"},\n        .summary = \"Quick capture (create + print ID only)\",\n        .usage = \"bz q <title> [-p PRIORITY]\",\n        .description = \"Creates a new issue and prints only the ID. Optimized for scripting \" ++\n            \"and quick capture workflows.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority level\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz q \\\"Quick thought\\\"\", .description = \"Capture idea, get ID back\" },\n            .{ .command = \"ID=$(bz q \\\"Task\\\"); echo $ID\", .description = \"Capture ID in shell variable\" },\n            .{ .command = \"bz q \\\"Urgent fix\\\" -p critical\", .description = \"Quick capture with priority\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"add-batch\" },\n    },\n    .{\n        .name = \"show\",\n        .aliases = &[_][]const u8{ \"get\", \"view\" },\n        .summary = \"Show issue details\",\n        .usage = \"bz show <id> [--no-comments] [--with-history]\",\n        .description = \"Displays full details of an issue including description, status, \" ++\n            \"dependencies, labels, and comments.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (e.g., bd-abc123)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--no-comments\", .description = \"Hide comments\" },\n            .{ .short = null, .long = \"--with-history\", .description = \"Include change history\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz show bd-abc123\", .description = \"Show issue details\" },\n            .{ .command = \"bz show bd-abc --json\", .description = \"Get issue as JSON\" },\n            .{ .command = \"bz show bd-abc --with-history\", .description = \"Include change history\" },\n        },\n        .see_also = &[_][]const u8{ \"update\", \"history\" },\n    },\n    .{\n        .name = \"update\",\n        .aliases = &[_][]const u8{\"edit\"},\n        .summary = \"Update issue fields\",\n        .usage = \"bz update <id> [options]\",\n        .description = \"Modifies one or more fields of an existing issue. Only specified \" ++\n            \"fields are changed; others remain unchanged.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to update\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--title\", .arg = \"TEXT\", .description = \"New title\" },\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"New description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"New issue type\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"New priority\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"New assignee\" },\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"New status (open, in_progress, blocked, deferred, closed)\" },\n            .{ .short = \"-v\", .long = \"--version\", .arg = \"NUM\", .description = \"Expected version for optimistic locking (fails if issue was modified)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz update bd-abc --title \\\"New title\\\"\", .description = \"Update title\" },\n            .{ .command = \"bz update bd-abc -p critical -a alice\", .description = \"Update priority and assignee\" },\n            .{ .command = \"bz update bd-abc -s in_progress\", .description = \"Change status to in_progress\" },\n            .{ .command = \"bz update bd-abc -v 3 --title \\\"Safe update\\\"\", .description = \"Update only if version is 3 (optimistic lock)\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"close\" },\n    },\n    .{\n        .name = \"close\",\n        .aliases = &[_][]const u8{ \"done\", \"finish\" },\n        .summary = \"Close an issue\",\n        .usage = \"bz close <id> [-r REASON]\",\n        .description = \"Marks an issue as closed. Optionally provide a close reason.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to close\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Close reason (e.g., \\\"Fixed in PR #42\\\")\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz close bd-abc123\", .description = \"Close an issue\" },\n            .{ .command = \"bz close bd-abc -r \\\"Duplicate of bd-xyz\\\"\", .description = \"Close with reason\" },\n            .{ .command = \"bz done bd-abc\", .description = \"Close using alias\" },\n        },\n        .see_also = &[_][]const u8{ \"reopen\", \"delete\" },\n    },\n    .{\n        .name = \"reopen\",\n        .summary = \"Reopen a closed issue\",\n        .usage = \"bz reopen <id>\",\n        .description = \"Changes a closed issue's status back to open.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to reopen\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz reopen bd-abc123\", .description = \"Reopen a closed issue\" },\n        },\n        .see_also = &[_][]const u8{ \"close\", \"update\" },\n    },\n    .{\n        .name = \"delete\",\n        .aliases = &[_][]const u8{ \"rm\", \"remove\" },\n        .summary = \"Soft delete an issue (tombstone)\",\n        .usage = \"bz delete <id>\",\n        .description = \"Marks an issue as deleted (tombstone status). The issue remains in \" ++\n            \"the database but is hidden from normal queries. Can be restored via update.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to delete\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz delete bd-abc123\", .description = \"Soft delete an issue\" },\n            .{ .command = \"bz rm bd-abc\", .description = \"Delete using alias\" },\n        },\n        .see_also = &[_][]const u8{\"close\"},\n    },\n    .{\n        .name = \"defer\",\n        .summary = \"Defer an issue\",\n        .usage = \"bz defer <id> [--until DATE] [-r REASON]\",\n        .description = \"Marks an issue as deferred, optionally until a specific date.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to defer\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-u\", .long = \"--until\", .arg = \"DATE\", .description = \"Date to resurface (YYYY-MM-DD or +7d)\" },\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Reason for deferral\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz defer bd-abc\", .description = \"Defer indefinitely\" },\n            .{ .command = \"bz defer bd-abc --until 2024-03-01\", .description = \"Defer until specific date\" },\n            .{ .command = \"bz defer bd-abc --until +7d\", .description = \"Defer for 7 days\" },\n        },\n        .see_also = &[_][]const u8{\"undefer\"},\n    },\n    .{\n        .name = \"undefer\",\n        .summary = \"Remove deferral from an issue\",\n        .usage = \"bz undefer <id>\",\n        .description = \"Clears the deferred status and defer_until date from an issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to undefer\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz undefer bd-abc123\", .description = \"Remove deferral\" },\n        },\n        .see_also = &[_][]const u8{\"defer\"},\n    },\n\n    // Batch operations\n    .{\n        .name = \"add-batch\",\n        .aliases = &[_][]const u8{ \"batch-add\", \"batch\" },\n        .summary = \"Create issues from stdin/file (single lock)\",\n        .usage = \"bz add-batch [-f FILE] [--format FORMAT]\",\n        .description = \"Creates multiple issues efficiently with a single lock acquisition. \" ++\n            \"Reads from stdin or a file. Supports plain titles (one per line) or JSONL format.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--file\", .arg = \"FILE\", .description = \"Read from file instead of stdin\" },\n            .{ .short = null, .long = \"--format\", .arg = \"FMT\", .description = \"Input format: titles (default) or jsonl\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"echo -e \\\"Task 1\\\\nTask 2\\\" | bz add-batch\", .description = \"Create from stdin\" },\n            .{ .command = \"bz add-batch -f tasks.txt\", .description = \"Create from file (one title per line)\" },\n            .{ .command = \"bz add-batch -f issues.jsonl --format jsonl\", .description = \"Create from JSONL file\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"import\" },\n    },\n    .{\n        .name = \"import\",\n        .summary = \"Import issues from JSONL file\",\n        .usage = \"bz import <file> [-m] [-n]\",\n        .description = \"Imports issues from a JSONL file. Handles deduplication via content hash \" ++\n            \"and external_ref matching.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"file\", .description = \"Path to JSONL file\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"Merge with existing issues (update if exists)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be imported without importing\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz import backup.jsonl\", .description = \"Import from backup\" },\n            .{ .command = \"bz import external.jsonl --merge\", .description = \"Merge external issues\" },\n            .{ .command = \"bz import data.jsonl --dry-run\", .description = \"Preview import\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"add-batch\" },\n    },\n\n    // Query commands\n    .{\n        .name = \"list\",\n        .aliases = &[_][]const u8{\"ls\"},\n        .summary = \"List issues with filters\",\n        .usage = \"bz list [options]\",\n        .description = \"Lists issues matching optional filters. By default shows only open issues. \" ++\n            \"Use --all to include closed/deleted issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"Filter by status\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Filter by priority\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Filter by issue type\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Filter by assignee\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Filter by label\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n            .{ .short = \"-A\", .long = \"--all\", .description = \"Include all statuses (not just open)\" },\n            .{ .short = null, .long = \"--sort\", .arg = \"FIELD\", .description = \"Sort by: created, updated, or priority\" },\n            .{ .short = null, .long = \"--asc\", .description = \"Sort ascending\" },\n            .{ .short = null, .long = \"--desc\", .description = \"Sort descending (default)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz list\", .description = \"List open issues\" },\n            .{ .command = \"bz list --all\", .description = \"List all issues\" },\n            .{ .command = \"bz list -p high -t bug\", .description = \"High priority bugs\" },\n            .{ .command = \"bz list --sort priority --asc\", .description = \"Sort by priority ascending\" },\n            .{ .command = \"bz list -l backend -n 5\", .description = \"Top 5 issues with 'backend' label\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"blocked\", \"search\" },\n    },\n    .{\n        .name = \"ready\",\n        .summary = \"Show actionable issues (unblocked)\",\n        .usage = \"bz ready [--limit N]\",\n        .description = \"Lists open issues that have no unresolved blocking dependencies. \" ++\n            \"These are issues ready to be worked on.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz ready\", .description = \"Show all ready issues\" },\n            .{ .command = \"bz ready -n 5\", .description = \"Show top 5 ready issues\" },\n            .{ .command = \"bz ready --json\", .description = \"Get ready work as JSON (for agents)\" },\n        },\n        .see_also = &[_][]const u8{ \"blocked\", \"list\" },\n    },\n    .{\n        .name = \"blocked\",\n        .summary = \"Show blocked issues\",\n        .usage = \"bz blocked [--limit N]\",\n        .description = \"Lists open issues that have unresolved blocking dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz blocked\", .description = \"Show all blocked issues\" },\n            .{ .command = \"bz blocked --json\", .description = \"Get blocked issues as JSON\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"dep\" },\n    },\n    .{\n        .name = \"search\",\n        .aliases = &[_][]const u8{\"find\"},\n        .summary = \"Full-text search\",\n        .usage = \"bz search <query> [--limit N]\",\n        .description = \"Searches issue titles and descriptions for the given query string.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"query\", .description = \"Search string\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz search login\", .description = \"Find issues mentioning 'login'\" },\n            .{ .command = \"bz search \\\"OAuth flow\\\" -n 10\", .description = \"Search with limit\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"stale\",\n        .summary = \"Find issues not updated recently\",\n        .usage = \"bz stale [--days N] [--limit N]\",\n        .description = \"Lists open issues that haven't been updated within the specified \" ++\n            \"number of days (default: 30).\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--days\", .arg = \"N\", .description = \"Days threshold (default: 30)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stale\", .description = \"Issues untouched for 30+ days\" },\n            .{ .command = \"bz stale --days 7\", .description = \"Issues untouched for 7+ days\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"count\",\n        .summary = \"Count issues by group\",\n        .usage = \"bz count [--group-by FIELD]\",\n        .description = \"Counts issues, optionally grouped by a field.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by: status, priority, type, assignee\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz count\", .description = \"Total issue count\" },\n            .{ .command = \"bz count --group-by status\", .description = \"Count by status\" },\n            .{ .command = \"bz count -g priority\", .description = \"Count by priority\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"stats\" },\n    },\n\n    // Dependency commands\n    .{\n        .name = \"dep\",\n        .aliases = &[_][]const u8{ \"deps\", \"dependency\" },\n        .summary = \"Manage issue dependencies\",\n        .usage = \"bz dep <subcommand> [args]\",\n        .description = \"Add, remove, or query dependencies between issues. \" ++\n            \"Dependencies are directional: A depends-on B means A is blocked by B.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, tree, or cycles\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz dep add bd-child bd-parent\", .description = \"child depends on parent\" },\n            .{ .command = \"bz dep add bd-a bd-b --type relates_to\", .description = \"Add non-blocking relation\" },\n            .{ .command = \"bz dep remove bd-child bd-parent\", .description = \"Remove dependency\" },\n            .{ .command = \"bz dep list bd-abc\", .description = \"List dependencies of an issue\" },\n            .{ .command = \"bz dep tree bd-abc\", .description = \"Show dependency tree\" },\n            .{ .command = \"bz dep cycles\", .description = \"Detect circular dependencies\" },\n        },\n        .see_also = &[_][]const u8{ \"graph\", \"ready\", \"blocked\" },\n    },\n    .{\n        .name = \"graph\",\n        .summary = \"Show dependency graph\",\n        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n        .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n            \"With an ID, shows that issue's dependency subgraph.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n            .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n            .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n            .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n        },\n        .see_also = &[_][]const u8{\"dep\"},\n    },\n\n    // Epic commands\n    .{\n        .name = \"epic\",\n        .aliases = &[_][]const u8{\"epics\"},\n        .summary = \"Manage epics\",\n        .usage = \"bz epic <subcommand> [args]\",\n        .description = \"Epics are special issues that group related work. Use epic commands \" ++\n            \"to create epics and manage their child issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"create, add, remove, or list\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz epic create \\\"Q1 Goals\\\"\", .description = \"Create a new epic\" },\n            .{ .command = \"bz epic create \\\"Auth Overhaul\\\" -p high\", .description = \"Create with priority\" },\n            .{ .command = \"bz epic add bd-epic bd-task\", .description = \"Add issue to epic\" },\n            .{ .command = \"bz epic remove bd-epic bd-task\", .description = \"Remove issue from epic\" },\n            .{ .command = \"bz epic list bd-epic\", .description = \"List issues in epic\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"dep\" },\n    },\n\n    // Label commands\n    .{\n        .name = \"label\",\n        .aliases = &[_][]const u8{ \"labels\", \"tag\" },\n        .summary = \"Manage issue labels\",\n        .usage = \"bz label <subcommand> [args]\",\n        .description = \"Add, remove, or list labels on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, or list-all\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz label add bd-abc urgent backend\", .description = \"Add multiple labels\" },\n            .{ .command = \"bz label remove bd-abc old-label\", .description = \"Remove a label\" },\n            .{ .command = \"bz label list bd-abc\", .description = \"List labels on issue\" },\n            .{ .command = \"bz label list-all\", .description = \"List all labels in project\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"create\" },\n    },\n\n    // Comment commands\n    .{\n        .name = \"comments\",\n        .aliases = &[_][]const u8{ \"comment\", \"note\" },\n        .summary = \"Manage issue comments\",\n        .usage = \"bz comments <subcommand> <id> [text]\",\n        .description = \"Add or list comments on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add or list\" },\n            .{ .name = \"id\", .description = \"Issue ID\" },\n            .{ .name = \"text\", .description = \"Comment text (for add)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz comments add bd-abc \\\"Working on this\\\"\", .description = \"Add a comment\" },\n            .{ .command = \"bz comments list bd-abc\", .description = \"List comments\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"history\" },\n    },\n\n    // Audit commands\n    .{\n        .name = \"history\",\n        .aliases = &[_][]const u8{\"log\"},\n        .summary = \"Show issue history\",\n        .usage = \"bz history <id>\",\n        .description = \"Displays the change history for a specific issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz history bd-abc123\", .description = \"Show change history\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"audit\" },\n    },\n    .{\n        .name = \"audit\",\n        .summary = \"Project-wide audit log\",\n        .usage = \"bz audit [--limit N]\",\n        .description = \"Shows recent events across all issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum events\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz audit\", .description = \"Show recent events\" },\n            .{ .command = \"bz audit --limit 100\", .description = \"Show last 100 events\" },\n        },\n        .see_also = &[_][]const u8{ \"history\", \"changelog\" },\n    },\n    .{\n        .name = \"changelog\",\n        .summary = \"Generate changelog from closed issues\",\n        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n            \"by date range and grouped by type.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n        },\n        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // System commands\n    .{\n        .name = \"version\",\n        .summary = \"Show version\",\n        .usage = \"bz version\",\n        .description = \"Displays the beads_zig version and build information.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz version\", .description = \"Show version\" },\n            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n        },\n    },\n    .{\n        .name = \"schema\",\n        .summary = \"Show data schema\",\n        .usage = \"bz schema\",\n        .description = \"Displays the JSONL data schema for issues and related types.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n        },\n    },\n    .{\n        .name = \"completions\",\n        .aliases = &[_][]const u8{\"completion\"},\n        .summary = \"Generate shell completions\",\n        .usage = \"bz completions <shell>\",\n        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },\n        },\n    },\n    .{\n        .name = \"help\",\n        .summary = \"Show help\",\n        .usage = \"bz help [command]\",\n        .description = \"Shows general help or detailed help for a specific command.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"command\", .description = \"Command to get help for\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz help\", .description = \"Show general help\" },\n            .{ .command = \"bz help create\", .description = \"Show help for create command\" },\n            .{ .command = \"bz --help\", .description = \"Same as bz help\" },\n        },\n    },\n};\n\n/// Find help for a specific command (including aliases).\nfn findCommand(name: []const u8) ?*const CommandHelp {\n    for (&commands) |*cmd| {\n        if (std.mem.eql(u8, cmd.name, name)) {\n            return cmd;\n        }\n        for (cmd.aliases) |alias| {\n            if (std.mem.eql(u8, alias, name)) {\n                return cmd;\n            }\n        }\n    }\n    return null;\n}\n\n/// Run the help command.\npub fn run(topic: ?[]const u8, allocator: std.mem.Allocator) !void {\n    const stdout = std.fs.File.stdout();\n    if (topic) |t| {\n        try showCommandHelp(t, stdout, allocator);\n    } else {\n        try showGeneralHelp(stdout);\n    }\n}\n\nfn showGeneralHelp(file: std.fs.File) !void {\n    try file.writeAll(\n        \\\\bz - beads_zig issue tracker\n        \\\\\n        \\\\USAGE:\n        \\\\  bz <command> [options]\n        \\\\\n        \\\\COMMANDS:\n        \\\\  Workspace:\n        \\\\    init              Initialize .beads/ workspace\n        \\\\    info              Show workspace information\n        \\\\    stats             Show project statistics\n        \\\\    doctor            Run diagnostic checks\n        \\\\    config            Manage configuration\n        \\\\    sync              Sync with JSONL file\n        \\\\    orphans           Find issues with missing parent refs\n        \\\\    lint              Validate database consistency\n        \\\\\n        \\\\  Issue Management:\n        \\\\    create <title>    Create new issue\n        \\\\    q <title>         Quick capture (create + print ID only)\n        \\\\    show <id>         Show issue details\n        \\\\    update <id>       Update issue fields\n        \\\\    close <id>        Close an issue\n        \\\\    reopen <id>       Reopen a closed issue\n        \\\\    delete <id>       Soft delete (tombstone)\n        \\\\    defer <id>        Defer an issue\n        \\\\    undefer <id>      Remove deferral from an issue\n        \\\\\n        \\\\  Batch Operations:\n        \\\\    add-batch         Create issues from stdin/file (single lock)\n        \\\\    import <file>     Import issues from JSONL file\n        \\\\\n        \\\\  Queries:\n        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n        \\\\    ready             Show actionable issues (unblocked)\n        \\\\    blocked           Show blocked issues\n        \\\\    search <query>    Full-text search\n        \\\\    stale [--days N]  Find issues not updated recently\n        \\\\    count [--group-by] Count issues by group\n        \\\\\n        \\\\  Dependencies:\n        \\\\    dep add <a> <b>   Make issue A depend on B\n        \\\\    dep remove <a> <b> Remove dependency\n        \\\\    dep list <id>     List dependencies\n        \\\\    dep tree <id>     Show dependency tree (ASCII)\n        \\\\    dep cycles        Detect dependency cycles\n        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n        \\\\\n        \\\\  Epics:\n        \\\\    epic create <title>       Create a new epic\n        \\\\    epic add <epic> <issue>   Add issue to epic\n        \\\\    epic remove <epic> <issue> Remove issue from epic\n        \\\\    epic list <epic>          List issues in epic\n        \\\\\n        \\\\  Labels:\n        \\\\    label add <id> <labels...>    Add labels to an issue\n        \\\\    label remove <id> <labels...> Remove labels from an issue\n        \\\\    label list <id>               List labels on an issue\n        \\\\    label list-all                List all labels in project\n        \\\\\n        \\\\  Comments:\n        \\\\    comments add <id> <text>  Add comment to an issue\n        \\\\    comments list <id>        List comments on an issue\n        \\\\\n        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:\n        \\\\    help              Show this help\n        \\\\    version           Show version\n        \\\\    schema            Show data schema\n        \\\\    completions <shell>  Generate shell completions\n        \\\\\n        \\\\GLOBAL OPTIONS:\n        \\\\  --json            Output in JSON format\n        \\\\  --toon            Output in TOON format (LLM-optimized)\n        \\\\  -q, --quiet       Suppress non-essential output\n        \\\\  -v, --verbose     Increase verbosity\n        \\\\  --no-color        Disable colors\n        \\\\  --data <path>     Override .beads/ directory\n        \\\\  --actor <name>    Override actor name for audit\n        \\\\  --no-auto-flush   Skip automatic JSONL export\n        \\\\  --no-auto-import  Skip JSONL freshness check\n        \\\\\n        \\\\Run 'bz help <command>' for command-specific help.\n        \\\\\n    );\n}\n\nfn showCommandHelp(name: []const u8, file: std.fs.File, allocator: std.mem.Allocator) !void {\n    const cmd = findCommand(name) orelse {\n        const msg = try std.fmt.allocPrint(allocator, \"Unknown command: {s}\\n\\n\", .{name});\n        defer allocator.free(msg);\n        try file.writeAll(msg);\n        try file.writeAll(\"Run 'bz help' for a list of available commands.\\n\");\n        return;\n    };\n\n    // Command name and aliases\n    try file.writeAll(cmd.name);\n    if (cmd.aliases.len > 0) {\n        try file.writeAll(\" (\");\n        for (cmd.aliases, 0..) |alias, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(alias);\n        }\n        try file.writeAll(\")\");\n    }\n    try file.writeAll(\"\\n\");\n\n    // Summary\n    try file.writeAll(\"\\n\");\n    try file.writeAll(cmd.summary);\n    try file.writeAll(\"\\n\");\n\n    // Usage\n    try file.writeAll(\"\\nUSAGE:\\n  \");\n    try file.writeAll(cmd.usage);\n    try file.writeAll(\"\\n\");\n\n    // Description\n    if (cmd.description.len > 0) {\n        try file.writeAll(\"\\nDESCRIPTION:\\n\");\n        try writeWrapped(file, cmd.description, 2, 78, allocator);\n    }\n\n    // Arguments\n    if (cmd.arguments.len > 0) {\n        try file.writeAll(\"\\nARGUMENTS:\\n\");\n        for (cmd.arguments) |arg| {\n            const req = if (arg.required) \" (required)\" else \" (optional)\";\n            const line = try std.fmt.allocPrint(allocator, \"  {s}{s}\\n\", .{ arg.name, req });\n            defer allocator.free(line);\n            try file.writeAll(line);\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{arg.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Flags\n    if (cmd.flags.len > 0) {\n        try file.writeAll(\"\\nFLAGS:\\n\");\n        for (cmd.flags) |flag| {\n            if (flag.short) |short| {\n                const line = try std.fmt.allocPrint(allocator, \"  {s}, {s}\", .{ short, flag.long });\n                defer allocator.free(line);\n                try file.writeAll(line);\n            } else {\n                const line = try std.fmt.allocPrint(allocator, \"      {s}\", .{flag.long});\n                defer allocator.free(line);\n                try file.writeAll(line);\n            }\n            if (flag.arg) |arg| {\n                const argline = try std.fmt.allocPrint(allocator, \" <{s}>\", .{arg});\n                defer allocator.free(argline);\n                try file.writeAll(argline);\n            }\n            try file.writeAll(\"\\n\");\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{flag.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Examples\n    if (cmd.examples.len > 0) {\n        try file.writeAll(\"\\nEXAMPLES:\\n\");\n        for (cmd.examples) |ex| {\n            const cmd_line = try std.fmt.allocPrint(allocator, \"  $ {s}\\n\", .{ex.command});\n            defer allocator.free(cmd_line);\n            try file.writeAll(cmd_line);\n            const desc_line = try std.fmt.allocPrint(allocator, \"    {s}\\n\\n\", .{ex.description});\n            defer allocator.free(desc_line);\n            try file.writeAll(desc_line);\n        }\n    }\n\n    // See also\n    if (cmd.see_also.len > 0) {\n        try file.writeAll(\"SEE ALSO:\\n  \");\n        for (cmd.see_also, 0..) |ref, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(ref);\n        }\n        try file.writeAll(\"\\n\");\n    }\n}\n\n/// Write text with word wrapping.\nfn writeWrapped(file: std.fs.File, text: []const u8, indent: usize, max_width: usize, allocator: std.mem.Allocator) !void {\n    const effective_width = max_width - indent;\n\n    // Pre-allocate indent string\n    const indent_str = try allocator.alloc(u8, indent);\n    defer allocator.free(indent_str);\n    @memset(indent_str, ' ');\n\n    var line_start: usize = 0;\n    var last_space: ?usize = null;\n    var col: usize = 0;\n\n    for (text, 0..) |c, i| {\n        if (c == ' ') {\n            last_space = i;\n        }\n        col += 1;\n\n        if (col >= effective_width) {\n            const break_at = last_space orelse i;\n            try file.writeAll(indent_str);\n            try file.writeAll(text[line_start..break_at]);\n            try file.writeAll(\"\\n\");\n\n            line_start = break_at + 1;\n            col = i - break_at;\n            last_space = null;\n        }\n    }\n\n    if (line_start < text.len) {\n        try file.writeAll(indent_str);\n        try file.writeAll(text[line_start..]);\n        try file.writeAll(\"\\n\");\n    }\n}\n\n// Tests\n\ntest \"findCommand finds by name\" {\n    const cmd = findCommand(\"create\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand finds by alias\" {\n    const cmd = findCommand(\"add\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand returns null for unknown\" {\n    const cmd = findCommand(\"nonexistent\");\n    try std.testing.expect(cmd == null);\n}\n\ntest \"findCommand finds all main commands\" {\n    // Verify a sampling of commands can be found\n    try std.testing.expect(findCommand(\"init\") != null);\n    try std.testing.expect(findCommand(\"list\") != null);\n    try std.testing.expect(findCommand(\"show\") != null);\n    try std.testing.expect(findCommand(\"update\") != null);\n    try std.testing.expect(findCommand(\"close\") != null);\n    try std.testing.expect(findCommand(\"dep\") != null);\n    try std.testing.expect(findCommand(\"help\") != null);\n}\n\ntest \"findCommand finds aliases\" {\n    // Test common aliases\n    try std.testing.expect(findCommand(\"ls\") != null);\n    try std.testing.expectEqualStrings(\"list\", findCommand(\"ls\").?.name);\n\n    try std.testing.expect(findCommand(\"rm\") != null);\n    try std.testing.expectEqualStrings(\"delete\", findCommand(\"rm\").?.name);\n\n    try std.testing.expect(findCommand(\"done\") != null);\n    try std.testing.expectEqualStrings(\"close\", findCommand(\"done\").?.name);\n}\n","structuredPatch":[{"oldStart":113,"oldLines":7,"newStart":113,"newLines":7,"lines":["     .{","         .name = \"sync\",","         .summary = \"Sync with JSONL file\",","-        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest]\",","+        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\",","         .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++","             \"bidirectional sync. Use flags to limit to export or import only.\",","         .flags = &[_]FlagHelp{"]},{"oldStart":122,"oldLines":6,"newStart":122,"newLines":9,"lines":["             .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },","             .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },","             .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },","+            .{ .short = null, .long = \"--error-policy\", .arg = \"POLICY\", .description = \"Export error handling: strict (default), best-effort, partial\" },","+            .{ .short = null, .long = \"--orphans\", .arg = \"POLICY\", .description = \"Import orphan handling: strict (default), resurrect, skip\" },","+            .{ .short = null, .long = \"--rename-prefix\", .description = \"Fix issues with wrong prefix during import\" },","         },","         .examples = &[_]ExampleHelp{","             .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },"]},{"oldStart":129,"oldLines":8,"newStart":132,"newLines":11,"lines":["             .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },","             .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },","             .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },","+            .{ .command = \"bz sync --flush-only --error-policy best-effort\", .description = \"Export, continuing on errors\" },","+            .{ .command = \"bz sync --import-only --orphans resurrect\", .description = \"Import, creating placeholders for orphans\" },","+            .{ .command = \"bz sync --import-only --rename-prefix\", .description = \"Import and fix wrong ID prefixes\" },","         },","-        .see_also = &[_][]const u8{ \"import\", \"add-batch\" },","+        .see_also = &[_][]const u8{ \"import\", \"add-batch\", \"backup\" },","     },","     .{","         .name = \"orphans\","]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TjrxEooxNPKC2GmdxjKmLw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XDE6GzDXYuxbe7j7uDDurf","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"completed","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"completed","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"in_progress","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1316,"cache_read_input_tokens":79487,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1316},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"52dd923d-5599-4013-be96-e18e6ff7f4fe"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XDE6GzDXYuxbe7j7uDDurf","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c1e5658a-468c-43a4-a426-e2ce11add347","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"completed","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"in_progress","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"pending","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"completed","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"completed","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"in_progress","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01923Kd32yWYBkeGAQmnjx97","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to implement the policy handling in sync.zig. Let me update the sync functions to use these new policy options."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":505,"cache_read_input_tokens":80803,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":505},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"58138fe3-4801-4610-a3a0-8232485b9209"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01923Kd32yWYBkeGAQmnjx97","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0174gm8sxkQM4UBcPb2dnHq3","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"pub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};","new_string":"pub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":505,"cache_read_input_tokens":80803,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":505},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7177ecbe-11f6-4c7a-9002-9cad6c07f6bf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0174gm8sxkQM4UBcPb2dnHq3","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"1eab5787-89ee-4c1a-b711-36626f967676","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"pub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};","newString":"pub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n\n    ctx.store.saveToFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n        return SyncError.ExportError;\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"flush\",\n            .issues_exported = count,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":33,"oldLines":6,"newStart":33,"newLines":10,"lines":["     issues_imported: ?usize = null,","     issues_updated: ?usize = null,","     issues_added: ?usize = null,","+    issues_skipped: ?usize = null,","+    issues_renamed: ?usize = null,","+    orphans_created: ?usize = null,","+    errors: ?usize = null,","     message: ?[]const u8 = null,","     // Status-specific fields","     db_count: ?usize = null,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MMLR4RrKPPCR8tATHwMznL","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the runFlush function to use error_policy and the runImport function to use orphan_policy and rename_prefix."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":559,"cache_read_input_tokens":81308,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":559},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"426eaa88-90d0-4997-ae6c-b0faa9aa2f57"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MMLR4RrKPPCR8tATHwMznL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GYomW6d19SuBhABvVzQPT9","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"pub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}","new_string":"pub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":559,"cache_read_input_tokens":81308,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":559},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"55049816-9c6e-4d95-8bd8-65be4533330c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GYomW6d19SuBhABvVzQPT9","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ff22cb17-b612-4d9a-b3ae-9f178c25368a","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"pub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}","newString":"pub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n\n    ctx.store.saveToFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n        return SyncError.ExportError;\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"flush\",\n            .issues_exported = count,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":61,"oldLines":11,"newStart":61,"newLines":11,"lines":["     if (sync_args.status) {","         try runStatus(&ctx, structured_output, global.quiet, allocator);","     } else if (sync_args.flush_only) {","-        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, allocator);","+        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);","     } else if (sync_args.import_only) {","-        try runImport(&ctx, structured_output, global.quiet, allocator);","+        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);","     } else if (sync_args.merge) {","-        try runMerge(&ctx, structured_output, global.quiet, allocator);","+        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);","     } else {","         try runBidirectional(&ctx, structured_output, global.quiet, allocator);","     }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FxBjKG9omNMoqH3yXp7rkP","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update runFlush to use the error_policy."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":793,"cache_read_input_tokens":81867,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":793},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"060f6921-196f-40c0-9445-33f2a4f3f54c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FxBjKG9omNMoqH3yXp7rkP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0145PuzVo4qGRuDbJQrBmWy7","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n\n    ctx.store.saveToFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n        return SyncError.ExportError;\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"flush\",\n            .issues_exported = count,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}","new_string":"fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":793,"cache_read_input_tokens":81867,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":793},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ff0b5971-dcc5-4ede-b02c-da4ea3f19b00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0145PuzVo4qGRuDbJQrBmWy7","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a386345f-2f6a-4712-825a-5181d788fc9d","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n\n    ctx.store.saveToFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n        return SyncError.ExportError;\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"flush\",\n            .issues_exported = count,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}","newString":"fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n\n    ctx.store.saveToFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n        return SyncError.ExportError;\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"flush\",\n            .issues_exported = count,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":71,"oldLines":12,"newStart":71,"newLines":27,"lines":["     }"," }"," ","-fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, allocator: std.mem.Allocator) !void {","+fn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {","     const count = ctx.store.issues.items.len;","+    var errors: usize = 0;"," ","-    ctx.store.saveToFile() catch {","-        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");","-        return SyncError.ExportError;","+    ctx.store.saveToFile() catch |err| {","+        switch (error_policy) {","+            .strict => {","+                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");","+                return SyncError.ExportError;","+            },","+            .best_effort => {","+                errors += 1;","+                if (!quiet and !structured_output) {","+                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});","+                }","+            },","+            .partial => {","+                errors += 1;","+                // Silent skip","+            },","+        }","     };"," ","     // Write manifest if requested"]},{"oldStart":88,"oldLines":13,"newStart":103,"newLines":18,"lines":[" ","     if (structured_output) {","         try ctx.output.printJson(SyncResult{","-            .success = true,","+            .success = errors == 0,","             .action = \"flush\",","             .issues_exported = count,","+            .errors = if (errors > 0) errors else null,","             .manifest_path = manifest_path,","         });","     } else if (!quiet) {","-        try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});","+        if (errors > 0) {","+            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });","+        } else {","+            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});","+        }","         if (manifest_path) |path| {","             try ctx.output.info(\"Manifest written to {s}\", .{path});","         }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MAZ1hQzUyEGGtLrVsbSvNr","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update runImport to use orphan_policy and rename_prefix. First, let me see the current runImport function more closely."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1016,"cache_read_input_tokens":82660,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1016},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f85432a8-a18e-4aae-9c8e-915d76ae0c5d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MAZ1hQzUyEGGtLrVsbSvNr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0172QzfxXPzm3wr5rryT3WAZ","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","offset":100,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1016,"cache_read_input_tokens":82660,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1016},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"40be125c-c530-48eb-8c79-b80e72ce7821"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0172QzfxXPzm3wr5rryT3WAZ","type":"tool_result","content":"   100→        manifest_path = try writeManifest(ctx, count, allocator);\n   101→    }\n   102→    defer if (manifest_path) |path| allocator.free(path);\n   103→\n   104→    if (structured_output) {\n   105→        try ctx.output.printJson(SyncResult{\n   106→            .success = errors == 0,\n   107→            .action = \"flush\",\n   108→            .issues_exported = count,\n   109→            .errors = if (errors > 0) errors else null,\n   110→            .manifest_path = manifest_path,\n   111→        });\n   112→    } else if (!quiet) {\n   113→        if (errors > 0) {\n   114→            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n   115→        } else {\n   116→            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n   117→        }\n   118→        if (manifest_path) |path| {\n   119→            try ctx.output.info(\"Manifest written to {s}\", .{path});\n   120→        }\n   121→    }\n   122→}\n   123→\n   124→fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   125→    // Check for merge conflict markers in the JSONL file\n   126→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   127→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   128→        return SyncError.MergeConflictDetected;\n   129→    }\n   130→\n   131→    // Reload from file (this replaces in-memory state)\n   132→    const old_count = ctx.store.issues.items.len;\n   133→\n   134→    // Deinit existing issues\n   135→    for (ctx.store.issues.items) |*issue| {\n   136→        issue.deinit(allocator);\n   137→    }\n   138→    ctx.store.issues.clearRetainingCapacity();\n   139→\n   140→    // Clear and rebuild index\n   141→    var id_it = ctx.store.id_index.keyIterator();\n   142→    while (id_it.next()) |key| {\n   143→        allocator.free(key.*);\n   144→    }\n   145→    ctx.store.id_index.clearRetainingCapacity();\n   146→\n   147→    // Reload from file\n   148→    ctx.store.loadFromFile() catch {\n   149→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n   150→        return SyncError.ImportError;\n   151→    };\n   152→\n   153→    const new_count = ctx.store.issues.items.len;\n   154→\n   155→    if (structured_output) {\n   156→        try ctx.output.printJson(SyncResult{\n   157→            .success = true,\n   158→            .action = \"import\",\n   159→            .issues_imported = new_count,\n   160→        });\n   161→    } else if (!quiet) {\n   162→        if (new_count > old_count) {\n   163→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n   164→        } else if (new_count < old_count) {\n   165→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n   166→        } else {\n   167→            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n   168→        }\n   169→    }\n   170→}\n   171→\n   172→fn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   173→    // Check for merge conflict markers\n   174→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   175→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   176→        return SyncError.MergeConflictDetected;\n   177→    }\n   178→\n   179→    // For bidirectional sync, we export the current state\n   180→    // A full bidirectional merge would require content hashing which is complex\n   181→    const count = ctx.store.issues.items.len;\n   182→\n   183→    if (ctx.store.dirty) {\n   184→        ctx.store.saveToFile() catch {\n   185→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n   186→            return SyncError.ExportError;\n   187→        };\n   188→\n   189→        if (structured_output) {\n   190→            try ctx.output.printJson(SyncResult{\n   191→                .success = true,\n   192→                .action = \"sync\",\n   193→                .issues_exported = count,\n   194→            });\n   195→        } else if (!quiet) {\n   196→            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n   197→        }\n   198→    } else {\n   199→        if (structured_output) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2473c606-851c-4500-affb-187e291bf8dc","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","content":"        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {","numLines":100,"startLine":100,"totalLines":538}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TEXvk5raKoZJtzuXFF36JJ","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at the config module to understand the prefix setting."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1721,"cache_read_input_tokens":83676,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1721},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"57d4256a-53da-468b-9fe6-672ecc10a503"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TEXvk5raKoZJtzuXFF36JJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B6f3i3yM9vWurZHG7tvx9y","name":"Grep","input":{"pattern":"prefix|id_prefix","path":"/home/hotschmoe/beads_zig/src/config","output_mode":"content","-C":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1721,"cache_read_input_tokens":83676,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1721},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ddee4186-413f-4399-9fc7-a02fab58f93d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B6f3i3yM9vWurZHG7tvx9y","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/config/yaml.zig-37-    }\n/home/hotschmoe/beads_zig/src/config/yaml.zig-38-\nsrc/config/yaml.zig:39:    /// Get a value by dot-separated path (e.g., \"id.prefix\").\n/home/hotschmoe/beads_zig/src/config/yaml.zig-40-    /// Supports both nested structures and flattened key format.\nsrc/config/yaml.zig-41-    pub fn get(self: YamlValue, path: []const u8) ?[]const u8 {\n--\nsrc/config/yaml.zig-184-    allocator: std.mem.Allocator,\nsrc/config/yaml.zig-185-    value: YamlValue,\nsrc/config/yaml.zig:186:    prefix: []const u8,\nsrc/config/yaml.zig-187-    result: *std.ArrayListUnmanaged(struct { key: []const u8, value: []const u8 }),\n/home/hotschmoe/beads_zig/src/config/yaml.zig-188-) !void {\n/home/hotschmoe/beads_zig/src/config/yaml.zig-189-    switch (value) {\n/home/hotschmoe/beads_zig/src/config/yaml.zig-190-        .string => |s| {\nsrc/config/yaml.zig:191:            const key = try allocator.dupe(u8, prefix);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-192-            try result.append(allocator, .{ .key = key, .value = s });\n/home/hotschmoe/beads_zig/src/config/yaml.zig-193-        },\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-195-            var it = m.iterator();\n/home/hotschmoe/beads_zig/src/config/yaml.zig-196-            while (it.next()) |entry| {\nsrc/config/yaml.zig:197:                const new_prefix = if (prefix.len > 0)\nsrc/config/yaml.zig:198:                    try std.fmt.allocPrint(allocator, \"{s}.{s}\", .{ prefix, entry.key_ptr.* })\n/home/hotschmoe/beads_zig/src/config/yaml.zig-199-                else\n/home/hotschmoe/beads_zig/src/config/yaml.zig-200-                    try allocator.dupe(u8, entry.key_ptr.*);\nsrc/config/yaml.zig:201:                defer if (prefix.len > 0) allocator.free(new_prefix);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-202-\nsrc/config/yaml.zig:203:                try flattenInner(allocator, entry.value_ptr.*, new_prefix, result);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-204-            }\n/home/hotschmoe/beads_zig/src/config/yaml.zig-205-        },\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-235-    const content =\nsrc/config/yaml.zig-236-        \\\\id:\nsrc/config/yaml.zig:237:        \\\\  prefix: bd\nsrc/config/yaml.zig-238-        \\\\  length: 4\nsrc/config/yaml.zig-239-        \\\\output:\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-243-    defer value.deinit(allocator);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-244-\nsrc/config/yaml.zig:245:    try std.testing.expectEqualStrings(\"bd\", value.get(\"id.prefix\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-246-    try std.testing.expectEqualStrings(\"4\", value.get(\"id.length\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-247-    try std.testing.expectEqualStrings(\"auto\", value.get(\"output.color\").?);"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a2a35d8a-5adc-47a6-985b-c441a26ca483","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"/home/hotschmoe/beads_zig/src/config/yaml.zig-37-    }\n/home/hotschmoe/beads_zig/src/config/yaml.zig-38-\nsrc/config/yaml.zig:39:    /// Get a value by dot-separated path (e.g., \"id.prefix\").\n/home/hotschmoe/beads_zig/src/config/yaml.zig-40-    /// Supports both nested structures and flattened key format.\nsrc/config/yaml.zig-41-    pub fn get(self: YamlValue, path: []const u8) ?[]const u8 {\n--\nsrc/config/yaml.zig-184-    allocator: std.mem.Allocator,\nsrc/config/yaml.zig-185-    value: YamlValue,\nsrc/config/yaml.zig:186:    prefix: []const u8,\nsrc/config/yaml.zig-187-    result: *std.ArrayListUnmanaged(struct { key: []const u8, value: []const u8 }),\n/home/hotschmoe/beads_zig/src/config/yaml.zig-188-) !void {\n/home/hotschmoe/beads_zig/src/config/yaml.zig-189-    switch (value) {\n/home/hotschmoe/beads_zig/src/config/yaml.zig-190-        .string => |s| {\nsrc/config/yaml.zig:191:            const key = try allocator.dupe(u8, prefix);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-192-            try result.append(allocator, .{ .key = key, .value = s });\n/home/hotschmoe/beads_zig/src/config/yaml.zig-193-        },\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-195-            var it = m.iterator();\n/home/hotschmoe/beads_zig/src/config/yaml.zig-196-            while (it.next()) |entry| {\nsrc/config/yaml.zig:197:                const new_prefix = if (prefix.len > 0)\nsrc/config/yaml.zig:198:                    try std.fmt.allocPrint(allocator, \"{s}.{s}\", .{ prefix, entry.key_ptr.* })\n/home/hotschmoe/beads_zig/src/config/yaml.zig-199-                else\n/home/hotschmoe/beads_zig/src/config/yaml.zig-200-                    try allocator.dupe(u8, entry.key_ptr.*);\nsrc/config/yaml.zig:201:                defer if (prefix.len > 0) allocator.free(new_prefix);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-202-\nsrc/config/yaml.zig:203:                try flattenInner(allocator, entry.value_ptr.*, new_prefix, result);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-204-            }\n/home/hotschmoe/beads_zig/src/config/yaml.zig-205-        },\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-235-    const content =\nsrc/config/yaml.zig-236-        \\\\id:\nsrc/config/yaml.zig:237:        \\\\  prefix: bd\nsrc/config/yaml.zig-238-        \\\\  length: 4\nsrc/config/yaml.zig-239-        \\\\output:\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-243-    defer value.deinit(allocator);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-244-\nsrc/config/yaml.zig:245:    try std.testing.expectEqualStrings(\"bd\", value.get(\"id.prefix\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-246-    try std.testing.expectEqualStrings(\"4\", value.get(\"id.length\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-247-    try std.testing.expectEqualStrings(\"auto\", value.get(\"output.color\").?);","numLines":40}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J6m4S7ET3jBHaVuXGgGVC5","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at the common module to understand how the config is accessed."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1615,"cache_read_input_tokens":85397,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1615},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7da15fd1-683d-4ea2-8e53-e2d2a1d2dd55"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J6m4S7ET3jBHaVuXGgGVC5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0194DhYWMmYp6VBw8twXhTHw","name":"Grep","input":{"pattern":"id\\.prefix|getPrefix","path":"/home/hotschmoe/beads_zig/src","output_mode":"content","-C":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1615,"cache_read_input_tokens":85397,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1615},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"384b8aa4-560f-43c2-aef2-93d6138a4a53"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0194DhYWMmYp6VBw8twXhTHw","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/config/yaml.zig-37-    }\n/home/hotschmoe/beads_zig/src/config/yaml.zig-38-\nsrc/config/yaml.zig:39:    /// Get a value by dot-separated path (e.g., \"id.prefix\").\n/home/hotschmoe/beads_zig/src/config/yaml.zig-40-    /// Supports both nested structures and flattened key format.\nsrc/config/yaml.zig-41-    pub fn get(self: YamlValue, path: []const u8) ?[]const u8 {\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-243-    defer value.deinit(allocator);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-244-\nsrc/config/yaml.zig:245:    try std.testing.expectEqualStrings(\"bd\", value.get(\"id.prefix\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-246-    try std.testing.expectEqualStrings(\"4\", value.get(\"id.length\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-247-    try std.testing.expectEqualStrings(\"auto\", value.get(\"output.color\").?);\n--\n/home/hotschmoe/beads_zig/src/cli/help.zig-101-        .arguments = &[_]ArgHelp{\nsrc/cli/help.zig-102-            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\nsrc/cli/help.zig:103:            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n/home/hotschmoe/beads_zig/src/cli/help.zig-104-            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n/home/hotschmoe/beads_zig/src/cli/help.zig-105-        },\n--\n/home/hotschmoe/beads_zig/src/cli/help.zig-107-            .{ .command = \"bz config\", .description = \"List all configuration\" },\n/home/hotschmoe/beads_zig/src/cli/help.zig-108-            .{ .command = \"bz config list\", .description = \"Same as above\" },\nsrc/cli/help.zig:109:            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n/home/hotschmoe/beads_zig/src/cli/help.zig-110-            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n/home/hotschmoe/beads_zig/src/cli/help.zig-111-        },\n--\n/home/hotschmoe/beads_zig/src/cli/args.zig-2504-\n/home/hotschmoe/beads_zig/src/cli/args.zig-2505-test \"parse config get\" {\nsrc/cli/args.zig:2506:    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n/home/hotschmoe/beads_zig/src/cli/args.zig-2507-    var parser = ArgParser.init(std.testing.allocator, &args);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2508-    const result = try parser.parse();\n/home/hotschmoe/beads_zig/src/cli/args.zig-2509-\nsrc/cli/args.zig:2510:    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2511-}\n/home/hotschmoe/beads_zig/src/cli/args.zig-2512-\n/home/hotschmoe/beads_zig/src/cli/args.zig-2513-test \"parse config set\" {\nsrc/cli/args.zig:2514:    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n/home/hotschmoe/beads_zig/src/cli/args.zig-2515-    var parser = ArgParser.init(std.testing.allocator, &args);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2516-    const result = try parser.parse();\n/home/hotschmoe/beads_zig/src/cli/args.zig-2517-\n/home/hotschmoe/beads_zig/src/cli/args.zig-2518-    const set = result.command.config.subcommand.set;\nsrc/cli/args.zig:2519:    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2520-    try std.testing.expectEqualStrings(\"proj\", set.value);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2521-}\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-43-\n/home/hotschmoe/beads_zig/src/cli/config.zig-44-const known_keys = [_]ConfigKey{\nsrc/cli/config.zig:45:    .{ .key = \"id.prefix\", .default = \"bd\", .description = \"Issue ID prefix\" },\n/home/hotschmoe/beads_zig/src/cli/config.zig-46-    .{ .key = \"id.length\", .default = \"4\", .description = \"Minimum ID length (adaptive)\" },\n/home/hotschmoe/beads_zig/src/cli/config.zig-47-    .{ .key = \"output.color\", .default = \"auto\", .description = \"Color output (auto, always, never)\" },\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-322-    const result = ConfigResult{\n/home/hotschmoe/beads_zig/src/cli/config.zig-323-        .success = true,\nsrc/cli/config.zig:324:        .key = \"id.prefix\",\n/home/hotschmoe/beads_zig/src/cli/config.zig-325-        .value = \"bd\",\n/home/hotschmoe/beads_zig/src/cli/config.zig-326-    };\n/home/hotschmoe/beads_zig/src/cli/config.zig-327-    try std.testing.expect(result.success);\nsrc/cli/config.zig:328:    try std.testing.expectEqualStrings(\"id.prefix\", result.key.?);\n/home/hotschmoe/beads_zig/src/cli/config.zig-329-}\n/home/hotschmoe/beads_zig/src/cli/config.zig-330-\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-341-test \"getConfigValue returns null for missing file\" {\n/home/hotschmoe/beads_zig/src/cli/config.zig-342-    const allocator = std.testing.allocator;\nsrc/cli/config.zig:343:    const value = try getConfigValue(allocator, \"/nonexistent/path\", \"id.prefix\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-344-    try std.testing.expect(value == null);\n/home/hotschmoe/beads_zig/src/cli/config.zig-345-}\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-351-    defer test_util.cleanupTestDir(test_dir);\n/home/hotschmoe/beads_zig/src/cli/config.zig-352-\nsrc/cli/config.zig:353:    try setConfigValue(allocator, test_dir, \"id.prefix\", \"test\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-354-\nsrc/cli/config.zig:355:    const value = try getConfigValue(allocator, test_dir, \"id.prefix\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-356-    try std.testing.expect(value != null);\n/home/hotschmoe/beads_zig/src/cli/config.zig-357-    defer allocator.free(value.?);\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-365-    defer test_util.cleanupTestDir(test_dir);\n/home/hotschmoe/beads_zig/src/cli/config.zig-366-\nsrc/cli/config.zig:367:    try setConfigValue(allocator, test_dir, \"id.prefix\", \"first\");\nsrc/cli/config.zig:368:    try setConfigValue(allocator, test_dir, \"id.prefix\", \"second\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-369-\nsrc/cli/config.zig:370:    const value = try getConfigValue(allocator, test_dir, \"id.prefix\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-371-    try std.testing.expect(value != null);\n/home/hotschmoe/beads_zig/src/cli/config.zig-372-    defer allocator.free(value.?);\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-378-    var found_color = false;\n/home/hotschmoe/beads_zig/src/cli/config.zig-379-    for (known_keys) |key_info| {\nsrc/cli/config.zig:380:        if (std.mem.eql(u8, key_info.key, \"id.prefix\")) found_prefix = true;\n/home/hotschmoe/beads_zig/src/cli/config.zig-381-        if (std.mem.eql(u8, key_info.key, \"output.color\")) found_color = true;\n/home/hotschmoe/beads_zig/src/cli/config.zig-382-    }"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"79e378f0-0bfa-490c-a045-f334b2f134d4","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"/home/hotschmoe/beads_zig/src/config/yaml.zig-37-    }\n/home/hotschmoe/beads_zig/src/config/yaml.zig-38-\nsrc/config/yaml.zig:39:    /// Get a value by dot-separated path (e.g., \"id.prefix\").\n/home/hotschmoe/beads_zig/src/config/yaml.zig-40-    /// Supports both nested structures and flattened key format.\nsrc/config/yaml.zig-41-    pub fn get(self: YamlValue, path: []const u8) ?[]const u8 {\n--\n/home/hotschmoe/beads_zig/src/config/yaml.zig-243-    defer value.deinit(allocator);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-244-\nsrc/config/yaml.zig:245:    try std.testing.expectEqualStrings(\"bd\", value.get(\"id.prefix\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-246-    try std.testing.expectEqualStrings(\"4\", value.get(\"id.length\").?);\n/home/hotschmoe/beads_zig/src/config/yaml.zig-247-    try std.testing.expectEqualStrings(\"auto\", value.get(\"output.color\").?);\n--\n/home/hotschmoe/beads_zig/src/cli/help.zig-101-        .arguments = &[_]ArgHelp{\nsrc/cli/help.zig-102-            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\nsrc/cli/help.zig:103:            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n/home/hotschmoe/beads_zig/src/cli/help.zig-104-            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n/home/hotschmoe/beads_zig/src/cli/help.zig-105-        },\n--\n/home/hotschmoe/beads_zig/src/cli/help.zig-107-            .{ .command = \"bz config\", .description = \"List all configuration\" },\n/home/hotschmoe/beads_zig/src/cli/help.zig-108-            .{ .command = \"bz config list\", .description = \"Same as above\" },\nsrc/cli/help.zig:109:            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n/home/hotschmoe/beads_zig/src/cli/help.zig-110-            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n/home/hotschmoe/beads_zig/src/cli/help.zig-111-        },\n--\n/home/hotschmoe/beads_zig/src/cli/args.zig-2504-\n/home/hotschmoe/beads_zig/src/cli/args.zig-2505-test \"parse config get\" {\nsrc/cli/args.zig:2506:    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n/home/hotschmoe/beads_zig/src/cli/args.zig-2507-    var parser = ArgParser.init(std.testing.allocator, &args);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2508-    const result = try parser.parse();\n/home/hotschmoe/beads_zig/src/cli/args.zig-2509-\nsrc/cli/args.zig:2510:    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2511-}\n/home/hotschmoe/beads_zig/src/cli/args.zig-2512-\n/home/hotschmoe/beads_zig/src/cli/args.zig-2513-test \"parse config set\" {\nsrc/cli/args.zig:2514:    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n/home/hotschmoe/beads_zig/src/cli/args.zig-2515-    var parser = ArgParser.init(std.testing.allocator, &args);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2516-    const result = try parser.parse();\n/home/hotschmoe/beads_zig/src/cli/args.zig-2517-\n/home/hotschmoe/beads_zig/src/cli/args.zig-2518-    const set = result.command.config.subcommand.set;\nsrc/cli/args.zig:2519:    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2520-    try std.testing.expectEqualStrings(\"proj\", set.value);\n/home/hotschmoe/beads_zig/src/cli/args.zig-2521-}\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-43-\n/home/hotschmoe/beads_zig/src/cli/config.zig-44-const known_keys = [_]ConfigKey{\nsrc/cli/config.zig:45:    .{ .key = \"id.prefix\", .default = \"bd\", .description = \"Issue ID prefix\" },\n/home/hotschmoe/beads_zig/src/cli/config.zig-46-    .{ .key = \"id.length\", .default = \"4\", .description = \"Minimum ID length (adaptive)\" },\n/home/hotschmoe/beads_zig/src/cli/config.zig-47-    .{ .key = \"output.color\", .default = \"auto\", .description = \"Color output (auto, always, never)\" },\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-322-    const result = ConfigResult{\n/home/hotschmoe/beads_zig/src/cli/config.zig-323-        .success = true,\nsrc/cli/config.zig:324:        .key = \"id.prefix\",\n/home/hotschmoe/beads_zig/src/cli/config.zig-325-        .value = \"bd\",\n/home/hotschmoe/beads_zig/src/cli/config.zig-326-    };\n/home/hotschmoe/beads_zig/src/cli/config.zig-327-    try std.testing.expect(result.success);\nsrc/cli/config.zig:328:    try std.testing.expectEqualStrings(\"id.prefix\", result.key.?);\n/home/hotschmoe/beads_zig/src/cli/config.zig-329-}\n/home/hotschmoe/beads_zig/src/cli/config.zig-330-\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-341-test \"getConfigValue returns null for missing file\" {\n/home/hotschmoe/beads_zig/src/cli/config.zig-342-    const allocator = std.testing.allocator;\nsrc/cli/config.zig:343:    const value = try getConfigValue(allocator, \"/nonexistent/path\", \"id.prefix\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-344-    try std.testing.expect(value == null);\n/home/hotschmoe/beads_zig/src/cli/config.zig-345-}\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-351-    defer test_util.cleanupTestDir(test_dir);\n/home/hotschmoe/beads_zig/src/cli/config.zig-352-\nsrc/cli/config.zig:353:    try setConfigValue(allocator, test_dir, \"id.prefix\", \"test\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-354-\nsrc/cli/config.zig:355:    const value = try getConfigValue(allocator, test_dir, \"id.prefix\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-356-    try std.testing.expect(value != null);\n/home/hotschmoe/beads_zig/src/cli/config.zig-357-    defer allocator.free(value.?);\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-365-    defer test_util.cleanupTestDir(test_dir);\n/home/hotschmoe/beads_zig/src/cli/config.zig-366-\nsrc/cli/config.zig:367:    try setConfigValue(allocator, test_dir, \"id.prefix\", \"first\");\nsrc/cli/config.zig:368:    try setConfigValue(allocator, test_dir, \"id.prefix\", \"second\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-369-\nsrc/cli/config.zig:370:    const value = try getConfigValue(allocator, test_dir, \"id.prefix\");\n/home/hotschmoe/beads_zig/src/cli/config.zig-371-    try std.testing.expect(value != null);\n/home/hotschmoe/beads_zig/src/cli/config.zig-372-    defer allocator.free(value.?);\n--\n/home/hotschmoe/beads_zig/src/cli/config.zig-378-    var found_color = false;\n/home/hotschmoe/beads_zig/src/cli/config.zig-379-    for (known_keys) |key_info| {\nsrc/cli/config.zig:380:        if (std.mem.eql(u8, key_info.key, \"id.prefix\")) found_prefix = true;\n/home/hotschmoe/beads_zig/src/cli/config.zig-381-        if (std.mem.eql(u8, key_info.key, \"output.color\")) found_color = true;\n/home/hotschmoe/beads_zig/src/cli/config.zig-382-    }","numLines":87}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012XmkytjkRk3EMUWn3yGzwn","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at how the store handles IDs and how to access the config prefix."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2946,"cache_read_input_tokens":87012,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2946},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b75a83fa-f53b-4f56-ae54-65734a142290"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012XmkytjkRk3EMUWn3yGzwn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012dJooNrZRtxW8yMWs5Myya","name":"Grep","input":{"pattern":"bd-|prefix","path":"/home/hotschmoe/beads_zig/src/storage/store.zig","output_mode":"content","-C":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2946,"cache_read_input_tokens":87012,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2946},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c9e0647d-9909-43ef-bdd2-4c9c6b931c06"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012dJooNrZRtxW8yMWs5Myya","type":"tool_result","content":"793-\n794-    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n795:    /// Uses prefix matching and Levenshtein-like scoring.\n796-    /// Returns up to `max_count` suggestions, caller must free.\n797-    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n--\n858-    var score: i32 = 0;\n859-\n860:    // Exact prefix match (bd-abc matches bd-abc123)\n861-    if (std.mem.startsWith(u8, candidate, target)) {\n862-        score += 100;\n863-    }\n864:    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n865-    else if (std.mem.startsWith(u8, target, candidate)) {\n866-        score += 80;\n867-    }\n868-\n869:    // Common prefix length\n870:    var common_prefix: usize = 0;\n871-    const min_len = @min(target.len, candidate.len);\n872-    for (0..min_len) |i| {\n873-        if (target[i] == candidate[i]) {\n874:            common_prefix += 1;\n875-        } else {\n876-            break;\n877-        }\n878-    }\n879:    score += @intCast(common_prefix * 5);\n880-\n881-    // Contains target as substring\n--\n1003-    defer store.deinit();\n1004-\n1005:    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n1006-    try store.insert(issue);\n1007-\n1008:    try std.testing.expect(try store.exists(\"bd-test1\"));\n1009-\n1010:    var retrieved = (try store.get(\"bd-test1\")).?;\n1011-    defer retrieved.deinit(allocator);\n1012-\n1013:    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n1014-    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n1015-}\n--\n1020-    defer store.deinit();\n1021-\n1022:    const result = try store.get(\"bd-nonexistent\");\n1023-    try std.testing.expect(result == null);\n1024-}\n--\n1029-    defer store.deinit();\n1030-\n1031:    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n1032-    try store.insert(issue);\n1033-\n1034:    try store.update(\"bd-update\", .{\n1035-        .title = \"Updated Title\",\n1036-        .status = .in_progress,\n--\n1038-    }, 1706550000);\n1039-\n1040:    var updated = (try store.get(\"bd-update\")).?;\n1041-    defer updated.deinit(allocator);\n1042-\n--\n1051-    defer store.deinit();\n1052-\n1053:    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n1054-    try store.insert(issue);\n1055-\n1056-    // Initial version should be 1\n1057:    var v1 = (try store.get(\"bd-version\")).?;\n1058-    defer v1.deinit(allocator);\n1059-    try std.testing.expectEqual(@as(u64, 1), v1.version);\n1060-\n1061-    // Update should increment version\n1062:    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n1063-\n1064:    var v2 = (try store.get(\"bd-version\")).?;\n1065-    defer v2.deinit(allocator);\n1066-    try std.testing.expectEqual(@as(u64, 2), v2.version);\n1067-\n1068-    // Another update should increment again\n1069:    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n1070-\n1071:    var v3 = (try store.get(\"bd-version\")).?;\n1072-    defer v3.deinit(allocator);\n1073-    try std.testing.expectEqual(@as(u64, 3), v3.version);\n--\n1079-    defer store.deinit();\n1080-\n1081:    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n1082-    try store.insert(issue);\n1083-\n1084-    // Get current version (1)\n1085:    var current = (try store.get(\"bd-optlock\")).?;\n1086-    const current_version = current.version;\n1087-    current.deinit(allocator);\n1088-\n1089-    // Update with correct expected version should succeed\n1090:    try store.update(\"bd-optlock\", .{\n1091-        .title = \"Updated with lock\",\n1092-        .expected_version = current_version,\n1093-    }, 1706550000);\n1094-\n1095:    var updated = (try store.get(\"bd-optlock\")).?;\n1096-    defer updated.deinit(allocator);\n1097-    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n--\n1104-    defer store.deinit();\n1105-\n1106:    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n1107-    try store.insert(issue);\n1108-\n1109-    // Update once to increment version to 2\n1110:    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n1111-\n1112-    // Try to update with stale expected_version (1 instead of 2)\n1113:    const result = store.update(\"bd-conflict\", .{\n1114-        .title = \"Conflicting Update\",\n1115-        .expected_version = 1, // Stale version\n--\n1119-\n1120-    // Verify original update is preserved\n1121:    var preserved = (try store.get(\"bd-conflict\")).?;\n1122-    defer preserved.deinit(allocator);\n1123-    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n--\n1130-    defer store.deinit();\n1131-\n1132:    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n1133-    try store.insert(issue);\n1134-\n1135:    try store.delete(\"bd-delete\", 1706550000);\n1136-\n1137:    var deleted = (try store.get(\"bd-delete\")).?;\n1138-    defer deleted.deinit(allocator);\n1139-\n--\n1146-    defer store.deinit();\n1147-\n1148:    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n1149:    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n1150:    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n1151-\n1152-    const issues = try store.list(.{});\n--\n1167-    defer store.deinit();\n1168-\n1169:    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n1170:    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n1171:    try store.delete(\"bd-deleted\", 1706560000);\n1172-\n1173-    const issues = try store.list(.{});\n--\n1181-\n1182-    try std.testing.expectEqual(@as(usize, 1), issues.len);\n1183:    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n1184-}\n1185-\n--\n1189-    defer store.deinit();\n1190-\n1191:    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n1192-    try store.insert(issue);\n1193-\n--\n1203-\n1204-    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n1205:    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n1206-\n1207:    try store.clearDirty(\"bd-dirty\");\n1208-\n1209-    const after_clear = try store.getDirtyIds();\n--\n1218-    defer store.deinit();\n1219-\n1220:    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n1221-\n1222:    try store.addLabel(\"bd-labels\", \"bug\");\n1223:    try store.addLabel(\"bd-labels\", \"urgent\");\n1224-\n1225:    const labels = try store.getLabels(\"bd-labels\");\n1226-    defer {\n1227-        for (labels) |lbl| {\n--\n1233-    try std.testing.expectEqual(@as(usize, 2), labels.len);\n1234-\n1235:    try store.removeLabel(\"bd-labels\", \"bug\");\n1236-\n1237:    const after_remove = try store.getLabels(\"bd-labels\");\n1238-    defer {\n1239-        for (after_remove) |lbl| {\n--\n1273-\n1274-        // Valid issue\n1275:[Omitted long matching line]\n1276-        try file.writeAll(valid1);\n1277-\n--\n1280-\n1281-        // Another valid issue\n1282:[Omitted long matching line]\n1283-        try file.writeAll(valid2);\n1284-    }\n--\n1298-\n1299-    // Verify the correct issues were loaded\n1300:    try std.testing.expect(try store.exists(\"bd-valid1\"));\n1301:    try std.testing.expect(try store.exists(\"bd-valid2\"));\n1302-}"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"dc490ec1-1cdf-478e-9fdc-6cf1adefaf80","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"793-\n794-    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n795:    /// Uses prefix matching and Levenshtein-like scoring.\n796-    /// Returns up to `max_count` suggestions, caller must free.\n797-    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n--\n858-    var score: i32 = 0;\n859-\n860:    // Exact prefix match (bd-abc matches bd-abc123)\n861-    if (std.mem.startsWith(u8, candidate, target)) {\n862-        score += 100;\n863-    }\n864:    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n865-    else if (std.mem.startsWith(u8, target, candidate)) {\n866-        score += 80;\n867-    }\n868-\n869:    // Common prefix length\n870:    var common_prefix: usize = 0;\n871-    const min_len = @min(target.len, candidate.len);\n872-    for (0..min_len) |i| {\n873-        if (target[i] == candidate[i]) {\n874:            common_prefix += 1;\n875-        } else {\n876-            break;\n877-        }\n878-    }\n879:    score += @intCast(common_prefix * 5);\n880-\n881-    // Contains target as substring\n--\n1003-    defer store.deinit();\n1004-\n1005:    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n1006-    try store.insert(issue);\n1007-\n1008:    try std.testing.expect(try store.exists(\"bd-test1\"));\n1009-\n1010:    var retrieved = (try store.get(\"bd-test1\")).?;\n1011-    defer retrieved.deinit(allocator);\n1012-\n1013:    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n1014-    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n1015-}\n--\n1020-    defer store.deinit();\n1021-\n1022:    const result = try store.get(\"bd-nonexistent\");\n1023-    try std.testing.expect(result == null);\n1024-}\n--\n1029-    defer store.deinit();\n1030-\n1031:    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n1032-    try store.insert(issue);\n1033-\n1034:    try store.update(\"bd-update\", .{\n1035-        .title = \"Updated Title\",\n1036-        .status = .in_progress,\n--\n1038-    }, 1706550000);\n1039-\n1040:    var updated = (try store.get(\"bd-update\")).?;\n1041-    defer updated.deinit(allocator);\n1042-\n--\n1051-    defer store.deinit();\n1052-\n1053:    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n1054-    try store.insert(issue);\n1055-\n1056-    // Initial version should be 1\n1057:    var v1 = (try store.get(\"bd-version\")).?;\n1058-    defer v1.deinit(allocator);\n1059-    try std.testing.expectEqual(@as(u64, 1), v1.version);\n1060-\n1061-    // Update should increment version\n1062:    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n1063-\n1064:    var v2 = (try store.get(\"bd-version\")).?;\n1065-    defer v2.deinit(allocator);\n1066-    try std.testing.expectEqual(@as(u64, 2), v2.version);\n1067-\n1068-    // Another update should increment again\n1069:    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n1070-\n1071:    var v3 = (try store.get(\"bd-version\")).?;\n1072-    defer v3.deinit(allocator);\n1073-    try std.testing.expectEqual(@as(u64, 3), v3.version);\n--\n1079-    defer store.deinit();\n1080-\n1081:    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n1082-    try store.insert(issue);\n1083-\n1084-    // Get current version (1)\n1085:    var current = (try store.get(\"bd-optlock\")).?;\n1086-    const current_version = current.version;\n1087-    current.deinit(allocator);\n1088-\n1089-    // Update with correct expected version should succeed\n1090:    try store.update(\"bd-optlock\", .{\n1091-        .title = \"Updated with lock\",\n1092-        .expected_version = current_version,\n1093-    }, 1706550000);\n1094-\n1095:    var updated = (try store.get(\"bd-optlock\")).?;\n1096-    defer updated.deinit(allocator);\n1097-    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n--\n1104-    defer store.deinit();\n1105-\n1106:    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n1107-    try store.insert(issue);\n1108-\n1109-    // Update once to increment version to 2\n1110:    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n1111-\n1112-    // Try to update with stale expected_version (1 instead of 2)\n1113:    const result = store.update(\"bd-conflict\", .{\n1114-        .title = \"Conflicting Update\",\n1115-        .expected_version = 1, // Stale version\n--\n1119-\n1120-    // Verify original update is preserved\n1121:    var preserved = (try store.get(\"bd-conflict\")).?;\n1122-    defer preserved.deinit(allocator);\n1123-    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n--\n1130-    defer store.deinit();\n1131-\n1132:    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n1133-    try store.insert(issue);\n1134-\n1135:    try store.delete(\"bd-delete\", 1706550000);\n1136-\n1137:    var deleted = (try store.get(\"bd-delete\")).?;\n1138-    defer deleted.deinit(allocator);\n1139-\n--\n1146-    defer store.deinit();\n1147-\n1148:    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n1149:    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n1150:    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n1151-\n1152-    const issues = try store.list(.{});\n--\n1167-    defer store.deinit();\n1168-\n1169:    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n1170:    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n1171:    try store.delete(\"bd-deleted\", 1706560000);\n1172-\n1173-    const issues = try store.list(.{});\n--\n1181-\n1182-    try std.testing.expectEqual(@as(usize, 1), issues.len);\n1183:    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n1184-}\n1185-\n--\n1189-    defer store.deinit();\n1190-\n1191:    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n1192-    try store.insert(issue);\n1193-\n--\n1203-\n1204-    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n1205:    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n1206-\n1207:    try store.clearDirty(\"bd-dirty\");\n1208-\n1209-    const after_clear = try store.getDirtyIds();\n--\n1218-    defer store.deinit();\n1219-\n1220:    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n1221-\n1222:    try store.addLabel(\"bd-labels\", \"bug\");\n1223:    try store.addLabel(\"bd-labels\", \"urgent\");\n1224-\n1225:    const labels = try store.getLabels(\"bd-labels\");\n1226-    defer {\n1227-        for (labels) |lbl| {\n--\n1233-    try std.testing.expectEqual(@as(usize, 2), labels.len);\n1234-\n1235:    try store.removeLabel(\"bd-labels\", \"bug\");\n1236-\n1237:    const after_remove = try store.getLabels(\"bd-labels\");\n1238-    defer {\n1239-        for (after_remove) |lbl| {\n--\n1273-\n1274-        // Valid issue\n1275:[Omitted long matching line]\n1276-        try file.writeAll(valid1);\n1277-\n--\n1280-\n1281-        // Another valid issue\n1282:[Omitted long matching line]\n1283-        try file.writeAll(valid2);\n1284-    }\n--\n1298-\n1299-    // Verify the correct issues were loaded\n1300:    try std.testing.expect(try store.exists(\"bd-valid1\"));\n1301:    try std.testing.expect(try store.exists(\"bd-valid2\"));\n1302-}","numLines":212}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Ds3dh428mdSWzkBeHTPn73","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding. Let me update the runImport function with orphan_policy and rename_prefix support."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2785,"cache_read_input_tokens":89958,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2785},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c29d24e9-c9ee-44d0-980b-c6535b6e4b00"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Ds3dh428mdSWzkBeHTPn73","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XFXZ4C5Nr3TQUSC2ut8psp","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}","new_string":"fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove = std.ArrayList(usize).init(allocator);\n    defer issues_to_remove.deinit();\n\n    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2785,"cache_read_input_tokens":89958,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2785},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"69ca8a9c-38ec-43c0-bc1f-e5b2151c65a6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XFXZ4C5Nr3TQUSC2ut8psp","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7021d554-fb27-459f-b9b5-300222248f7e","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}","newString":"fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove = std.ArrayList(usize).init(allocator);\n    defer issues_to_remove.deinit();\n\n    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":121,"oldLines":7,"newStart":121,"newLines":7,"lines":["     }"," }"," ","-fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {","+fn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {","     // Check for merge conflict markers in the JSONL file","     if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {","         try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");"]},{"oldStart":150,"oldLines":6,"newStart":150,"newLines":100,"lines":["         return SyncError.ImportError;","     };"," ","+    var orphans_created: usize = 0;","+    var issues_skipped: usize = 0;","+    var issues_renamed: usize = 0;","+","+    // Get the expected prefix from config (default to \"bd\")","+    const expected_prefix = ctx.store.getPrefix();","+","+    // Process orphans and prefix renaming","+    var issues_to_remove = std.ArrayList(usize).init(allocator);","+    defer issues_to_remove.deinit();","+","+    var orphan_ids = std.ArrayList([]const u8).init(allocator);","+    defer {","+        for (orphan_ids.items) |id| allocator.free(id);","+        orphan_ids.deinit();","+    }","+","+    for (ctx.store.issues.items, 0..) |*issue, idx| {","+        // Check for wrong prefix and rename if requested","+        if (rename_prefix) {","+            if (issue.id.len >= 3) {","+                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");","+                if (dash_pos) |pos| {","+                    const current_prefix = issue.id[0..pos];","+                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {","+                        // Create new ID with correct prefix","+                        const suffix = issue.id[pos..];","+                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });","+","+                        // Update the issue's ID (need to free old and set new)","+                        allocator.free(issue.id);","+                        issue.id = new_id;","+                        issues_renamed += 1;","+                    }","+                }","+            }","+        }","+","+        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)","+        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {","+            const parent_id = issue.id[0..dot_pos];","+            const parent_exists = ctx.store.id_index.contains(parent_id);","+","+            if (!parent_exists) {","+                switch (orphan_policy) {","+                    .strict => {","+                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");","+                        return SyncError.ImportError;","+                    },","+                    .resurrect => {","+                        // Create a placeholder parent issue","+                        const parent_id_copy = try allocator.dupe(u8, parent_id);","+                        try orphan_ids.append(parent_id_copy);","+                        orphans_created += 1;","+                    },","+                    .skip => {","+                        try issues_to_remove.append(idx);","+                        issues_skipped += 1;","+                    },","+                }","+            }","+        }","+    }","+","+    // Remove skipped issues (in reverse order to maintain indices)","+    var i = issues_to_remove.items.len;","+    while (i > 0) {","+        i -= 1;","+        const idx = issues_to_remove.items[i];","+        var removed = ctx.store.issues.orderedRemove(idx);","+        removed.deinit(allocator);","+    }","+","+    // Create placeholder parents for orphans (resurrect policy)","+    for (orphan_ids.items) |parent_id| {","+        if (!ctx.store.id_index.contains(parent_id)) {","+            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});","+            defer allocator.free(placeholder_title);","+","+            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());","+            placeholder.id = try allocator.dupe(u8, parent_id);","+            placeholder.title = try allocator.dupe(u8, placeholder_title);","+            try ctx.store.insert(placeholder);","+        }","+    }","+","+    // Rebuild index after modifications","+    ctx.store.rebuildIndex() catch {};","+","+    // Mark dirty if we made changes","+    if (issues_renamed > 0 or orphans_created > 0) {","+        ctx.store.dirty = true;","+    }","+","     const new_count = ctx.store.issues.items.len;"," ","     if (structured_output) {"]},{"oldStart":157,"oldLines":6,"newStart":251,"newLines":9,"lines":["             .success = true,","             .action = \"import\",","             .issues_imported = new_count,","+            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,","+            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,","+            .orphans_created = if (orphans_created > 0) orphans_created else null,","         });","     } else if (!quiet) {","         if (new_count > old_count) {"]},{"oldStart":166,"oldLines":6,"newStart":263,"newLines":15,"lines":["         } else {","             try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});","         }","+        if (issues_renamed > 0) {","+            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});","+        }","+        if (orphans_created > 0) {","+            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});","+        }","+        if (issues_skipped > 0) {","+            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});","+        }","     }"," }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LatycuL2iSXnskmqCuFMtA","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update runMerge to accept the same parameters and add a getPrefix method to the store and rebuildIndex method. Let me first check the store.zig for existing methods."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2630,"cache_read_input_tokens":92743,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2630},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"0d06ad03-17e7-48e8-8b62-f17e51af335f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LatycuL2iSXnskmqCuFMtA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KdDbZNBEQooA2wpvCUbRjz","name":"Grep","input":{"pattern":"pub fn|getPrefix|rebuildIndex","path":"/home/hotschmoe/beads_zig/src/storage/store.zig","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2630,"cache_read_input_tokens":92743,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2630},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ce4c839c-fcf9-42bf-ace9-008f79a59f3f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KdDbZNBEQooA2wpvCUbRjz","type":"tool_result","content":"35:    pub fn hasCorruption(self: StoreLoadResult) bool {\n39:    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n56:    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n67:    pub fn deinit(self: *Self) void {\n87:    pub fn loadFromFile(self: *Self) !void {\n107:    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n136:    pub fn saveToFile(self: *Self) !void {\n150:    pub fn insert(self: *Self, issue: Issue) !void {\n172:    pub fn get(self: *Self, id: []const u8) !?Issue {\n181:    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n187:    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n224:    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n326:    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n332:    pub fn remove(self: *Self, id: []const u8) !void {\n392:    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n535:    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n585:    pub fn exists(self: *Self, id: []const u8) !bool {\n590:    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n607:    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n635:    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n673:    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n690:    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n707:    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n729:    pub fn markDirty(self: *Self, id: []const u8) !void {\n742:    pub fn clearDirty(self: *Self, id: []const u8) !void {\n749:    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n768:    pub fn isDirty(self: *Self) bool {\n773:    pub fn countTotal(self: *Self) usize {\n784:    pub fn getAllRef(self: *Self) []const Issue {\n797:    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n846:    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n912:pub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e929811d-325d-4130-b0fd-3210185c7ba4","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"35:    pub fn hasCorruption(self: StoreLoadResult) bool {\n39:    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n56:    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n67:    pub fn deinit(self: *Self) void {\n87:    pub fn loadFromFile(self: *Self) !void {\n107:    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n136:    pub fn saveToFile(self: *Self) !void {\n150:    pub fn insert(self: *Self, issue: Issue) !void {\n172:    pub fn get(self: *Self, id: []const u8) !?Issue {\n181:    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n187:    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n224:    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n326:    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n332:    pub fn remove(self: *Self, id: []const u8) !void {\n392:    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n535:    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n585:    pub fn exists(self: *Self, id: []const u8) !bool {\n590:    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n607:    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n635:    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n673:    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n690:    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n707:    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n729:    pub fn markDirty(self: *Self, id: []const u8) !void {\n742:    pub fn clearDirty(self: *Self, id: []const u8) !void {\n749:    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n768:    pub fn isDirty(self: *Self) bool {\n773:    pub fn countTotal(self: *Self) usize {\n784:    pub fn getAllRef(self: *Self) []const Issue {\n797:    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n846:    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n912:pub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {","numLines":32}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Lb82JycgMgFF9dAQSSpnmZ","type":"message","role":"assistant","content":[{"type":"text","text":"I need to add `getPrefix` and `rebuildIndex` methods to the store. Let me read the store.zig to find a good place to add them."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1014,"cache_read_input_tokens":95373,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1014},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c27b20fd-1949-4c5e-8211-e3532961c64a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Lb82JycgMgFF9dAQSSpnmZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M9rNDq3swafix1zJczVdGh","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1014,"cache_read_input_tokens":95373,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1014},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4d780436-75c9-4a68-9be1-59386b2737f4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M9rNDq3swafix1zJczVdGh","type":"tool_result","content":"     1→//! In-memory issue store for beads_zig.\n     2→//!\n     3→//! Provides CRUD operations for issues using in-memory storage with:\n     4→//! - Arena allocator for issue memory management\n     5→//! - ArrayList + StringHashMap for fast ID lookup\n     6→//! - Dirty tracking for sync operations\n     7→//! - JSONL persistence via JsonlFile\n     8→\n     9→const std = @import(\"std\");\n    10→const JsonlFile = @import(\"jsonl.zig\").JsonlFile;\n    11→const Issue = @import(\"../models/issue.zig\").Issue;\n    12→const Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\n    13→const OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\n    14→const Status = @import(\"../models/status.zig\").Status;\n    15→const Priority = @import(\"../models/priority.zig\").Priority;\n    16→const IssueType = @import(\"../models/issue_type.zig\").IssueType;\n    17→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    18→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    19→const Comment = @import(\"../models/comment.zig\").Comment;\n    20→\n    21→pub const IssueStoreError = error{\n    22→    IssueNotFound,\n    23→    DuplicateId,\n    24→    InvalidIssue,\n    25→    VersionMismatch,\n    26→};\n    27→\n    28→/// Result of loading the store with corruption tracking.\n    29→pub const StoreLoadResult = struct {\n    30→    /// Number of corrupt JSONL entries skipped.\n    31→    jsonl_corruption_count: usize = 0,\n    32→    /// Line numbers of corrupt JSONL entries (1-indexed).\n    33→    jsonl_corrupt_lines: []const usize = &.{},\n    34→\n    35→    pub fn hasCorruption(self: StoreLoadResult) bool {\n    36→        return self.jsonl_corruption_count > 0;\n    37→    }\n    38→\n    39→    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n    40→        if (self.jsonl_corrupt_lines.len > 0) {\n    41→            allocator.free(self.jsonl_corrupt_lines);\n    42→        }\n    43→    }\n    44→};\n    45→\n    46→pub const IssueStore = struct {\n    47→    allocator: std.mem.Allocator,\n    48→    issues: std.ArrayListUnmanaged(Issue),\n    49→    id_index: std.StringHashMapUnmanaged(usize),\n    50→    dirty_ids: std.StringHashMapUnmanaged(i64),\n    51→    dirty: bool,\n    52→    jsonl_path: []const u8,\n    53→\n    54→    const Self = @This();\n    55→\n    56→    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n    57→        return .{\n    58→            .allocator = allocator,\n    59→            .issues = .{},\n    60→            .id_index = .{},\n    61→            .dirty_ids = .{},\n    62→            .dirty = false,\n    63→            .jsonl_path = jsonl_path,\n    64→        };\n    65→    }\n    66→\n    67→    pub fn deinit(self: *Self) void {\n    68→        for (self.issues.items) |*issue| {\n    69→            issue.deinit(self.allocator);\n    70→        }\n    71→        self.issues.deinit(self.allocator);\n    72→\n    73→        var id_it = self.id_index.keyIterator();\n    74→        while (id_it.next()) |key| {\n    75→            self.allocator.free(key.*);\n    76→        }\n    77→        self.id_index.deinit(self.allocator);\n    78→\n    79→        var dirty_it = self.dirty_ids.keyIterator();\n    80→        while (dirty_it.next()) |key| {\n    81→            self.allocator.free(key.*);\n    82→        }\n    83→        self.dirty_ids.deinit(self.allocator);\n    84→    }\n    85→\n    86→    /// Load issues from the JSONL file into memory.\n    87→    pub fn loadFromFile(self: *Self) !void {\n    88→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n    89→        const loaded_issues = try jsonl.readAll();\n    90→        defer self.allocator.free(loaded_issues);\n    91→\n    92→        for (loaded_issues) |issue| {\n    93→            const id_copy = try self.allocator.dupe(u8, issue.id);\n    94→            errdefer self.allocator.free(id_copy);\n    95→\n    96→            const idx = self.issues.items.len;\n    97→            try self.issues.append(self.allocator, issue);\n    98→            try self.id_index.put(self.allocator, id_copy, idx);\n    99→        }\n   100→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"71343f71-56c1-4b5d-bd24-c88ac829f50c","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","content":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {\n            allocator.free(self.jsonl_corrupt_lines);\n        }\n    }\n};\n\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),\n    id_index: std.StringHashMapUnmanaged(usize),\n    dirty_ids: std.StringHashMapUnmanaged(i64),\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .issues = .{},\n            .id_index = .{},\n            .dirty_ids = .{},\n            .dirty = false,\n            .jsonl_path = jsonl_path,\n        };\n    }\n\n    pub fn deinit(self: *Self) void {\n        for (self.issues.items) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.issues.deinit(self.allocator);\n\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.deinit(self.allocator);\n\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.deinit(self.allocator);\n    }\n\n    /// Load issues from the JSONL file into memory.\n    pub fn loadFromFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        const loaded_issues = try jsonl.readAll();\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n","numLines":100,"startLine":1,"totalLines":1303}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WK4QowXujkbwXRZJrvXkYD","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read more of the store to find a good place to add the methods."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1968,"cache_read_input_tokens":96387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1968},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"0cabd91e-f55b-4618-babc-529cf406893b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WK4QowXujkbwXRZJrvXkYD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VHbGux9ib9psn6Uvn9Ypc2","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","offset":765,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1968,"cache_read_input_tokens":96387,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1968},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8b47d68d-0412-4cc3-b391-d57dd7deca81"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VHbGux9ib9psn6Uvn9Ypc2","type":"tool_result","content":"   765→    }\n   766→\n   767→    /// Check if the store has unsaved changes.\n   768→    pub fn isDirty(self: *Self) bool {\n   769→        return self.dirty;\n   770→    }\n   771→\n   772→    /// Get total number of issues (excluding tombstones).\n   773→    pub fn countTotal(self: *Self) usize {\n   774→        var total: usize = 0;\n   775→        for (self.issues.items) |issue| {\n   776→            if (!statusEql(issue.status, .tombstone)) {\n   777→                total += 1;\n   778→            }\n   779→        }\n   780→        return total;\n   781→    }\n   782→\n   783→    /// Get all issues as a slice (no clone, read-only).\n   784→    pub fn getAllRef(self: *Self) []const Issue {\n   785→        return self.issues.items;\n   786→    }\n   787→\n   788→    /// Suggestion for similar ID lookup.\n   789→    pub const IdSuggestion = struct {\n   790→        id: []const u8,\n   791→        title: []const u8,\n   792→    };\n   793→\n   794→    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n   795→    /// Uses prefix matching and Levenshtein-like scoring.\n   796→    /// Returns up to `max_count` suggestions, caller must free.\n   797→    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n   798→        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n   799→\n   800→        const Scored = struct {\n   801→            id: []const u8,\n   802→            title: []const u8,\n   803→            score: i32,\n   804→        };\n   805→\n   806→        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n   807→        defer candidates.deinit(self.allocator);\n   808→\n   809→        for (self.issues.items) |issue| {\n   810→            if (statusEql(issue.status, .tombstone)) continue;\n   811→\n   812→            const score = computeSimilarity(target, issue.id);\n   813→            if (score > 0) {\n   814→                try candidates.append(self.allocator, .{\n   815→                    .id = issue.id,\n   816→                    .title = issue.title,\n   817→                    .score = score,\n   818→                });\n   819→            }\n   820→        }\n   821→\n   822→        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n   823→\n   824→        // Sort by score descending\n   825→        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n   826→            fn lessThan(_: void, a: Scored, b: Scored) bool {\n   827→                return a.score > b.score;\n   828→            }\n   829→        }.lessThan);\n   830→\n   831→        const result_count = @min(max_count, candidates.items.len);\n   832→        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n   833→        errdefer self.allocator.free(suggestions);\n   834→\n   835→        for (0..result_count) |i| {\n   836→            suggestions[i] = .{\n   837→                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n   838→                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n   839→            };\n   840→        }\n   841→\n   842→        return suggestions;\n   843→    }\n   844→\n   845→    /// Free suggestions returned by findSimilarIds.\n   846→    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n   847→        for (suggestions) |s| {\n   848→            self.allocator.free(s.id);\n   849→            self.allocator.free(s.title);\n   850→        }\n   851→        self.allocator.free(suggestions);\n   852→    }\n   853→};\n   854→\n   855→/// Compute similarity score between target and candidate ID.\n   856→/// Higher score = more similar.\n   857→fn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n   858→    var score: i32 = 0;\n   859→\n   860→    // Exact prefix match (bd-abc matches bd-abc123)\n   861→    if (std.mem.startsWith(u8, candidate, target)) {\n   862→        score += 100;\n   863→    }\n   864→    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"90a5d39c-a3ae-4dd8-a232-b579ad3f2070","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","content":"    }\n\n    /// Check if the store has unsaved changes.\n    pub fn isDirty(self: *Self) bool {\n        return self.dirty;\n    }\n\n    /// Get total number of issues (excluding tombstones).\n    pub fn countTotal(self: *Self) usize {\n        var total: usize = 0;\n        for (self.issues.items) |issue| {\n            if (!statusEql(issue.status, .tombstone)) {\n                total += 1;\n            }\n        }\n        return total;\n    }\n\n    /// Get all issues as a slice (no clone, read-only).\n    pub fn getAllRef(self: *Self) []const Issue {\n        return self.issues.items;\n    }\n\n    /// Suggestion for similar ID lookup.\n    pub const IdSuggestion = struct {\n        id: []const u8,\n        title: []const u8,\n    };\n\n    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n    /// Uses prefix matching and Levenshtein-like scoring.\n    /// Returns up to `max_count` suggestions, caller must free.\n    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n\n        const Scored = struct {\n            id: []const u8,\n            title: []const u8,\n            score: i32,\n        };\n\n        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n        defer candidates.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const score = computeSimilarity(target, issue.id);\n            if (score > 0) {\n                try candidates.append(self.allocator, .{\n                    .id = issue.id,\n                    .title = issue.title,\n                    .score = score,\n                });\n            }\n        }\n\n        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n\n        // Sort by score descending\n        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n            fn lessThan(_: void, a: Scored, b: Scored) bool {\n                return a.score > b.score;\n            }\n        }.lessThan);\n\n        const result_count = @min(max_count, candidates.items.len);\n        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n        errdefer self.allocator.free(suggestions);\n\n        for (0..result_count) |i| {\n            suggestions[i] = .{\n                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n            };\n        }\n\n        return suggestions;\n    }\n\n    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};\n\n/// Compute similarity score between target and candidate ID.\n/// Higher score = more similar.\nfn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n    var score: i32 = 0;\n\n    // Exact prefix match (bd-abc matches bd-abc123)\n    if (std.mem.startsWith(u8, candidate, target)) {\n        score += 100;\n    }\n    // Candidate is prefix of target (bd-abc123 starts with bd-abc)","numLines":100,"startLine":765,"totalLines":1303}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KWsJKDQh8i1QxPamfSZAwd","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the `getPrefix` and `rebuildIndex` methods to the store. I'll add them before the closing brace of the struct."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1511,"cache_read_input_tokens":98355,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1511},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"aca6c1d7-c154-4386-9523-ba5427b9e775"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KWsJKDQh8i1QxPamfSZAwd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016MDS5rqdvZH4oYbVXeBkKM","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","old_string":"    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};","new_string":"    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n\n    /// Get the ID prefix from existing issues, or return default \"bd\".\n    /// Infers the prefix from the first issue's ID format.\n    pub fn getPrefix(self: *Self) []const u8 {\n        for (self.issues.items) |issue| {\n            if (std.mem.indexOf(u8, issue.id, \"-\")) |dash_pos| {\n                return issue.id[0..dash_pos];\n            }\n        }\n        return \"bd\"; // Default prefix\n    }\n\n    /// Rebuild the ID index from current issues.\n    /// Used after modifying issue IDs or removing issues.\n    pub fn rebuildIndex(self: *Self) !void {\n        // Clear existing index\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.clearRetainingCapacity();\n\n        // Rebuild from issues array\n        for (self.issues.items, 0..) |issue, idx| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n    }\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1511,"cache_read_input_tokens":98355,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1511},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3b9a6331-69ac-4fc9-bf2d-d05d2654d7d9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016MDS5rqdvZH4oYbVXeBkKM","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/store.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6a84ebb7-8dd7-40aa-b5da-597299374a55","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/store.zig","oldString":"    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};","newString":"    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n\n    /// Get the ID prefix from existing issues, or return default \"bd\".\n    /// Infers the prefix from the first issue's ID format.\n    pub fn getPrefix(self: *Self) []const u8 {\n        for (self.issues.items) |issue| {\n            if (std.mem.indexOf(u8, issue.id, \"-\")) |dash_pos| {\n                return issue.id[0..dash_pos];\n            }\n        }\n        return \"bd\"; // Default prefix\n    }\n\n    /// Rebuild the ID index from current issues.\n    /// Used after modifying issue IDs or removing issues.\n    pub fn rebuildIndex(self: *Self) !void {\n        // Clear existing index\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.clearRetainingCapacity();\n\n        // Rebuild from issues array\n        for (self.issues.items, 0..) |issue, idx| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n    }\n};","originalFile":"//! In-memory issue store for beads_zig.\n//!\n//! Provides CRUD operations for issues using in-memory storage with:\n//! - Arena allocator for issue memory management\n//! - ArrayList + StringHashMap for fast ID lookup\n//! - Dirty tracking for sync operations\n//! - JSONL persistence via JsonlFile\n\nconst std = @import(\"std\");\nconst JsonlFile = @import(\"jsonl.zig\").JsonlFile;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\nconst OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\nconst Status = @import(\"../models/status.zig\").Status;\nconst Priority = @import(\"../models/priority.zig\").Priority;\nconst IssueType = @import(\"../models/issue_type.zig\").IssueType;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Comment = @import(\"../models/comment.zig\").Comment;\n\npub const IssueStoreError = error{\n    IssueNotFound,\n    DuplicateId,\n    InvalidIssue,\n    VersionMismatch,\n};\n\n/// Result of loading the store with corruption tracking.\npub const StoreLoadResult = struct {\n    /// Number of corrupt JSONL entries skipped.\n    jsonl_corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (1-indexed).\n    jsonl_corrupt_lines: []const usize = &.{},\n\n    pub fn hasCorruption(self: StoreLoadResult) bool {\n        return self.jsonl_corruption_count > 0;\n    }\n\n    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n        if (self.jsonl_corrupt_lines.len > 0) {\n            allocator.free(self.jsonl_corrupt_lines);\n        }\n    }\n};\n\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),\n    id_index: std.StringHashMapUnmanaged(usize),\n    dirty_ids: std.StringHashMapUnmanaged(i64),\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .issues = .{},\n            .id_index = .{},\n            .dirty_ids = .{},\n            .dirty = false,\n            .jsonl_path = jsonl_path,\n        };\n    }\n\n    pub fn deinit(self: *Self) void {\n        for (self.issues.items) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.issues.deinit(self.allocator);\n\n        var id_it = self.id_index.keyIterator();\n        while (id_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.id_index.deinit(self.allocator);\n\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.deinit(self.allocator);\n    }\n\n    /// Load issues from the JSONL file into memory.\n    pub fn loadFromFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        const loaded_issues = try jsonl.readAll();\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n    }\n\n    /// Load issues from the JSONL file with graceful corruption recovery.\n    /// Logs and skips corrupt entries instead of failing.\n    /// Returns statistics about the load including corruption count.\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        var load_result = try jsonl.readAllWithRecovery();\n        // Take ownership of corrupt_lines before freeing issues slice\n        const corrupt_lines = load_result.corrupt_lines;\n        load_result.corrupt_lines = &.{}; // Prevent double-free\n        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n\n        const loaded_issues = load_result.issues;\n        defer self.allocator.free(loaded_issues);\n\n        for (loaded_issues) |issue| {\n            const id_copy = try self.allocator.dupe(u8, issue.id);\n            errdefer self.allocator.free(id_copy);\n\n            const idx = self.issues.items.len;\n            try self.issues.append(self.allocator, issue);\n            try self.id_index.put(self.allocator, id_copy, idx);\n        }\n\n        self.dirty = false;\n\n        return StoreLoadResult{\n            .jsonl_corruption_count = load_result.corruption_count,\n            .jsonl_corrupt_lines = corrupt_lines,\n        };\n    }\n\n    /// Save all issues to the JSONL file.\n    pub fn saveToFile(self: *Self) !void {\n        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n        try jsonl.writeAll(self.issues.items);\n        self.dirty = false;\n\n        // Clear dirty tracking\n        var dirty_it = self.dirty_ids.keyIterator();\n        while (dirty_it.next()) |key| {\n            self.allocator.free(key.*);\n        }\n        self.dirty_ids.clearRetainingCapacity();\n    }\n\n    /// Insert a new issue into the store.\n    pub fn insert(self: *Self, issue: Issue) !void {\n        if (self.id_index.contains(issue.id)) {\n            return IssueStoreError.DuplicateId;\n        }\n\n        const cloned = try issue.clone(self.allocator);\n        errdefer {\n            var c = cloned;\n            c.deinit(self.allocator);\n        }\n\n        const id_copy = try self.allocator.dupe(u8, cloned.id);\n        errdefer self.allocator.free(id_copy);\n\n        const idx = self.issues.items.len;\n        try self.issues.append(self.allocator, cloned);\n        try self.id_index.put(self.allocator, id_copy, idx);\n\n        try self.markDirty(issue.id);\n    }\n\n    /// Get an issue by ID (without embedded relations).\n    pub fn get(self: *Self, id: []const u8) !?Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n\n        return try self.issues.items[idx].clone(self.allocator);\n    }\n\n    /// Get an issue with all embedded relations (labels, deps, comments).\n    /// Since we store everything in-memory, this just returns the issue as-is.\n    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n        return try self.get(id);\n    }\n\n    /// Get a reference to the stored issue (no clone).\n    /// Caller must NOT free or modify the returned issue.\n    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n        const idx = self.id_index.get(id) orelse return null;\n        if (idx >= self.issues.items.len) return null;\n        return &self.issues.items[idx];\n    }\n\n    /// Fields that can be updated on an issue.\n    pub const IssueUpdate = struct {\n        title: ?[]const u8 = null,\n        description: ?[]const u8 = null,\n        design: ?[]const u8 = null,\n        acceptance_criteria: ?[]const u8 = null,\n        notes: ?[]const u8 = null,\n        status: ?Status = null,\n        priority: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        owner: ?[]const u8 = null,\n        estimated_minutes: ?i32 = null,\n        closed_at: ?i64 = null,\n        close_reason: ?[]const u8 = null,\n        closed_by_session: ?[]const u8 = null,\n        due_at: ?i64 = null,\n        defer_until: ?i64 = null,\n        external_ref: ?[]const u8 = null,\n        source_system: ?[]const u8 = null,\n        pinned: ?bool = null,\n        is_template: ?bool = null,\n        content_hash: ?[]const u8 = null,\n\n        /// Expected version for optimistic locking.\n        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n        expected_version: ?u64 = null,\n    };\n\n    /// Update an issue with the given fields.\n    /// If updates.expected_version is set, performs optimistic locking check.\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Optimistic locking check\n        if (updates.expected_version) |expected| {\n            if (issue.version != expected) {\n                return IssueStoreError.VersionMismatch;\n            }\n        }\n\n        // Increment version on every update\n        issue.version += 1;\n\n        // Update timestamp\n        issue.updated_at = Rfc3339Timestamp{ .value = now };\n\n        // Apply updates\n        if (updates.title) |v| {\n            self.allocator.free(issue.title);\n            issue.title = try self.allocator.dupe(u8, v);\n        }\n        if (updates.description) |v| {\n            if (issue.description) |d| self.allocator.free(d);\n            issue.description = try self.allocator.dupe(u8, v);\n        }\n        if (updates.design) |v| {\n            if (issue.design) |d| self.allocator.free(d);\n            issue.design = try self.allocator.dupe(u8, v);\n        }\n        if (updates.acceptance_criteria) |v| {\n            if (issue.acceptance_criteria) |a| self.allocator.free(a);\n            issue.acceptance_criteria = try self.allocator.dupe(u8, v);\n        }\n        if (updates.notes) |v| {\n            if (issue.notes) |n| self.allocator.free(n);\n            issue.notes = try self.allocator.dupe(u8, v);\n        }\n        if (updates.status) |v| {\n            freeStatus(issue.status, self.allocator);\n            issue.status = try cloneStatus(v, self.allocator);\n        }\n        if (updates.priority) |v| {\n            issue.priority = v;\n        }\n        if (updates.issue_type) |v| {\n            freeIssueType(issue.issue_type, self.allocator);\n            issue.issue_type = try cloneIssueType(v, self.allocator);\n        }\n        if (updates.assignee) |v| {\n            if (issue.assignee) |a| self.allocator.free(a);\n            issue.assignee = try self.allocator.dupe(u8, v);\n        }\n        if (updates.owner) |v| {\n            if (issue.owner) |o| self.allocator.free(o);\n            issue.owner = try self.allocator.dupe(u8, v);\n        }\n        if (updates.estimated_minutes) |v| {\n            issue.estimated_minutes = v;\n        }\n        if (updates.closed_at) |v| {\n            issue.closed_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.close_reason) |v| {\n            if (issue.close_reason) |r| self.allocator.free(r);\n            issue.close_reason = try self.allocator.dupe(u8, v);\n        }\n        if (updates.closed_by_session) |v| {\n            if (issue.closed_by_session) |s| self.allocator.free(s);\n            issue.closed_by_session = try self.allocator.dupe(u8, v);\n        }\n        if (updates.due_at) |v| {\n            issue.due_at = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.defer_until) |v| {\n            issue.defer_until = OptionalRfc3339Timestamp{ .value = v };\n        }\n        if (updates.external_ref) |v| {\n            if (issue.external_ref) |e| self.allocator.free(e);\n            issue.external_ref = try self.allocator.dupe(u8, v);\n        }\n        if (updates.source_system) |v| {\n            if (issue.source_system) |s| self.allocator.free(s);\n            issue.source_system = try self.allocator.dupe(u8, v);\n        }\n        if (updates.pinned) |v| {\n            issue.pinned = v;\n        }\n        if (updates.is_template) |v| {\n            issue.is_template = v;\n        }\n        if (updates.content_hash) |v| {\n            if (issue.content_hash) |h| self.allocator.free(h);\n            issue.content_hash = try self.allocator.dupe(u8, v);\n        }\n\n        try self.markDirty(id);\n    }\n\n    /// Soft delete an issue by setting its status to tombstone.\n    pub fn delete(self: *Self, id: []const u8, now: i64) !void {\n        try self.update(id, .{ .status = .tombstone }, now);\n    }\n\n    /// Hard delete an issue by removing it from the store entirely.\n    /// Unlike soft delete (tombstone), this permanently removes the issue.\n    pub fn remove(self: *Self, id: []const u8) !void {\n        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        // Free the issue data\n        self.issues.items[idx].deinit(self.allocator);\n\n        // Remove from index (free the key)\n        if (self.id_index.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n\n        // Remove from issues array using swap-remove for O(1)\n        _ = self.issues.swapRemove(idx);\n\n        // Update the index for the swapped element (if any)\n        if (idx < self.issues.items.len) {\n            const swapped_id = self.issues.items[idx].id;\n            if (self.id_index.getPtr(swapped_id)) |idx_ptr| {\n                idx_ptr.* = idx;\n            }\n        }\n\n        // Also remove from dirty_ids if present\n        if (self.dirty_ids.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n\n        self.dirty = true;\n    }\n\n    /// Filters for listing issues.\n    pub const ListFilters = struct {\n        status: ?Status = null,\n        priority: ?Priority = null,\n        priority_min: ?Priority = null,\n        priority_max: ?Priority = null,\n        issue_type: ?IssueType = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        label_any: []const []const u8 = &[_][]const u8{},\n        title_contains: ?[]const u8 = null,\n        desc_contains: ?[]const u8 = null,\n        notes_contains: ?[]const u8 = null,\n        include_tombstones: bool = false,\n        overdue: bool = false,\n        include_deferred: bool = false,\n        limit: ?u32 = null,\n        offset: ?u32 = null,\n        order_by: OrderBy = .created_at,\n        order_desc: bool = true,\n\n        pub const OrderBy = enum {\n            created_at,\n            updated_at,\n            priority,\n        };\n    };\n\n    /// List issues with optional filters.\n    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const now = if (filters.overdue) std.time.timestamp() else 0;\n\n        for (self.issues.items) |issue| {\n            // Filter tombstones\n            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n                continue;\n            }\n\n            // Apply filters\n            if (filters.status) |s| {\n                // When include_deferred is set, allow deferred issues through even when filtering for open\n                const status_matches = statusEql(issue.status, s);\n                const deferred_allowed = filters.include_deferred and statusEql(issue.status, .deferred);\n                if (!status_matches and !deferred_allowed) continue;\n            }\n            if (filters.priority) |p| {\n                if (issue.priority.value != p.value) continue;\n            }\n            if (filters.issue_type) |t| {\n                if (!issueTypeEql(issue.issue_type, t)) continue;\n            }\n            if (filters.assignee) |a| {\n                if (issue.assignee == null) continue;\n                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n            }\n            if (filters.label) |lbl| {\n                var found = false;\n                for (issue.labels) |label| {\n                    if (std.mem.eql(u8, label, lbl)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) continue;\n            }\n\n            // label_any: OR logic - issue must have at least ONE of the specified labels\n            if (filters.label_any.len > 0) {\n                var found_any = false;\n                for (filters.label_any) |any_label| {\n                    for (issue.labels) |issue_label| {\n                        if (std.mem.eql(u8, issue_label, any_label)) {\n                            found_any = true;\n                            break;\n                        }\n                    }\n                    if (found_any) break;\n                }\n                if (!found_any) continue;\n            }\n\n            // Priority range filters (lower value = higher priority)\n            if (filters.priority_min) |min_p| {\n                if (issue.priority.value < min_p.value) continue;\n            }\n            if (filters.priority_max) |max_p| {\n                if (issue.priority.value > max_p.value) continue;\n            }\n\n            // Substring filters (case-insensitive)\n            if (filters.title_contains) |query| {\n                if (!containsIgnoreCase(issue.title, query)) continue;\n            }\n            if (filters.desc_contains) |query| {\n                if (issue.description) |desc| {\n                    if (!containsIgnoreCase(desc, query)) continue;\n                } else continue;\n            }\n            if (filters.notes_contains) |query| {\n                if (issue.notes) |notes| {\n                    if (!containsIgnoreCase(notes, query)) continue;\n                } else continue;\n            }\n\n            // Overdue filter: only include issues past their due date\n            if (filters.overdue) {\n                if (issue.due_at.value) |due_time| {\n                    if (due_time >= now) continue;\n                } else continue;\n            }\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort\n        const SortContext = struct {\n            order_by: ListFilters.OrderBy,\n            order_desc: bool,\n        };\n        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n\n        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n                const cmp: i64 = switch (c.order_by) {\n                    .created_at => a.created_at.value - b.created_at.value,\n                    .updated_at => a.updated_at.value - b.updated_at.value,\n                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n                };\n                return if (c.order_desc) cmp > 0 else cmp < 0;\n            }\n        }.lessThan);\n\n        // Apply offset and limit\n        var start: usize = 0;\n        if (filters.offset) |off| {\n            start = @min(off, results.items.len);\n        }\n\n        var end: usize = results.items.len;\n        if (filters.limit) |lim| {\n            end = @min(start + lim, results.items.len);\n        }\n\n        // Free items outside the range\n        for (results.items[0..start]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        for (results.items[end..]) |*issue| {\n            issue.deinit(self.allocator);\n        }\n\n        // Return slice\n        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n        results.deinit(self.allocator);\n        return slice;\n    }\n\n    /// Result from counting issues.\n    pub const CountResult = struct {\n        key: []const u8,\n        count: u64,\n    };\n\n    /// Count issues, optionally grouped by a field.\n    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n        var counts: std.StringHashMapUnmanaged(u64) = .{};\n        defer counts.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const key_str: []const u8 = if (group_by) |g| switch (g) {\n                .status => issue.status.toString(),\n                .priority => switch (issue.priority.value) {\n                    0 => \"0\",\n                    1 => \"1\",\n                    2 => \"2\",\n                    3 => \"3\",\n                    4 => \"4\",\n                    else => unreachable,\n                },\n                .issue_type => issue.issue_type.toString(),\n                .assignee => issue.assignee orelse \"(unassigned)\",\n            } else \"total\";\n\n            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n            entry.value_ptr.* += 1;\n        }\n\n        var results: std.ArrayListUnmanaged(CountResult) = .{};\n        errdefer {\n            for (results.items) |r| {\n                self.allocator.free(r.key);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var it = counts.iterator();\n        while (it.next()) |entry| {\n            const key = try self.allocator.dupe(u8, entry.key_ptr.*);\n            try results.append(self.allocator, .{ .key = key, .count = entry.value_ptr.* });\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    pub const GroupBy = enum {\n        status,\n        priority,\n        issue_type,\n        assignee,\n    };\n\n    /// Check if an issue exists.\n    pub fn exists(self: *Self, id: []const u8) !bool {\n        return self.id_index.contains(id);\n    }\n\n    /// Get labels for an issue.\n    pub fn getLabels(self: *Self, issue_id: []const u8) ![]const []const u8 {\n        const idx = self.id_index.get(issue_id) orelse return &[_][]const u8{};\n        if (idx >= self.issues.items.len) return &[_][]const u8{};\n\n        const issue = self.issues.items[idx];\n        if (issue.labels.len == 0) return &[_][]const u8{};\n\n        const labels = try self.allocator.alloc([]const u8, issue.labels.len);\n        errdefer self.allocator.free(labels);\n\n        for (issue.labels, 0..) |label, i| {\n            labels[i] = try self.allocator.dupe(u8, label);\n        }\n        return labels;\n    }\n\n    /// Add a label to an issue.\n    pub fn addLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        // Check if already exists\n        for (issue.labels) |existing| {\n            if (std.mem.eql(u8, existing, label)) return;\n        }\n\n        // Add new label\n        const label_copy = try self.allocator.dupe(u8, label);\n        errdefer self.allocator.free(label_copy);\n\n        const new_labels = try self.allocator.alloc([]const u8, issue.labels.len + 1);\n        @memcpy(new_labels[0..issue.labels.len], issue.labels);\n        new_labels[issue.labels.len] = label_copy;\n\n        if (issue.labels.len > 0) {\n            self.allocator.free(issue.labels);\n        }\n        issue.labels = new_labels;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Remove a label from an issue.\n    pub fn removeLabel(self: *Self, issue_id: []const u8, label: []const u8) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        var found_idx: ?usize = null;\n        for (issue.labels, 0..) |existing, i| {\n            if (std.mem.eql(u8, existing, label)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            self.allocator.free(issue.labels[fi]);\n\n            if (issue.labels.len == 1) {\n                self.allocator.free(issue.labels);\n                issue.labels = &[_][]const u8{};\n            } else {\n                const new_labels = try self.allocator.alloc([]const u8, issue.labels.len - 1);\n                var j: usize = 0;\n                for (issue.labels, 0..) |lbl, i| {\n                    if (i != fi) {\n                        new_labels[j] = lbl;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.labels);\n                issue.labels = new_labels;\n            }\n\n            try self.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue.\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]const Dependency {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Dependency{};\n        if (idx >= self.issues.items.len) return &[_]Dependency{};\n\n        const issue = self.issues.items[idx];\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n        return deps;\n    }\n\n    /// Get comments for an issue.\n    pub fn getComments(self: *Self, issue_id: []const u8) ![]const Comment {\n        const idx = self.id_index.get(issue_id) orelse return &[_]Comment{};\n        if (idx >= self.issues.items.len) return &[_]Comment{};\n\n        const issue = self.issues.items[idx];\n        if (issue.comments.len == 0) return &[_]Comment{};\n\n        const comments = try self.allocator.alloc(Comment, issue.comments.len);\n        errdefer self.allocator.free(comments);\n\n        for (issue.comments, 0..) |c, i| {\n            comments[i] = try cloneComment(c, self.allocator);\n        }\n        return comments;\n    }\n\n    /// Add a comment to an issue.\n    pub fn addComment(self: *Self, issue_id: []const u8, comment: Comment) !void {\n        const idx = self.id_index.get(issue_id) orelse return IssueStoreError.IssueNotFound;\n        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n\n        var issue = &self.issues.items[idx];\n\n        const cloned = try cloneComment(comment, self.allocator);\n        errdefer freeComment(@constCast(&cloned), self.allocator);\n\n        const new_comments = try self.allocator.alloc(Comment, issue.comments.len + 1);\n        @memcpy(new_comments[0..issue.comments.len], issue.comments);\n        new_comments[issue.comments.len] = cloned;\n\n        if (issue.comments.len > 0) {\n            self.allocator.free(issue.comments);\n        }\n        issue.comments = new_comments;\n\n        try self.markDirty(issue_id);\n    }\n\n    /// Mark an issue as dirty for sync.\n    pub fn markDirty(self: *Self, id: []const u8) !void {\n        self.dirty = true;\n        const now = std.time.timestamp();\n\n        if (!self.dirty_ids.contains(id)) {\n            const id_copy = try self.allocator.dupe(u8, id);\n            try self.dirty_ids.put(self.allocator, id_copy, now);\n        } else {\n            self.dirty_ids.getPtr(id).?.* = now;\n        }\n    }\n\n    /// Clear dirty flag for an issue.\n    pub fn clearDirty(self: *Self, id: []const u8) !void {\n        if (self.dirty_ids.fetchRemove(id)) |kv| {\n            self.allocator.free(kv.key);\n        }\n    }\n\n    /// Get all dirty issue IDs.\n    pub fn getDirtyIds(self: *Self) ![][]const u8 {\n        var ids: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (ids.items) |id| {\n                self.allocator.free(id);\n            }\n            ids.deinit(self.allocator);\n        }\n\n        var it = self.dirty_ids.keyIterator();\n        while (it.next()) |key| {\n            const id = try self.allocator.dupe(u8, key.*);\n            try ids.append(self.allocator, id);\n        }\n\n        return ids.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if the store has unsaved changes.\n    pub fn isDirty(self: *Self) bool {\n        return self.dirty;\n    }\n\n    /// Get total number of issues (excluding tombstones).\n    pub fn countTotal(self: *Self) usize {\n        var total: usize = 0;\n        for (self.issues.items) |issue| {\n            if (!statusEql(issue.status, .tombstone)) {\n                total += 1;\n            }\n        }\n        return total;\n    }\n\n    /// Get all issues as a slice (no clone, read-only).\n    pub fn getAllRef(self: *Self) []const Issue {\n        return self.issues.items;\n    }\n\n    /// Suggestion for similar ID lookup.\n    pub const IdSuggestion = struct {\n        id: []const u8,\n        title: []const u8,\n    };\n\n    /// Find similar IDs when a lookup fails (for \"did you mean\" suggestions).\n    /// Uses prefix matching and Levenshtein-like scoring.\n    /// Returns up to `max_count` suggestions, caller must free.\n    pub fn findSimilarIds(self: *Self, target: []const u8, max_count: usize) ![]IdSuggestion {\n        if (self.issues.items.len == 0) return &[_]IdSuggestion{};\n\n        const Scored = struct {\n            id: []const u8,\n            title: []const u8,\n            score: i32,\n        };\n\n        var candidates: std.ArrayListUnmanaged(Scored) = .{};\n        defer candidates.deinit(self.allocator);\n\n        for (self.issues.items) |issue| {\n            if (statusEql(issue.status, .tombstone)) continue;\n\n            const score = computeSimilarity(target, issue.id);\n            if (score > 0) {\n                try candidates.append(self.allocator, .{\n                    .id = issue.id,\n                    .title = issue.title,\n                    .score = score,\n                });\n            }\n        }\n\n        if (candidates.items.len == 0) return &[_]IdSuggestion{};\n\n        // Sort by score descending\n        std.mem.sortUnstable(Scored, candidates.items, {}, struct {\n            fn lessThan(_: void, a: Scored, b: Scored) bool {\n                return a.score > b.score;\n            }\n        }.lessThan);\n\n        const result_count = @min(max_count, candidates.items.len);\n        var suggestions = try self.allocator.alloc(IdSuggestion, result_count);\n        errdefer self.allocator.free(suggestions);\n\n        for (0..result_count) |i| {\n            suggestions[i] = .{\n                .id = try self.allocator.dupe(u8, candidates.items[i].id),\n                .title = try self.allocator.dupe(u8, candidates.items[i].title),\n            };\n        }\n\n        return suggestions;\n    }\n\n    /// Free suggestions returned by findSimilarIds.\n    pub fn freeSuggestions(self: *Self, suggestions: []IdSuggestion) void {\n        for (suggestions) |s| {\n            self.allocator.free(s.id);\n            self.allocator.free(s.title);\n        }\n        self.allocator.free(suggestions);\n    }\n};\n\n/// Compute similarity score between target and candidate ID.\n/// Higher score = more similar.\nfn computeSimilarity(target: []const u8, candidate: []const u8) i32 {\n    var score: i32 = 0;\n\n    // Exact prefix match (bd-abc matches bd-abc123)\n    if (std.mem.startsWith(u8, candidate, target)) {\n        score += 100;\n    }\n    // Candidate is prefix of target (bd-abc123 starts with bd-abc)\n    else if (std.mem.startsWith(u8, target, candidate)) {\n        score += 80;\n    }\n\n    // Common prefix length\n    var common_prefix: usize = 0;\n    const min_len = @min(target.len, candidate.len);\n    for (0..min_len) |i| {\n        if (target[i] == candidate[i]) {\n            common_prefix += 1;\n        } else {\n            break;\n        }\n    }\n    score += @intCast(common_prefix * 5);\n\n    // Contains target as substring\n    if (std.mem.indexOf(u8, candidate, target) != null) {\n        score += 30;\n    }\n\n    // Similar length bonus\n    const len_diff: i32 = @intCast(@abs(@as(i64, @intCast(target.len)) - @as(i64, @intCast(candidate.len))));\n    if (len_diff <= 2) {\n        score += 10;\n    }\n\n    return score;\n}\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn issueTypeEql(a: IssueType, b: IssueType) bool {\n    const Tag = std.meta.Tag(IssueType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\npub fn containsIgnoreCase(haystack: []const u8, needle: []const u8) bool {\n    if (needle.len == 0) return true;\n    if (needle.len > haystack.len) return false;\n\n    const end = haystack.len - needle.len + 1;\n    var i: usize = 0;\n    while (i < end) : (i += 1) {\n        var match = true;\n        for (needle, 0..) |nc, j| {\n            const hc = haystack[i + j];\n            if (std.ascii.toLower(hc) != std.ascii.toLower(nc)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nfn cloneStatus(status: Status, allocator: std.mem.Allocator) !Status {\n    return switch (status) {\n        .custom => |s| Status{ .custom = try allocator.dupe(u8, s) },\n        else => status,\n    };\n}\n\nfn freeStatus(status: Status, allocator: std.mem.Allocator) void {\n    switch (status) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneIssueType(issue_type: IssueType, allocator: std.mem.Allocator) !IssueType {\n    return switch (issue_type) {\n        .custom => |s| IssueType{ .custom = try allocator.dupe(u8, s) },\n        else => issue_type,\n    };\n}\n\nfn freeIssueType(issue_type: IssueType, allocator: std.mem.Allocator) void {\n    switch (issue_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn cloneComment(comment: Comment, allocator: std.mem.Allocator) !Comment {\n    return Comment{\n        .id = comment.id,\n        .issue_id = try allocator.dupe(u8, comment.issue_id),\n        .author = try allocator.dupe(u8, comment.author),\n        .body = try allocator.dupe(u8, comment.body),\n        .created_at = comment.created_at,\n    };\n}\n\nfn freeComment(comment: *Comment, allocator: std.mem.Allocator) void {\n    allocator.free(comment.issue_id);\n    allocator.free(comment.author);\n    allocator.free(comment.body);\n}\n\n// --- Tests ---\n\ntest \"IssueStore insert and get\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-test1\", \"Test Issue\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(try store.exists(\"bd-test1\"));\n\n    var retrieved = (try store.get(\"bd-test1\")).?;\n    defer retrieved.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"bd-test1\", retrieved.id);\n    try std.testing.expectEqualStrings(\"Test Issue\", retrieved.title);\n}\n\ntest \"IssueStore get returns null for missing\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const result = try store.get(\"bd-nonexistent\");\n    try std.testing.expect(result == null);\n}\n\ntest \"IssueStore update modifies fields\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-update\", \"Original Title\", 1706540000);\n    try store.insert(issue);\n\n    try store.update(\"bd-update\", .{\n        .title = \"Updated Title\",\n        .status = .in_progress,\n        .priority = Priority.HIGH,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-update\")).?;\n    defer updated.deinit(allocator);\n\n    try std.testing.expectEqualStrings(\"Updated Title\", updated.title);\n    try std.testing.expect(statusEql(updated.status, .in_progress));\n    try std.testing.expectEqual(Priority.HIGH, updated.priority);\n}\n\ntest \"IssueStore update increments version\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-version\", \"Version Test\", 1706540000);\n    try store.insert(issue);\n\n    // Initial version should be 1\n    var v1 = (try store.get(\"bd-version\")).?;\n    defer v1.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 1), v1.version);\n\n    // Update should increment version\n    try store.update(\"bd-version\", .{ .title = \"Updated\" }, 1706550000);\n\n    var v2 = (try store.get(\"bd-version\")).?;\n    defer v2.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 2), v2.version);\n\n    // Another update should increment again\n    try store.update(\"bd-version\", .{ .title = \"Updated Again\" }, 1706560000);\n\n    var v3 = (try store.get(\"bd-version\")).?;\n    defer v3.deinit(allocator);\n    try std.testing.expectEqual(@as(u64, 3), v3.version);\n}\n\ntest \"IssueStore update with expected_version succeeds on match\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-optlock\", \"Optimistic Lock Test\", 1706540000);\n    try store.insert(issue);\n\n    // Get current version (1)\n    var current = (try store.get(\"bd-optlock\")).?;\n    const current_version = current.version;\n    current.deinit(allocator);\n\n    // Update with correct expected version should succeed\n    try store.update(\"bd-optlock\", .{\n        .title = \"Updated with lock\",\n        .expected_version = current_version,\n    }, 1706550000);\n\n    var updated = (try store.get(\"bd-optlock\")).?;\n    defer updated.deinit(allocator);\n    try std.testing.expectEqualStrings(\"Updated with lock\", updated.title);\n    try std.testing.expectEqual(@as(u64, 2), updated.version);\n}\n\ntest \"IssueStore update with expected_version fails on mismatch\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-conflict\", \"Conflict Test\", 1706540000);\n    try store.insert(issue);\n\n    // Update once to increment version to 2\n    try store.update(\"bd-conflict\", .{ .title = \"First Update\" }, 1706550000);\n\n    // Try to update with stale expected_version (1 instead of 2)\n    const result = store.update(\"bd-conflict\", .{\n        .title = \"Conflicting Update\",\n        .expected_version = 1, // Stale version\n    }, 1706560000);\n\n    try std.testing.expectError(IssueStoreError.VersionMismatch, result);\n\n    // Verify original update is preserved\n    var preserved = (try store.get(\"bd-conflict\")).?;\n    defer preserved.deinit(allocator);\n    try std.testing.expectEqualStrings(\"First Update\", preserved.title);\n    try std.testing.expectEqual(@as(u64, 2), preserved.version);\n}\n\ntest \"IssueStore delete sets tombstone\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-delete\", \"To Delete\", 1706540000);\n    try store.insert(issue);\n\n    try store.delete(\"bd-delete\", 1706550000);\n\n    var deleted = (try store.get(\"bd-delete\")).?;\n    defer deleted.deinit(allocator);\n\n    try std.testing.expect(statusEql(deleted.status, .tombstone));\n}\n\ntest \"IssueStore list returns issues\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-list1\", \"Issue 1\", 1706540000));\n    try store.insert(Issue.init(\"bd-list2\", \"Issue 2\", 1706550000));\n    try store.insert(Issue.init(\"bd-list3\", \"Issue 3\", 1706560000));\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 3), issues.len);\n}\n\ntest \"IssueStore list excludes tombstones\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-active\", \"Active\", 1706540000));\n    try store.insert(Issue.init(\"bd-deleted\", \"Deleted\", 1706550000));\n    try store.delete(\"bd-deleted\", 1706560000);\n\n    const issues = try store.list(.{});\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), issues.len);\n    try std.testing.expectEqualStrings(\"bd-active\", issues[0].id);\n}\n\ntest \"IssueStore dirty tracking\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    const issue = Issue.init(\"bd-dirty\", \"Dirty Test\", 1706540000);\n    try store.insert(issue);\n\n    try std.testing.expect(store.isDirty());\n\n    const dirty_ids = try store.getDirtyIds();\n    defer {\n        for (dirty_ids) |id| {\n            allocator.free(id);\n        }\n        allocator.free(dirty_ids);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), dirty_ids.len);\n    try std.testing.expectEqualStrings(\"bd-dirty\", dirty_ids[0]);\n\n    try store.clearDirty(\"bd-dirty\");\n\n    const after_clear = try store.getDirtyIds();\n    defer allocator.free(after_clear);\n\n    try std.testing.expectEqual(@as(usize, 0), after_clear.len);\n}\n\ntest \"IssueStore addLabel and removeLabel\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-labels\", \"Label Test\", 1706540000));\n\n    try store.addLabel(\"bd-labels\", \"bug\");\n    try store.addLabel(\"bd-labels\", \"urgent\");\n\n    const labels = try store.getLabels(\"bd-labels\");\n    defer {\n        for (labels) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(labels);\n    }\n\n    try std.testing.expectEqual(@as(usize, 2), labels.len);\n\n    try store.removeLabel(\"bd-labels\", \"bug\");\n\n    const after_remove = try store.getLabels(\"bd-labels\");\n    defer {\n        for (after_remove) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(after_remove);\n    }\n\n    try std.testing.expectEqual(@as(usize, 1), after_remove.len);\n}\n\ntest \"StoreLoadResult.hasCorruption\" {\n    var result = StoreLoadResult{\n        .jsonl_corruption_count = 0,\n    };\n    try std.testing.expect(!result.hasCorruption());\n\n    result.jsonl_corruption_count = 3;\n    try std.testing.expect(result.hasCorruption());\n}\n\ntest \"IssueStore loadFromFileWithRecovery handles corrupt entries\" {\n    const allocator = std.testing.allocator;\n    const test_util = @import(\"../test_util.zig\");\n    const test_dir = try test_util.createTestDir(allocator, \"store_recovery\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"issues.jsonl\" });\n    defer allocator.free(test_path);\n\n    // Write a file with mixed valid and corrupt entries\n    // Use full Issue JSON format (all fields required by parser)\n    {\n        const file = try std.fs.cwd().createFile(test_path, .{});\n        defer file.close();\n\n        // Valid issue\n        const valid1 = \"{\\\"id\\\":\\\"bd-valid1\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid1);\n\n        // Corrupt entry\n        try file.writeAll(\"{invalid json here}\\n\");\n\n        // Another valid issue\n        const valid2 = \"{\\\"id\\\":\\\"bd-valid2\\\",\\\"content_hash\\\":null,\\\"title\\\":\\\"Another Valid Issue\\\",\\\"description\\\":null,\\\"design\\\":null,\\\"acceptance_criteria\\\":null,\\\"notes\\\":null,\\\"status\\\":\\\"open\\\",\\\"priority\\\":2,\\\"issue_type\\\":\\\"task\\\",\\\"assignee\\\":null,\\\"owner\\\":null,\\\"created_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"created_by\\\":null,\\\"updated_at\\\":\\\"2024-01-29T10:00:00Z\\\",\\\"closed_at\\\":null,\\\"close_reason\\\":null,\\\"due_at\\\":null,\\\"defer_until\\\":null,\\\"estimated_minutes\\\":null,\\\"external_ref\\\":null,\\\"source_system\\\":null,\\\"pinned\\\":false,\\\"is_template\\\":false,\\\"labels\\\":[],\\\"dependencies\\\":[],\\\"comments\\\":[]}\\n\";\n        try file.writeAll(valid2);\n    }\n\n    var store = IssueStore.init(allocator, test_path);\n    defer store.deinit();\n\n    var result = try store.loadFromFileWithRecovery();\n    defer result.deinit(allocator);\n\n    // Should have loaded 2 valid issues\n    try std.testing.expectEqual(@as(usize, 2), store.issues.items.len);\n\n    // Should have tracked 1 corrupt entry\n    try std.testing.expectEqual(@as(usize, 1), result.jsonl_corruption_count);\n    try std.testing.expect(result.hasCorruption());\n\n    // Verify the correct issues were loaded\n    try std.testing.expect(try store.exists(\"bd-valid1\"));\n    try std.testing.expect(try store.exists(\"bd-valid2\"));\n}\n","structuredPatch":[{"oldStart":850,"oldLines":6,"newStart":850,"newLines":35,"lines":["         }","         self.allocator.free(suggestions);","     }","+","+    /// Get the ID prefix from existing issues, or return default \"bd\".","+    /// Infers the prefix from the first issue's ID format.","+    pub fn getPrefix(self: *Self) []const u8 {","+        for (self.issues.items) |issue| {","+            if (std.mem.indexOf(u8, issue.id, \"-\")) |dash_pos| {","+                return issue.id[0..dash_pos];","+            }","+        }","+        return \"bd\"; // Default prefix","+    }","+","+    /// Rebuild the ID index from current issues.","+    /// Used after modifying issue IDs or removing issues.","+    pub fn rebuildIndex(self: *Self) !void {","+        // Clear existing index","+        var id_it = self.id_index.keyIterator();","+        while (id_it.next()) |key| {","+            self.allocator.free(key.*);","+        }","+        self.id_index.clearRetainingCapacity();","+","+        // Rebuild from issues array","+        for (self.issues.items, 0..) |issue, idx| {","+            const id_copy = try self.allocator.dupe(u8, issue.id);","+            errdefer self.allocator.free(id_copy);","+            try self.id_index.put(self.allocator, id_copy, idx);","+        }","+    }"," };"," "," /// Compute similarity score between target and candidate ID."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X28JP6iKwb9P5Q5uawYYnt","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update runMerge to accept the orphan_policy and rename_prefix parameters."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":714,"cache_read_input_tokens":99866,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":714},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b746a95b-f64d-4417-9672-48dec51df6f5"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X28JP6iKwb9P5Q5uawYYnt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GKDWMM7iMCPDkwZXp8TRYv","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","offset":280,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":714,"cache_read_input_tokens":99866,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":714},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7b456dc7-0a77-414f-be11-ec2fa8b3ec8f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GKDWMM7iMCPDkwZXp8TRYv","type":"tool_result","content":"   280→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   281→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   282→        return SyncError.MergeConflictDetected;\n   283→    }\n   284→\n   285→    // For bidirectional sync, we export the current state\n   286→    // A full bidirectional merge would require content hashing which is complex\n   287→    const count = ctx.store.issues.items.len;\n   288→\n   289→    if (ctx.store.dirty) {\n   290→        ctx.store.saveToFile() catch {\n   291→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n   292→            return SyncError.ExportError;\n   293→        };\n   294→\n   295→        if (structured_output) {\n   296→            try ctx.output.printJson(SyncResult{\n   297→                .success = true,\n   298→                .action = \"sync\",\n   299→                .issues_exported = count,\n   300→            });\n   301→        } else if (!quiet) {\n   302→            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n   303→        }\n   304→    } else {\n   305→        if (structured_output) {\n   306→            try ctx.output.printJson(SyncResult{\n   307→                .success = true,\n   308→                .action = \"sync\",\n   309→                .message = \"no changes to sync\",\n   310→            });\n   311→        } else if (!quiet) {\n   312→            try ctx.output.info(\"No changes to sync\", .{});\n   313→        }\n   314→    }\n   315→}\n   316→\n   317→/// Perform 3-way merge of local DB and remote JSONL.\n   318→/// For each issue:\n   319→/// - If only in local: keep\n   320→/// - If only in remote: add\n   321→/// - If in both: keep the one with newer updated_at timestamp\n   322→fn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   323→    // Check for merge conflict markers\n   324→    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n   325→        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n   326→        return SyncError.MergeConflictDetected;\n   327→    }\n   328→\n   329→    // Load remote issues from JSONL file directly (without replacing store)\n   330→    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n   331→    defer remote_store.deinit();\n   332→\n   333→    remote_store.loadFromFile() catch |err| {\n   334→        if (err != error.FileNotFound) {\n   335→            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n   336→            return SyncError.ImportError;\n   337→        }\n   338→    };\n   339→\n   340→    var added: usize = 0;\n   341→    var updated: usize = 0;\n   342→\n   343→    // Iterate through remote issues and merge into local store\n   344→    for (remote_store.issues.items) |remote_issue| {\n   345→        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n   346→            // Issue exists in both - compare updated_at timestamps\n   347→            const local_ts = local_issue.updated_at.value;\n   348→            const remote_ts = remote_issue.updated_at.value;\n   349→\n   350→            if (remote_ts > local_ts) {\n   351→                // Remote is newer - update local with remote data\n   352→                // We need to copy the remote issue's data\n   353→                const update = storage.IssueStore.IssueUpdate{\n   354→                    .title = remote_issue.title,\n   355→                    .description = remote_issue.description,\n   356→                    .design = remote_issue.design,\n   357→                    .acceptance_criteria = remote_issue.acceptance_criteria,\n   358→                    .notes = remote_issue.notes,\n   359→                    .status = remote_issue.status,\n   360→                    .priority = remote_issue.priority,\n   361→                    .issue_type = remote_issue.issue_type,\n   362→                    .assignee = remote_issue.assignee,\n   363→                    .owner = remote_issue.owner,\n   364→                    .estimated_minutes = remote_issue.estimated_minutes,\n   365→                    .closed_at = remote_issue.closed_at.value,\n   366→                    .close_reason = remote_issue.close_reason,\n   367→                    .due_at = remote_issue.due_at.value,\n   368→                    .defer_until = remote_issue.defer_until.value,\n   369→                    .external_ref = remote_issue.external_ref,\n   370→                    .source_system = remote_issue.source_system,\n   371→                    .pinned = remote_issue.pinned,\n   372→                    .is_template = remote_issue.is_template,\n   373→                };\n   374→\n   375→                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n   376→                updated += 1;\n   377→            }\n   378→            // If local is newer or equal, keep local (no action needed)\n   379→        } else {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d4fcfe3a-d0c3-43c2-8eae-47dc8d636bfd","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","content":"    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {","numLines":100,"startLine":280,"totalLines":644}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HEDuq3dvMd4cArVUNDeUzx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PuNUeqovo1KxkrQv9xmUd4","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {","new_string":"/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    _ = orphan_policy; // TODO: implement orphan handling for merge\n    _ = rename_prefix; // TODO: implement prefix renaming for merge"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1731,"cache_read_input_tokens":100580,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1731},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f401a1b2-7c13-414a-81bf-8f27b64fb83c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PuNUeqovo1KxkrQv9xmUd4","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e3f11550-f6b4-4ca1-a59a-e14cd1d4b69b","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {","newString":"/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    _ = orphan_policy; // TODO: implement orphan handling for merge\n    _ = rename_prefix; // TODO: implement prefix renaming for merge","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove = std.ArrayList(usize).init(allocator);\n    defer issues_to_remove.deinit();\n\n    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":319,"oldLines":7,"newStart":319,"newLines":9,"lines":[" /// - If only in local: keep"," /// - If only in remote: add"," /// - If in both: keep the one with newer updated_at timestamp","-fn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {","+fn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {","+    _ = orphan_policy; // TODO: implement orphan handling for merge","+    _ = rename_prefix; // TODO: implement prefix renaming for merge","     // Check for merge conflict markers","     if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {","         try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015xg7Aq8HeAdJdRXtzA2gRY","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run the build to check for errors."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":410,"cache_read_input_tokens":102311,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":410},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"316d3cf5-2525-432a-800c-9367a52c8a32"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015xg7Aq8HeAdJdRXtzA2gRY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011UoXmDX6EBU28zVq3mjUwk","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build the project to check for errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":410,"cache_read_input_tokens":102311,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":410},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"1b014f3c-63b8-4cc3-bf64-2f88d237fbde"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011UoXmDX6EBU28zVq3mjUwk","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/sync.zig:161:48: \u001b[31merror: \u001b[0m\u001b[1mstruct 'array_list.Aligned(usize,null)' has no member named 'init'\n\u001b[0m    var issues_to_remove = std.ArrayList(usize).init(allocator);\n                           \u001b[32m~~~~~~~~~~~~~~~~~~~~^~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/array_list.zig:606:12: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0m    return struct {\n           \u001b[32m^~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/sync.zig:66:22\n    dispatch: src/main.zig:139:24\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x9ed5c25d -Z9c9b76ce29ad9a47","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5eeb9a7b-9a84-484d-b888-b79802efc523","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/sync.zig:161:48: \u001b[31merror: \u001b[0m\u001b[1mstruct 'array_list.Aligned(usize,null)' has no member named 'init'\n\u001b[0m    var issues_to_remove = std.ArrayList(usize).init(allocator);\n                           \u001b[32m~~~~~~~~~~~~~~~~~~~~^~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/array_list.zig:606:12: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0m    return struct {\n           \u001b[32m^~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/sync.zig:66:22\n    dispatch: src/main.zig:139:24\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x9ed5c25d -Z9c9b76ce29ad9a47","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CRXB8hrSjqMuQ9NQHnSwdL","type":"message","role":"assistant","content":[{"type":"text","text":"Let me fix the ArrayListUnmanaged initialization issue."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":785,"cache_read_input_tokens":102721,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":785},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b165c355-34eb-443b-b483-13b0a2a0e159"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CRXB8hrSjqMuQ9NQHnSwdL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018uFLtm6jJt9wFrFCu6ZUVy","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"    var issues_to_remove = std.ArrayList(usize).init(allocator);\n    defer issues_to_remove.deinit();","new_string":"    var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};\n    defer issues_to_remove.deinit(allocator);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":785,"cache_read_input_tokens":102721,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":785},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a9bee5da-5d95-4dc4-994d-ab57805e2b12"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018uFLtm6jJt9wFrFCu6ZUVy","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"619815c2-70f3-4369-862e-dec7f7e61af3","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"    var issues_to_remove = std.ArrayList(usize).init(allocator);\n    defer issues_to_remove.deinit();","newString":"    var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};\n    defer issues_to_remove.deinit(allocator);","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove = std.ArrayList(usize).init(allocator);\n    defer issues_to_remove.deinit();\n\n    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    _ = orphan_policy; // TODO: implement orphan handling for merge\n    _ = rename_prefix; // TODO: implement prefix renaming for merge\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":158,"oldLines":8,"newStart":158,"newLines":8,"lines":["     const expected_prefix = ctx.store.getPrefix();"," ","     // Process orphans and prefix renaming","-    var issues_to_remove = std.ArrayList(usize).init(allocator);","-    defer issues_to_remove.deinit();","+    var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};","+    defer issues_to_remove.deinit(allocator);"," ","     var orphan_ids = std.ArrayList([]const u8).init(allocator);","     defer {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KTjrARYtKqnW3qNKcgk9pS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013RbtFTBHsLJvgam4EbRi1p","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }","new_string":"    var orphan_ids: std.ArrayListUnmanaged([]const u8) = .{};\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit(allocator);\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":578,"cache_read_input_tokens":103506,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":578},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"cc9f1f83-0a47-45e6-96ae-46d12d0fbe6f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013RbtFTBHsLJvgam4EbRi1p","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"09fe332b-d3bc-4e2b-9dcc-162d4e268be4","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }","newString":"    var orphan_ids: std.ArrayListUnmanaged([]const u8) = .{};\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit(allocator);\n    }","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};\n    defer issues_to_remove.deinit(allocator);\n\n    var orphan_ids = std.ArrayList([]const u8).init(allocator);\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit();\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    _ = orphan_policy; // TODO: implement orphan handling for merge\n    _ = rename_prefix; // TODO: implement prefix renaming for merge\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":161,"oldLines":10,"newStart":161,"newLines":10,"lines":["     var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};","     defer issues_to_remove.deinit(allocator);"," ","-    var orphan_ids = std.ArrayList([]const u8).init(allocator);","+    var orphan_ids: std.ArrayListUnmanaged([]const u8) = .{};","     defer {","         for (orphan_ids.items) |id| allocator.free(id);","-        orphan_ids.deinit();","+        orphan_ids.deinit(allocator);","     }"," ","     for (ctx.store.issues.items, 0..) |*issue, idx| {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KwM6PUmEWJP3T7y1djjq1r","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018rBzGXVZxKps7CmQmbh7Lk","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build the project to check for errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":295,"cache_read_input_tokens":104084,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":295},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"00823fe9-4912-4bd8-bb52-efcd79300c4d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018rBzGXVZxKps7CmQmbh7Lk","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/sync.zig:205:39: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 2 argument(s), found 1\n\u001b[0m                        try orphan_ids.append(parent_id_copy);\n                            \u001b[32m~~~~~~~~~~^~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/array_list.zig:893:13: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m        pub fn append(self: *Self, gpa: Allocator, item: T) Allocator.Error!void {\n        \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/sync.zig:66:22\n    dispatch: src/main.zig:139:24\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xee008ce4 -Zeb884812442c1c13","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d416ac7d-8d11-45ed-a72d-e53fe0ce089e","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/sync.zig:205:39: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 2 argument(s), found 1\n\u001b[0m                        try orphan_ids.append(parent_id_copy);\n                            \u001b[32m~~~~~~~~~~^~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/array_list.zig:893:13: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m        pub fn append(self: *Self, gpa: Allocator, item: T) Allocator.Error!void {\n        \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/sync.zig:66:22\n    dispatch: src/main.zig:139:24\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xee008ce4 -Zeb884812442c1c13","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PbUbWYwzHWm8dhcaRd3Lqh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KTAgzikvaaSMrCNxtMZRdW","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"                        try orphan_ids.append(parent_id_copy);","new_string":"                        try orphan_ids.append(allocator, parent_id_copy);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":782,"cache_read_input_tokens":104379,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":782},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a993ca09-dae6-46cd-9f8c-252b719347f8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KTAgzikvaaSMrCNxtMZRdW","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"381aef33-8073-408c-a88a-8e946bde53a5","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"                        try orphan_ids.append(parent_id_copy);","newString":"                        try orphan_ids.append(allocator, parent_id_copy);","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};\n    defer issues_to_remove.deinit(allocator);\n\n    var orphan_ids: std.ArrayListUnmanaged([]const u8) = .{};\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    _ = orphan_policy; // TODO: implement orphan handling for merge\n    _ = rename_prefix; // TODO: implement prefix renaming for merge\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":202,"oldLines":7,"newStart":202,"newLines":7,"lines":["                     .resurrect => {","                         // Create a placeholder parent issue","                         const parent_id_copy = try allocator.dupe(u8, parent_id);","-                        try orphan_ids.append(parent_id_copy);","+                        try orphan_ids.append(allocator, parent_id_copy);","                         orphans_created += 1;","                     },","                     .skip => {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YEEVrCHwmXsqrTeo8UbMMZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BG3VJsBRh45WYNUh2uYxPq","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build the project to check for errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":204,"cache_read_input_tokens":105161,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":204},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b8818a19-b175-441f-a53c-5e77b011eecd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BG3VJsBRh45WYNUh2uYxPq","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/sync.zig:209:45: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 2 argument(s), found 1\n\u001b[0m                        try issues_to_remove.append(idx);\n                            \u001b[32m~~~~~~~~~~~~~~~~^~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/array_list.zig:893:13: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m        pub fn append(self: *Self, gpa: Allocator, item: T) Allocator.Error!void {\n        \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/sync.zig:66:22\n    dispatch: src/main.zig:139:24\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x584816cb -Z9e1b83ce47b3c4ce","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"14b50ee9-c83e-4f27-9a8b-7a8d00ed9403","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/sync.zig:209:45: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 2 argument(s), found 1\n\u001b[0m                        try issues_to_remove.append(idx);\n                            \u001b[32m~~~~~~~~~~~~~~~~^~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/array_list.zig:893:13: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0m        pub fn append(self: *Self, gpa: Allocator, item: T) Allocator.Error!void {\n        \u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/sync.zig:66:22\n    dispatch: src/main.zig:139:24\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x584816cb -Z9e1b83ce47b3c4ce","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JdCcCb6r89QLhV2n7UY5rN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HF4xnNHrjbdLV33XUrDM7s","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/sync.zig","old_string":"                        try issues_to_remove.append(idx);","new_string":"                        try issues_to_remove.append(allocator, idx);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":779,"cache_read_input_tokens":105365,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":779},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e6406368-8baa-42af-8614-b89277311e73"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HF4xnNHrjbdLV33XUrDM7s","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/sync.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d4197245-e3c4-4fd3-b0f0-f49f501681ee","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/sync.zig","oldString":"                        try issues_to_remove.append(idx);","newString":"                        try issues_to_remove.append(allocator, idx);","originalFile":"//! Sync command for beads_zig.\n//!\n//! `bz sync` - Bidirectional sync with JSONL file\n//! `bz sync --flush-only` - Export to JSONL only\n//! `bz sync --import-only` - Import from JSONL only\n//! `bz sync --merge` - 3-way merge of local DB and remote JSONL\n//!\n//! Handles synchronization between in-memory state and JSONL file.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const SyncError = error{\n    WorkspaceNotInitialized,\n    MergeConflictDetected,\n    ImportError,\n    ExportError,\n    OutOfMemory,\n};\n\npub const SyncResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    issues_exported: ?usize = null,\n    issues_imported: ?usize = null,\n    issues_updated: ?usize = null,\n    issues_added: ?usize = null,\n    issues_skipped: ?usize = null,\n    issues_renamed: ?usize = null,\n    orphans_created: ?usize = null,\n    errors: ?usize = null,\n    message: ?[]const u8 = null,\n    // Status-specific fields\n    db_count: ?usize = null,\n    jsonl_count: ?usize = null,\n    pending_export: ?usize = null,\n    // Manifest-specific fields\n    manifest_path: ?[]const u8 = null,\n};\n\npub fn run(\n    sync_args: args.SyncArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return SyncError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    if (sync_args.status) {\n        try runStatus(&ctx, structured_output, global.quiet, allocator);\n    } else if (sync_args.flush_only) {\n        try runFlush(&ctx, structured_output, global.quiet, sync_args.manifest, sync_args.error_policy, allocator);\n    } else if (sync_args.import_only) {\n        try runImport(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else if (sync_args.merge) {\n        try runMerge(&ctx, structured_output, global.quiet, sync_args.orphan_policy, sync_args.rename_prefix, allocator);\n    } else {\n        try runBidirectional(&ctx, structured_output, global.quiet, allocator);\n    }\n}\n\nfn runFlush(ctx: *CommandContext, structured_output: bool, quiet: bool, write_manifest: bool, error_policy: args.ErrorPolicy, allocator: std.mem.Allocator) !void {\n    const count = ctx.store.issues.items.len;\n    var errors: usize = 0;\n\n    ctx.store.saveToFile() catch |err| {\n        switch (error_policy) {\n            .strict => {\n                try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to export issues\");\n                return SyncError.ExportError;\n            },\n            .best_effort => {\n                errors += 1;\n                if (!quiet and !structured_output) {\n                    try ctx.output.warn(\"Export error (continuing): {}\", .{err});\n                }\n            },\n            .partial => {\n                errors += 1;\n                // Silent skip\n            },\n        }\n    };\n\n    // Write manifest if requested\n    var manifest_path: ?[]const u8 = null;\n    if (write_manifest) {\n        manifest_path = try writeManifest(ctx, count, allocator);\n    }\n    defer if (manifest_path) |path| allocator.free(path);\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = errors == 0,\n            .action = \"flush\",\n            .issues_exported = count,\n            .errors = if (errors > 0) errors else null,\n            .manifest_path = manifest_path,\n        });\n    } else if (!quiet) {\n        if (errors > 0) {\n            try ctx.output.warn(\"Exported {d} issue(s) to JSONL with {d} error(s)\", .{ count, errors });\n        } else {\n            try ctx.output.success(\"Exported {d} issue(s) to JSONL\", .{count});\n        }\n        if (manifest_path) |path| {\n            try ctx.output.info(\"Manifest written to {s}\", .{path});\n        }\n    }\n}\n\nfn runImport(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers in the JSONL file\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Reload from file (this replaces in-memory state)\n    const old_count = ctx.store.issues.items.len;\n\n    // Deinit existing issues\n    for (ctx.store.issues.items) |*issue| {\n        issue.deinit(allocator);\n    }\n    ctx.store.issues.clearRetainingCapacity();\n\n    // Clear and rebuild index\n    var id_it = ctx.store.id_index.keyIterator();\n    while (id_it.next()) |key| {\n        allocator.free(key.*);\n    }\n    ctx.store.id_index.clearRetainingCapacity();\n\n    // Reload from file\n    ctx.store.loadFromFile() catch {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to import from JSONL\");\n        return SyncError.ImportError;\n    };\n\n    var orphans_created: usize = 0;\n    var issues_skipped: usize = 0;\n    var issues_renamed: usize = 0;\n\n    // Get the expected prefix from config (default to \"bd\")\n    const expected_prefix = ctx.store.getPrefix();\n\n    // Process orphans and prefix renaming\n    var issues_to_remove: std.ArrayListUnmanaged(usize) = .{};\n    defer issues_to_remove.deinit(allocator);\n\n    var orphan_ids: std.ArrayListUnmanaged([]const u8) = .{};\n    defer {\n        for (orphan_ids.items) |id| allocator.free(id);\n        orphan_ids.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items, 0..) |*issue, idx| {\n        // Check for wrong prefix and rename if requested\n        if (rename_prefix) {\n            if (issue.id.len >= 3) {\n                const dash_pos = std.mem.indexOf(u8, issue.id, \"-\");\n                if (dash_pos) |pos| {\n                    const current_prefix = issue.id[0..pos];\n                    if (!std.mem.eql(u8, current_prefix, expected_prefix)) {\n                        // Create new ID with correct prefix\n                        const suffix = issue.id[pos..];\n                        const new_id = try std.fmt.allocPrint(allocator, \"{s}{s}\", .{ expected_prefix, suffix });\n\n                        // Update the issue's ID (need to free old and set new)\n                        allocator.free(issue.id);\n                        issue.id = new_id;\n                        issues_renamed += 1;\n                    }\n                }\n            }\n        }\n\n        // Check for orphaned parent references (hierarchical IDs like bd-abc.1)\n        if (std.mem.indexOf(u8, issue.id, \".\")) |dot_pos| {\n            const parent_id = issue.id[0..dot_pos];\n            const parent_exists = ctx.store.id_index.contains(parent_id);\n\n            if (!parent_exists) {\n                switch (orphan_policy) {\n                    .strict => {\n                        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"orphan detected: parent not found for hierarchical ID\");\n                        return SyncError.ImportError;\n                    },\n                    .resurrect => {\n                        // Create a placeholder parent issue\n                        const parent_id_copy = try allocator.dupe(u8, parent_id);\n                        try orphan_ids.append(allocator, parent_id_copy);\n                        orphans_created += 1;\n                    },\n                    .skip => {\n                        try issues_to_remove.append(idx);\n                        issues_skipped += 1;\n                    },\n                }\n            }\n        }\n    }\n\n    // Remove skipped issues (in reverse order to maintain indices)\n    var i = issues_to_remove.items.len;\n    while (i > 0) {\n        i -= 1;\n        const idx = issues_to_remove.items[i];\n        var removed = ctx.store.issues.orderedRemove(idx);\n        removed.deinit(allocator);\n    }\n\n    // Create placeholder parents for orphans (resurrect policy)\n    for (orphan_ids.items) |parent_id| {\n        if (!ctx.store.id_index.contains(parent_id)) {\n            const placeholder_title = try std.fmt.allocPrint(allocator, \"[Placeholder] Parent of orphaned issue(s)\", .{});\n            defer allocator.free(placeholder_title);\n\n            var placeholder = Issue.init(parent_id, placeholder_title, std.time.timestamp());\n            placeholder.id = try allocator.dupe(u8, parent_id);\n            placeholder.title = try allocator.dupe(u8, placeholder_title);\n            try ctx.store.insert(placeholder);\n        }\n    }\n\n    // Rebuild index after modifications\n    ctx.store.rebuildIndex() catch {};\n\n    // Mark dirty if we made changes\n    if (issues_renamed > 0 or orphans_created > 0) {\n        ctx.store.dirty = true;\n    }\n\n    const new_count = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"import\",\n            .issues_imported = new_count,\n            .issues_skipped = if (issues_skipped > 0) issues_skipped else null,\n            .issues_renamed = if (issues_renamed > 0) issues_renamed else null,\n            .orphans_created = if (orphans_created > 0) orphans_created else null,\n        });\n    } else if (!quiet) {\n        if (new_count > old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (+{d})\", .{ new_count, new_count - old_count });\n        } else if (new_count < old_count) {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (-{d})\", .{ new_count, old_count - new_count });\n        } else {\n            try ctx.output.success(\"Imported {d} issue(s) from JSONL (no change)\", .{new_count});\n        }\n        if (issues_renamed > 0) {\n            try ctx.output.info(\"Renamed {d} issue(s) with wrong prefix\", .{issues_renamed});\n        }\n        if (orphans_created > 0) {\n            try ctx.output.info(\"Created {d} placeholder parent(s) for orphans\", .{orphans_created});\n        }\n        if (issues_skipped > 0) {\n            try ctx.output.info(\"Skipped {d} orphaned issue(s)\", .{issues_skipped});\n        }\n    }\n}\n\nfn runBidirectional(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // For bidirectional sync, we export the current state\n    // A full bidirectional merge would require content hashing which is complex\n    const count = ctx.store.issues.items.len;\n\n    if (ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to sync issues\");\n            return SyncError.ExportError;\n        };\n\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .issues_exported = count,\n            });\n        } else if (!quiet) {\n            try ctx.output.success(\"Synced {d} issue(s)\", .{count});\n        }\n    } else {\n        if (structured_output) {\n            try ctx.output.printJson(SyncResult{\n                .success = true,\n                .action = \"sync\",\n                .message = \"no changes to sync\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"No changes to sync\", .{});\n        }\n    }\n}\n\n/// Perform 3-way merge of local DB and remote JSONL.\n/// For each issue:\n/// - If only in local: keep\n/// - If only in remote: add\n/// - If in both: keep the one with newer updated_at timestamp\nfn runMerge(ctx: *CommandContext, structured_output: bool, quiet: bool, orphan_policy: args.OrphanPolicy, rename_prefix: bool, allocator: std.mem.Allocator) !void {\n    _ = orphan_policy; // TODO: implement orphan handling for merge\n    _ = rename_prefix; // TODO: implement prefix renaming for merge\n    // Check for merge conflict markers\n    if (try hasMergeConflicts(ctx.store.jsonl_path, allocator)) {\n        try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"JSONL file contains merge conflict markers - resolve conflicts first\");\n        return SyncError.MergeConflictDetected;\n    }\n\n    // Load remote issues from JSONL file directly (without replacing store)\n    var remote_store = storage.IssueStore.init(allocator, ctx.store.jsonl_path);\n    defer remote_store.deinit();\n\n    remote_store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to load remote JSONL\");\n            return SyncError.ImportError;\n        }\n    };\n\n    var added: usize = 0;\n    var updated: usize = 0;\n\n    // Iterate through remote issues and merge into local store\n    for (remote_store.issues.items) |remote_issue| {\n        if (ctx.store.getRef(remote_issue.id)) |local_issue| {\n            // Issue exists in both - compare updated_at timestamps\n            const local_ts = local_issue.updated_at.value;\n            const remote_ts = remote_issue.updated_at.value;\n\n            if (remote_ts > local_ts) {\n                // Remote is newer - update local with remote data\n                // We need to copy the remote issue's data\n                const update = storage.IssueStore.IssueUpdate{\n                    .title = remote_issue.title,\n                    .description = remote_issue.description,\n                    .design = remote_issue.design,\n                    .acceptance_criteria = remote_issue.acceptance_criteria,\n                    .notes = remote_issue.notes,\n                    .status = remote_issue.status,\n                    .priority = remote_issue.priority,\n                    .issue_type = remote_issue.issue_type,\n                    .assignee = remote_issue.assignee,\n                    .owner = remote_issue.owner,\n                    .estimated_minutes = remote_issue.estimated_minutes,\n                    .closed_at = remote_issue.closed_at.value,\n                    .close_reason = remote_issue.close_reason,\n                    .due_at = remote_issue.due_at.value,\n                    .defer_until = remote_issue.defer_until.value,\n                    .external_ref = remote_issue.external_ref,\n                    .source_system = remote_issue.source_system,\n                    .pinned = remote_issue.pinned,\n                    .is_template = remote_issue.is_template,\n                };\n\n                ctx.store.update(remote_issue.id, update, remote_ts) catch continue;\n                updated += 1;\n            }\n            // If local is newer or equal, keep local (no action needed)\n        } else {\n            // Issue only in remote - add to local\n            // Clone the remote issue for insertion\n            var cloned = try remote_issue.clone(allocator);\n            ctx.store.insert(cloned) catch {\n                cloned.deinit(allocator);\n                continue;\n            };\n            added += 1;\n        }\n    }\n\n    // Save merged state if any changes were made\n    if (added > 0 or updated > 0 or ctx.store.dirty) {\n        ctx.store.saveToFile() catch {\n            try common.outputErrorTyped(SyncResult, &ctx.output, structured_output, \"failed to save merged issues\");\n            return SyncError.ExportError;\n        };\n    }\n\n    const total = ctx.store.issues.items.len;\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"merge\",\n            .issues_added = added,\n            .issues_updated = updated,\n            .issues_exported = total,\n        });\n    } else if (!quiet) {\n        if (added == 0 and updated == 0) {\n            try ctx.output.info(\"No changes to merge\", .{});\n        } else {\n            try ctx.output.success(\"Merged: {d} added, {d} updated ({d} total)\", .{ added, updated, total });\n        }\n    }\n}\n\n/// Show sync status without making changes.\n/// Reports: DB issue count, JSONL issue count, pending export count.\nfn runStatus(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const db_count = ctx.store.issues.items.len;\n\n    // Count issues in JSONL file (without loading into store)\n    const jsonl_count = countJsonlIssues(ctx.store.jsonl_path, allocator) catch |err| switch (err) {\n        error.FileNotFound => 0,\n        else => return err,\n    };\n\n    // Count pending exports (dirty issues)\n    const pending_export = ctx.store.dirty_ids.count();\n\n    if (structured_output) {\n        try ctx.output.printJson(SyncResult{\n            .success = true,\n            .action = \"status\",\n            .db_count = db_count,\n            .jsonl_count = jsonl_count,\n            .pending_export = pending_export,\n        });\n    } else if (!quiet) {\n        try ctx.output.print(\"DB: {d} issues, JSONL: {d} issues\\n\", .{ db_count, jsonl_count });\n        if (pending_export > 0) {\n            try ctx.output.print(\"{d} issues pending export\\n\", .{pending_export});\n        } else {\n            try ctx.output.info(\"No pending changes\", .{});\n        }\n    }\n}\n\n/// Count the number of issues in a JSONL file without fully parsing them.\nfn countJsonlIssues(path: []const u8, allocator: std.mem.Allocator) !usize {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 50); // 50MB max\n    defer allocator.free(content);\n\n    var count: usize = 0;\n    var lines = std.mem.splitScalar(u8, content, '\\n');\n    while (lines.next()) |line| {\n        const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n        if (trimmed.len > 0 and trimmed[0] == '{') {\n            count += 1;\n        }\n    }\n    return count;\n}\n\n/// Write a manifest file with export metadata.\nfn writeManifest(ctx: *CommandContext, issue_count: usize, allocator: std.mem.Allocator) ![]const u8 {\n    // Derive manifest path from jsonl_path\n    const dir_path = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const manifest_path = try std.fs.path.join(allocator, &.{ dir_path, \"manifest.json\" });\n    errdefer allocator.free(manifest_path);\n\n    const timestamp = std.time.timestamp();\n\n    // Build manifest JSON\n    var json_buf: std.ArrayListUnmanaged(u8) = .{};\n    defer json_buf.deinit(allocator);\n\n    const writer = json_buf.writer(allocator);\n    try writer.writeAll(\"{\\n\");\n    try writer.print(\"  \\\"exported_at\\\": {d},\\n\", .{timestamp});\n    try writer.print(\"  \\\"issue_count\\\": {d},\\n\", .{issue_count});\n    try writer.print(\"  \\\"jsonl_path\\\": \\\"{s}\\\",\\n\", .{ctx.store.jsonl_path});\n    try writer.print(\"  \\\"version\\\": \\\"0.1.0\\\"\\n\", .{});\n    try writer.writeAll(\"}\\n\");\n\n    // Write to file\n    const file = try std.fs.cwd().createFile(manifest_path, .{});\n    defer file.close();\n    try file.writeAll(json_buf.items);\n\n    return manifest_path;\n}\n\n/// Check if the JSONL file contains git merge conflict markers\nfn hasMergeConflicts(path: []const u8, allocator: std.mem.Allocator) !bool {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return false,\n        else => return err,\n    };\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024 * 10);\n    defer allocator.free(content);\n\n    // Check for common merge conflict markers\n    if (std.mem.indexOf(u8, content, \"<<<<<<<\") != null) return true;\n    if (std.mem.indexOf(u8, content, \"=======\") != null) return true;\n    if (std.mem.indexOf(u8, content, \">>>>>>>\") != null) return true;\n\n    return false;\n}\n\n// --- Tests ---\n\ntest \"SyncError enum exists\" {\n    const err: SyncError = SyncError.MergeConflictDetected;\n    try std.testing.expect(err == SyncError.MergeConflictDetected);\n}\n\ntest \"SyncResult struct works\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"flush\",\n        .issues_exported = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"flush\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issues_exported.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const sync_args = args.SyncArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(sync_args, global, allocator);\n    try std.testing.expectError(SyncError.WorkspaceNotInitialized, result);\n}\n\ntest \"hasMergeConflicts returns false for clean file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_clean\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"clean.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-test\\\",\\\"title\\\":\\\"Test\\\"}\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"hasMergeConflicts returns true for conflicted file\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_conflict\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"conflict.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"<<<<<<< HEAD\\n{\\\"id\\\":\\\"bd-test1\\\"}\\n=======\\n{\\\"id\\\":\\\"bd-test2\\\"}\\n>>>>>>> branch\\n\");\n    file.close();\n\n    const has_conflicts = try hasMergeConflicts(test_path, allocator);\n    try std.testing.expect(has_conflicts);\n}\n\ntest \"hasMergeConflicts returns false for missing file\" {\n    const has_conflicts = try hasMergeConflicts(\"/nonexistent/path.jsonl\", std.testing.allocator);\n    try std.testing.expect(!has_conflicts);\n}\n\ntest \"countJsonlIssues counts valid JSON lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n{\\\"id\\\":\\\"bd-2\\\"}\\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"countJsonlIssues handles empty lines\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"sync_count_empty\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const test_path = try std.fs.path.join(allocator, &.{ test_dir, \"count_empty.jsonl\" });\n    defer allocator.free(test_path);\n\n    const file = try std.fs.cwd().createFile(test_path, .{});\n    try file.writeAll(\"{\\\"id\\\":\\\"bd-1\\\"}\\n\\n{\\\"id\\\":\\\"bd-2\\\"}\\n  \\n{\\\"id\\\":\\\"bd-3\\\"}\\n\");\n    file.close();\n\n    const count = try countJsonlIssues(test_path, allocator);\n    try std.testing.expectEqual(@as(usize, 3), count);\n}\n\ntest \"SyncResult with status fields\" {\n    const result = SyncResult{\n        .success = true,\n        .action = \"status\",\n        .db_count = 45,\n        .jsonl_count = 43,\n        .pending_export = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"status\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 45), result.db_count.?);\n    try std.testing.expectEqual(@as(usize, 43), result.jsonl_count.?);\n    try std.testing.expectEqual(@as(usize, 2), result.pending_export.?);\n}\n\ntest \"SyncArgs parses status flag\" {\n    const sync_args = args.SyncArgs{ .status = true };\n    try std.testing.expect(sync_args.status);\n    try std.testing.expect(!sync_args.flush_only);\n}\n\ntest \"SyncArgs parses manifest flag\" {\n    const sync_args = args.SyncArgs{ .manifest = true, .flush_only = true };\n    try std.testing.expect(sync_args.manifest);\n    try std.testing.expect(sync_args.flush_only);\n}\n","structuredPatch":[{"oldStart":206,"oldLines":7,"newStart":206,"newLines":7,"lines":["                         orphans_created += 1;","                     },","                     .skip => {","-                        try issues_to_remove.append(idx);","+                        try issues_to_remove.append(allocator, idx);","                         issues_skipped += 1;","                     },","                 }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012ZmwRXwiAe4VdSQAhDQTjY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S5hrZ7ob4kt4DBm6K5qjt5","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build the project to check for errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":198,"cache_read_input_tokens":106144,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":198},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"9ff1ee7a-84a8-4396-9181-cea147366212"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S5hrZ7ob4kt4DBm6K5qjt5","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"64830c7e-5bfb-4ef7-8349-6d601bc22ffd","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BtSGQQs6PRSK7dCwPMRkD8","type":"message","role":"assistant","content":[{"type":"text","text":"The build succeeds. Now let me run the tests to verify everything works."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":112,"cache_read_input_tokens":106342,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":112},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f859b058-6ede-49be-999b-5342abce5086"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BtSGQQs6PRSK7dCwPMRkD8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017QA4bfA1ZKWMyU3DfvA8xE","name":"Bash","input":{"command":"zig build test 2>&1 | tail -30","description":"Run tests to verify changes","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":112,"cache_read_input_tokens":106342,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":112},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"28b960be-af45-4076-baea-4dd7247452d5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017QA4bfA1ZKWMyU3DfvA8xE","type":"tool_result","content":"653/674 tests.cli_test.test.bz create returns ID...OK\n654/674 tests.cli_test.test.bz q returns ID...OK\n655/674 tests.cli_test.test.bz list returns issues...OK\n656/674 tests.cli_test.test.bz list --json returns output...OK\n657/674 tests.cli_test.test.bz show displays issue...OK\n658/674 tests.cli_test.test.bz show not-found returns error...OK\n659/674 tests.cli_test.test.bz close marks issue as closed...OK\n660/674 tests.cli_test.test.bz reopen reopens closed issue...OK\n661/674 tests.cli_test.test.bz delete soft deletes issue...OK\n662/674 tests.cli_test.test.bz search finds matching issues...OK\n663/674 tests.cli_test.test.bz dep add creates dependency...OK\n664/674 tests.cli_test.test.bz dep add rejects cycles...OK\n665/674 tests.cli_test.test.bz ready shows unblocked issues...OK\n666/674 tests.cli_test.test.bz blocked shows blocked issues...OK\n667/674 tests.cli_test.test.bz unknown command returns error...OK\n668/674 tests.cli_test.test.bz without workspace shows error...OK\n669/674 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n670/674 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n671/674 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 74 issues created\nOK\n672/674 tests.stress_test.test.sequential writes: single thread baseline...OK\n673/674 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n674/674 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 674 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"26f84a37-0079-440a-aa07-7c1805c8770a","tool_use_result":{"stdout":"653/674 tests.cli_test.test.bz create returns ID...OK\n654/674 tests.cli_test.test.bz q returns ID...OK\n655/674 tests.cli_test.test.bz list returns issues...OK\n656/674 tests.cli_test.test.bz list --json returns output...OK\n657/674 tests.cli_test.test.bz show displays issue...OK\n658/674 tests.cli_test.test.bz show not-found returns error...OK\n659/674 tests.cli_test.test.bz close marks issue as closed...OK\n660/674 tests.cli_test.test.bz reopen reopens closed issue...OK\n661/674 tests.cli_test.test.bz delete soft deletes issue...OK\n662/674 tests.cli_test.test.bz search finds matching issues...OK\n663/674 tests.cli_test.test.bz dep add creates dependency...OK\n664/674 tests.cli_test.test.bz dep add rejects cycles...OK\n665/674 tests.cli_test.test.bz ready shows unblocked issues...OK\n666/674 tests.cli_test.test.bz blocked shows blocked issues...OK\n667/674 tests.cli_test.test.bz unknown command returns error...OK\n668/674 tests.cli_test.test.bz without workspace shows error...OK\n669/674 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n670/674 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n671/674 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 74 issues created\nOK\n672/674 tests.stress_test.test.sequential writes: single thread baseline...OK\n673/674 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n674/674 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 674 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RHwq4y2Y9vT9rRS5jdjWri","type":"message","role":"assistant","content":[{"type":"text","text":"All 674 tests passed. Now let me update the todo list and move to Task 2."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":673,"cache_read_input_tokens":106454,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":673},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f8c8ac4e-7662-4aa6-aa2f-3233966058f3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RHwq4y2Y9vT9rRS5jdjWri","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TYtNXWDFNXroS21yyfufPG","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"in_progress","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":673,"cache_read_input_tokens":106454,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":673},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f4048734-fdb5-449c-ad8d-cb25e2f85630"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TYtNXWDFNXroS21yyfufPG","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7b85bd8f-ebc9-4859-bdd7-4ab8cd08386b","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"in_progress","activeForm":"Adding sync policy options"},{"content":"Add ErrorPolicy, OrphanPolicy enums to args.zig","status":"completed","activeForm":"Adding policy enums to args.zig"},{"content":"Update SyncArgs struct with new policy fields","status":"completed","activeForm":"Updating SyncArgs struct"},{"content":"Update parseSyncArgs to parse new flags","status":"completed","activeForm":"Updating parseSyncArgs"},{"content":"Update help.zig with new sync flags","status":"completed","activeForm":"Updating help.zig"},{"content":"Implement policy handling in sync.zig","status":"in_progress","activeForm":"Implementing policy handling in sync.zig"},{"content":"Task 2: Add backup command for JSONL backup management","status":"pending","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"pending","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"in_progress","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MwAmJ36DYgLBQZFQMP9SXM","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's implement Task 2: Add backup command for JSONL backup management. First, let me add the BackupArgs and BackupSubcommand to args.zig."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":350,"cache_read_input_tokens":107127,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":350},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"99097275-8c67-4021-bdef-040ee668bfa5"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MwAmJ36DYgLBQZFQMP9SXM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SetTk2HfxnG3Q5kX9qSFe6","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":35,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":350,"cache_read_input_tokens":107127,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":350},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f74b9f19-4f8d-443f-a946-5cc1ec2bd14b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SetTk2HfxnG3Q5kX9qSFe6","type":"tool_result","content":"    35→\n    36→/// All available subcommands.\n    37→pub const Command = union(enum) {\n    38→    // Workspace\n    39→    init: InitArgs,\n    40→    info: void,\n    41→    stats: void,\n    42→    doctor: void,\n    43→    config: ConfigArgs,\n    44→    orphans: OrphansArgs,\n    45→    lint: LintArgs,\n    46→    where: void,\n    47→\n    48→    // Issue CRUD\n    49→    create: CreateArgs,\n    50→    q: QuickArgs,\n    51→    show: ShowArgs,\n    52→    update: UpdateArgs,\n    53→    close: CloseArgs,\n    54→    reopen: ReopenArgs,\n    55→    delete: DeleteArgs,\n    56→\n    57→    // Batch Operations\n    58→    add_batch: AddBatchArgs,\n    59→    import_cmd: ImportArgs,\n    60→\n    61→    // Query\n    62→    list: ListArgs,\n    63→    ready: ReadyArgs,\n    64→    blocked: BlockedArgs,\n    65→    search: SearchArgs,\n    66→    stale: StaleArgs,\n    67→    count: CountArgs,\n    68→    defer_cmd: DeferArgs,\n    69→    undefer: UndeferArgs,\n    70→\n    71→    // Dependencies\n    72→    dep: DepArgs,\n    73→    graph: GraphArgs,\n    74→\n    75→    // Epics\n    76→    epic: EpicArgs,\n    77→\n    78→    // Labels\n    79→    label: LabelArgs,\n    80→\n    81→    // Comments\n    82→    comments: CommentsArgs,\n    83→\n    84→    // Audit\n    85→    history: HistoryArgs,\n    86→    audit: AuditArgs,\n    87→\n    88→    // Changelog\n    89→    changelog: ChangelogArgs,\n    90→\n    91→    // Sync\n    92→    sync: SyncArgs,\n    93→\n    94→    // System\n    95→    version: void,\n    96→    schema: void,\n    97→    completions: CompletionsArgs,\n    98→    metrics: MetricsArgs,\n    99→\n   100→    // Saved Queries\n   101→    query: QueryArgs,\n   102→\n   103→    // Self-upgrade\n   104→    upgrade: UpgradeArgs,\n   105→\n   106→    // Help\n   107→    help: HelpArgs,\n   108→};\n   109→\n   110→/// Init command arguments.\n   111→pub const InitArgs = struct {\n   112→    prefix: []const u8 = \"bd\",\n   113→};\n   114→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d650b764-cfd5-4079-8ea9-9d10c82b2f74","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n","numLines":80,"startLine":35,"totalLines":2677}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013XEXP37BaDDr1ZgNMMVqoz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0115MbfqQCJKudVWrgs4wRts","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    // Sync\n    sync: SyncArgs,\n\n    // System","new_string":"    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":948,"cache_read_input_tokens":107477,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":948},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"cd2ca6a4-36c4-4968-adc2-ed36eb783494"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0115MbfqQCJKudVWrgs4wRts","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"123e8716-dbcd-4818-aa52-5e37cf8ebc18","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    // Sync\n    sync: SyncArgs,\n\n    // System","newString":"    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":91,"oldLines":6,"newStart":91,"newLines":9,"lines":["     // Sync","     sync: SyncArgs,"," ","+    // Backup","+    backup: BackupArgs,","+","     // System","     version: void,","     schema: void,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NtAzgDX9pBNgsHHcYoXUeQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the BackupArgs and BackupSubcommand structs. Let me find a good place to add them."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":214,"cache_read_input_tokens":108425,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":214},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"cf77ea45-bda7-4f59-8485-91735afa2278"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NtAzgDX9pBNgsHHcYoXUeQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017vPgtop4yxLRQzvfoSz4xf","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":515,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":214,"cache_read_input_tokens":108425,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":214},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6c5fd186-9953-427d-a3f0-1620cbdad084"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017vPgtop4yxLRQzvfoSz4xf","type":"tool_result","content":"   515→    }\n   516→};\n   517→\n   518→/// Sync command arguments.\n   519→pub const SyncArgs = struct {\n   520→    flush_only: bool = false,\n   521→    import_only: bool = false,\n   522→    merge: bool = false,\n   523→    status: bool = false,\n   524→    manifest: bool = false,\n   525→    error_policy: ErrorPolicy = .strict,\n   526→    orphan_policy: OrphanPolicy = .strict,\n   527→    rename_prefix: bool = false,\n   528→};\n   529→\n   530→/// Shell completion types.\n   531→pub const Shell = enum {\n   532→    bash,\n   533→    zsh,\n   534→    fish,\n   535→    powershell,\n   536→\n   537→    pub fn fromString(s: []const u8) ?Shell {\n   538→        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n   539→        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n   540→        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n   541→        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n   542→        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n   543→        return null;\n   544→    }\n   545→};\n   546→\n   547→/// Completions command arguments.\n   548→pub const CompletionsArgs = struct {\n   549→    shell: Shell,\n   550→};\n   551→\n   552→/// Metrics command arguments.\n   553→pub const MetricsArgs = struct {\n   554→    reset: bool = false, // Reset metrics after displaying\n   555→};\n   556→\n   557→/// Help command arguments.\n   558→pub const HelpArgs = struct {\n   559→    topic: ?[]const u8 = null,\n   560→};\n   561→\n   562→/// Config subcommand variants.\n   563→pub const ConfigSubcommand = union(enum) {\n   564→    get: struct {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2053c8fb-d178-4167-af0f-5c370ca5795f","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {","numLines":50,"startLine":515,"totalLines":2680}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011C4PwQ8PBY438Q24bpnHhG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RYYFAmLKGbgBu3WYDspwjK","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Shell completion types.","new_string":"/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":785,"cache_read_input_tokens":108639,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":785},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"53c627d8-9e4d-41a9-aaa7-337e535dc493"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RYYFAmLKGbgBu3WYDspwjK","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"83fdbaa0-321c-4f05-9987-97d3074d6990","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Shell completion types.","newString":"/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":527,"oldLines":6,"newStart":527,"newLines":28,"lines":["     rename_prefix: bool = false,"," };"," ","+/// Backup subcommand variants.","+pub const BackupSubcommand = union(enum) {","+    list: void,","+    diff: struct {","+        file: []const u8,","+    },","+    restore: struct {","+        file: []const u8,","+        dry_run: bool = false,","+    },","+    prune: struct {","+        keep: u32 = 10,","+        dry_run: bool = false,","+    },","+    create: void,","+};","+","+/// Backup command arguments.","+pub const BackupArgs = struct {","+    subcommand: BackupSubcommand,","+};","+"," /// Shell completion types."," pub const Shell = enum {","     bash,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017SpbmLnx2W215utg4egsBS","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the parsing for the backup command. Let me find where the command parsing happens."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":519,"cache_read_input_tokens":109424,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":519},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5aead62f-07f4-4f9a-8839-e7f1405cf6a3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017SpbmLnx2W215utg4egsBS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Cd9jpAdJfD9Nwt25YsM2Xd","name":"Grep","input":{"pattern":"\\\"sync\\\"|std.mem.eql.*cmd.*\\\"","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-n":true,"-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":519,"cache_read_input_tokens":109424,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":519},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"47a66fc3-3ed7-4510-a8ea-bb52a1a4cb7e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Cd9jpAdJfD9Nwt25YsM2Xd","type":"tool_result","content":"797-\n798-    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n799-        // Workspace\n800:        if (std.mem.eql(u8, cmd, \"init\")) {\n801-            return .{ .init = try self.parseInitArgs() };\n802-        }\n803:        if (std.mem.eql(u8, cmd, \"info\")) {\n804-            return .{ .info = {} };\n805-        }\n806:        if (std.mem.eql(u8, cmd, \"stats\")) {\n807-            return .{ .stats = {} };\n808-        }\n809:        if (std.mem.eql(u8, cmd, \"doctor\")) {\n810-            return .{ .doctor = {} };\n811-        }\n812:        if (std.mem.eql(u8, cmd, \"config\")) {\n813-            return .{ .config = try self.parseConfigArgs() };\n814-        }\n815:        if (std.mem.eql(u8, cmd, \"orphans\")) {\n816-            return .{ .orphans = try self.parseOrphansArgs() };\n817-        }\n818:        if (std.mem.eql(u8, cmd, \"lint\")) {\n819-            return .{ .lint = try self.parseLintArgs() };\n820-        }\n821:        if (std.mem.eql(u8, cmd, \"where\")) {\n822-            return .{ .where = {} };\n823-        }\n824-\n825-        // Issue CRUD\n826:        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n827-            return .{ .create = try self.parseCreateArgs() };\n828-        }\n829:        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n830-            return .{ .q = try self.parseQuickArgs() };\n831-        }\n832:        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n833-            return .{ .show = try self.parseShowArgs() };\n834-        }\n835:        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n836-            return .{ .update = try self.parseUpdateArgs() };\n837-        }\n838:        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n839-            return .{ .close = try self.parseCloseArgs() };\n840-        }\n841:        if (std.mem.eql(u8, cmd, \"reopen\")) {\n842-            return .{ .reopen = try self.parseReopenArgs() };\n843-        }\n844:        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n845-            return .{ .delete = try self.parseDeleteArgs() };\n846-        }\n847-\n848-        // Batch Operations\n849:        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n850-            return .{ .add_batch = try self.parseAddBatchArgs() };\n851-        }\n852:        if (std.mem.eql(u8, cmd, \"import\")) {\n853-            return .{ .import_cmd = try self.parseImportArgs() };\n854-        }\n855-\n856-        // Query\n857:        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n858-            return .{ .list = try self.parseListArgs() };\n859-        }\n860:        if (std.mem.eql(u8, cmd, \"ready\")) {\n861-            return .{ .ready = try self.parseReadyArgs() };\n862-        }\n863:        if (std.mem.eql(u8, cmd, \"blocked\")) {\n864-            return .{ .blocked = try self.parseBlockedArgs() };\n865-        }\n866:        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n867-            return .{ .search = try self.parseSearchArgs() };\n868-        }\n869:        if (std.mem.eql(u8, cmd, \"stale\")) {\n870-            return .{ .stale = try self.parseStaleArgs() };\n871-        }\n872:        if (std.mem.eql(u8, cmd, \"count\")) {\n873-            return .{ .count = try self.parseCountArgs() };\n874-        }\n875:        if (std.mem.eql(u8, cmd, \"defer\")) {\n876-            return .{ .defer_cmd = try self.parseDeferArgs() };\n877-        }\n878:        if (std.mem.eql(u8, cmd, \"undefer\")) {\n879-            return .{ .undefer = try self.parseUndeferArgs() };\n880-        }\n881-\n882-        // Dependencies\n883:        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n884-            return .{ .dep = try self.parseDepArgs() };\n885-        }\n886:        if (std.mem.eql(u8, cmd, \"graph\")) {\n887-            return .{ .graph = try self.parseGraphArgs() };\n888-        }\n889-\n890-        // Epics\n891:        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n892-            return .{ .epic = try self.parseEpicArgs() };\n893-        }\n894-\n895-        // Labels\n896:        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n897-            return .{ .label = try self.parseLabelArgs() };\n898-        }\n899-\n900-        // Comments\n901:        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n902-            return .{ .comments = try self.parseCommentsArgs() };\n903-        }\n904-\n905-        // Audit\n906:        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n907-            return .{ .history = try self.parseHistoryArgs() };\n908-        }\n909:        if (std.mem.eql(u8, cmd, \"audit\")) {\n910-            return .{ .audit = try self.parseAuditArgs() };\n911-        }\n912-\n913-        // Changelog\n914:        if (std.mem.eql(u8, cmd, \"changelog\")) {\n915-            return .{ .changelog = try self.parseChangelogArgs() };\n916-        }\n917-\n918-        // Sync\n919:        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n920-            return .{ .sync = try self.parseSyncArgs() };\n921-        }\n922-\n923-        // System\n924:        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n925-            return .{ .version = {} };\n926-        }\n927:        if (std.mem.eql(u8, cmd, \"schema\")) {\n928-            return .{ .schema = {} };\n929-        }\n930:        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n931-            return .{ .completions = try self.parseCompletionsArgs() };\n932-        }\n933:        if (std.mem.eql(u8, cmd, \"metrics\")) {\n934-            return .{ .metrics = try self.parseMetricsArgs() };\n935-        }\n936-\n937-        // Saved Queries\n938:        if (std.mem.eql(u8, cmd, \"query\")) {\n939-            return .{ .query = try self.parseQueryArgs() };\n940-        }\n941-\n942-        // Self-upgrade\n943:        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n944-            return .{ .upgrade = try self.parseUpgradeArgs() };\n945-        }\n946-\n947-        // Help\n948:        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n949-            return .{ .help = try self.parseHelpArgs() };\n950-        }\n951-\n--\n1368-    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n1369-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1370-\n1371:        if (std.mem.eql(u8, subcmd, \"add\")) {\n1372-            const child = self.next() orelse return error.MissingRequiredArgument;\n1373-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1374-            var dep_type: []const u8 = \"blocks\";\n--\n1382-            }\n1383-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n1384-        }\n1385:        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1386-            const child = self.next() orelse return error.MissingRequiredArgument;\n1387-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1388-            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n1389-        }\n1390:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1391-            const id = self.next() orelse return error.MissingRequiredArgument;\n1392-            var direction: DepDirection = .both;\n1393-            while (self.hasNext()) {\n--\n1398-            }\n1399-            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n1400-        }\n1401:        if (std.mem.eql(u8, subcmd, \"tree\")) {\n1402-            const id = self.next() orelse return error.MissingRequiredArgument;\n1403-            var format: TreeFormat = .ascii;\n1404-            while (self.hasNext()) {\n--\n1409-            }\n1410-            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n1411-        }\n1412:        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n1413-            return .{ .subcommand = .{ .cycles = {} } };\n1414-        }\n1415-        return error.UnknownSubcommand;\n--\n1437-    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n1438-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1439-\n1440:        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n1441-            var title: ?[]const u8 = null;\n1442-            var description: ?[]const u8 = null;\n1443-            var priority: ?[]const u8 = null;\n--\n1461-                .priority = priority,\n1462-            } } };\n1463-        }\n1464:        if (std.mem.eql(u8, subcmd, \"add\")) {\n1465-            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n1466-            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n1467-            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n1468-        }\n1469:        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1470-            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n1471-            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n1472-            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n1473-        }\n1474:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1475-            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n1476-        }\n1477:        if (std.mem.eql(u8, subcmd, \"status\")) {\n1478-            return .{ .subcommand = .{ .status = {} } };\n1479-        }\n1480:        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n1481-            var dry_run = false;\n1482-            while (self.hasNext()) {\n1483-                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n--\n1492-    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n1493-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1494-\n1495:        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1496:            const is_add = std.mem.eql(u8, subcmd, \"add\");\n1497-            const id = self.next() orelse return error.MissingRequiredArgument;\n1498-            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n1499-\n--\n1510-                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n1511-            }\n1512-        }\n1513:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1514-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n1515-        }\n1516:        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n1517-            return .{ .subcommand = .{ .list_all = {} } };\n1518-        }\n1519:        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n1520-            const old_name = self.next() orelse return error.MissingRequiredArgument;\n1521-            const new_name = self.next() orelse return error.MissingRequiredArgument;\n1522-            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n--\n1527-    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n1528-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1529-\n1530:        if (std.mem.eql(u8, subcmd, \"add\")) {\n1531-            return .{ .subcommand = .{ .add = .{\n1532-                .id = self.next() orelse return error.MissingRequiredArgument,\n1533-                .text = self.next() orelse return error.MissingRequiredArgument,\n1534-            } } };\n1535-        }\n1536:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1537-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n1538-        }\n1539-        return error.UnknownSubcommand;\n--\n1619-    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n1620-        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n1621-\n1622:        if (std.mem.eql(u8, subcmd, \"get\")) {\n1623-            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n1624-        }\n1625:        if (std.mem.eql(u8, subcmd, \"set\")) {\n1626-            return .{ .subcommand = .{ .set = .{\n1627-                .key = self.next() orelse return error.MissingRequiredArgument,\n1628-                .value = self.next() orelse return error.MissingRequiredArgument,\n1629-            } } };\n1630-        }\n1631:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1632-            return .{ .subcommand = .{ .list = {} } };\n1633-        }\n1634-        return error.UnknownSubcommand;\n--\n1661-    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n1662-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1663-\n1664:        if (std.mem.eql(u8, subcmd, \"save\")) {\n1665-            const name = self.next() orelse return error.MissingRequiredArgument;\n1666-            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n1667-\n--\n1683-\n1684-            return .{ .subcommand = save_args };\n1685-        }\n1686:        if (std.mem.eql(u8, subcmd, \"run\")) {\n1687-            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n1688-        }\n1689:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1690-            return .{ .subcommand = .{ .list = {} } };\n1691-        }\n1692:        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1693-            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n1694-        }\n1695-        return error.UnknownSubcommand;\n--\n2444-}\n2445-\n2446-test \"parse sync command\" {\n2447:    const args = [_][]const u8{\"sync\"};\n2448-    var parser = ArgParser.init(std.testing.allocator, &args);\n2449-    const result = try parser.parse();\n2450-\n--\n2454-}\n2455-\n2456-test \"parse sync --flush-only\" {\n2457:    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n2458-    var parser = ArgParser.init(std.testing.allocator, &args);\n2459-    const result = try parser.parse();\n2460-\n--\n2463-}\n2464-\n2465-test \"parse sync --import-only\" {\n2466:    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n2467-    var parser = ArgParser.init(std.testing.allocator, &args);\n2468-    const result = try parser.parse();\n2469-"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f56555c6-e0af-44ca-8b91-a0e08860063d","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"797-\n798-    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n799-        // Workspace\n800:        if (std.mem.eql(u8, cmd, \"init\")) {\n801-            return .{ .init = try self.parseInitArgs() };\n802-        }\n803:        if (std.mem.eql(u8, cmd, \"info\")) {\n804-            return .{ .info = {} };\n805-        }\n806:        if (std.mem.eql(u8, cmd, \"stats\")) {\n807-            return .{ .stats = {} };\n808-        }\n809:        if (std.mem.eql(u8, cmd, \"doctor\")) {\n810-            return .{ .doctor = {} };\n811-        }\n812:        if (std.mem.eql(u8, cmd, \"config\")) {\n813-            return .{ .config = try self.parseConfigArgs() };\n814-        }\n815:        if (std.mem.eql(u8, cmd, \"orphans\")) {\n816-            return .{ .orphans = try self.parseOrphansArgs() };\n817-        }\n818:        if (std.mem.eql(u8, cmd, \"lint\")) {\n819-            return .{ .lint = try self.parseLintArgs() };\n820-        }\n821:        if (std.mem.eql(u8, cmd, \"where\")) {\n822-            return .{ .where = {} };\n823-        }\n824-\n825-        // Issue CRUD\n826:        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n827-            return .{ .create = try self.parseCreateArgs() };\n828-        }\n829:        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n830-            return .{ .q = try self.parseQuickArgs() };\n831-        }\n832:        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n833-            return .{ .show = try self.parseShowArgs() };\n834-        }\n835:        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n836-            return .{ .update = try self.parseUpdateArgs() };\n837-        }\n838:        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n839-            return .{ .close = try self.parseCloseArgs() };\n840-        }\n841:        if (std.mem.eql(u8, cmd, \"reopen\")) {\n842-            return .{ .reopen = try self.parseReopenArgs() };\n843-        }\n844:        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n845-            return .{ .delete = try self.parseDeleteArgs() };\n846-        }\n847-\n848-        // Batch Operations\n849:        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n850-            return .{ .add_batch = try self.parseAddBatchArgs() };\n851-        }\n852:        if (std.mem.eql(u8, cmd, \"import\")) {\n853-            return .{ .import_cmd = try self.parseImportArgs() };\n854-        }\n855-\n856-        // Query\n857:        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n858-            return .{ .list = try self.parseListArgs() };\n859-        }\n860:        if (std.mem.eql(u8, cmd, \"ready\")) {\n861-            return .{ .ready = try self.parseReadyArgs() };\n862-        }\n863:        if (std.mem.eql(u8, cmd, \"blocked\")) {\n864-            return .{ .blocked = try self.parseBlockedArgs() };\n865-        }\n866:        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n867-            return .{ .search = try self.parseSearchArgs() };\n868-        }\n869:        if (std.mem.eql(u8, cmd, \"stale\")) {\n870-            return .{ .stale = try self.parseStaleArgs() };\n871-        }\n872:        if (std.mem.eql(u8, cmd, \"count\")) {\n873-            return .{ .count = try self.parseCountArgs() };\n874-        }\n875:        if (std.mem.eql(u8, cmd, \"defer\")) {\n876-            return .{ .defer_cmd = try self.parseDeferArgs() };\n877-        }\n878:        if (std.mem.eql(u8, cmd, \"undefer\")) {\n879-            return .{ .undefer = try self.parseUndeferArgs() };\n880-        }\n881-\n882-        // Dependencies\n883:        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n884-            return .{ .dep = try self.parseDepArgs() };\n885-        }\n886:        if (std.mem.eql(u8, cmd, \"graph\")) {\n887-            return .{ .graph = try self.parseGraphArgs() };\n888-        }\n889-\n890-        // Epics\n891:        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n892-            return .{ .epic = try self.parseEpicArgs() };\n893-        }\n894-\n895-        // Labels\n896:        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n897-            return .{ .label = try self.parseLabelArgs() };\n898-        }\n899-\n900-        // Comments\n901:        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n902-            return .{ .comments = try self.parseCommentsArgs() };\n903-        }\n904-\n905-        // Audit\n906:        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n907-            return .{ .history = try self.parseHistoryArgs() };\n908-        }\n909:        if (std.mem.eql(u8, cmd, \"audit\")) {\n910-            return .{ .audit = try self.parseAuditArgs() };\n911-        }\n912-\n913-        // Changelog\n914:        if (std.mem.eql(u8, cmd, \"changelog\")) {\n915-            return .{ .changelog = try self.parseChangelogArgs() };\n916-        }\n917-\n918-        // Sync\n919:        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n920-            return .{ .sync = try self.parseSyncArgs() };\n921-        }\n922-\n923-        // System\n924:        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n925-            return .{ .version = {} };\n926-        }\n927:        if (std.mem.eql(u8, cmd, \"schema\")) {\n928-            return .{ .schema = {} };\n929-        }\n930:        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n931-            return .{ .completions = try self.parseCompletionsArgs() };\n932-        }\n933:        if (std.mem.eql(u8, cmd, \"metrics\")) {\n934-            return .{ .metrics = try self.parseMetricsArgs() };\n935-        }\n936-\n937-        // Saved Queries\n938:        if (std.mem.eql(u8, cmd, \"query\")) {\n939-            return .{ .query = try self.parseQueryArgs() };\n940-        }\n941-\n942-        // Self-upgrade\n943:        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n944-            return .{ .upgrade = try self.parseUpgradeArgs() };\n945-        }\n946-\n947-        // Help\n948:        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n949-            return .{ .help = try self.parseHelpArgs() };\n950-        }\n951-\n--\n1368-    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n1369-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1370-\n1371:        if (std.mem.eql(u8, subcmd, \"add\")) {\n1372-            const child = self.next() orelse return error.MissingRequiredArgument;\n1373-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1374-            var dep_type: []const u8 = \"blocks\";\n--\n1382-            }\n1383-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n1384-        }\n1385:        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1386-            const child = self.next() orelse return error.MissingRequiredArgument;\n1387-            const parent = self.next() orelse return error.MissingRequiredArgument;\n1388-            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n1389-        }\n1390:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1391-            const id = self.next() orelse return error.MissingRequiredArgument;\n1392-            var direction: DepDirection = .both;\n1393-            while (self.hasNext()) {\n--\n1398-            }\n1399-            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n1400-        }\n1401:        if (std.mem.eql(u8, subcmd, \"tree\")) {\n1402-            const id = self.next() orelse return error.MissingRequiredArgument;\n1403-            var format: TreeFormat = .ascii;\n1404-            while (self.hasNext()) {\n--\n1409-            }\n1410-            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n1411-        }\n1412:        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n1413-            return .{ .subcommand = .{ .cycles = {} } };\n1414-        }\n1415-        return error.UnknownSubcommand;\n--\n1437-    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n1438-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1439-\n1440:        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n1441-            var title: ?[]const u8 = null;\n1442-            var description: ?[]const u8 = null;\n1443-            var priority: ?[]const u8 = null;\n--\n1461-                .priority = priority,\n1462-            } } };\n1463-        }\n1464:        if (std.mem.eql(u8, subcmd, \"add\")) {\n1465-            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n1466-            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n1467-            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n1468-        }\n1469:        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1470-            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n1471-            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n1472-            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n1473-        }\n1474:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1475-            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n1476-        }\n1477:        if (std.mem.eql(u8, subcmd, \"status\")) {\n1478-            return .{ .subcommand = .{ .status = {} } };\n1479-        }\n1480:        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n1481-            var dry_run = false;\n1482-            while (self.hasNext()) {\n1483-                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n--\n1492-    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n1493-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1494-\n1495:        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1496:            const is_add = std.mem.eql(u8, subcmd, \"add\");\n1497-            const id = self.next() orelse return error.MissingRequiredArgument;\n1498-            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n1499-\n--\n1510-                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n1511-            }\n1512-        }\n1513:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1514-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n1515-        }\n1516:        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n1517-            return .{ .subcommand = .{ .list_all = {} } };\n1518-        }\n1519:        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n1520-            const old_name = self.next() orelse return error.MissingRequiredArgument;\n1521-            const new_name = self.next() orelse return error.MissingRequiredArgument;\n1522-            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n--\n1527-    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n1528-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1529-\n1530:        if (std.mem.eql(u8, subcmd, \"add\")) {\n1531-            return .{ .subcommand = .{ .add = .{\n1532-                .id = self.next() orelse return error.MissingRequiredArgument,\n1533-                .text = self.next() orelse return error.MissingRequiredArgument,\n1534-            } } };\n1535-        }\n1536:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1537-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n1538-        }\n1539-        return error.UnknownSubcommand;\n--\n1619-    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n1620-        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n1621-\n1622:        if (std.mem.eql(u8, subcmd, \"get\")) {\n1623-            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n1624-        }\n1625:        if (std.mem.eql(u8, subcmd, \"set\")) {\n1626-            return .{ .subcommand = .{ .set = .{\n1627-                .key = self.next() orelse return error.MissingRequiredArgument,\n1628-                .value = self.next() orelse return error.MissingRequiredArgument,\n1629-            } } };\n1630-        }\n1631:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1632-            return .{ .subcommand = .{ .list = {} } };\n1633-        }\n1634-        return error.UnknownSubcommand;\n--\n1661-    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n1662-        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n1663-\n1664:        if (std.mem.eql(u8, subcmd, \"save\")) {\n1665-            const name = self.next() orelse return error.MissingRequiredArgument;\n1666-            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n1667-\n--\n1683-\n1684-            return .{ .subcommand = save_args };\n1685-        }\n1686:        if (std.mem.eql(u8, subcmd, \"run\")) {\n1687-            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n1688-        }\n1689:        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n1690-            return .{ .subcommand = .{ .list = {} } };\n1691-        }\n1692:        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n1693-            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n1694-        }\n1695-        return error.UnknownSubcommand;\n--\n2444-}\n2445-\n2446-test \"parse sync command\" {\n2447:    const args = [_][]const u8{\"sync\"};\n2448-    var parser = ArgParser.init(std.testing.allocator, &args);\n2449-    const result = try parser.parse();\n2450-\n--\n2454-}\n2455-\n2456-test \"parse sync --flush-only\" {\n2457:    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n2458-    var parser = ArgParser.init(std.testing.allocator, &args);\n2459-    const result = try parser.parse();\n2460-\n--\n2463-}\n2464-\n2465-test \"parse sync --import-only\" {\n2466:    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n2467-    var parser = ArgParser.init(std.testing.allocator, &args);\n2468-    const result = try parser.parse();\n2469-","numLines":324}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018GcmmTbtQauJKEHqZau7EY","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the backup command parsing and the parseBackupArgs function."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":5806,"cache_read_input_tokens":109943,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5806},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3333a827-8b60-4aa4-a423-18d07e4f5eee"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018GcmmTbtQauJKEHqZau7EY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CZv6boi5x8cAUTEGpDVfYF","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System","new_string":"        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":5806,"cache_read_input_tokens":109943,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5806},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"79419d50-c412-4cb9-a0fb-3b00b96a236f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CZv6boi5x8cAUTEGpDVfYF","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"1c2e270c-f296-4497-9308-e504d08be64a","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System","newString":"        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":920,"oldLines":6,"newStart":920,"newLines":11,"lines":["             return .{ .sync = try self.parseSyncArgs() };","         }"," ","+        // Backup","+        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {","+            return .{ .backup = try self.parseBackupArgs() };","+        }","+","         // System","         if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {","             return .{ .version = {} };"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Vq5jd7ZiGEunu1FSNomRHQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the parseBackupArgs function. Let me find where to add it, after parseSyncArgs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":651,"cache_read_input_tokens":115749,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":651},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f561d036-9ece-4e5b-a15a-a75139432858"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Vq5jd7ZiGEunu1FSNomRHQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ukn7ZXmpLGbyHAnxSvdma9","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1595,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":651,"cache_read_input_tokens":115749,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":651},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d0f8d3b4-0376-420d-8e33-9a07bd639387"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ukn7ZXmpLGbyHAnxSvdma9","type":"tool_result","content":"  1595→                const policy_str = self.next() orelse return error.MissingFlagValue;\n  1596→                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n  1597→            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n  1598→                result.rename_prefix = true;\n  1599→            } else break;\n  1600→        }\n  1601→        return result;\n  1602→    }\n  1603→\n  1604→    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n  1605→        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n  1606→        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n  1607→        return .{ .shell = shell };\n  1608→    }\n  1609→\n  1610→    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n  1611→        var result = MetricsArgs{};\n  1612→        while (self.hasNext()) {\n  1613→            if (self.consumeFlag(\"-r\", \"--reset\")) {\n  1614→                result.reset = true;\n  1615→            } else break;\n  1616→        }\n  1617→        return result;\n  1618→    }\n  1619→\n  1620→    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n  1621→        return .{ .topic = self.next() };\n  1622→    }\n  1623→\n  1624→    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n  1625→        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n  1626→\n  1627→        if (std.mem.eql(u8, subcmd, \"get\")) {\n  1628→            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n  1629→        }\n  1630→        if (std.mem.eql(u8, subcmd, \"set\")) {\n  1631→            return .{ .subcommand = .{ .set = .{\n  1632→                .key = self.next() orelse return error.MissingRequiredArgument,\n  1633→                .value = self.next() orelse return error.MissingRequiredArgument,\n  1634→            } } };\n  1635→        }\n  1636→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1637→            return .{ .subcommand = .{ .list = {} } };\n  1638→        }\n  1639→        return error.UnknownSubcommand;\n  1640→    }\n  1641→\n  1642→    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n  1643→        var result = OrphansArgs{};\n  1644→        while (self.hasNext()) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"763a534d-0ad1-4bc4-8b09-8898c2c30e62","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {","numLines":50,"startLine":1595,"totalLines":2707}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MM6DM5zGBApjxZssdC6Cjx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KbLgfg9Xyz8V3j4b9Lax7d","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {","new_string":"            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1051,"cache_read_input_tokens":116400,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1051},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"015597c8-9c1e-42a3-a5f9-cf41a65feaa3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KbLgfg9Xyz8V3j4b9Lax7d","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8c7ef27f-cf41-4feb-877b-2510177ca777","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {","newString":"            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1601,"oldLines":6,"newStart":1601,"newLines":45,"lines":["         return result;","     }"," ","+    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {","+        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };","+","+        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {","+            return .{ .subcommand = .{ .list = {} } };","+        }","+        if (std.mem.eql(u8, subcmd, \"diff\")) {","+            const file = self.next() orelse return error.MissingRequiredArgument;","+            return .{ .subcommand = .{ .diff = .{ .file = file } } };","+        }","+        if (std.mem.eql(u8, subcmd, \"restore\")) {","+            const file = self.next() orelse return error.MissingRequiredArgument;","+            var dry_run = false;","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-n\", \"--dry-run\")) {","+                    dry_run = true;","+                } else break;","+            }","+            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };","+        }","+        if (std.mem.eql(u8, subcmd, \"prune\")) {","+            var keep: u32 = 10;","+            var dry_run = false;","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-k\", \"--keep\")) {","+                    const keep_str = self.next() orelse return error.MissingFlagValue;","+                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;","+                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {","+                    dry_run = true;","+                } else break;","+            }","+            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };","+        }","+        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {","+            return .{ .subcommand = .{ .create = {} } };","+        }","+        return error.UnknownSubcommand;","+    }","+","     fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {","         const shell_str = self.next() orelse return error.MissingRequiredArgument;","         const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01K2VbejaTfQotjU8ja2zbcS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KYKSDKoqm15qUahJGahh4Y","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"in_progress","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":827,"cache_read_input_tokens":117451,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":827},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6c4f10e4-8657-4c83-b7e6-faa8a413f775"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KYKSDKoqm15qUahJGahh4Y","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"62fcea73-acdc-44cf-861f-42b4277a6848","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"in_progress","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"pending","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"in_progress","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VSKFJt8Fr5DnUhJh6DH49F","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create the backup.zig file. First, let me look at an existing command file for the pattern."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":118278,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b65cae45-1fde-4b19-b76e-c1b7f32ef9f0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VSKFJt8Fr5DnUhJh6DH49F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AwaHxJkemRgfG6bZfQZD84","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/info.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":118278,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"64980656-81d5-4e53-a156-6ed8667bb405"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AwaHxJkemRgfG6bZfQZD84","type":"tool_result","content":"     1→//! Info command for beads_zig.\n     2→//!\n     3→//! `bz info` - Show workspace information\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const InfoError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const InfoResult = struct {\n    18→    success: bool,\n    19→    beads_dir: ?[]const u8 = null,\n    20→    jsonl_path: ?[]const u8 = null,\n    21→    issue_count: ?usize = null,\n    22→    jsonl_size: ?u64 = null,\n    23→    wal_size: ?u64 = null,\n    24→    message: ?[]const u8 = null,\n    25→};\n    26→\n    27→pub fn run(\n    28→    global: args.GlobalOptions,\n    29→    allocator: std.mem.Allocator,\n    30→) !void {\n    31→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    32→        return InfoError.WorkspaceNotInitialized;\n    33→    };\n    34→    defer ctx.deinit();\n    35→\n    36→    const beads_dir = global.data_path orelse \".beads\";\n    37→    const jsonl_size = getFileSize(ctx.issues_path);\n    38→\n    39→    const wal_path = try std.fs.path.join(allocator, &.{ beads_dir, \"beads.wal\" });\n    40→    defer allocator.free(wal_path);\n    41→    const wal_size = getFileSize(wal_path);\n    42→\n    43→    const issue_count = ctx.store.countTotal();\n    44→\n    45→    if (global.isStructuredOutput()) {\n    46→        try ctx.output.printJson(InfoResult{\n    47→            .success = true,\n    48→            .beads_dir = beads_dir,\n    49→            .jsonl_path = ctx.issues_path,\n    50→            .issue_count = issue_count,\n    51→            .jsonl_size = jsonl_size,\n    52→            .wal_size = wal_size,\n    53→        });\n    54→    } else if (!global.quiet) {\n    55→        try ctx.output.println(\"beads_zig workspace\", .{});\n    56→        try ctx.output.print(\"\\n\", .{});\n    57→        try ctx.output.print(\"Directory:     {s}\\n\", .{beads_dir});\n    58→        try ctx.output.print(\"JSONL:         {s} ({s})\\n\", .{ ctx.issues_path, formatBytes(jsonl_size) });\n    59→        try ctx.output.print(\"WAL:           {s} ({s})\\n\", .{ wal_path, formatBytes(wal_size) });\n    60→        try ctx.output.print(\"Total issues:  {d}\\n\", .{issue_count});\n    61→    }\n    62→}\n    63→\n    64→fn getFileSize(path: []const u8) u64 {\n    65→    const file = std.fs.cwd().openFile(path, .{}) catch return 0;\n    66→    defer file.close();\n    67→    const stat = file.stat() catch return 0;\n    68→    return stat.size;\n    69→}\n    70→\n    71→fn formatBytes(bytes: u64) []const u8 {\n    72→    if (bytes == 0) return \"0 B\";\n    73→    if (bytes < 1024) return \"<1 KB\";\n    74→    if (bytes < 1024 * 1024) return \"<1 MB\";\n    75→    return \">1 MB\";\n    76→}\n    77→\n    78→// --- Tests ---\n    79→\n    80→test \"InfoError enum exists\" {\n    81→    const err: InfoError = InfoError.WorkspaceNotInitialized;\n    82→    try std.testing.expect(err == InfoError.WorkspaceNotInitialized);\n    83→}\n    84→\n    85→test \"InfoResult struct works\" {\n    86→    const result = InfoResult{\n    87→        .success = true,\n    88→        .beads_dir = \".beads\",\n    89→        .issue_count = 5,\n    90→    };\n    91→    try std.testing.expect(result.success);\n    92→    try std.testing.expectEqualStrings(\".beads\", result.beads_dir.?);\n    93→    try std.testing.expectEqual(@as(usize, 5), result.issue_count.?);\n    94→}\n    95→\n    96→test \"run detects uninitialized workspace\" {\n    97→    const allocator = std.testing.allocator;\n    98→\n    99→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   100→\n   101→    const result = run(global, allocator);\n   102→    try std.testing.expectError(InfoError.WorkspaceNotInitialized, result);\n   103→}\n   104→\n   105→test \"formatBytes handles zero\" {\n   106→    try std.testing.expectEqualStrings(\"0 B\", formatBytes(0));\n   107→}\n   108→\n   109→test \"formatBytes handles small values\" {\n   110→    try std.testing.expectEqualStrings(\"<1 KB\", formatBytes(500));\n   111→}\n   112→\n   113→test \"getFileSize returns 0 for missing file\" {\n   114→    const size = getFileSize(\"/nonexistent/file.txt\");\n   115→    try std.testing.expectEqual(@as(u64, 0), size);\n   116→}\n   117→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"917fd3b2-56fc-4125-adf9-562adc7c79d6","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/info.zig","content":"//! Info command for beads_zig.\n//!\n//! `bz info` - Show workspace information\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const InfoError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const InfoResult = struct {\n    success: bool,\n    beads_dir: ?[]const u8 = null,\n    jsonl_path: ?[]const u8 = null,\n    issue_count: ?usize = null,\n    jsonl_size: ?u64 = null,\n    wal_size: ?u64 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return InfoError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const beads_dir = global.data_path orelse \".beads\";\n    const jsonl_size = getFileSize(ctx.issues_path);\n\n    const wal_path = try std.fs.path.join(allocator, &.{ beads_dir, \"beads.wal\" });\n    defer allocator.free(wal_path);\n    const wal_size = getFileSize(wal_path);\n\n    const issue_count = ctx.store.countTotal();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(InfoResult{\n            .success = true,\n            .beads_dir = beads_dir,\n            .jsonl_path = ctx.issues_path,\n            .issue_count = issue_count,\n            .jsonl_size = jsonl_size,\n            .wal_size = wal_size,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"beads_zig workspace\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Directory:     {s}\\n\", .{beads_dir});\n        try ctx.output.print(\"JSONL:         {s} ({s})\\n\", .{ ctx.issues_path, formatBytes(jsonl_size) });\n        try ctx.output.print(\"WAL:           {s} ({s})\\n\", .{ wal_path, formatBytes(wal_size) });\n        try ctx.output.print(\"Total issues:  {d}\\n\", .{issue_count});\n    }\n}\n\nfn getFileSize(path: []const u8) u64 {\n    const file = std.fs.cwd().openFile(path, .{}) catch return 0;\n    defer file.close();\n    const stat = file.stat() catch return 0;\n    return stat.size;\n}\n\nfn formatBytes(bytes: u64) []const u8 {\n    if (bytes == 0) return \"0 B\";\n    if (bytes < 1024) return \"<1 KB\";\n    if (bytes < 1024 * 1024) return \"<1 MB\";\n    return \">1 MB\";\n}\n\n// --- Tests ---\n\ntest \"InfoError enum exists\" {\n    const err: InfoError = InfoError.WorkspaceNotInitialized;\n    try std.testing.expect(err == InfoError.WorkspaceNotInitialized);\n}\n\ntest \"InfoResult struct works\" {\n    const result = InfoResult{\n        .success = true,\n        .beads_dir = \".beads\",\n        .issue_count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\".beads\", result.beads_dir.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issue_count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(global, allocator);\n    try std.testing.expectError(InfoError.WorkspaceNotInitialized, result);\n}\n\ntest \"formatBytes handles zero\" {\n    try std.testing.expectEqualStrings(\"0 B\", formatBytes(0));\n}\n\ntest \"formatBytes handles small values\" {\n    try std.testing.expectEqualStrings(\"<1 KB\", formatBytes(500));\n}\n\ntest \"getFileSize returns 0 for missing file\" {\n    const size = getFileSize(\"/nonexistent/file.txt\");\n    try std.testing.expectEqual(@as(u64, 0), size);\n}\n","numLines":117,"startLine":1,"totalLines":117}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KDEe2FzgQvK8y1MfL8XtsV","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create the backup.zig file."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1771,"cache_read_input_tokens":118606,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1771},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3c2f1335-e5a0-4318-8d60-2fe805847b93"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KDEe2FzgQvK8y1MfL8XtsV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AqhQnD8fwXKGt8BsnJr1yc","name":"Write","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/backup.zig","content":"//! Backup command for beads_zig.\n//!\n//! `bz backup` - Manage JSONL backup files\n//! `bz backup list` - List available backups\n//! `bz backup diff <file>` - Show diff between backup and current\n//! `bz backup restore <file>` - Restore from backup\n//! `bz backup prune` - Remove old backups keeping N most recent\n//! `bz backup create` - Create a new backup\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const BackupError = error{\n    WorkspaceNotInitialized,\n    BackupNotFound,\n    RestoreFailed,\n    CreateFailed,\n    OutOfMemory,\n};\n\npub const BackupInfo = struct {\n    filename: []const u8,\n    size: u64,\n    modified: i64,\n};\n\npub const BackupResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    backups: ?[]const BackupInfo = null,\n    backup_count: ?usize = null,\n    diff_added: ?usize = null,\n    diff_removed: ?usize = null,\n    diff_modified: ?usize = null,\n    restored_count: ?usize = null,\n    pruned_count: ?usize = null,\n    created_path: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    backup_args: args.BackupArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return BackupError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    switch (backup_args.subcommand) {\n        .list => try runList(&ctx, structured_output, global.quiet, allocator),\n        .diff => |d| try runDiff(&ctx, d.file, structured_output, global.quiet, allocator),\n        .restore => |r| try runRestore(&ctx, r.file, r.dry_run, structured_output, global.quiet, allocator),\n        .prune => |p| try runPrune(&ctx, p.keep, p.dry_run, structured_output, global.quiet, allocator),\n        .create => try runCreate(&ctx, structured_output, global.quiet, allocator),\n    }\n}\n\nfn runList(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n\n    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n    defer {\n        for (backups.items) |b| allocator.free(b.filename);\n        backups.deinit(allocator);\n    }\n\n    // Open the .beads directory and look for backup files\n    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n        if (err == error.FileNotFound) {\n            if (structured_output) {\n                try ctx.output.printJson(BackupResult{\n                    .success = true,\n                    .action = \"list\",\n                    .backup_count = 0,\n                    .message = \"no backups found\",\n                });\n            } else if (!quiet) {\n                try ctx.output.info(\"No backups found\", .{});\n            }\n            return;\n        }\n        return err;\n    };\n    defer dir.close();\n\n    var iter = dir.iterate();\n    while (try iter.next()) |entry| {\n        // Look for backup files matching pattern: issues.jsonl.bak.* or issues.*.jsonl\n        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n        {\n            const stat = dir.statFile(entry.name) catch continue;\n            try backups.append(allocator, .{\n                .filename = try allocator.dupe(u8, entry.name),\n                .size = stat.size,\n                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n            });\n        }\n    }\n\n    // Sort by modified time (newest first)\n    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n            return a.modified > b.modified;\n        }\n    }.lessThan);\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"list\",\n            .backup_count = backups.items.len,\n            .backups = backups.items,\n        });\n    } else if (!quiet) {\n        if (backups.items.len == 0) {\n            try ctx.output.info(\"No backups found\", .{});\n        } else {\n            try ctx.output.println(\"Available backups:\", .{});\n            for (backups.items) |b| {\n                try ctx.output.print(\"  {s} ({d} bytes)\\n\", .{ b.filename, b.size });\n            }\n        }\n    }\n}\n\nfn runDiff(ctx: *CommandContext, file: []const u8, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const backup_path = try std.fs.path.join(allocator, &.{ beads_dir, file });\n    defer allocator.free(backup_path);\n\n    // Check if backup file exists\n    std.fs.cwd().access(backup_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"diff\",\n                .message = \"backup file not found\",\n            });\n        } else {\n            try ctx.output.err(\"Backup file not found: {s}\", .{file});\n        }\n        return BackupError.BackupNotFound;\n    };\n\n    // Load backup issues\n    const storage = @import(\"../storage/mod.zig\");\n    var backup_store = storage.IssueStore.init(allocator, backup_path);\n    defer backup_store.deinit();\n    backup_store.loadFromFile() catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"diff\",\n                .message = \"failed to load backup file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to load backup file\", .{});\n        }\n        return BackupError.BackupNotFound;\n    };\n\n    // Compare: count added, removed, modified\n    var added: usize = 0;\n    var removed: usize = 0;\n    var modified: usize = 0;\n\n    // Check current issues against backup\n    for (ctx.store.issues.items) |current| {\n        if (backup_store.getRef(current.id)) |backup| {\n            // Issue exists in both - check if modified\n            if (current.updated_at.value != backup.updated_at.value) {\n                modified += 1;\n            }\n        } else {\n            // Issue only in current\n            added += 1;\n        }\n    }\n\n    // Check backup issues not in current\n    for (backup_store.issues.items) |backup| {\n        if (ctx.store.getRef(backup.id) == null) {\n            removed += 1;\n        }\n    }\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"diff\",\n            .diff_added = added,\n            .diff_removed = removed,\n            .diff_modified = modified,\n        });\n    } else if (!quiet) {\n        try ctx.output.println(\"Diff: current vs {s}\", .{file});\n        try ctx.output.print(\"  Added:    {d}\\n\", .{added});\n        try ctx.output.print(\"  Removed:  {d}\\n\", .{removed});\n        try ctx.output.print(\"  Modified: {d}\\n\", .{modified});\n        if (added == 0 and removed == 0 and modified == 0) {\n            try ctx.output.info(\"No differences found\", .{});\n        }\n    }\n}\n\nfn runRestore(ctx: *CommandContext, file: []const u8, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const backup_path = try std.fs.path.join(allocator, &.{ beads_dir, file });\n    defer allocator.free(backup_path);\n\n    // Check if backup file exists\n    std.fs.cwd().access(backup_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"backup file not found\",\n            });\n        } else {\n            try ctx.output.err(\"Backup file not found: {s}\", .{file});\n        }\n        return BackupError.BackupNotFound;\n    };\n\n    // Load backup to count issues\n    const storage = @import(\"../storage/mod.zig\");\n    var backup_store = storage.IssueStore.init(allocator, backup_path);\n    defer backup_store.deinit();\n    backup_store.loadFromFile() catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to load backup file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to load backup file\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n\n    const issue_count = backup_store.issues.items.len;\n\n    if (dry_run) {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = true,\n                .action = \"restore\",\n                .restored_count = issue_count,\n                .message = \"dry run - no changes made\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"Would restore {d} issue(s) from {s}\", .{ issue_count, file });\n        }\n        return;\n    }\n\n    // Perform the restore by copying backup over current\n    const backup_content = std.fs.cwd().readFileAlloc(allocator, backup_path, 1024 * 1024 * 100) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to read backup file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to read backup file\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n    defer allocator.free(backup_content);\n\n    // Create backup of current before restoring\n    const timestamp = std.time.timestamp();\n    const pre_restore_backup = try std.fmt.allocPrint(allocator, \"{s}.pre-restore.{d}\", .{ ctx.store.jsonl_path, timestamp });\n    defer allocator.free(pre_restore_backup);\n\n    std.fs.cwd().copyFile(ctx.store.jsonl_path, std.fs.cwd(), pre_restore_backup, .{}) catch {};\n\n    // Write backup content to current file\n    const current_file = std.fs.cwd().createFile(ctx.store.jsonl_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to write to current file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to write to current file\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n    defer current_file.close();\n    current_file.writeAll(backup_content) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to write backup content\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to write backup content\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"restore\",\n            .restored_count = issue_count,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Restored {d} issue(s) from {s}\", .{ issue_count, file });\n    }\n}\n\nfn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n\n    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n    defer {\n        for (backups.items) |b| allocator.free(b.filename);\n        backups.deinit(allocator);\n    }\n\n    // Collect backup files\n    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n        if (err == error.FileNotFound) {\n            if (structured_output) {\n                try ctx.output.printJson(BackupResult{\n                    .success = true,\n                    .action = \"prune\",\n                    .pruned_count = 0,\n                    .message = \"no backups to prune\",\n                });\n            } else if (!quiet) {\n                try ctx.output.info(\"No backups to prune\", .{});\n            }\n            return;\n        }\n        return err;\n    };\n    defer dir.close();\n\n    var iter = dir.iterate();\n    while (try iter.next()) |entry| {\n        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n        {\n            const stat = dir.statFile(entry.name) catch continue;\n            try backups.append(allocator, .{\n                .filename = try allocator.dupe(u8, entry.name),\n                .size = stat.size,\n                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n            });\n        }\n    }\n\n    if (backups.items.len <= keep) {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = true,\n                .action = \"prune\",\n                .pruned_count = 0,\n                .message = \"nothing to prune\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"Only {d} backup(s) found, keeping all (threshold: {d})\", .{ backups.items.len, keep });\n        }\n        return;\n    }\n\n    // Sort by modified time (newest first)\n    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n            return a.modified > b.modified;\n        }\n    }.lessThan);\n\n    const to_prune = backups.items.len - keep;\n\n    if (dry_run) {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = true,\n                .action = \"prune\",\n                .pruned_count = to_prune,\n                .message = \"dry run - no changes made\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"Would prune {d} backup(s), keeping {d} most recent\", .{ to_prune, keep });\n            for (backups.items[keep..]) |b| {\n                try ctx.output.print(\"  Would delete: {s}\\n\", .{b.filename});\n            }\n        }\n        return;\n    }\n\n    // Delete oldest backups\n    var pruned: usize = 0;\n    for (backups.items[keep..]) |b| {\n        const full_path = try std.fs.path.join(allocator, &.{ beads_dir, b.filename });\n        defer allocator.free(full_path);\n        std.fs.cwd().deleteFile(full_path) catch continue;\n        pruned += 1;\n    }\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"prune\",\n            .pruned_count = pruned,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Pruned {d} backup(s), kept {d} most recent\", .{ pruned, keep });\n    }\n}\n\nfn runCreate(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const timestamp = std.time.timestamp();\n    const backup_path = try std.fmt.allocPrint(allocator, \"{s}.bak.{d}\", .{ ctx.store.jsonl_path, timestamp });\n    defer allocator.free(backup_path);\n\n    // Copy current file to backup\n    std.fs.cwd().copyFile(ctx.store.jsonl_path, std.fs.cwd(), backup_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"create\",\n                .message = \"failed to create backup\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to create backup\", .{});\n        }\n        return BackupError.CreateFailed;\n    };\n\n    const basename = std.fs.path.basename(backup_path);\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"create\",\n            .created_path = backup_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Created backup: {s}\", .{basename});\n    }\n}\n\n// --- Tests ---\n\ntest \"BackupError enum exists\" {\n    const err: BackupError = BackupError.BackupNotFound;\n    try std.testing.expect(err == BackupError.BackupNotFound);\n}\n\ntest \"BackupResult struct works\" {\n    const result = BackupResult{\n        .success = true,\n        .action = \"list\",\n        .backup_count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"list\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 3), result.backup_count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const backup_args = args.BackupArgs{ .subcommand = .{ .list = {} } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(backup_args, global, allocator);\n    try std.testing.expectError(BackupError.WorkspaceNotInitialized, result);\n}\n\ntest \"BackupInfo struct works\" {\n    const info = BackupInfo{\n        .filename = \"issues.jsonl.bak.123\",\n        .size = 1024,\n        .modified = 1706540000,\n    };\n    try std.testing.expectEqualStrings(\"issues.jsonl.bak.123\", info.filename);\n    try std.testing.expectEqual(@as(u64, 1024), info.size);\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1771,"cache_read_input_tokens":118606,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1771},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7b1d24b1-c7c0-40a9-965a-a21b580b479b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AqhQnD8fwXKGt8BsnJr1yc","type":"tool_result","content":"File created successfully at: /home/hotschmoe/beads_zig/src/cli/backup.zig"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"144b13f2-6fc3-4d2e-82b7-64ae0c47a4d3","tool_use_result":{"type":"create","filePath":"/home/hotschmoe/beads_zig/src/cli/backup.zig","content":"//! Backup command for beads_zig.\n//!\n//! `bz backup` - Manage JSONL backup files\n//! `bz backup list` - List available backups\n//! `bz backup diff <file>` - Show diff between backup and current\n//! `bz backup restore <file>` - Restore from backup\n//! `bz backup prune` - Remove old backups keeping N most recent\n//! `bz backup create` - Create a new backup\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const BackupError = error{\n    WorkspaceNotInitialized,\n    BackupNotFound,\n    RestoreFailed,\n    CreateFailed,\n    OutOfMemory,\n};\n\npub const BackupInfo = struct {\n    filename: []const u8,\n    size: u64,\n    modified: i64,\n};\n\npub const BackupResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    backups: ?[]const BackupInfo = null,\n    backup_count: ?usize = null,\n    diff_added: ?usize = null,\n    diff_removed: ?usize = null,\n    diff_modified: ?usize = null,\n    restored_count: ?usize = null,\n    pruned_count: ?usize = null,\n    created_path: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    backup_args: args.BackupArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return BackupError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    switch (backup_args.subcommand) {\n        .list => try runList(&ctx, structured_output, global.quiet, allocator),\n        .diff => |d| try runDiff(&ctx, d.file, structured_output, global.quiet, allocator),\n        .restore => |r| try runRestore(&ctx, r.file, r.dry_run, structured_output, global.quiet, allocator),\n        .prune => |p| try runPrune(&ctx, p.keep, p.dry_run, structured_output, global.quiet, allocator),\n        .create => try runCreate(&ctx, structured_output, global.quiet, allocator),\n    }\n}\n\nfn runList(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n\n    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n    defer {\n        for (backups.items) |b| allocator.free(b.filename);\n        backups.deinit(allocator);\n    }\n\n    // Open the .beads directory and look for backup files\n    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n        if (err == error.FileNotFound) {\n            if (structured_output) {\n                try ctx.output.printJson(BackupResult{\n                    .success = true,\n                    .action = \"list\",\n                    .backup_count = 0,\n                    .message = \"no backups found\",\n                });\n            } else if (!quiet) {\n                try ctx.output.info(\"No backups found\", .{});\n            }\n            return;\n        }\n        return err;\n    };\n    defer dir.close();\n\n    var iter = dir.iterate();\n    while (try iter.next()) |entry| {\n        // Look for backup files matching pattern: issues.jsonl.bak.* or issues.*.jsonl\n        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n        {\n            const stat = dir.statFile(entry.name) catch continue;\n            try backups.append(allocator, .{\n                .filename = try allocator.dupe(u8, entry.name),\n                .size = stat.size,\n                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n            });\n        }\n    }\n\n    // Sort by modified time (newest first)\n    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n            return a.modified > b.modified;\n        }\n    }.lessThan);\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"list\",\n            .backup_count = backups.items.len,\n            .backups = backups.items,\n        });\n    } else if (!quiet) {\n        if (backups.items.len == 0) {\n            try ctx.output.info(\"No backups found\", .{});\n        } else {\n            try ctx.output.println(\"Available backups:\", .{});\n            for (backups.items) |b| {\n                try ctx.output.print(\"  {s} ({d} bytes)\\n\", .{ b.filename, b.size });\n            }\n        }\n    }\n}\n\nfn runDiff(ctx: *CommandContext, file: []const u8, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const backup_path = try std.fs.path.join(allocator, &.{ beads_dir, file });\n    defer allocator.free(backup_path);\n\n    // Check if backup file exists\n    std.fs.cwd().access(backup_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"diff\",\n                .message = \"backup file not found\",\n            });\n        } else {\n            try ctx.output.err(\"Backup file not found: {s}\", .{file});\n        }\n        return BackupError.BackupNotFound;\n    };\n\n    // Load backup issues\n    const storage = @import(\"../storage/mod.zig\");\n    var backup_store = storage.IssueStore.init(allocator, backup_path);\n    defer backup_store.deinit();\n    backup_store.loadFromFile() catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"diff\",\n                .message = \"failed to load backup file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to load backup file\", .{});\n        }\n        return BackupError.BackupNotFound;\n    };\n\n    // Compare: count added, removed, modified\n    var added: usize = 0;\n    var removed: usize = 0;\n    var modified: usize = 0;\n\n    // Check current issues against backup\n    for (ctx.store.issues.items) |current| {\n        if (backup_store.getRef(current.id)) |backup| {\n            // Issue exists in both - check if modified\n            if (current.updated_at.value != backup.updated_at.value) {\n                modified += 1;\n            }\n        } else {\n            // Issue only in current\n            added += 1;\n        }\n    }\n\n    // Check backup issues not in current\n    for (backup_store.issues.items) |backup| {\n        if (ctx.store.getRef(backup.id) == null) {\n            removed += 1;\n        }\n    }\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"diff\",\n            .diff_added = added,\n            .diff_removed = removed,\n            .diff_modified = modified,\n        });\n    } else if (!quiet) {\n        try ctx.output.println(\"Diff: current vs {s}\", .{file});\n        try ctx.output.print(\"  Added:    {d}\\n\", .{added});\n        try ctx.output.print(\"  Removed:  {d}\\n\", .{removed});\n        try ctx.output.print(\"  Modified: {d}\\n\", .{modified});\n        if (added == 0 and removed == 0 and modified == 0) {\n            try ctx.output.info(\"No differences found\", .{});\n        }\n    }\n}\n\nfn runRestore(ctx: *CommandContext, file: []const u8, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n    const backup_path = try std.fs.path.join(allocator, &.{ beads_dir, file });\n    defer allocator.free(backup_path);\n\n    // Check if backup file exists\n    std.fs.cwd().access(backup_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"backup file not found\",\n            });\n        } else {\n            try ctx.output.err(\"Backup file not found: {s}\", .{file});\n        }\n        return BackupError.BackupNotFound;\n    };\n\n    // Load backup to count issues\n    const storage = @import(\"../storage/mod.zig\");\n    var backup_store = storage.IssueStore.init(allocator, backup_path);\n    defer backup_store.deinit();\n    backup_store.loadFromFile() catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to load backup file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to load backup file\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n\n    const issue_count = backup_store.issues.items.len;\n\n    if (dry_run) {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = true,\n                .action = \"restore\",\n                .restored_count = issue_count,\n                .message = \"dry run - no changes made\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"Would restore {d} issue(s) from {s}\", .{ issue_count, file });\n        }\n        return;\n    }\n\n    // Perform the restore by copying backup over current\n    const backup_content = std.fs.cwd().readFileAlloc(allocator, backup_path, 1024 * 1024 * 100) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to read backup file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to read backup file\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n    defer allocator.free(backup_content);\n\n    // Create backup of current before restoring\n    const timestamp = std.time.timestamp();\n    const pre_restore_backup = try std.fmt.allocPrint(allocator, \"{s}.pre-restore.{d}\", .{ ctx.store.jsonl_path, timestamp });\n    defer allocator.free(pre_restore_backup);\n\n    std.fs.cwd().copyFile(ctx.store.jsonl_path, std.fs.cwd(), pre_restore_backup, .{}) catch {};\n\n    // Write backup content to current file\n    const current_file = std.fs.cwd().createFile(ctx.store.jsonl_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to write to current file\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to write to current file\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n    defer current_file.close();\n    current_file.writeAll(backup_content) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"restore\",\n                .message = \"failed to write backup content\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to write backup content\", .{});\n        }\n        return BackupError.RestoreFailed;\n    };\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"restore\",\n            .restored_count = issue_count,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Restored {d} issue(s) from {s}\", .{ issue_count, file });\n    }\n}\n\nfn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n\n    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n    defer {\n        for (backups.items) |b| allocator.free(b.filename);\n        backups.deinit(allocator);\n    }\n\n    // Collect backup files\n    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n        if (err == error.FileNotFound) {\n            if (structured_output) {\n                try ctx.output.printJson(BackupResult{\n                    .success = true,\n                    .action = \"prune\",\n                    .pruned_count = 0,\n                    .message = \"no backups to prune\",\n                });\n            } else if (!quiet) {\n                try ctx.output.info(\"No backups to prune\", .{});\n            }\n            return;\n        }\n        return err;\n    };\n    defer dir.close();\n\n    var iter = dir.iterate();\n    while (try iter.next()) |entry| {\n        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n        {\n            const stat = dir.statFile(entry.name) catch continue;\n            try backups.append(allocator, .{\n                .filename = try allocator.dupe(u8, entry.name),\n                .size = stat.size,\n                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n            });\n        }\n    }\n\n    if (backups.items.len <= keep) {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = true,\n                .action = \"prune\",\n                .pruned_count = 0,\n                .message = \"nothing to prune\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"Only {d} backup(s) found, keeping all (threshold: {d})\", .{ backups.items.len, keep });\n        }\n        return;\n    }\n\n    // Sort by modified time (newest first)\n    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n            return a.modified > b.modified;\n        }\n    }.lessThan);\n\n    const to_prune = backups.items.len - keep;\n\n    if (dry_run) {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = true,\n                .action = \"prune\",\n                .pruned_count = to_prune,\n                .message = \"dry run - no changes made\",\n            });\n        } else if (!quiet) {\n            try ctx.output.info(\"Would prune {d} backup(s), keeping {d} most recent\", .{ to_prune, keep });\n            for (backups.items[keep..]) |b| {\n                try ctx.output.print(\"  Would delete: {s}\\n\", .{b.filename});\n            }\n        }\n        return;\n    }\n\n    // Delete oldest backups\n    var pruned: usize = 0;\n    for (backups.items[keep..]) |b| {\n        const full_path = try std.fs.path.join(allocator, &.{ beads_dir, b.filename });\n        defer allocator.free(full_path);\n        std.fs.cwd().deleteFile(full_path) catch continue;\n        pruned += 1;\n    }\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"prune\",\n            .pruned_count = pruned,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Pruned {d} backup(s), kept {d} most recent\", .{ pruned, keep });\n    }\n}\n\nfn runCreate(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n    const timestamp = std.time.timestamp();\n    const backup_path = try std.fmt.allocPrint(allocator, \"{s}.bak.{d}\", .{ ctx.store.jsonl_path, timestamp });\n    defer allocator.free(backup_path);\n\n    // Copy current file to backup\n    std.fs.cwd().copyFile(ctx.store.jsonl_path, std.fs.cwd(), backup_path, .{}) catch {\n        if (structured_output) {\n            try ctx.output.printJson(BackupResult{\n                .success = false,\n                .action = \"create\",\n                .message = \"failed to create backup\",\n            });\n        } else {\n            try ctx.output.err(\"Failed to create backup\", .{});\n        }\n        return BackupError.CreateFailed;\n    };\n\n    const basename = std.fs.path.basename(backup_path);\n\n    if (structured_output) {\n        try ctx.output.printJson(BackupResult{\n            .success = true,\n            .action = \"create\",\n            .created_path = backup_path,\n        });\n    } else if (!quiet) {\n        try ctx.output.success(\"Created backup: {s}\", .{basename});\n    }\n}\n\n// --- Tests ---\n\ntest \"BackupError enum exists\" {\n    const err: BackupError = BackupError.BackupNotFound;\n    try std.testing.expect(err == BackupError.BackupNotFound);\n}\n\ntest \"BackupResult struct works\" {\n    const result = BackupResult{\n        .success = true,\n        .action = \"list\",\n        .backup_count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"list\", result.action.?);\n    try std.testing.expectEqual(@as(usize, 3), result.backup_count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const backup_args = args.BackupArgs{ .subcommand = .{ .list = {} } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(backup_args, global, allocator);\n    try std.testing.expectError(BackupError.WorkspaceNotInitialized, result);\n}\n\ntest \"BackupInfo struct works\" {\n    const info = BackupInfo{\n        .filename = \"issues.jsonl.bak.123\",\n        .size = 1024,\n        .modified = 1706540000,\n    };\n    try std.testing.expectEqualStrings(\"issues.jsonl.bak.123\", info.filename);\n    try std.testing.expectEqual(@as(u64, 1024), info.size);\n}\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01F9bwxbhevx9cLi1HRhKHSu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0191QtkFiB54QJFeMvbxKybs","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"completed","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"in_progress","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":5484,"cache_read_input_tokens":120377,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5484},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2d847c52-0a2e-41d5-9352-0886bde7b031"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0191QtkFiB54QJFeMvbxKybs","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d59b68cb-6fe4-4d3a-b95e-d55cc9e19c57","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"in_progress","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"pending","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"completed","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"in_progress","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FrkB3gPxq1Xv1JovJmsNBR","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the backup command to help.zig."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":125861,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"02dff94d-2754-4aa3-bcad-c83f4c28fb6c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FrkB3gPxq1Xv1JovJmsNBR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016nw11oUoUC7Xthf7WGFPMw","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig","offset":630,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":125861,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5cf2b250-7a84-4a2c-92a2-93d2cf22ab81"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016nw11oUoUC7Xthf7WGFPMw","type":"tool_result","content":"   630→        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n   631→        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n   632→            \"by date range and grouped by type.\",\n   633→        .flags = &[_]FlagHelp{\n   634→            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n   635→            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n   636→            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n   637→            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n   638→        },\n   639→        .examples = &[_]ExampleHelp{\n   640→            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n   641→            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n   642→            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n   643→        },\n   644→        .see_also = &[_][]const u8{\"audit\"},\n   645→    },\n   646→\n   647→    // System commands\n   648→    .{\n   649→        .name = \"version\",\n   650→        .summary = \"Show version\",\n   651→        .usage = \"bz version\",\n   652→        .description = \"Displays the beads_zig version and build information.\",\n   653→        .examples = &[_]ExampleHelp{\n   654→            .{ .command = \"bz version\", .description = \"Show version\" },\n   655→            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n   656→        },\n   657→    },\n   658→    .{\n   659→        .name = \"schema\",\n   660→        .summary = \"Show data schema\",\n   661→        .usage = \"bz schema\",\n   662→        .description = \"Displays the JSONL data schema for issues and related types.\",\n   663→        .examples = &[_]ExampleHelp{\n   664→            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n   665→        },\n   666→    },\n   667→    .{\n   668→        .name = \"completions\",\n   669→        .aliases = &[_][]const u8{\"completion\"},\n   670→        .summary = \"Generate shell completions\",\n   671→        .usage = \"bz completions <shell>\",\n   672→        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n   673→        .arguments = &[_]ArgHelp{\n   674→            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n   675→        },\n   676→        .examples = &[_]ExampleHelp{\n   677→            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n   678→            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n   679→            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"d998e493-3e75-4e1b-9f44-8d4360a6b687","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/help.zig","content":"        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n            \"by date range and grouped by type.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n        },\n        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // System commands\n    .{\n        .name = \"version\",\n        .summary = \"Show version\",\n        .usage = \"bz version\",\n        .description = \"Displays the beads_zig version and build information.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz version\", .description = \"Show version\" },\n            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n        },\n    },\n    .{\n        .name = \"schema\",\n        .summary = \"Show data schema\",\n        .usage = \"bz schema\",\n        .description = \"Displays the JSONL data schema for issues and related types.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n        },\n    },\n    .{\n        .name = \"completions\",\n        .aliases = &[_][]const u8{\"completion\"},\n        .summary = \"Generate shell completions\",\n        .usage = \"bz completions <shell>\",\n        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },","numLines":50,"startLine":630,"totalLines":994}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GqNTYZkGvTJ8zAj8uLSM1z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L2r85EWCq28ayvJxqWuzgx","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig","old_string":"        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // System commands","new_string":"        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // Backup commands\n    .{\n        .name = \"backup\",\n        .aliases = &[_][]const u8{\"backups\"},\n        .summary = \"Manage JSONL backup files\",\n        .usage = \"bz backup <subcommand> [args]\",\n        .description = \"Manage JSONL backup files. Create backups before major operations, \" ++\n            \"compare backups with current state, restore from backups, and prune old backups.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"list, diff, restore, prune, or create\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-k\", .long = \"--keep\", .arg = \"N\", .description = \"Keep N most recent backups (prune, default: 10)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be done without making changes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz backup list\", .description = \"List available backups\" },\n            .{ .command = \"bz backup create\", .description = \"Create a new backup\" },\n            .{ .command = \"bz backup diff issues.jsonl.bak.123\", .description = \"Compare backup with current\" },\n            .{ .command = \"bz backup restore issues.jsonl.bak.123\", .description = \"Restore from backup\" },\n            .{ .command = \"bz backup restore issues.jsonl.bak.123 --dry-run\", .description = \"Preview restore\" },\n            .{ .command = \"bz backup prune --keep 5\", .description = \"Keep only 5 most recent backups\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"import\" },\n    },\n\n    // System commands"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1152,"cache_read_input_tokens":126189,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1152},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"9834a783-f6fe-4bd2-b177-4f782d16bf4f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L2r85EWCq28ayvJxqWuzgx","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/help.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6cf1d7bb-55bf-441f-9411-90073a0ad779","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/help.zig","oldString":"        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // System commands","newString":"        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // Backup commands\n    .{\n        .name = \"backup\",\n        .aliases = &[_][]const u8{\"backups\"},\n        .summary = \"Manage JSONL backup files\",\n        .usage = \"bz backup <subcommand> [args]\",\n        .description = \"Manage JSONL backup files. Create backups before major operations, \" ++\n            \"compare backups with current state, restore from backups, and prune old backups.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"list, diff, restore, prune, or create\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-k\", .long = \"--keep\", .arg = \"N\", .description = \"Keep N most recent backups (prune, default: 10)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be done without making changes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz backup list\", .description = \"List available backups\" },\n            .{ .command = \"bz backup create\", .description = \"Create a new backup\" },\n            .{ .command = \"bz backup diff issues.jsonl.bak.123\", .description = \"Compare backup with current\" },\n            .{ .command = \"bz backup restore issues.jsonl.bak.123\", .description = \"Restore from backup\" },\n            .{ .command = \"bz backup restore issues.jsonl.bak.123 --dry-run\", .description = \"Preview restore\" },\n            .{ .command = \"bz backup prune --keep 5\", .description = \"Keep only 5 most recent backups\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"import\" },\n    },\n\n    // System commands","originalFile":"//! Help command for beads_zig.\n//!\n//! Provides detailed per-command help with usage examples and flag references.\n\nconst std = @import(\"std\");\n\npub const HelpError = error{\n    WriteError,\n    OutOfMemory,\n};\n\npub const HelpResult = struct {\n    success: bool,\n    topic: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Command metadata for generating help text.\nconst CommandHelp = struct {\n    name: []const u8,\n    aliases: []const []const u8 = &[_][]const u8{},\n    summary: []const u8,\n    usage: []const u8,\n    description: []const u8 = \"\",\n    arguments: []const ArgHelp = &[_]ArgHelp{},\n    flags: []const FlagHelp = &[_]FlagHelp{},\n    examples: []const ExampleHelp = &[_]ExampleHelp{},\n    see_also: []const []const u8 = &[_][]const u8{},\n};\n\nconst ArgHelp = struct {\n    name: []const u8,\n    description: []const u8,\n    required: bool = true,\n};\n\nconst FlagHelp = struct {\n    short: ?[]const u8,\n    long: []const u8,\n    arg: ?[]const u8 = null,\n    description: []const u8,\n};\n\nconst ExampleHelp = struct {\n    command: []const u8,\n    description: []const u8,\n};\n\n/// All command help definitions.\nconst commands = [_]CommandHelp{\n    // Workspace commands\n    .{\n        .name = \"init\",\n        .summary = \"Initialize a .beads/ workspace\",\n        .usage = \"bz init [--prefix PREFIX]\",\n        .description = \"Creates the .beads/ directory structure for issue tracking. \" ++\n            \"This command must be run before using any other beads commands.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--prefix\", .arg = \"PREFIX\", .description = \"Issue ID prefix (default: bd)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz init\", .description = \"Initialize with default prefix 'bd'\" },\n            .{ .command = \"bz init --prefix proj\", .description = \"Use 'proj' as ID prefix (e.g., proj-abc123)\" },\n        },\n    },\n    .{\n        .name = \"info\",\n        .summary = \"Show workspace information\",\n        .usage = \"bz info\",\n        .description = \"Displays current workspace configuration, file locations, and basic status.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz info\", .description = \"Show workspace details\" },\n            .{ .command = \"bz info --json\", .description = \"Output as JSON for scripting\" },\n        },\n    },\n    .{\n        .name = \"stats\",\n        .summary = \"Show project statistics\",\n        .usage = \"bz stats\",\n        .description = \"Shows aggregate statistics about issues: counts by status, priority, type, etc.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stats\", .description = \"Show issue statistics\" },\n            .{ .command = \"bz stats --json\", .description = \"Output as JSON for dashboards\" },\n        },\n    },\n    .{\n        .name = \"doctor\",\n        .summary = \"Run diagnostic checks\",\n        .usage = \"bz doctor\",\n        .description = \"Checks workspace integrity: validates JSONL format, detects orphaned references, \" ++\n            \"and reports any data consistency issues.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz doctor\", .description = \"Run all diagnostic checks\" },\n        },\n    },\n    .{\n        .name = \"config\",\n        .summary = \"Manage configuration\",\n        .usage = \"bz config [get|set|list] [KEY] [VALUE]\",\n        .description = \"View or modify project configuration settings.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\n            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz config\", .description = \"List all configuration\" },\n            .{ .command = \"bz config list\", .description = \"Same as above\" },\n            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n        },\n    },\n    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n            .{ .short = null, .long = \"--error-policy\", .arg = \"POLICY\", .description = \"Export error handling: strict (default), best-effort, partial\" },\n            .{ .short = null, .long = \"--orphans\", .arg = \"POLICY\", .description = \"Import orphan handling: strict (default), resurrect, skip\" },\n            .{ .short = null, .long = \"--rename-prefix\", .description = \"Fix issues with wrong prefix during import\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n            .{ .command = \"bz sync --flush-only --error-policy best-effort\", .description = \"Export, continuing on errors\" },\n            .{ .command = \"bz sync --import-only --orphans resurrect\", .description = \"Import, creating placeholders for orphans\" },\n            .{ .command = \"bz sync --import-only --rename-prefix\", .description = \"Import and fix wrong ID prefixes\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\", \"backup\" },\n    },\n    .{\n        .name = \"orphans\",\n        .summary = \"Find issues with missing parent references\",\n        .usage = \"bz orphans [--limit N] [--hierarchy-only] [--deps-only]\",\n        .description = \"Identifies issues that reference non-existent parent issues or dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results to show\" },\n            .{ .short = null, .long = \"--hierarchy-only\", .description = \"Only check hierarchical parent refs\" },\n            .{ .short = null, .long = \"--deps-only\", .description = \"Only check dependency refs\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz orphans\", .description = \"Find all orphaned references\" },\n            .{ .command = \"bz orphans --limit 10\", .description = \"Show at most 10 orphans\" },\n        },\n    },\n    .{\n        .name = \"lint\",\n        .summary = \"Validate database consistency\",\n        .usage = \"bz lint [--limit N]\",\n        .description = \"Checks for data quality issues: empty titles, invalid priorities, \" ++\n            \"malformed IDs, and other consistency problems.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum issues to report\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz lint\", .description = \"Run all lint checks\" },\n        },\n    },\n\n    // Issue CRUD commands\n    .{\n        .name = \"create\",\n        .aliases = &[_][]const u8{ \"add\", \"new\" },\n        .summary = \"Create a new issue\",\n        .usage = \"bz create <title> [options]\",\n        .description = \"Creates a new issue with the given title. The issue is assigned a \" ++\n            \"unique ID and added to the database. Use flags to set optional fields.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title (1-500 characters)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"Detailed description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Issue type (task, bug, feature, epic, chore, docs, question)\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority (critical, high, medium, low, backlog, or 0-4)\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Assignee name or email\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Add label (can be repeated)\" },\n            .{ .short = null, .long = \"--depends-on\", .arg = \"ID\", .description = \"Add dependency (can be repeated)\" },\n            .{ .short = null, .long = \"--due\", .arg = \"DATE\", .description = \"Due date (YYYY-MM-DD)\" },\n            .{ .short = \"-e\", .long = \"--estimate\", .arg = \"MINS\", .description = \"Estimate in minutes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz create \\\"Fix login bug\\\"\", .description = \"Create a simple issue\" },\n            .{ .command = \"bz create \\\"Add OAuth\\\" -t feature -p high\", .description = \"Create a high-priority feature\" },\n            .{ .command = \"bz create \\\"Bug fix\\\" -l urgent -l backend\", .description = \"Create with multiple labels\" },\n            .{ .command = \"bz create \\\"Task\\\" --depends-on bd-abc123\", .description = \"Create with dependency\" },\n        },\n        .see_also = &[_][]const u8{ \"q\", \"show\", \"update\" },\n    },\n    .{\n        .name = \"q\",\n        .aliases = &[_][]const u8{\"quick\"},\n        .summary = \"Quick capture (create + print ID only)\",\n        .usage = \"bz q <title> [-p PRIORITY]\",\n        .description = \"Creates a new issue and prints only the ID. Optimized for scripting \" ++\n            \"and quick capture workflows.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority level\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz q \\\"Quick thought\\\"\", .description = \"Capture idea, get ID back\" },\n            .{ .command = \"ID=$(bz q \\\"Task\\\"); echo $ID\", .description = \"Capture ID in shell variable\" },\n            .{ .command = \"bz q \\\"Urgent fix\\\" -p critical\", .description = \"Quick capture with priority\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"add-batch\" },\n    },\n    .{\n        .name = \"show\",\n        .aliases = &[_][]const u8{ \"get\", \"view\" },\n        .summary = \"Show issue details\",\n        .usage = \"bz show <id> [--no-comments] [--with-history]\",\n        .description = \"Displays full details of an issue including description, status, \" ++\n            \"dependencies, labels, and comments.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (e.g., bd-abc123)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--no-comments\", .description = \"Hide comments\" },\n            .{ .short = null, .long = \"--with-history\", .description = \"Include change history\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz show bd-abc123\", .description = \"Show issue details\" },\n            .{ .command = \"bz show bd-abc --json\", .description = \"Get issue as JSON\" },\n            .{ .command = \"bz show bd-abc --with-history\", .description = \"Include change history\" },\n        },\n        .see_also = &[_][]const u8{ \"update\", \"history\" },\n    },\n    .{\n        .name = \"update\",\n        .aliases = &[_][]const u8{\"edit\"},\n        .summary = \"Update issue fields\",\n        .usage = \"bz update <id> [options]\",\n        .description = \"Modifies one or more fields of an existing issue. Only specified \" ++\n            \"fields are changed; others remain unchanged.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to update\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--title\", .arg = \"TEXT\", .description = \"New title\" },\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"New description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"New issue type\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"New priority\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"New assignee\" },\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"New status (open, in_progress, blocked, deferred, closed)\" },\n            .{ .short = \"-v\", .long = \"--version\", .arg = \"NUM\", .description = \"Expected version for optimistic locking (fails if issue was modified)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz update bd-abc --title \\\"New title\\\"\", .description = \"Update title\" },\n            .{ .command = \"bz update bd-abc -p critical -a alice\", .description = \"Update priority and assignee\" },\n            .{ .command = \"bz update bd-abc -s in_progress\", .description = \"Change status to in_progress\" },\n            .{ .command = \"bz update bd-abc -v 3 --title \\\"Safe update\\\"\", .description = \"Update only if version is 3 (optimistic lock)\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"close\" },\n    },\n    .{\n        .name = \"close\",\n        .aliases = &[_][]const u8{ \"done\", \"finish\" },\n        .summary = \"Close an issue\",\n        .usage = \"bz close <id> [-r REASON]\",\n        .description = \"Marks an issue as closed. Optionally provide a close reason.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to close\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Close reason (e.g., \\\"Fixed in PR #42\\\")\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz close bd-abc123\", .description = \"Close an issue\" },\n            .{ .command = \"bz close bd-abc -r \\\"Duplicate of bd-xyz\\\"\", .description = \"Close with reason\" },\n            .{ .command = \"bz done bd-abc\", .description = \"Close using alias\" },\n        },\n        .see_also = &[_][]const u8{ \"reopen\", \"delete\" },\n    },\n    .{\n        .name = \"reopen\",\n        .summary = \"Reopen a closed issue\",\n        .usage = \"bz reopen <id>\",\n        .description = \"Changes a closed issue's status back to open.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to reopen\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz reopen bd-abc123\", .description = \"Reopen a closed issue\" },\n        },\n        .see_also = &[_][]const u8{ \"close\", \"update\" },\n    },\n    .{\n        .name = \"delete\",\n        .aliases = &[_][]const u8{ \"rm\", \"remove\" },\n        .summary = \"Soft delete an issue (tombstone)\",\n        .usage = \"bz delete <id>\",\n        .description = \"Marks an issue as deleted (tombstone status). The issue remains in \" ++\n            \"the database but is hidden from normal queries. Can be restored via update.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to delete\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz delete bd-abc123\", .description = \"Soft delete an issue\" },\n            .{ .command = \"bz rm bd-abc\", .description = \"Delete using alias\" },\n        },\n        .see_also = &[_][]const u8{\"close\"},\n    },\n    .{\n        .name = \"defer\",\n        .summary = \"Defer an issue\",\n        .usage = \"bz defer <id> [--until DATE] [-r REASON]\",\n        .description = \"Marks an issue as deferred, optionally until a specific date.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to defer\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-u\", .long = \"--until\", .arg = \"DATE\", .description = \"Date to resurface (YYYY-MM-DD or +7d)\" },\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Reason for deferral\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz defer bd-abc\", .description = \"Defer indefinitely\" },\n            .{ .command = \"bz defer bd-abc --until 2024-03-01\", .description = \"Defer until specific date\" },\n            .{ .command = \"bz defer bd-abc --until +7d\", .description = \"Defer for 7 days\" },\n        },\n        .see_also = &[_][]const u8{\"undefer\"},\n    },\n    .{\n        .name = \"undefer\",\n        .summary = \"Remove deferral from an issue\",\n        .usage = \"bz undefer <id>\",\n        .description = \"Clears the deferred status and defer_until date from an issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to undefer\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz undefer bd-abc123\", .description = \"Remove deferral\" },\n        },\n        .see_also = &[_][]const u8{\"defer\"},\n    },\n\n    // Batch operations\n    .{\n        .name = \"add-batch\",\n        .aliases = &[_][]const u8{ \"batch-add\", \"batch\" },\n        .summary = \"Create issues from stdin/file (single lock)\",\n        .usage = \"bz add-batch [-f FILE] [--format FORMAT]\",\n        .description = \"Creates multiple issues efficiently with a single lock acquisition. \" ++\n            \"Reads from stdin or a file. Supports plain titles (one per line) or JSONL format.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--file\", .arg = \"FILE\", .description = \"Read from file instead of stdin\" },\n            .{ .short = null, .long = \"--format\", .arg = \"FMT\", .description = \"Input format: titles (default) or jsonl\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"echo -e \\\"Task 1\\\\nTask 2\\\" | bz add-batch\", .description = \"Create from stdin\" },\n            .{ .command = \"bz add-batch -f tasks.txt\", .description = \"Create from file (one title per line)\" },\n            .{ .command = \"bz add-batch -f issues.jsonl --format jsonl\", .description = \"Create from JSONL file\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"import\" },\n    },\n    .{\n        .name = \"import\",\n        .summary = \"Import issues from JSONL file\",\n        .usage = \"bz import <file> [-m] [-n]\",\n        .description = \"Imports issues from a JSONL file. Handles deduplication via content hash \" ++\n            \"and external_ref matching.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"file\", .description = \"Path to JSONL file\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"Merge with existing issues (update if exists)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be imported without importing\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz import backup.jsonl\", .description = \"Import from backup\" },\n            .{ .command = \"bz import external.jsonl --merge\", .description = \"Merge external issues\" },\n            .{ .command = \"bz import data.jsonl --dry-run\", .description = \"Preview import\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"add-batch\" },\n    },\n\n    // Query commands\n    .{\n        .name = \"list\",\n        .aliases = &[_][]const u8{\"ls\"},\n        .summary = \"List issues with filters\",\n        .usage = \"bz list [options]\",\n        .description = \"Lists issues matching optional filters. By default shows only open issues. \" ++\n            \"Use --all to include closed/deleted issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"Filter by status\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Filter by priority\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Filter by issue type\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Filter by assignee\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Filter by label\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n            .{ .short = \"-A\", .long = \"--all\", .description = \"Include all statuses (not just open)\" },\n            .{ .short = null, .long = \"--sort\", .arg = \"FIELD\", .description = \"Sort by: created, updated, or priority\" },\n            .{ .short = null, .long = \"--asc\", .description = \"Sort ascending\" },\n            .{ .short = null, .long = \"--desc\", .description = \"Sort descending (default)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz list\", .description = \"List open issues\" },\n            .{ .command = \"bz list --all\", .description = \"List all issues\" },\n            .{ .command = \"bz list -p high -t bug\", .description = \"High priority bugs\" },\n            .{ .command = \"bz list --sort priority --asc\", .description = \"Sort by priority ascending\" },\n            .{ .command = \"bz list -l backend -n 5\", .description = \"Top 5 issues with 'backend' label\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"blocked\", \"search\" },\n    },\n    .{\n        .name = \"ready\",\n        .summary = \"Show actionable issues (unblocked)\",\n        .usage = \"bz ready [--limit N]\",\n        .description = \"Lists open issues that have no unresolved blocking dependencies. \" ++\n            \"These are issues ready to be worked on.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz ready\", .description = \"Show all ready issues\" },\n            .{ .command = \"bz ready -n 5\", .description = \"Show top 5 ready issues\" },\n            .{ .command = \"bz ready --json\", .description = \"Get ready work as JSON (for agents)\" },\n        },\n        .see_also = &[_][]const u8{ \"blocked\", \"list\" },\n    },\n    .{\n        .name = \"blocked\",\n        .summary = \"Show blocked issues\",\n        .usage = \"bz blocked [--limit N]\",\n        .description = \"Lists open issues that have unresolved blocking dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz blocked\", .description = \"Show all blocked issues\" },\n            .{ .command = \"bz blocked --json\", .description = \"Get blocked issues as JSON\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"dep\" },\n    },\n    .{\n        .name = \"search\",\n        .aliases = &[_][]const u8{\"find\"},\n        .summary = \"Full-text search\",\n        .usage = \"bz search <query> [--limit N]\",\n        .description = \"Searches issue titles and descriptions for the given query string.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"query\", .description = \"Search string\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz search login\", .description = \"Find issues mentioning 'login'\" },\n            .{ .command = \"bz search \\\"OAuth flow\\\" -n 10\", .description = \"Search with limit\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"stale\",\n        .summary = \"Find issues not updated recently\",\n        .usage = \"bz stale [--days N] [--limit N]\",\n        .description = \"Lists open issues that haven't been updated within the specified \" ++\n            \"number of days (default: 30).\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--days\", .arg = \"N\", .description = \"Days threshold (default: 30)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stale\", .description = \"Issues untouched for 30+ days\" },\n            .{ .command = \"bz stale --days 7\", .description = \"Issues untouched for 7+ days\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"count\",\n        .summary = \"Count issues by group\",\n        .usage = \"bz count [--group-by FIELD]\",\n        .description = \"Counts issues, optionally grouped by a field.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by: status, priority, type, assignee\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz count\", .description = \"Total issue count\" },\n            .{ .command = \"bz count --group-by status\", .description = \"Count by status\" },\n            .{ .command = \"bz count -g priority\", .description = \"Count by priority\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"stats\" },\n    },\n\n    // Dependency commands\n    .{\n        .name = \"dep\",\n        .aliases = &[_][]const u8{ \"deps\", \"dependency\" },\n        .summary = \"Manage issue dependencies\",\n        .usage = \"bz dep <subcommand> [args]\",\n        .description = \"Add, remove, or query dependencies between issues. \" ++\n            \"Dependencies are directional: A depends-on B means A is blocked by B.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, tree, or cycles\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz dep add bd-child bd-parent\", .description = \"child depends on parent\" },\n            .{ .command = \"bz dep add bd-a bd-b --type relates_to\", .description = \"Add non-blocking relation\" },\n            .{ .command = \"bz dep remove bd-child bd-parent\", .description = \"Remove dependency\" },\n            .{ .command = \"bz dep list bd-abc\", .description = \"List dependencies of an issue\" },\n            .{ .command = \"bz dep tree bd-abc\", .description = \"Show dependency tree\" },\n            .{ .command = \"bz dep cycles\", .description = \"Detect circular dependencies\" },\n        },\n        .see_also = &[_][]const u8{ \"graph\", \"ready\", \"blocked\" },\n    },\n    .{\n        .name = \"graph\",\n        .summary = \"Show dependency graph\",\n        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n        .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n            \"With an ID, shows that issue's dependency subgraph.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n            .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n            .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n            .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n        },\n        .see_also = &[_][]const u8{\"dep\"},\n    },\n\n    // Epic commands\n    .{\n        .name = \"epic\",\n        .aliases = &[_][]const u8{\"epics\"},\n        .summary = \"Manage epics\",\n        .usage = \"bz epic <subcommand> [args]\",\n        .description = \"Epics are special issues that group related work. Use epic commands \" ++\n            \"to create epics and manage their child issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"create, add, remove, or list\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz epic create \\\"Q1 Goals\\\"\", .description = \"Create a new epic\" },\n            .{ .command = \"bz epic create \\\"Auth Overhaul\\\" -p high\", .description = \"Create with priority\" },\n            .{ .command = \"bz epic add bd-epic bd-task\", .description = \"Add issue to epic\" },\n            .{ .command = \"bz epic remove bd-epic bd-task\", .description = \"Remove issue from epic\" },\n            .{ .command = \"bz epic list bd-epic\", .description = \"List issues in epic\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"dep\" },\n    },\n\n    // Label commands\n    .{\n        .name = \"label\",\n        .aliases = &[_][]const u8{ \"labels\", \"tag\" },\n        .summary = \"Manage issue labels\",\n        .usage = \"bz label <subcommand> [args]\",\n        .description = \"Add, remove, or list labels on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, or list-all\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz label add bd-abc urgent backend\", .description = \"Add multiple labels\" },\n            .{ .command = \"bz label remove bd-abc old-label\", .description = \"Remove a label\" },\n            .{ .command = \"bz label list bd-abc\", .description = \"List labels on issue\" },\n            .{ .command = \"bz label list-all\", .description = \"List all labels in project\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"create\" },\n    },\n\n    // Comment commands\n    .{\n        .name = \"comments\",\n        .aliases = &[_][]const u8{ \"comment\", \"note\" },\n        .summary = \"Manage issue comments\",\n        .usage = \"bz comments <subcommand> <id> [text]\",\n        .description = \"Add or list comments on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add or list\" },\n            .{ .name = \"id\", .description = \"Issue ID\" },\n            .{ .name = \"text\", .description = \"Comment text (for add)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz comments add bd-abc \\\"Working on this\\\"\", .description = \"Add a comment\" },\n            .{ .command = \"bz comments list bd-abc\", .description = \"List comments\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"history\" },\n    },\n\n    // Audit commands\n    .{\n        .name = \"history\",\n        .aliases = &[_][]const u8{\"log\"},\n        .summary = \"Show issue history\",\n        .usage = \"bz history <id>\",\n        .description = \"Displays the change history for a specific issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz history bd-abc123\", .description = \"Show change history\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"audit\" },\n    },\n    .{\n        .name = \"audit\",\n        .summary = \"Project-wide audit log\",\n        .usage = \"bz audit [--limit N]\",\n        .description = \"Shows recent events across all issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum events\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz audit\", .description = \"Show recent events\" },\n            .{ .command = \"bz audit --limit 100\", .description = \"Show last 100 events\" },\n        },\n        .see_also = &[_][]const u8{ \"history\", \"changelog\" },\n    },\n    .{\n        .name = \"changelog\",\n        .summary = \"Generate changelog from closed issues\",\n        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n            \"by date range and grouped by type.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n        },\n        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // System commands\n    .{\n        .name = \"version\",\n        .summary = \"Show version\",\n        .usage = \"bz version\",\n        .description = \"Displays the beads_zig version and build information.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz version\", .description = \"Show version\" },\n            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n        },\n    },\n    .{\n        .name = \"schema\",\n        .summary = \"Show data schema\",\n        .usage = \"bz schema\",\n        .description = \"Displays the JSONL data schema for issues and related types.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n        },\n    },\n    .{\n        .name = \"completions\",\n        .aliases = &[_][]const u8{\"completion\"},\n        .summary = \"Generate shell completions\",\n        .usage = \"bz completions <shell>\",\n        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },\n        },\n    },\n    .{\n        .name = \"help\",\n        .summary = \"Show help\",\n        .usage = \"bz help [command]\",\n        .description = \"Shows general help or detailed help for a specific command.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"command\", .description = \"Command to get help for\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz help\", .description = \"Show general help\" },\n            .{ .command = \"bz help create\", .description = \"Show help for create command\" },\n            .{ .command = \"bz --help\", .description = \"Same as bz help\" },\n        },\n    },\n};\n\n/// Find help for a specific command (including aliases).\nfn findCommand(name: []const u8) ?*const CommandHelp {\n    for (&commands) |*cmd| {\n        if (std.mem.eql(u8, cmd.name, name)) {\n            return cmd;\n        }\n        for (cmd.aliases) |alias| {\n            if (std.mem.eql(u8, alias, name)) {\n                return cmd;\n            }\n        }\n    }\n    return null;\n}\n\n/// Run the help command.\npub fn run(topic: ?[]const u8, allocator: std.mem.Allocator) !void {\n    const stdout = std.fs.File.stdout();\n    if (topic) |t| {\n        try showCommandHelp(t, stdout, allocator);\n    } else {\n        try showGeneralHelp(stdout);\n    }\n}\n\nfn showGeneralHelp(file: std.fs.File) !void {\n    try file.writeAll(\n        \\\\bz - beads_zig issue tracker\n        \\\\\n        \\\\USAGE:\n        \\\\  bz <command> [options]\n        \\\\\n        \\\\COMMANDS:\n        \\\\  Workspace:\n        \\\\    init              Initialize .beads/ workspace\n        \\\\    info              Show workspace information\n        \\\\    stats             Show project statistics\n        \\\\    doctor            Run diagnostic checks\n        \\\\    config            Manage configuration\n        \\\\    sync              Sync with JSONL file\n        \\\\    orphans           Find issues with missing parent refs\n        \\\\    lint              Validate database consistency\n        \\\\\n        \\\\  Issue Management:\n        \\\\    create <title>    Create new issue\n        \\\\    q <title>         Quick capture (create + print ID only)\n        \\\\    show <id>         Show issue details\n        \\\\    update <id>       Update issue fields\n        \\\\    close <id>        Close an issue\n        \\\\    reopen <id>       Reopen a closed issue\n        \\\\    delete <id>       Soft delete (tombstone)\n        \\\\    defer <id>        Defer an issue\n        \\\\    undefer <id>      Remove deferral from an issue\n        \\\\\n        \\\\  Batch Operations:\n        \\\\    add-batch         Create issues from stdin/file (single lock)\n        \\\\    import <file>     Import issues from JSONL file\n        \\\\\n        \\\\  Queries:\n        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n        \\\\    ready             Show actionable issues (unblocked)\n        \\\\    blocked           Show blocked issues\n        \\\\    search <query>    Full-text search\n        \\\\    stale [--days N]  Find issues not updated recently\n        \\\\    count [--group-by] Count issues by group\n        \\\\\n        \\\\  Dependencies:\n        \\\\    dep add <a> <b>   Make issue A depend on B\n        \\\\    dep remove <a> <b> Remove dependency\n        \\\\    dep list <id>     List dependencies\n        \\\\    dep tree <id>     Show dependency tree (ASCII)\n        \\\\    dep cycles        Detect dependency cycles\n        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n        \\\\\n        \\\\  Epics:\n        \\\\    epic create <title>       Create a new epic\n        \\\\    epic add <epic> <issue>   Add issue to epic\n        \\\\    epic remove <epic> <issue> Remove issue from epic\n        \\\\    epic list <epic>          List issues in epic\n        \\\\\n        \\\\  Labels:\n        \\\\    label add <id> <labels...>    Add labels to an issue\n        \\\\    label remove <id> <labels...> Remove labels from an issue\n        \\\\    label list <id>               List labels on an issue\n        \\\\    label list-all                List all labels in project\n        \\\\\n        \\\\  Comments:\n        \\\\    comments add <id> <text>  Add comment to an issue\n        \\\\    comments list <id>        List comments on an issue\n        \\\\\n        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:\n        \\\\    help              Show this help\n        \\\\    version           Show version\n        \\\\    schema            Show data schema\n        \\\\    completions <shell>  Generate shell completions\n        \\\\\n        \\\\GLOBAL OPTIONS:\n        \\\\  --json            Output in JSON format\n        \\\\  --toon            Output in TOON format (LLM-optimized)\n        \\\\  -q, --quiet       Suppress non-essential output\n        \\\\  -v, --verbose     Increase verbosity\n        \\\\  --no-color        Disable colors\n        \\\\  --data <path>     Override .beads/ directory\n        \\\\  --actor <name>    Override actor name for audit\n        \\\\  --no-auto-flush   Skip automatic JSONL export\n        \\\\  --no-auto-import  Skip JSONL freshness check\n        \\\\\n        \\\\Run 'bz help <command>' for command-specific help.\n        \\\\\n    );\n}\n\nfn showCommandHelp(name: []const u8, file: std.fs.File, allocator: std.mem.Allocator) !void {\n    const cmd = findCommand(name) orelse {\n        const msg = try std.fmt.allocPrint(allocator, \"Unknown command: {s}\\n\\n\", .{name});\n        defer allocator.free(msg);\n        try file.writeAll(msg);\n        try file.writeAll(\"Run 'bz help' for a list of available commands.\\n\");\n        return;\n    };\n\n    // Command name and aliases\n    try file.writeAll(cmd.name);\n    if (cmd.aliases.len > 0) {\n        try file.writeAll(\" (\");\n        for (cmd.aliases, 0..) |alias, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(alias);\n        }\n        try file.writeAll(\")\");\n    }\n    try file.writeAll(\"\\n\");\n\n    // Summary\n    try file.writeAll(\"\\n\");\n    try file.writeAll(cmd.summary);\n    try file.writeAll(\"\\n\");\n\n    // Usage\n    try file.writeAll(\"\\nUSAGE:\\n  \");\n    try file.writeAll(cmd.usage);\n    try file.writeAll(\"\\n\");\n\n    // Description\n    if (cmd.description.len > 0) {\n        try file.writeAll(\"\\nDESCRIPTION:\\n\");\n        try writeWrapped(file, cmd.description, 2, 78, allocator);\n    }\n\n    // Arguments\n    if (cmd.arguments.len > 0) {\n        try file.writeAll(\"\\nARGUMENTS:\\n\");\n        for (cmd.arguments) |arg| {\n            const req = if (arg.required) \" (required)\" else \" (optional)\";\n            const line = try std.fmt.allocPrint(allocator, \"  {s}{s}\\n\", .{ arg.name, req });\n            defer allocator.free(line);\n            try file.writeAll(line);\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{arg.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Flags\n    if (cmd.flags.len > 0) {\n        try file.writeAll(\"\\nFLAGS:\\n\");\n        for (cmd.flags) |flag| {\n            if (flag.short) |short| {\n                const line = try std.fmt.allocPrint(allocator, \"  {s}, {s}\", .{ short, flag.long });\n                defer allocator.free(line);\n                try file.writeAll(line);\n            } else {\n                const line = try std.fmt.allocPrint(allocator, \"      {s}\", .{flag.long});\n                defer allocator.free(line);\n                try file.writeAll(line);\n            }\n            if (flag.arg) |arg| {\n                const argline = try std.fmt.allocPrint(allocator, \" <{s}>\", .{arg});\n                defer allocator.free(argline);\n                try file.writeAll(argline);\n            }\n            try file.writeAll(\"\\n\");\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{flag.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Examples\n    if (cmd.examples.len > 0) {\n        try file.writeAll(\"\\nEXAMPLES:\\n\");\n        for (cmd.examples) |ex| {\n            const cmd_line = try std.fmt.allocPrint(allocator, \"  $ {s}\\n\", .{ex.command});\n            defer allocator.free(cmd_line);\n            try file.writeAll(cmd_line);\n            const desc_line = try std.fmt.allocPrint(allocator, \"    {s}\\n\\n\", .{ex.description});\n            defer allocator.free(desc_line);\n            try file.writeAll(desc_line);\n        }\n    }\n\n    // See also\n    if (cmd.see_also.len > 0) {\n        try file.writeAll(\"SEE ALSO:\\n  \");\n        for (cmd.see_also, 0..) |ref, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(ref);\n        }\n        try file.writeAll(\"\\n\");\n    }\n}\n\n/// Write text with word wrapping.\nfn writeWrapped(file: std.fs.File, text: []const u8, indent: usize, max_width: usize, allocator: std.mem.Allocator) !void {\n    const effective_width = max_width - indent;\n\n    // Pre-allocate indent string\n    const indent_str = try allocator.alloc(u8, indent);\n    defer allocator.free(indent_str);\n    @memset(indent_str, ' ');\n\n    var line_start: usize = 0;\n    var last_space: ?usize = null;\n    var col: usize = 0;\n\n    for (text, 0..) |c, i| {\n        if (c == ' ') {\n            last_space = i;\n        }\n        col += 1;\n\n        if (col >= effective_width) {\n            const break_at = last_space orelse i;\n            try file.writeAll(indent_str);\n            try file.writeAll(text[line_start..break_at]);\n            try file.writeAll(\"\\n\");\n\n            line_start = break_at + 1;\n            col = i - break_at;\n            last_space = null;\n        }\n    }\n\n    if (line_start < text.len) {\n        try file.writeAll(indent_str);\n        try file.writeAll(text[line_start..]);\n        try file.writeAll(\"\\n\");\n    }\n}\n\n// Tests\n\ntest \"findCommand finds by name\" {\n    const cmd = findCommand(\"create\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand finds by alias\" {\n    const cmd = findCommand(\"add\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand returns null for unknown\" {\n    const cmd = findCommand(\"nonexistent\");\n    try std.testing.expect(cmd == null);\n}\n\ntest \"findCommand finds all main commands\" {\n    // Verify a sampling of commands can be found\n    try std.testing.expect(findCommand(\"init\") != null);\n    try std.testing.expect(findCommand(\"list\") != null);\n    try std.testing.expect(findCommand(\"show\") != null);\n    try std.testing.expect(findCommand(\"update\") != null);\n    try std.testing.expect(findCommand(\"close\") != null);\n    try std.testing.expect(findCommand(\"dep\") != null);\n    try std.testing.expect(findCommand(\"help\") != null);\n}\n\ntest \"findCommand finds aliases\" {\n    // Test common aliases\n    try std.testing.expect(findCommand(\"ls\") != null);\n    try std.testing.expectEqualStrings(\"list\", findCommand(\"ls\").?.name);\n\n    try std.testing.expect(findCommand(\"rm\") != null);\n    try std.testing.expectEqualStrings(\"delete\", findCommand(\"rm\").?.name);\n\n    try std.testing.expect(findCommand(\"done\") != null);\n    try std.testing.expectEqualStrings(\"close\", findCommand(\"done\").?.name);\n}\n","structuredPatch":[{"oldStart":644,"oldLines":6,"newStart":644,"newLines":32,"lines":["         .see_also = &[_][]const u8{\"audit\"},","     },"," ","+    // Backup commands","+    .{","+        .name = \"backup\",","+        .aliases = &[_][]const u8{\"backups\"},","+        .summary = \"Manage JSONL backup files\",","+        .usage = \"bz backup <subcommand> [args]\",","+        .description = \"Manage JSONL backup files. Create backups before major operations, \" ++","+            \"compare backups with current state, restore from backups, and prune old backups.\",","+        .arguments = &[_]ArgHelp{","+            .{ .name = \"subcommand\", .description = \"list, diff, restore, prune, or create\" },","+        },","+        .flags = &[_]FlagHelp{","+            .{ .short = \"-k\", .long = \"--keep\", .arg = \"N\", .description = \"Keep N most recent backups (prune, default: 10)\" },","+            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be done without making changes\" },","+        },","+        .examples = &[_]ExampleHelp{","+            .{ .command = \"bz backup list\", .description = \"List available backups\" },","+            .{ .command = \"bz backup create\", .description = \"Create a new backup\" },","+            .{ .command = \"bz backup diff issues.jsonl.bak.123\", .description = \"Compare backup with current\" },","+            .{ .command = \"bz backup restore issues.jsonl.bak.123\", .description = \"Restore from backup\" },","+            .{ .command = \"bz backup restore issues.jsonl.bak.123 --dry-run\", .description = \"Preview restore\" },","+            .{ .command = \"bz backup prune --keep 5\", .description = \"Keep only 5 most recent backups\" },","+        },","+        .see_also = &[_][]const u8{ \"sync\", \"import\" },","+    },","+","     // System commands","     .{","         .name = \"version\","]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015y2rtaF1d4dBb9K3VGt8BV","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the general help output to include the backup command."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":688,"cache_read_input_tokens":127341,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":688},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6b695b64-a0fd-483e-b0a9-032edf60e94f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015y2rtaF1d4dBb9K3VGt8BV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013zxvYFCmq5oVPfDP7ZHhsr","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig","offset":750,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":688,"cache_read_input_tokens":127341,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":688},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ed8d6f8d-1aa1-40fd-9d0b-5250f9e694cd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013zxvYFCmq5oVPfDP7ZHhsr","type":"tool_result","content":"   750→    try file.writeAll(\n   751→        \\\\bz - beads_zig issue tracker\n   752→        \\\\\n   753→        \\\\USAGE:\n   754→        \\\\  bz <command> [options]\n   755→        \\\\\n   756→        \\\\COMMANDS:\n   757→        \\\\  Workspace:\n   758→        \\\\    init              Initialize .beads/ workspace\n   759→        \\\\    info              Show workspace information\n   760→        \\\\    stats             Show project statistics\n   761→        \\\\    doctor            Run diagnostic checks\n   762→        \\\\    config            Manage configuration\n   763→        \\\\    sync              Sync with JSONL file\n   764→        \\\\    orphans           Find issues with missing parent refs\n   765→        \\\\    lint              Validate database consistency\n   766→        \\\\\n   767→        \\\\  Issue Management:\n   768→        \\\\    create <title>    Create new issue\n   769→        \\\\    q <title>         Quick capture (create + print ID only)\n   770→        \\\\    show <id>         Show issue details\n   771→        \\\\    update <id>       Update issue fields\n   772→        \\\\    close <id>        Close an issue\n   773→        \\\\    reopen <id>       Reopen a closed issue\n   774→        \\\\    delete <id>       Soft delete (tombstone)\n   775→        \\\\    defer <id>        Defer an issue\n   776→        \\\\    undefer <id>      Remove deferral from an issue\n   777→        \\\\\n   778→        \\\\  Batch Operations:\n   779→        \\\\    add-batch         Create issues from stdin/file (single lock)\n   780→        \\\\    import <file>     Import issues from JSONL file\n   781→        \\\\\n   782→        \\\\  Queries:\n   783→        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n   784→        \\\\    ready             Show actionable issues (unblocked)\n   785→        \\\\    blocked           Show blocked issues\n   786→        \\\\    search <query>    Full-text search\n   787→        \\\\    stale [--days N]  Find issues not updated recently\n   788→        \\\\    count [--group-by] Count issues by group\n   789→        \\\\\n   790→        \\\\  Dependencies:\n   791→        \\\\    dep add <a> <b>   Make issue A depend on B\n   792→        \\\\    dep remove <a> <b> Remove dependency\n   793→        \\\\    dep list <id>     List dependencies\n   794→        \\\\    dep tree <id>     Show dependency tree (ASCII)\n   795→        \\\\    dep cycles        Detect dependency cycles\n   796→        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n   797→        \\\\\n   798→        \\\\  Epics:\n   799→        \\\\    epic create <title>       Create a new epic\n   800→        \\\\    epic add <epic> <issue>   Add issue to epic\n   801→        \\\\    epic remove <epic> <issue> Remove issue from epic\n   802→        \\\\    epic list <epic>          List issues in epic\n   803→        \\\\\n   804→        \\\\  Labels:\n   805→        \\\\    label add <id> <labels...>    Add labels to an issue\n   806→        \\\\    label remove <id> <labels...> Remove labels from an issue\n   807→        \\\\    label list <id>               List labels on an issue\n   808→        \\\\    label list-all                List all labels in project\n   809→        \\\\\n   810→        \\\\  Comments:\n   811→        \\\\    comments add <id> <text>  Add comment to an issue\n   812→        \\\\    comments list <id>        List comments on an issue\n   813→        \\\\\n   814→        \\\\  Audit:\n   815→        \\\\    history <id>      Show issue history\n   816→        \\\\    audit             Project-wide audit log\n   817→        \\\\    changelog         Generate changelog from closed issues\n   818→        \\\\\n   819→        \\\\  System:\n   820→        \\\\    help              Show this help\n   821→        \\\\    version           Show version\n   822→        \\\\    schema            Show data schema\n   823→        \\\\    completions <shell>  Generate shell completions\n   824→        \\\\\n   825→        \\\\GLOBAL OPTIONS:\n   826→        \\\\  --json            Output in JSON format\n   827→        \\\\  --toon            Output in TOON format (LLM-optimized)\n   828→        \\\\  -q, --quiet       Suppress non-essential output\n   829→        \\\\  -v, --verbose     Increase verbosity\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"015016a0-3e22-4807-9904-546a3f4d1f76","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/help.zig","content":"    try file.writeAll(\n        \\\\bz - beads_zig issue tracker\n        \\\\\n        \\\\USAGE:\n        \\\\  bz <command> [options]\n        \\\\\n        \\\\COMMANDS:\n        \\\\  Workspace:\n        \\\\    init              Initialize .beads/ workspace\n        \\\\    info              Show workspace information\n        \\\\    stats             Show project statistics\n        \\\\    doctor            Run diagnostic checks\n        \\\\    config            Manage configuration\n        \\\\    sync              Sync with JSONL file\n        \\\\    orphans           Find issues with missing parent refs\n        \\\\    lint              Validate database consistency\n        \\\\\n        \\\\  Issue Management:\n        \\\\    create <title>    Create new issue\n        \\\\    q <title>         Quick capture (create + print ID only)\n        \\\\    show <id>         Show issue details\n        \\\\    update <id>       Update issue fields\n        \\\\    close <id>        Close an issue\n        \\\\    reopen <id>       Reopen a closed issue\n        \\\\    delete <id>       Soft delete (tombstone)\n        \\\\    defer <id>        Defer an issue\n        \\\\    undefer <id>      Remove deferral from an issue\n        \\\\\n        \\\\  Batch Operations:\n        \\\\    add-batch         Create issues from stdin/file (single lock)\n        \\\\    import <file>     Import issues from JSONL file\n        \\\\\n        \\\\  Queries:\n        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n        \\\\    ready             Show actionable issues (unblocked)\n        \\\\    blocked           Show blocked issues\n        \\\\    search <query>    Full-text search\n        \\\\    stale [--days N]  Find issues not updated recently\n        \\\\    count [--group-by] Count issues by group\n        \\\\\n        \\\\  Dependencies:\n        \\\\    dep add <a> <b>   Make issue A depend on B\n        \\\\    dep remove <a> <b> Remove dependency\n        \\\\    dep list <id>     List dependencies\n        \\\\    dep tree <id>     Show dependency tree (ASCII)\n        \\\\    dep cycles        Detect dependency cycles\n        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n        \\\\\n        \\\\  Epics:\n        \\\\    epic create <title>       Create a new epic\n        \\\\    epic add <epic> <issue>   Add issue to epic\n        \\\\    epic remove <epic> <issue> Remove issue from epic\n        \\\\    epic list <epic>          List issues in epic\n        \\\\\n        \\\\  Labels:\n        \\\\    label add <id> <labels...>    Add labels to an issue\n        \\\\    label remove <id> <labels...> Remove labels from an issue\n        \\\\    label list <id>               List labels on an issue\n        \\\\    label list-all                List all labels in project\n        \\\\\n        \\\\  Comments:\n        \\\\    comments add <id> <text>  Add comment to an issue\n        \\\\    comments list <id>        List comments on an issue\n        \\\\\n        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:\n        \\\\    help              Show this help\n        \\\\    version           Show version\n        \\\\    schema            Show data schema\n        \\\\    completions <shell>  Generate shell completions\n        \\\\\n        \\\\GLOBAL OPTIONS:\n        \\\\  --json            Output in JSON format\n        \\\\  --toon            Output in TOON format (LLM-optimized)\n        \\\\  -q, --quiet       Suppress non-essential output\n        \\\\  -v, --verbose     Increase verbosity","numLines":80,"startLine":750,"totalLines":1020}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VdLGmsdnZZztg96fvn89zx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Rknrkmid8NZaMzvt6gcKnW","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/help.zig","old_string":"        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:","new_string":"        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  Backup:\n        \\\\    backup list       List available backups\n        \\\\    backup create     Create a new backup\n        \\\\    backup diff <f>   Compare backup with current\n        \\\\    backup restore <f> Restore from backup\n        \\\\    backup prune      Remove old backups\n        \\\\\n        \\\\  System:"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1417,"cache_read_input_tokens":128029,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1417},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8d5719ea-77bf-426a-aad0-caab2b884f0c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Rknrkmid8NZaMzvt6gcKnW","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/help.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3d5a4a5d-44f8-44cc-ab4e-da69fdd8c3e7","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/help.zig","oldString":"        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:","newString":"        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  Backup:\n        \\\\    backup list       List available backups\n        \\\\    backup create     Create a new backup\n        \\\\    backup diff <f>   Compare backup with current\n        \\\\    backup restore <f> Restore from backup\n        \\\\    backup prune      Remove old backups\n        \\\\\n        \\\\  System:","originalFile":"//! Help command for beads_zig.\n//!\n//! Provides detailed per-command help with usage examples and flag references.\n\nconst std = @import(\"std\");\n\npub const HelpError = error{\n    WriteError,\n    OutOfMemory,\n};\n\npub const HelpResult = struct {\n    success: bool,\n    topic: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Command metadata for generating help text.\nconst CommandHelp = struct {\n    name: []const u8,\n    aliases: []const []const u8 = &[_][]const u8{},\n    summary: []const u8,\n    usage: []const u8,\n    description: []const u8 = \"\",\n    arguments: []const ArgHelp = &[_]ArgHelp{},\n    flags: []const FlagHelp = &[_]FlagHelp{},\n    examples: []const ExampleHelp = &[_]ExampleHelp{},\n    see_also: []const []const u8 = &[_][]const u8{},\n};\n\nconst ArgHelp = struct {\n    name: []const u8,\n    description: []const u8,\n    required: bool = true,\n};\n\nconst FlagHelp = struct {\n    short: ?[]const u8,\n    long: []const u8,\n    arg: ?[]const u8 = null,\n    description: []const u8,\n};\n\nconst ExampleHelp = struct {\n    command: []const u8,\n    description: []const u8,\n};\n\n/// All command help definitions.\nconst commands = [_]CommandHelp{\n    // Workspace commands\n    .{\n        .name = \"init\",\n        .summary = \"Initialize a .beads/ workspace\",\n        .usage = \"bz init [--prefix PREFIX]\",\n        .description = \"Creates the .beads/ directory structure for issue tracking. \" ++\n            \"This command must be run before using any other beads commands.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--prefix\", .arg = \"PREFIX\", .description = \"Issue ID prefix (default: bd)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz init\", .description = \"Initialize with default prefix 'bd'\" },\n            .{ .command = \"bz init --prefix proj\", .description = \"Use 'proj' as ID prefix (e.g., proj-abc123)\" },\n        },\n    },\n    .{\n        .name = \"info\",\n        .summary = \"Show workspace information\",\n        .usage = \"bz info\",\n        .description = \"Displays current workspace configuration, file locations, and basic status.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz info\", .description = \"Show workspace details\" },\n            .{ .command = \"bz info --json\", .description = \"Output as JSON for scripting\" },\n        },\n    },\n    .{\n        .name = \"stats\",\n        .summary = \"Show project statistics\",\n        .usage = \"bz stats\",\n        .description = \"Shows aggregate statistics about issues: counts by status, priority, type, etc.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stats\", .description = \"Show issue statistics\" },\n            .{ .command = \"bz stats --json\", .description = \"Output as JSON for dashboards\" },\n        },\n    },\n    .{\n        .name = \"doctor\",\n        .summary = \"Run diagnostic checks\",\n        .usage = \"bz doctor\",\n        .description = \"Checks workspace integrity: validates JSONL format, detects orphaned references, \" ++\n            \"and reports any data consistency issues.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz doctor\", .description = \"Run all diagnostic checks\" },\n        },\n    },\n    .{\n        .name = \"config\",\n        .summary = \"Manage configuration\",\n        .usage = \"bz config [get|set|list] [KEY] [VALUE]\",\n        .description = \"View or modify project configuration settings.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"get, set, or list (default: list)\", .required = false },\n            .{ .name = \"key\", .description = \"Configuration key (e.g., id.prefix)\", .required = false },\n            .{ .name = \"value\", .description = \"New value (for set)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz config\", .description = \"List all configuration\" },\n            .{ .command = \"bz config list\", .description = \"Same as above\" },\n            .{ .command = \"bz config get id.prefix\", .description = \"Get the ID prefix setting\" },\n            .{ .command = \"bz config set defaults.priority 1\", .description = \"Set default priority to high\" },\n        },\n    },\n    .{\n        .name = \"sync\",\n        .summary = \"Sync with JSONL file\",\n        .usage = \"bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\",\n        .description = \"Synchronizes in-memory state with the JSONL file. By default, performs \" ++\n            \"bidirectional sync. Use flags to limit to export or import only.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--flush-only\", .description = \"Only export (write to JSONL)\" },\n            .{ .short = null, .long = \"--import-only\", .description = \"Only import (read from JSONL)\" },\n            .{ .short = \"-s\", .long = \"--status\", .description = \"Show sync status without changes\" },\n            .{ .short = null, .long = \"--manifest\", .description = \"Write manifest.json with export metadata\" },\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"3-way merge with remote JSONL\" },\n            .{ .short = null, .long = \"--error-policy\", .arg = \"POLICY\", .description = \"Export error handling: strict (default), best-effort, partial\" },\n            .{ .short = null, .long = \"--orphans\", .arg = \"POLICY\", .description = \"Import orphan handling: strict (default), resurrect, skip\" },\n            .{ .short = null, .long = \"--rename-prefix\", .description = \"Fix issues with wrong prefix during import\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz sync\", .description = \"Full bidirectional sync\" },\n            .{ .command = \"bz sync --flush-only\", .description = \"Export changes to JSONL\" },\n            .{ .command = \"bz sync --import-only\", .description = \"Import changes from JSONL\" },\n            .{ .command = \"bz sync --status\", .description = \"Show DB/JSONL issue counts\" },\n            .{ .command = \"bz sync --flush-only --manifest\", .description = \"Export with manifest file\" },\n            .{ .command = \"bz sync --flush-only --error-policy best-effort\", .description = \"Export, continuing on errors\" },\n            .{ .command = \"bz sync --import-only --orphans resurrect\", .description = \"Import, creating placeholders for orphans\" },\n            .{ .command = \"bz sync --import-only --rename-prefix\", .description = \"Import and fix wrong ID prefixes\" },\n        },\n        .see_also = &[_][]const u8{ \"import\", \"add-batch\", \"backup\" },\n    },\n    .{\n        .name = \"orphans\",\n        .summary = \"Find issues with missing parent references\",\n        .usage = \"bz orphans [--limit N] [--hierarchy-only] [--deps-only]\",\n        .description = \"Identifies issues that reference non-existent parent issues or dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results to show\" },\n            .{ .short = null, .long = \"--hierarchy-only\", .description = \"Only check hierarchical parent refs\" },\n            .{ .short = null, .long = \"--deps-only\", .description = \"Only check dependency refs\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz orphans\", .description = \"Find all orphaned references\" },\n            .{ .command = \"bz orphans --limit 10\", .description = \"Show at most 10 orphans\" },\n        },\n    },\n    .{\n        .name = \"lint\",\n        .summary = \"Validate database consistency\",\n        .usage = \"bz lint [--limit N]\",\n        .description = \"Checks for data quality issues: empty titles, invalid priorities, \" ++\n            \"malformed IDs, and other consistency problems.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum issues to report\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz lint\", .description = \"Run all lint checks\" },\n        },\n    },\n\n    // Issue CRUD commands\n    .{\n        .name = \"create\",\n        .aliases = &[_][]const u8{ \"add\", \"new\" },\n        .summary = \"Create a new issue\",\n        .usage = \"bz create <title> [options]\",\n        .description = \"Creates a new issue with the given title. The issue is assigned a \" ++\n            \"unique ID and added to the database. Use flags to set optional fields.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title (1-500 characters)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"Detailed description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Issue type (task, bug, feature, epic, chore, docs, question)\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority (critical, high, medium, low, backlog, or 0-4)\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Assignee name or email\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Add label (can be repeated)\" },\n            .{ .short = null, .long = \"--depends-on\", .arg = \"ID\", .description = \"Add dependency (can be repeated)\" },\n            .{ .short = null, .long = \"--due\", .arg = \"DATE\", .description = \"Due date (YYYY-MM-DD)\" },\n            .{ .short = \"-e\", .long = \"--estimate\", .arg = \"MINS\", .description = \"Estimate in minutes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz create \\\"Fix login bug\\\"\", .description = \"Create a simple issue\" },\n            .{ .command = \"bz create \\\"Add OAuth\\\" -t feature -p high\", .description = \"Create a high-priority feature\" },\n            .{ .command = \"bz create \\\"Bug fix\\\" -l urgent -l backend\", .description = \"Create with multiple labels\" },\n            .{ .command = \"bz create \\\"Task\\\" --depends-on bd-abc123\", .description = \"Create with dependency\" },\n        },\n        .see_also = &[_][]const u8{ \"q\", \"show\", \"update\" },\n    },\n    .{\n        .name = \"q\",\n        .aliases = &[_][]const u8{\"quick\"},\n        .summary = \"Quick capture (create + print ID only)\",\n        .usage = \"bz q <title> [-p PRIORITY]\",\n        .description = \"Creates a new issue and prints only the ID. Optimized for scripting \" ++\n            \"and quick capture workflows.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"title\", .description = \"Issue title\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Priority level\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz q \\\"Quick thought\\\"\", .description = \"Capture idea, get ID back\" },\n            .{ .command = \"ID=$(bz q \\\"Task\\\"); echo $ID\", .description = \"Capture ID in shell variable\" },\n            .{ .command = \"bz q \\\"Urgent fix\\\" -p critical\", .description = \"Quick capture with priority\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"add-batch\" },\n    },\n    .{\n        .name = \"show\",\n        .aliases = &[_][]const u8{ \"get\", \"view\" },\n        .summary = \"Show issue details\",\n        .usage = \"bz show <id> [--no-comments] [--with-history]\",\n        .description = \"Displays full details of an issue including description, status, \" ++\n            \"dependencies, labels, and comments.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (e.g., bd-abc123)\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--no-comments\", .description = \"Hide comments\" },\n            .{ .short = null, .long = \"--with-history\", .description = \"Include change history\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz show bd-abc123\", .description = \"Show issue details\" },\n            .{ .command = \"bz show bd-abc --json\", .description = \"Get issue as JSON\" },\n            .{ .command = \"bz show bd-abc --with-history\", .description = \"Include change history\" },\n        },\n        .see_also = &[_][]const u8{ \"update\", \"history\" },\n    },\n    .{\n        .name = \"update\",\n        .aliases = &[_][]const u8{\"edit\"},\n        .summary = \"Update issue fields\",\n        .usage = \"bz update <id> [options]\",\n        .description = \"Modifies one or more fields of an existing issue. Only specified \" ++\n            \"fields are changed; others remain unchanged.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to update\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--title\", .arg = \"TEXT\", .description = \"New title\" },\n            .{ .short = \"-d\", .long = \"--description\", .arg = \"TEXT\", .description = \"New description\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"New issue type\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"New priority\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"New assignee\" },\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"New status (open, in_progress, blocked, deferred, closed)\" },\n            .{ .short = \"-v\", .long = \"--version\", .arg = \"NUM\", .description = \"Expected version for optimistic locking (fails if issue was modified)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz update bd-abc --title \\\"New title\\\"\", .description = \"Update title\" },\n            .{ .command = \"bz update bd-abc -p critical -a alice\", .description = \"Update priority and assignee\" },\n            .{ .command = \"bz update bd-abc -s in_progress\", .description = \"Change status to in_progress\" },\n            .{ .command = \"bz update bd-abc -v 3 --title \\\"Safe update\\\"\", .description = \"Update only if version is 3 (optimistic lock)\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"close\" },\n    },\n    .{\n        .name = \"close\",\n        .aliases = &[_][]const u8{ \"done\", \"finish\" },\n        .summary = \"Close an issue\",\n        .usage = \"bz close <id> [-r REASON]\",\n        .description = \"Marks an issue as closed. Optionally provide a close reason.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to close\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Close reason (e.g., \\\"Fixed in PR #42\\\")\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz close bd-abc123\", .description = \"Close an issue\" },\n            .{ .command = \"bz close bd-abc -r \\\"Duplicate of bd-xyz\\\"\", .description = \"Close with reason\" },\n            .{ .command = \"bz done bd-abc\", .description = \"Close using alias\" },\n        },\n        .see_also = &[_][]const u8{ \"reopen\", \"delete\" },\n    },\n    .{\n        .name = \"reopen\",\n        .summary = \"Reopen a closed issue\",\n        .usage = \"bz reopen <id>\",\n        .description = \"Changes a closed issue's status back to open.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to reopen\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz reopen bd-abc123\", .description = \"Reopen a closed issue\" },\n        },\n        .see_also = &[_][]const u8{ \"close\", \"update\" },\n    },\n    .{\n        .name = \"delete\",\n        .aliases = &[_][]const u8{ \"rm\", \"remove\" },\n        .summary = \"Soft delete an issue (tombstone)\",\n        .usage = \"bz delete <id>\",\n        .description = \"Marks an issue as deleted (tombstone status). The issue remains in \" ++\n            \"the database but is hidden from normal queries. Can be restored via update.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to delete\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz delete bd-abc123\", .description = \"Soft delete an issue\" },\n            .{ .command = \"bz rm bd-abc\", .description = \"Delete using alias\" },\n        },\n        .see_also = &[_][]const u8{\"close\"},\n    },\n    .{\n        .name = \"defer\",\n        .summary = \"Defer an issue\",\n        .usage = \"bz defer <id> [--until DATE] [-r REASON]\",\n        .description = \"Marks an issue as deferred, optionally until a specific date.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to defer\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-u\", .long = \"--until\", .arg = \"DATE\", .description = \"Date to resurface (YYYY-MM-DD or +7d)\" },\n            .{ .short = \"-r\", .long = \"--reason\", .arg = \"TEXT\", .description = \"Reason for deferral\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz defer bd-abc\", .description = \"Defer indefinitely\" },\n            .{ .command = \"bz defer bd-abc --until 2024-03-01\", .description = \"Defer until specific date\" },\n            .{ .command = \"bz defer bd-abc --until +7d\", .description = \"Defer for 7 days\" },\n        },\n        .see_also = &[_][]const u8{\"undefer\"},\n    },\n    .{\n        .name = \"undefer\",\n        .summary = \"Remove deferral from an issue\",\n        .usage = \"bz undefer <id>\",\n        .description = \"Clears the deferred status and defer_until date from an issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID to undefer\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz undefer bd-abc123\", .description = \"Remove deferral\" },\n        },\n        .see_also = &[_][]const u8{\"defer\"},\n    },\n\n    // Batch operations\n    .{\n        .name = \"add-batch\",\n        .aliases = &[_][]const u8{ \"batch-add\", \"batch\" },\n        .summary = \"Create issues from stdin/file (single lock)\",\n        .usage = \"bz add-batch [-f FILE] [--format FORMAT]\",\n        .description = \"Creates multiple issues efficiently with a single lock acquisition. \" ++\n            \"Reads from stdin or a file. Supports plain titles (one per line) or JSONL format.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--file\", .arg = \"FILE\", .description = \"Read from file instead of stdin\" },\n            .{ .short = null, .long = \"--format\", .arg = \"FMT\", .description = \"Input format: titles (default) or jsonl\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"echo -e \\\"Task 1\\\\nTask 2\\\" | bz add-batch\", .description = \"Create from stdin\" },\n            .{ .command = \"bz add-batch -f tasks.txt\", .description = \"Create from file (one title per line)\" },\n            .{ .command = \"bz add-batch -f issues.jsonl --format jsonl\", .description = \"Create from JSONL file\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"import\" },\n    },\n    .{\n        .name = \"import\",\n        .summary = \"Import issues from JSONL file\",\n        .usage = \"bz import <file> [-m] [-n]\",\n        .description = \"Imports issues from a JSONL file. Handles deduplication via content hash \" ++\n            \"and external_ref matching.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"file\", .description = \"Path to JSONL file\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-m\", .long = \"--merge\", .description = \"Merge with existing issues (update if exists)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be imported without importing\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz import backup.jsonl\", .description = \"Import from backup\" },\n            .{ .command = \"bz import external.jsonl --merge\", .description = \"Merge external issues\" },\n            .{ .command = \"bz import data.jsonl --dry-run\", .description = \"Preview import\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"add-batch\" },\n    },\n\n    // Query commands\n    .{\n        .name = \"list\",\n        .aliases = &[_][]const u8{\"ls\"},\n        .summary = \"List issues with filters\",\n        .usage = \"bz list [options]\",\n        .description = \"Lists issues matching optional filters. By default shows only open issues. \" ++\n            \"Use --all to include closed/deleted issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-s\", .long = \"--status\", .arg = \"STATUS\", .description = \"Filter by status\" },\n            .{ .short = \"-p\", .long = \"--priority\", .arg = \"PRIO\", .description = \"Filter by priority\" },\n            .{ .short = \"-t\", .long = \"--type\", .arg = \"TYPE\", .description = \"Filter by issue type\" },\n            .{ .short = \"-a\", .long = \"--assignee\", .arg = \"USER\", .description = \"Filter by assignee\" },\n            .{ .short = \"-l\", .long = \"--label\", .arg = \"LABEL\", .description = \"Filter by label\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n            .{ .short = \"-A\", .long = \"--all\", .description = \"Include all statuses (not just open)\" },\n            .{ .short = null, .long = \"--sort\", .arg = \"FIELD\", .description = \"Sort by: created, updated, or priority\" },\n            .{ .short = null, .long = \"--asc\", .description = \"Sort ascending\" },\n            .{ .short = null, .long = \"--desc\", .description = \"Sort descending (default)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz list\", .description = \"List open issues\" },\n            .{ .command = \"bz list --all\", .description = \"List all issues\" },\n            .{ .command = \"bz list -p high -t bug\", .description = \"High priority bugs\" },\n            .{ .command = \"bz list --sort priority --asc\", .description = \"Sort by priority ascending\" },\n            .{ .command = \"bz list -l backend -n 5\", .description = \"Top 5 issues with 'backend' label\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"blocked\", \"search\" },\n    },\n    .{\n        .name = \"ready\",\n        .summary = \"Show actionable issues (unblocked)\",\n        .usage = \"bz ready [--limit N]\",\n        .description = \"Lists open issues that have no unresolved blocking dependencies. \" ++\n            \"These are issues ready to be worked on.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz ready\", .description = \"Show all ready issues\" },\n            .{ .command = \"bz ready -n 5\", .description = \"Show top 5 ready issues\" },\n            .{ .command = \"bz ready --json\", .description = \"Get ready work as JSON (for agents)\" },\n        },\n        .see_also = &[_][]const u8{ \"blocked\", \"list\" },\n    },\n    .{\n        .name = \"blocked\",\n        .summary = \"Show blocked issues\",\n        .usage = \"bz blocked [--limit N]\",\n        .description = \"Lists open issues that have unresolved blocking dependencies.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz blocked\", .description = \"Show all blocked issues\" },\n            .{ .command = \"bz blocked --json\", .description = \"Get blocked issues as JSON\" },\n        },\n        .see_also = &[_][]const u8{ \"ready\", \"dep\" },\n    },\n    .{\n        .name = \"search\",\n        .aliases = &[_][]const u8{\"find\"},\n        .summary = \"Full-text search\",\n        .usage = \"bz search <query> [--limit N]\",\n        .description = \"Searches issue titles and descriptions for the given query string.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"query\", .description = \"Search string\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz search login\", .description = \"Find issues mentioning 'login'\" },\n            .{ .command = \"bz search \\\"OAuth flow\\\" -n 10\", .description = \"Search with limit\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"stale\",\n        .summary = \"Find issues not updated recently\",\n        .usage = \"bz stale [--days N] [--limit N]\",\n        .description = \"Lists open issues that haven't been updated within the specified \" ++\n            \"number of days (default: 30).\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-d\", .long = \"--days\", .arg = \"N\", .description = \"Days threshold (default: 30)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum results\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz stale\", .description = \"Issues untouched for 30+ days\" },\n            .{ .command = \"bz stale --days 7\", .description = \"Issues untouched for 7+ days\" },\n        },\n        .see_also = &[_][]const u8{\"list\"},\n    },\n    .{\n        .name = \"count\",\n        .summary = \"Count issues by group\",\n        .usage = \"bz count [--group-by FIELD]\",\n        .description = \"Counts issues, optionally grouped by a field.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by: status, priority, type, assignee\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz count\", .description = \"Total issue count\" },\n            .{ .command = \"bz count --group-by status\", .description = \"Count by status\" },\n            .{ .command = \"bz count -g priority\", .description = \"Count by priority\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"stats\" },\n    },\n\n    // Dependency commands\n    .{\n        .name = \"dep\",\n        .aliases = &[_][]const u8{ \"deps\", \"dependency\" },\n        .summary = \"Manage issue dependencies\",\n        .usage = \"bz dep <subcommand> [args]\",\n        .description = \"Add, remove, or query dependencies between issues. \" ++\n            \"Dependencies are directional: A depends-on B means A is blocked by B.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, tree, or cycles\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz dep add bd-child bd-parent\", .description = \"child depends on parent\" },\n            .{ .command = \"bz dep add bd-a bd-b --type relates_to\", .description = \"Add non-blocking relation\" },\n            .{ .command = \"bz dep remove bd-child bd-parent\", .description = \"Remove dependency\" },\n            .{ .command = \"bz dep list bd-abc\", .description = \"List dependencies of an issue\" },\n            .{ .command = \"bz dep tree bd-abc\", .description = \"Show dependency tree\" },\n            .{ .command = \"bz dep cycles\", .description = \"Detect circular dependencies\" },\n        },\n        .see_also = &[_][]const u8{ \"graph\", \"ready\", \"blocked\" },\n    },\n    .{\n        .name = \"graph\",\n        .summary = \"Show dependency graph\",\n        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n        .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n            \"With an ID, shows that issue's dependency subgraph.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n            .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n            .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n            .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n        },\n        .see_also = &[_][]const u8{\"dep\"},\n    },\n\n    // Epic commands\n    .{\n        .name = \"epic\",\n        .aliases = &[_][]const u8{\"epics\"},\n        .summary = \"Manage epics\",\n        .usage = \"bz epic <subcommand> [args]\",\n        .description = \"Epics are special issues that group related work. Use epic commands \" ++\n            \"to create epics and manage their child issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"create, add, remove, or list\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz epic create \\\"Q1 Goals\\\"\", .description = \"Create a new epic\" },\n            .{ .command = \"bz epic create \\\"Auth Overhaul\\\" -p high\", .description = \"Create with priority\" },\n            .{ .command = \"bz epic add bd-epic bd-task\", .description = \"Add issue to epic\" },\n            .{ .command = \"bz epic remove bd-epic bd-task\", .description = \"Remove issue from epic\" },\n            .{ .command = \"bz epic list bd-epic\", .description = \"List issues in epic\" },\n        },\n        .see_also = &[_][]const u8{ \"create\", \"dep\" },\n    },\n\n    // Label commands\n    .{\n        .name = \"label\",\n        .aliases = &[_][]const u8{ \"labels\", \"tag\" },\n        .summary = \"Manage issue labels\",\n        .usage = \"bz label <subcommand> [args]\",\n        .description = \"Add, remove, or list labels on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add, remove, list, or list-all\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz label add bd-abc urgent backend\", .description = \"Add multiple labels\" },\n            .{ .command = \"bz label remove bd-abc old-label\", .description = \"Remove a label\" },\n            .{ .command = \"bz label list bd-abc\", .description = \"List labels on issue\" },\n            .{ .command = \"bz label list-all\", .description = \"List all labels in project\" },\n        },\n        .see_also = &[_][]const u8{ \"list\", \"create\" },\n    },\n\n    // Comment commands\n    .{\n        .name = \"comments\",\n        .aliases = &[_][]const u8{ \"comment\", \"note\" },\n        .summary = \"Manage issue comments\",\n        .usage = \"bz comments <subcommand> <id> [text]\",\n        .description = \"Add or list comments on issues.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"add or list\" },\n            .{ .name = \"id\", .description = \"Issue ID\" },\n            .{ .name = \"text\", .description = \"Comment text (for add)\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz comments add bd-abc \\\"Working on this\\\"\", .description = \"Add a comment\" },\n            .{ .command = \"bz comments list bd-abc\", .description = \"List comments\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"history\" },\n    },\n\n    // Audit commands\n    .{\n        .name = \"history\",\n        .aliases = &[_][]const u8{\"log\"},\n        .summary = \"Show issue history\",\n        .usage = \"bz history <id>\",\n        .description = \"Displays the change history for a specific issue.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"id\", .description = \"Issue ID\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz history bd-abc123\", .description = \"Show change history\" },\n        },\n        .see_also = &[_][]const u8{ \"show\", \"audit\" },\n    },\n    .{\n        .name = \"audit\",\n        .summary = \"Project-wide audit log\",\n        .usage = \"bz audit [--limit N]\",\n        .description = \"Shows recent events across all issues.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum events\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz audit\", .description = \"Show recent events\" },\n            .{ .command = \"bz audit --limit 100\", .description = \"Show last 100 events\" },\n        },\n        .see_also = &[_][]const u8{ \"history\", \"changelog\" },\n    },\n    .{\n        .name = \"changelog\",\n        .summary = \"Generate changelog from closed issues\",\n        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n        .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n            \"by date range and grouped by type.\",\n        .flags = &[_]FlagHelp{\n            .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n            .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n            .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n            .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n            .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n            .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n        },\n        .see_also = &[_][]const u8{\"audit\"},\n    },\n\n    // Backup commands\n    .{\n        .name = \"backup\",\n        .aliases = &[_][]const u8{\"backups\"},\n        .summary = \"Manage JSONL backup files\",\n        .usage = \"bz backup <subcommand> [args]\",\n        .description = \"Manage JSONL backup files. Create backups before major operations, \" ++\n            \"compare backups with current state, restore from backups, and prune old backups.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"subcommand\", .description = \"list, diff, restore, prune, or create\" },\n        },\n        .flags = &[_]FlagHelp{\n            .{ .short = \"-k\", .long = \"--keep\", .arg = \"N\", .description = \"Keep N most recent backups (prune, default: 10)\" },\n            .{ .short = \"-n\", .long = \"--dry-run\", .description = \"Show what would be done without making changes\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz backup list\", .description = \"List available backups\" },\n            .{ .command = \"bz backup create\", .description = \"Create a new backup\" },\n            .{ .command = \"bz backup diff issues.jsonl.bak.123\", .description = \"Compare backup with current\" },\n            .{ .command = \"bz backup restore issues.jsonl.bak.123\", .description = \"Restore from backup\" },\n            .{ .command = \"bz backup restore issues.jsonl.bak.123 --dry-run\", .description = \"Preview restore\" },\n            .{ .command = \"bz backup prune --keep 5\", .description = \"Keep only 5 most recent backups\" },\n        },\n        .see_also = &[_][]const u8{ \"sync\", \"import\" },\n    },\n\n    // System commands\n    .{\n        .name = \"version\",\n        .summary = \"Show version\",\n        .usage = \"bz version\",\n        .description = \"Displays the beads_zig version and build information.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz version\", .description = \"Show version\" },\n            .{ .command = \"bz --version\", .description = \"Same (alternate form)\" },\n        },\n    },\n    .{\n        .name = \"schema\",\n        .summary = \"Show data schema\",\n        .usage = \"bz schema\",\n        .description = \"Displays the JSONL data schema for issues and related types.\",\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz schema\", .description = \"Show schema documentation\" },\n        },\n    },\n    .{\n        .name = \"completions\",\n        .aliases = &[_][]const u8{\"completion\"},\n        .summary = \"Generate shell completions\",\n        .usage = \"bz completions <shell>\",\n        .description = \"Generates shell completion scripts for bash, zsh, fish, or powershell.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"shell\", .description = \"Shell type: bash, zsh, fish, or powershell\" },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz completions bash >> ~/.bashrc\", .description = \"Add bash completions\" },\n            .{ .command = \"bz completions zsh > ~/.zsh/completions/_bz\", .description = \"Install zsh completions\" },\n            .{ .command = \"bz completions fish > ~/.config/fish/completions/bz.fish\", .description = \"Install fish completions\" },\n        },\n    },\n    .{\n        .name = \"help\",\n        .summary = \"Show help\",\n        .usage = \"bz help [command]\",\n        .description = \"Shows general help or detailed help for a specific command.\",\n        .arguments = &[_]ArgHelp{\n            .{ .name = \"command\", .description = \"Command to get help for\", .required = false },\n        },\n        .examples = &[_]ExampleHelp{\n            .{ .command = \"bz help\", .description = \"Show general help\" },\n            .{ .command = \"bz help create\", .description = \"Show help for create command\" },\n            .{ .command = \"bz --help\", .description = \"Same as bz help\" },\n        },\n    },\n};\n\n/// Find help for a specific command (including aliases).\nfn findCommand(name: []const u8) ?*const CommandHelp {\n    for (&commands) |*cmd| {\n        if (std.mem.eql(u8, cmd.name, name)) {\n            return cmd;\n        }\n        for (cmd.aliases) |alias| {\n            if (std.mem.eql(u8, alias, name)) {\n                return cmd;\n            }\n        }\n    }\n    return null;\n}\n\n/// Run the help command.\npub fn run(topic: ?[]const u8, allocator: std.mem.Allocator) !void {\n    const stdout = std.fs.File.stdout();\n    if (topic) |t| {\n        try showCommandHelp(t, stdout, allocator);\n    } else {\n        try showGeneralHelp(stdout);\n    }\n}\n\nfn showGeneralHelp(file: std.fs.File) !void {\n    try file.writeAll(\n        \\\\bz - beads_zig issue tracker\n        \\\\\n        \\\\USAGE:\n        \\\\  bz <command> [options]\n        \\\\\n        \\\\COMMANDS:\n        \\\\  Workspace:\n        \\\\    init              Initialize .beads/ workspace\n        \\\\    info              Show workspace information\n        \\\\    stats             Show project statistics\n        \\\\    doctor            Run diagnostic checks\n        \\\\    config            Manage configuration\n        \\\\    sync              Sync with JSONL file\n        \\\\    orphans           Find issues with missing parent refs\n        \\\\    lint              Validate database consistency\n        \\\\\n        \\\\  Issue Management:\n        \\\\    create <title>    Create new issue\n        \\\\    q <title>         Quick capture (create + print ID only)\n        \\\\    show <id>         Show issue details\n        \\\\    update <id>       Update issue fields\n        \\\\    close <id>        Close an issue\n        \\\\    reopen <id>       Reopen a closed issue\n        \\\\    delete <id>       Soft delete (tombstone)\n        \\\\    defer <id>        Defer an issue\n        \\\\    undefer <id>      Remove deferral from an issue\n        \\\\\n        \\\\  Batch Operations:\n        \\\\    add-batch         Create issues from stdin/file (single lock)\n        \\\\    import <file>     Import issues from JSONL file\n        \\\\\n        \\\\  Queries:\n        \\\\    list              List issues (--sort created|updated|priority, --asc/--desc)\n        \\\\    ready             Show actionable issues (unblocked)\n        \\\\    blocked           Show blocked issues\n        \\\\    search <query>    Full-text search\n        \\\\    stale [--days N]  Find issues not updated recently\n        \\\\    count [--group-by] Count issues by group\n        \\\\\n        \\\\  Dependencies:\n        \\\\    dep add <a> <b>   Make issue A depend on B\n        \\\\    dep remove <a> <b> Remove dependency\n        \\\\    dep list <id>     List dependencies\n        \\\\    dep tree <id>     Show dependency tree (ASCII)\n        \\\\    dep cycles        Detect dependency cycles\n        \\\\    graph [id]        Show dependency graph (ASCII/DOT)\n        \\\\\n        \\\\  Epics:\n        \\\\    epic create <title>       Create a new epic\n        \\\\    epic add <epic> <issue>   Add issue to epic\n        \\\\    epic remove <epic> <issue> Remove issue from epic\n        \\\\    epic list <epic>          List issues in epic\n        \\\\\n        \\\\  Labels:\n        \\\\    label add <id> <labels...>    Add labels to an issue\n        \\\\    label remove <id> <labels...> Remove labels from an issue\n        \\\\    label list <id>               List labels on an issue\n        \\\\    label list-all                List all labels in project\n        \\\\\n        \\\\  Comments:\n        \\\\    comments add <id> <text>  Add comment to an issue\n        \\\\    comments list <id>        List comments on an issue\n        \\\\\n        \\\\  Audit:\n        \\\\    history <id>      Show issue history\n        \\\\    audit             Project-wide audit log\n        \\\\    changelog         Generate changelog from closed issues\n        \\\\\n        \\\\  System:\n        \\\\    help              Show this help\n        \\\\    version           Show version\n        \\\\    schema            Show data schema\n        \\\\    completions <shell>  Generate shell completions\n        \\\\\n        \\\\GLOBAL OPTIONS:\n        \\\\  --json            Output in JSON format\n        \\\\  --toon            Output in TOON format (LLM-optimized)\n        \\\\  -q, --quiet       Suppress non-essential output\n        \\\\  -v, --verbose     Increase verbosity\n        \\\\  --no-color        Disable colors\n        \\\\  --data <path>     Override .beads/ directory\n        \\\\  --actor <name>    Override actor name for audit\n        \\\\  --no-auto-flush   Skip automatic JSONL export\n        \\\\  --no-auto-import  Skip JSONL freshness check\n        \\\\\n        \\\\Run 'bz help <command>' for command-specific help.\n        \\\\\n    );\n}\n\nfn showCommandHelp(name: []const u8, file: std.fs.File, allocator: std.mem.Allocator) !void {\n    const cmd = findCommand(name) orelse {\n        const msg = try std.fmt.allocPrint(allocator, \"Unknown command: {s}\\n\\n\", .{name});\n        defer allocator.free(msg);\n        try file.writeAll(msg);\n        try file.writeAll(\"Run 'bz help' for a list of available commands.\\n\");\n        return;\n    };\n\n    // Command name and aliases\n    try file.writeAll(cmd.name);\n    if (cmd.aliases.len > 0) {\n        try file.writeAll(\" (\");\n        for (cmd.aliases, 0..) |alias, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(alias);\n        }\n        try file.writeAll(\")\");\n    }\n    try file.writeAll(\"\\n\");\n\n    // Summary\n    try file.writeAll(\"\\n\");\n    try file.writeAll(cmd.summary);\n    try file.writeAll(\"\\n\");\n\n    // Usage\n    try file.writeAll(\"\\nUSAGE:\\n  \");\n    try file.writeAll(cmd.usage);\n    try file.writeAll(\"\\n\");\n\n    // Description\n    if (cmd.description.len > 0) {\n        try file.writeAll(\"\\nDESCRIPTION:\\n\");\n        try writeWrapped(file, cmd.description, 2, 78, allocator);\n    }\n\n    // Arguments\n    if (cmd.arguments.len > 0) {\n        try file.writeAll(\"\\nARGUMENTS:\\n\");\n        for (cmd.arguments) |arg| {\n            const req = if (arg.required) \" (required)\" else \" (optional)\";\n            const line = try std.fmt.allocPrint(allocator, \"  {s}{s}\\n\", .{ arg.name, req });\n            defer allocator.free(line);\n            try file.writeAll(line);\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{arg.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Flags\n    if (cmd.flags.len > 0) {\n        try file.writeAll(\"\\nFLAGS:\\n\");\n        for (cmd.flags) |flag| {\n            if (flag.short) |short| {\n                const line = try std.fmt.allocPrint(allocator, \"  {s}, {s}\", .{ short, flag.long });\n                defer allocator.free(line);\n                try file.writeAll(line);\n            } else {\n                const line = try std.fmt.allocPrint(allocator, \"      {s}\", .{flag.long});\n                defer allocator.free(line);\n                try file.writeAll(line);\n            }\n            if (flag.arg) |arg| {\n                const argline = try std.fmt.allocPrint(allocator, \" <{s}>\", .{arg});\n                defer allocator.free(argline);\n                try file.writeAll(argline);\n            }\n            try file.writeAll(\"\\n\");\n            const desc = try std.fmt.allocPrint(allocator, \"      {s}\\n\", .{flag.description});\n            defer allocator.free(desc);\n            try file.writeAll(desc);\n        }\n    }\n\n    // Examples\n    if (cmd.examples.len > 0) {\n        try file.writeAll(\"\\nEXAMPLES:\\n\");\n        for (cmd.examples) |ex| {\n            const cmd_line = try std.fmt.allocPrint(allocator, \"  $ {s}\\n\", .{ex.command});\n            defer allocator.free(cmd_line);\n            try file.writeAll(cmd_line);\n            const desc_line = try std.fmt.allocPrint(allocator, \"    {s}\\n\\n\", .{ex.description});\n            defer allocator.free(desc_line);\n            try file.writeAll(desc_line);\n        }\n    }\n\n    // See also\n    if (cmd.see_also.len > 0) {\n        try file.writeAll(\"SEE ALSO:\\n  \");\n        for (cmd.see_also, 0..) |ref, i| {\n            if (i > 0) try file.writeAll(\", \");\n            try file.writeAll(ref);\n        }\n        try file.writeAll(\"\\n\");\n    }\n}\n\n/// Write text with word wrapping.\nfn writeWrapped(file: std.fs.File, text: []const u8, indent: usize, max_width: usize, allocator: std.mem.Allocator) !void {\n    const effective_width = max_width - indent;\n\n    // Pre-allocate indent string\n    const indent_str = try allocator.alloc(u8, indent);\n    defer allocator.free(indent_str);\n    @memset(indent_str, ' ');\n\n    var line_start: usize = 0;\n    var last_space: ?usize = null;\n    var col: usize = 0;\n\n    for (text, 0..) |c, i| {\n        if (c == ' ') {\n            last_space = i;\n        }\n        col += 1;\n\n        if (col >= effective_width) {\n            const break_at = last_space orelse i;\n            try file.writeAll(indent_str);\n            try file.writeAll(text[line_start..break_at]);\n            try file.writeAll(\"\\n\");\n\n            line_start = break_at + 1;\n            col = i - break_at;\n            last_space = null;\n        }\n    }\n\n    if (line_start < text.len) {\n        try file.writeAll(indent_str);\n        try file.writeAll(text[line_start..]);\n        try file.writeAll(\"\\n\");\n    }\n}\n\n// Tests\n\ntest \"findCommand finds by name\" {\n    const cmd = findCommand(\"create\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand finds by alias\" {\n    const cmd = findCommand(\"add\");\n    try std.testing.expect(cmd != null);\n    try std.testing.expectEqualStrings(\"create\", cmd.?.name);\n}\n\ntest \"findCommand returns null for unknown\" {\n    const cmd = findCommand(\"nonexistent\");\n    try std.testing.expect(cmd == null);\n}\n\ntest \"findCommand finds all main commands\" {\n    // Verify a sampling of commands can be found\n    try std.testing.expect(findCommand(\"init\") != null);\n    try std.testing.expect(findCommand(\"list\") != null);\n    try std.testing.expect(findCommand(\"show\") != null);\n    try std.testing.expect(findCommand(\"update\") != null);\n    try std.testing.expect(findCommand(\"close\") != null);\n    try std.testing.expect(findCommand(\"dep\") != null);\n    try std.testing.expect(findCommand(\"help\") != null);\n}\n\ntest \"findCommand finds aliases\" {\n    // Test common aliases\n    try std.testing.expect(findCommand(\"ls\") != null);\n    try std.testing.expectEqualStrings(\"list\", findCommand(\"ls\").?.name);\n\n    try std.testing.expect(findCommand(\"rm\") != null);\n    try std.testing.expectEqualStrings(\"delete\", findCommand(\"rm\").?.name);\n\n    try std.testing.expect(findCommand(\"done\") != null);\n    try std.testing.expectEqualStrings(\"close\", findCommand(\"done\").?.name);\n}\n","structuredPatch":[{"oldStart":816,"oldLines":6,"newStart":816,"newLines":13,"lines":["         \\\\    audit             Project-wide audit log","         \\\\    changelog         Generate changelog from closed issues","         \\\\","+        \\\\  Backup:","+        \\\\    backup list       List available backups","+        \\\\    backup create     Create a new backup","+        \\\\    backup diff <f>   Compare backup with current","+        \\\\    backup restore <f> Restore from backup","+        \\\\    backup prune      Remove old backups","+        \\\\","         \\\\  System:","         \\\\    help              Show this help","         \\\\    version           Show version"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Ry52qXpRuMxKuETqbsjd4G","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WKfRSgsptnRALnnoUNjMXt","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"completed","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"completed","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"in_progress","activeForm":"Wiring backup in main.zig"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":355,"cache_read_input_tokens":129446,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":355},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f477eb9a-518f-4ab3-91d9-6c34394d260d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WKfRSgsptnRALnnoUNjMXt","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5cdbeee6-b72c-4c2f-b2bc-668b4b657894","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"completed","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"in_progress","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"pending","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"completed","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"completed","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"in_progress","activeForm":"Wiring backup in main.zig"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D5aB5xrbbH8AXABfvSAjd1","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me wire up the backup command in main.zig. Let me first look at the main.zig file."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":129801,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"23c82c3f-a5a7-4787-a7df-a9352ec4b7c0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D5aB5xrbbH8AXABfvSAjd1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FbK9VKvXErknXM8z3VGSoR","name":"Grep","input":{"pattern":"sync.*run|\\.sync =>|dispatch","path":"/home/hotschmoe/beads_zig/src/main.zig","output_mode":"content","-n":true,"-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":129801,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"fa89356e-56f9-4bcc-86e6-ef4de3f80632"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FbK9VKvXErknXM8z3VGSoR","type":"tool_result","content":"34-    };\n35-    defer result.deinit(allocator);\n36-\n37:    try dispatch(result, allocator);\n38-}\n39-\n40:fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n41-    switch (result.command) {\n42-        .init => |init_args| {\n43-            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n--\n135-                else => return err,\n136-            };\n137-        },\n138:        .sync => |sync_args| {\n139-            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n140-                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n141-                else => return err,"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"a7278781-0045-4bd1-90a2-bf0d4db0b037","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"34-    };\n35-    defer result.deinit(allocator);\n36-\n37:    try dispatch(result, allocator);\n38-}\n39-\n40:fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n41-    switch (result.command) {\n42-        .init => |init_args| {\n43-            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n--\n135-                else => return err,\n136-            };\n137-        },\n138:        .sync => |sync_args| {\n139-            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n140-                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n141-                else => return err,","numLines":18}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01H571uCrTLYkT6YS6YuCY2o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JzdCp87jQk4pjw1MGLTrbn","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig","offset":135,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":426,"cache_read_input_tokens":130129,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":426},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7270ed71-1589-45cf-b820-b86703165fe6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JzdCp87jQk4pjw1MGLTrbn","type":"tool_result","content":"   135→                else => return err,\n   136→            };\n   137→        },\n   138→        .sync => |sync_args| {\n   139→            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n   140→                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n   141→                else => return err,\n   142→            };\n   143→        },\n   144→        .search => |search_args| {\n   145→            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n   146→                error.WorkspaceNotInitialized => std.process.exit(1),\n   147→                else => return err,\n   148→            };\n   149→        },\n   150→        .stale => |stale_args| {\n   151→            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n   152→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   153→                else => return err,\n   154→            };\n   155→        },\n   156→        .count => |count_args| {\n   157→            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n   158→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   159→                else => return err,\n   160→            };\n   161→        },\n   162→        .defer_cmd => |defer_args| {\n   163→            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n   164→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n   165→                else => return err,\n   166→            };\n   167→        },\n   168→        .undefer => |undefer_args| {\n   169→            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n   170→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n   171→                else => return err,\n   172→            };\n   173→        },\n   174→        .help => |help_args| {\n   175→            cli.runHelp(help_args.topic, allocator) catch {\n   176→                std.process.exit(1);\n   177→            };\n   178→        },\n   179→        .version => {\n   180→            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n   181→                error.WriteError => std.process.exit(1),\n   182→            };\n   183→        },\n   184→        .schema => {\n   185→            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n   186→                error.WriteError, error.OutOfMemory => std.process.exit(1),\n   187→            };\n   188→        },\n   189→        .completions => |comp_args| {\n   190→            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n   191→                error.WriteError => std.process.exit(1),\n   192→            };\n   193→        },\n   194→        .metrics => |metrics_args| {\n   195→            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n   196→                error.WriteError, error.OutOfMemory => std.process.exit(1),\n   197→            };\n   198→        },\n   199→        .info => {\n   200→            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n   201→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   202→                else => return err,\n   203→            };\n   204→        },\n   205→        .stats => {\n   206→            cli.runStats(result.global, allocator) catch |err| switch (err) {\n   207→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   208→                else => return err,\n   209→            };\n   210→        },\n   211→        .doctor => {\n   212→            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n   213→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   214→                else => return err,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"876d61ff-0f6b-40a8-ae5c-81fdeed6414a","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","content":"                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,","numLines":80,"startLine":135,"totalLines":310}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XCvKThV2uFazy7JYvj4e6H","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TXVT8uegn9HaFWz48eXGNe","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/main.zig","old_string":"        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {","new_string":"        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .backup => |backup_args| {\n            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1441,"cache_read_input_tokens":130555,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1441},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"9f0cc8a4-7632-41d2-bdd7-f11bb6af1c13"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TXVT8uegn9HaFWz48eXGNe","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/main.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"3ec8a7dd-3066-4722-9f1f-5e9fd0abd5ca","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","oldString":"        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {","newString":"        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .backup => |backup_args| {\n            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {","originalFile":"//! beads_zig CLI entry point.\n//!\n//! Binary name: bz (beads-zig)\n\nconst std = @import(\"std\");\nconst beads_zig = @import(\"beads_zig\");\nconst cli = beads_zig.cli;\nconst output = beads_zig.output;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    run(allocator) catch |err| {\n        const stderr = std.fs.File.stderr();\n        stderr.writeAll(\"error: \") catch {};\n        stderr.writeAll(@errorName(err)) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        std.process.exit(1);\n    };\n}\n\nfn run(allocator: std.mem.Allocator) !void {\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    // Skip program name\n    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n\n    var parser = cli.ArgParser.init(allocator, cmd_args);\n    var result = parser.parse() catch |err| {\n        return handleParseError(err, allocator);\n    };\n    defer result.deinit(allocator);\n\n    try dispatch(result, allocator);\n}\n\nfn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    switch (result.command) {\n        .init => |init_args| {\n            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n                error.AlreadyInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .create => |create_args| {\n            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .q => |quick_args| {\n            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .list => |list_args| {\n            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .show => |show_args| {\n            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .update => |update_args| {\n            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .close => |close_args| {\n            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .reopen => |reopen_args| {\n            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .delete => |delete_args| {\n            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .add_batch => |batch_args| {\n            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .import_cmd => |import_args| {\n            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .ready => |ready_args| {\n            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .blocked => |blocked_args| {\n            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .dep => |dep_args| {\n            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .graph => |graph_args| {\n            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .epic => |epic_args| {\n            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .orphans => |orphans_args| {\n            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .lint => |lint_args| {\n            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .label => |label_args| {\n            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .comments => |comments_args| {\n            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .history => |history_args| {\n            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .where => {\n            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n    }\n    std.process.exit(1);\n}\n\ntest \"library imports compile\" {\n    // Verify all modules are accessible\n    _ = beads_zig.cli;\n    _ = beads_zig.storage;\n    _ = beads_zig.models;\n    _ = beads_zig.sync;\n    _ = beads_zig.id;\n    _ = beads_zig.config;\n    _ = beads_zig.output;\n}\n","structuredPatch":[{"oldStart":141,"oldLines":6,"newStart":141,"newLines":12,"lines":["                 else => return err,","             };","         },","+        .backup => |backup_args| {","+            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {","+                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),","+                else => return err,","+            };","+        },","         .search => |search_args| {","             cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {","                 error.WorkspaceNotInitialized => std.process.exit(1),"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GnnZ4bE63ULtspqXGVnssB","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the runBackup export to the cli module. Let me check the cli module exports."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":463,"cache_read_input_tokens":131996,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":463},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6f15fac5-3941-4fa8-a315-ef2709a3fc7b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GnnZ4bE63ULtspqXGVnssB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E5Jy5EwbmjtUZZN8uMsixB","name":"Grep","input":{"pattern":"runSync|pub const","path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":463,"cache_read_input_tokens":131996,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":463},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"20fd456c-7b52-4fd0-b44c-f3b5698f86e9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E5Jy5EwbmjtUZZN8uMsixB","type":"tool_result","content":"10:pub const args = @import(\"args.zig\");\n11:pub const common = @import(\"common.zig\");\n12:pub const init = @import(\"init.zig\");\n13:pub const create = @import(\"create.zig\");\n14:pub const list = @import(\"list.zig\");\n15:pub const show = @import(\"show.zig\");\n16:pub const update = @import(\"update.zig\");\n17:pub const close = @import(\"close.zig\");\n18:pub const delete = @import(\"delete.zig\");\n19:pub const ready = @import(\"ready.zig\");\n20:pub const dep = @import(\"dep.zig\");\n21:pub const graph = @import(\"graph.zig\");\n22:pub const epic = @import(\"epic.zig\");\n23:pub const sync = @import(\"sync.zig\");\n24:pub const batch = @import(\"batch.zig\");\n25:pub const search = @import(\"search.zig\");\n26:pub const stale = @import(\"stale.zig\");\n27:pub const count = @import(\"count.zig\");\n28:pub const defer_cmd = @import(\"defer.zig\");\n29:pub const label = @import(\"label.zig\");\n30:pub const comments = @import(\"comments.zig\");\n31:pub const history = @import(\"history.zig\");\n32:pub const audit = @import(\"audit.zig\");\n33:pub const changelog = @import(\"changelog.zig\");\n34:pub const info = @import(\"info.zig\");\n35:pub const stats = @import(\"stats.zig\");\n36:pub const doctor = @import(\"doctor.zig\");\n37:pub const config = @import(\"config.zig\");\n38:pub const orphans = @import(\"orphans.zig\");\n39:pub const lint = @import(\"lint.zig\");\n40:pub const version = @import(\"version.zig\");\n41:pub const schema = @import(\"schema.zig\");\n42:pub const completions = @import(\"completions.zig\");\n43:pub const metrics_cmd = @import(\"metrics.zig\");\n44:pub const help = @import(\"help.zig\");\n45:pub const query = @import(\"query.zig\");\n46:pub const upgrade = @import(\"upgrade.zig\");\n47:pub const where = @import(\"where.zig\");\n49:pub const ArgParser = args.ArgParser;\n50:pub const ParseResult = args.ParseResult;\n51:pub const ParseError = args.ParseError;\n52:pub const GlobalOptions = args.GlobalOptions;\n53:pub const Command = args.Command;\n54:pub const InitArgs = args.InitArgs;\n55:pub const CreateArgs = args.CreateArgs;\n56:pub const QuickArgs = args.QuickArgs;\n58:pub const InitError = init.InitError;\n59:pub const InitResult = init.InitResult;\n60:pub const runInit = init.run;\n62:pub const CreateError = create.CreateError;\n63:pub const CreateResult = create.CreateResult;\n64:pub const runCreate = create.run;\n65:pub const runQuick = create.runQuick;\n67:pub const ListError = list.ListError;\n68:pub const ListResult = list.ListResult;\n69:pub const runList = list.run;\n71:pub const ShowError = show.ShowError;\n72:pub const ShowResult = show.ShowResult;\n73:pub const runShow = show.run;\n75:pub const UpdateError = update.UpdateError;\n76:pub const UpdateResult = update.UpdateResult;\n77:pub const runUpdate = update.run;\n79:pub const CloseError = close.CloseError;\n80:pub const CloseResult = close.CloseResult;\n81:pub const runClose = close.run;\n82:pub const runReopen = close.runReopen;\n84:pub const DeleteError = delete.DeleteError;\n85:pub const DeleteResult = delete.DeleteResult;\n86:pub const runDelete = delete.run;\n88:pub const ReadyError = ready.ReadyError;\n89:pub const ReadyResult = ready.ReadyResult;\n90:pub const runReady = ready.run;\n91:pub const runBlocked = ready.runBlocked;\n93:pub const DepError = dep.DepError;\n94:pub const DepResult = dep.DepResult;\n95:pub const runDep = dep.run;\n97:pub const GraphError = graph.GraphError;\n98:pub const GraphResult = graph.GraphResult;\n99:pub const runGraph = graph.run;\n101:pub const EpicError = epic.EpicError;\n102:pub const EpicResult = epic.EpicResult;\n103:pub const runEpic = epic.run;\n105:pub const SyncError = sync.SyncError;\n106:pub const SyncResult = sync.SyncResult;\n107:pub const runSync = sync.run;\n109:pub const BatchError = batch.BatchError;\n110:pub const BatchResult = batch.BatchResult;\n111:pub const ImportResult = batch.ImportResult;\n112:pub const runAddBatch = batch.runAddBatch;\n113:pub const runImportCmd = batch.runImport;\n115:pub const AddBatchArgs = args.AddBatchArgs;\n116:pub const BatchFormat = args.BatchFormat;\n117:pub const ImportArgs = args.ImportArgs;\n118:pub const EpicArgs = args.EpicArgs;\n119:pub const SortField = args.SortField;\n121:pub const SearchError = search.SearchError;\n122:pub const SearchResult = search.SearchResult;\n123:pub const runSearch = search.run;\n125:pub const runStale = stale.run;\n127:pub const runCount = count.run;\n129:pub const runDefer = defer_cmd.run;\n130:pub const runUndefer = defer_cmd.runUndefer;\n132:pub const LabelError = label.LabelError;\n133:pub const LabelResult = label.LabelResult;\n134:pub const runLabel = label.run;\n136:pub const CommentsError = comments.CommentsError;\n137:pub const CommentsResult = comments.CommentsResult;\n138:pub const runComments = comments.run;\n140:pub const HistoryError = history.HistoryError;\n141:pub const HistoryResult = history.HistoryResult;\n142:pub const runHistory = history.run;\n144:pub const AuditError = audit.AuditError;\n145:pub const AuditResult = audit.AuditResult;\n146:pub const runAudit = audit.run;\n148:pub const ChangelogError = changelog.ChangelogError;\n149:pub const ChangelogResult = changelog.ChangelogResult;\n150:pub const runChangelog = changelog.run;\n151:pub const ChangelogArgs = args.ChangelogArgs;\n153:pub const InfoError = info.InfoError;\n154:pub const InfoResult = info.InfoResult;\n155:pub const runInfo = info.run;\n157:pub const StatsError = stats.StatsError;\n158:pub const StatsResult = stats.StatsResult;\n159:pub const runStats = stats.run;\n161:pub const DoctorError = doctor.DoctorError;\n162:pub const DoctorResult = doctor.DoctorResult;\n163:pub const runDoctor = doctor.run;\n165:pub const ConfigError = config.ConfigError;\n166:pub const ConfigResult = config.ConfigResult;\n167:pub const runConfig = config.run;\n169:pub const OrphansError = orphans.OrphansError;\n170:pub const OrphansResult = orphans.OrphansResult;\n171:pub const runOrphans = orphans.run;\n173:pub const LintError = lint.LintError;\n174:pub const LintResult = lint.LintResult;\n175:pub const runLint = lint.run;\n177:pub const OrphansArgs = args.OrphansArgs;\n178:pub const LintArgs = args.LintArgs;\n180:pub const VersionError = version.VersionError;\n181:pub const VersionResult = version.VersionResult;\n182:pub const runVersion = version.run;\n183:pub const VERSION = version.VERSION;\n185:pub const SchemaError = schema.SchemaError;\n186:pub const SchemaResult = schema.SchemaResult;\n187:pub const runSchema = schema.run;\n189:pub const CompletionsError = completions.CompletionsError;\n190:pub const CompletionsResult = completions.CompletionsResult;\n191:pub const runCompletions = completions.run;\n192:pub const Shell = completions.Shell;\n194:pub const MetricsError = metrics_cmd.MetricsError;\n195:pub const MetricsResult = metrics_cmd.MetricsResult;\n196:pub const runMetrics = metrics_cmd.run;\n197:pub const MetricsArgs = args.MetricsArgs;\n199:pub const HelpError = help.HelpError;\n200:pub const HelpResult = help.HelpResult;\n201:pub const runHelp = help.run;\n203:pub const QueryError = query.QueryError;\n204:pub const QueryResult = query.QueryResult;\n205:pub const runQuery = query.run;\n206:pub const QueryArgs = args.QueryArgs;\n208:pub const UpgradeError = upgrade.UpgradeError;\n209:pub const UpgradeResult = upgrade.UpgradeResult;\n210:pub const runUpgrade = upgrade.run;\n211:pub const UpgradeArgs = args.UpgradeArgs;\n213:pub const WhereError = where.WhereError;\n214:pub const WhereResult = where.WhereResult;\n215:pub const runWhere = where.run;"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"147a3cab-6235-4dcd-bcd2-b50fdc228bcf","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"10:pub const args = @import(\"args.zig\");\n11:pub const common = @import(\"common.zig\");\n12:pub const init = @import(\"init.zig\");\n13:pub const create = @import(\"create.zig\");\n14:pub const list = @import(\"list.zig\");\n15:pub const show = @import(\"show.zig\");\n16:pub const update = @import(\"update.zig\");\n17:pub const close = @import(\"close.zig\");\n18:pub const delete = @import(\"delete.zig\");\n19:pub const ready = @import(\"ready.zig\");\n20:pub const dep = @import(\"dep.zig\");\n21:pub const graph = @import(\"graph.zig\");\n22:pub const epic = @import(\"epic.zig\");\n23:pub const sync = @import(\"sync.zig\");\n24:pub const batch = @import(\"batch.zig\");\n25:pub const search = @import(\"search.zig\");\n26:pub const stale = @import(\"stale.zig\");\n27:pub const count = @import(\"count.zig\");\n28:pub const defer_cmd = @import(\"defer.zig\");\n29:pub const label = @import(\"label.zig\");\n30:pub const comments = @import(\"comments.zig\");\n31:pub const history = @import(\"history.zig\");\n32:pub const audit = @import(\"audit.zig\");\n33:pub const changelog = @import(\"changelog.zig\");\n34:pub const info = @import(\"info.zig\");\n35:pub const stats = @import(\"stats.zig\");\n36:pub const doctor = @import(\"doctor.zig\");\n37:pub const config = @import(\"config.zig\");\n38:pub const orphans = @import(\"orphans.zig\");\n39:pub const lint = @import(\"lint.zig\");\n40:pub const version = @import(\"version.zig\");\n41:pub const schema = @import(\"schema.zig\");\n42:pub const completions = @import(\"completions.zig\");\n43:pub const metrics_cmd = @import(\"metrics.zig\");\n44:pub const help = @import(\"help.zig\");\n45:pub const query = @import(\"query.zig\");\n46:pub const upgrade = @import(\"upgrade.zig\");\n47:pub const where = @import(\"where.zig\");\n49:pub const ArgParser = args.ArgParser;\n50:pub const ParseResult = args.ParseResult;\n51:pub const ParseError = args.ParseError;\n52:pub const GlobalOptions = args.GlobalOptions;\n53:pub const Command = args.Command;\n54:pub const InitArgs = args.InitArgs;\n55:pub const CreateArgs = args.CreateArgs;\n56:pub const QuickArgs = args.QuickArgs;\n58:pub const InitError = init.InitError;\n59:pub const InitResult = init.InitResult;\n60:pub const runInit = init.run;\n62:pub const CreateError = create.CreateError;\n63:pub const CreateResult = create.CreateResult;\n64:pub const runCreate = create.run;\n65:pub const runQuick = create.runQuick;\n67:pub const ListError = list.ListError;\n68:pub const ListResult = list.ListResult;\n69:pub const runList = list.run;\n71:pub const ShowError = show.ShowError;\n72:pub const ShowResult = show.ShowResult;\n73:pub const runShow = show.run;\n75:pub const UpdateError = update.UpdateError;\n76:pub const UpdateResult = update.UpdateResult;\n77:pub const runUpdate = update.run;\n79:pub const CloseError = close.CloseError;\n80:pub const CloseResult = close.CloseResult;\n81:pub const runClose = close.run;\n82:pub const runReopen = close.runReopen;\n84:pub const DeleteError = delete.DeleteError;\n85:pub const DeleteResult = delete.DeleteResult;\n86:pub const runDelete = delete.run;\n88:pub const ReadyError = ready.ReadyError;\n89:pub const ReadyResult = ready.ReadyResult;\n90:pub const runReady = ready.run;\n91:pub const runBlocked = ready.runBlocked;\n93:pub const DepError = dep.DepError;\n94:pub const DepResult = dep.DepResult;\n95:pub const runDep = dep.run;\n97:pub const GraphError = graph.GraphError;\n98:pub const GraphResult = graph.GraphResult;\n99:pub const runGraph = graph.run;\n101:pub const EpicError = epic.EpicError;\n102:pub const EpicResult = epic.EpicResult;\n103:pub const runEpic = epic.run;\n105:pub const SyncError = sync.SyncError;\n106:pub const SyncResult = sync.SyncResult;\n107:pub const runSync = sync.run;\n109:pub const BatchError = batch.BatchError;\n110:pub const BatchResult = batch.BatchResult;\n111:pub const ImportResult = batch.ImportResult;\n112:pub const runAddBatch = batch.runAddBatch;\n113:pub const runImportCmd = batch.runImport;\n115:pub const AddBatchArgs = args.AddBatchArgs;\n116:pub const BatchFormat = args.BatchFormat;\n117:pub const ImportArgs = args.ImportArgs;\n118:pub const EpicArgs = args.EpicArgs;\n119:pub const SortField = args.SortField;\n121:pub const SearchError = search.SearchError;\n122:pub const SearchResult = search.SearchResult;\n123:pub const runSearch = search.run;\n125:pub const runStale = stale.run;\n127:pub const runCount = count.run;\n129:pub const runDefer = defer_cmd.run;\n130:pub const runUndefer = defer_cmd.runUndefer;\n132:pub const LabelError = label.LabelError;\n133:pub const LabelResult = label.LabelResult;\n134:pub const runLabel = label.run;\n136:pub const CommentsError = comments.CommentsError;\n137:pub const CommentsResult = comments.CommentsResult;\n138:pub const runComments = comments.run;\n140:pub const HistoryError = history.HistoryError;\n141:pub const HistoryResult = history.HistoryResult;\n142:pub const runHistory = history.run;\n144:pub const AuditError = audit.AuditError;\n145:pub const AuditResult = audit.AuditResult;\n146:pub const runAudit = audit.run;\n148:pub const ChangelogError = changelog.ChangelogError;\n149:pub const ChangelogResult = changelog.ChangelogResult;\n150:pub const runChangelog = changelog.run;\n151:pub const ChangelogArgs = args.ChangelogArgs;\n153:pub const InfoError = info.InfoError;\n154:pub const InfoResult = info.InfoResult;\n155:pub const runInfo = info.run;\n157:pub const StatsError = stats.StatsError;\n158:pub const StatsResult = stats.StatsResult;\n159:pub const runStats = stats.run;\n161:pub const DoctorError = doctor.DoctorError;\n162:pub const DoctorResult = doctor.DoctorResult;\n163:pub const runDoctor = doctor.run;\n165:pub const ConfigError = config.ConfigError;\n166:pub const ConfigResult = config.ConfigResult;\n167:pub const runConfig = config.run;\n169:pub const OrphansError = orphans.OrphansError;\n170:pub const OrphansResult = orphans.OrphansResult;\n171:pub const runOrphans = orphans.run;\n173:pub const LintError = lint.LintError;\n174:pub const LintResult = lint.LintResult;\n175:pub const runLint = lint.run;\n177:pub const OrphansArgs = args.OrphansArgs;\n178:pub const LintArgs = args.LintArgs;\n180:pub const VersionError = version.VersionError;\n181:pub const VersionResult = version.VersionResult;\n182:pub const runVersion = version.run;\n183:pub const VERSION = version.VERSION;\n185:pub const SchemaError = schema.SchemaError;\n186:pub const SchemaResult = schema.SchemaResult;\n187:pub const runSchema = schema.run;\n189:pub const CompletionsError = completions.CompletionsError;\n190:pub const CompletionsResult = completions.CompletionsResult;\n191:pub const runCompletions = completions.run;\n192:pub const Shell = completions.Shell;\n194:pub const MetricsError = metrics_cmd.MetricsError;\n195:pub const MetricsResult = metrics_cmd.MetricsResult;\n196:pub const runMetrics = metrics_cmd.run;\n197:pub const MetricsArgs = args.MetricsArgs;\n199:pub const HelpError = help.HelpError;\n200:pub const HelpResult = help.HelpResult;\n201:pub const runHelp = help.run;\n203:pub const QueryError = query.QueryError;\n204:pub const QueryResult = query.QueryResult;\n205:pub const runQuery = query.run;\n206:pub const QueryArgs = args.QueryArgs;\n208:pub const UpgradeError = upgrade.UpgradeError;\n209:pub const UpgradeResult = upgrade.UpgradeResult;\n210:pub const runUpgrade = upgrade.run;\n211:pub const UpgradeArgs = args.UpgradeArgs;\n213:pub const WhereError = where.WhereError;\n214:pub const WhereResult = where.WhereResult;\n215:pub const runWhere = where.run;","numLines":167}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D4TaeEek1SYhTPQjawA1Ta","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q3W2CMiGZCS95n4v2s8gka","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","offset":105,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2592,"cache_read_input_tokens":132459,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2592},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e1fe4adf-0eb6-487f-adc0-ce11a25a657a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q3W2CMiGZCS95n4v2s8gka","type":"tool_result","content":"   105→pub const SyncError = sync.SyncError;\n   106→pub const SyncResult = sync.SyncResult;\n   107→pub const runSync = sync.run;\n   108→\n   109→pub const BatchError = batch.BatchError;\n   110→pub const BatchResult = batch.BatchResult;\n   111→pub const ImportResult = batch.ImportResult;\n   112→pub const runAddBatch = batch.runAddBatch;\n   113→pub const runImportCmd = batch.runImport;\n   114→\n   115→pub const AddBatchArgs = args.AddBatchArgs;\n   116→pub const BatchFormat = args.BatchFormat;\n   117→pub const ImportArgs = args.ImportArgs;\n   118→pub const EpicArgs = args.EpicArgs;\n   119→pub const SortField = args.SortField;\n   120→\n   121→pub const SearchError = search.SearchError;\n   122→pub const SearchResult = search.SearchResult;\n   123→pub const runSearch = search.run;\n   124→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2a6365a7-5aa4-4117-8130-eb342e8f5f34","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","content":"pub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n","numLines":20,"startLine":105,"totalLines":220}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014JNVhSnzDedUp7RFfMsCat","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A7VgPWhaB2BWo4G4NvmYj2","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","old_string":"pub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;","new_string":"pub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const backup = @import(\"backup.zig\");\npub const BackupError = backup.BackupError;\npub const BackupResult = backup.BackupResult;\npub const runBackup = backup.run;\npub const BackupArgs = args.BackupArgs;\n\npub const BatchError = batch.BatchError;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":458,"cache_read_input_tokens":135051,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":458},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"18d88ee1-9174-45d3-a8e8-b330803a2c2b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A7VgPWhaB2BWo4G4NvmYj2","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"41fd98ed-353b-4641-be1f-f5bd5d1a56d9","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","oldString":"pub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;","newString":"pub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const backup = @import(\"backup.zig\");\npub const BackupError = backup.BackupError;\npub const BackupResult = backup.BackupResult;\npub const runBackup = backup.run;\npub const BackupArgs = args.BackupArgs;\n\npub const BatchError = batch.BatchError;","originalFile":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\npub const WhereError = where.WhereError;\npub const WhereResult = where.WhereResult;\npub const runWhere = where.run;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","structuredPatch":[{"oldStart":106,"oldLines":6,"newStart":106,"newLines":12,"lines":[" pub const SyncResult = sync.SyncResult;"," pub const runSync = sync.run;"," ","+pub const backup = @import(\"backup.zig\");","+pub const BackupError = backup.BackupError;","+pub const BackupResult = backup.BackupResult;","+pub const runBackup = backup.run;","+pub const BackupArgs = args.BackupArgs;","+"," pub const BatchError = batch.BatchError;"," pub const BatchResult = batch.BatchResult;"," pub const ImportResult = batch.ImportResult;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01F7YupU1AM5XNuecLCa9D8X","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's build and test."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":322,"cache_read_input_tokens":135509,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":322},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2df90be4-ab5b-4a23-bb35-5c01511fc011"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01F7YupU1AM5XNuecLCa9D8X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MXPdaTrfsFpbP1G2D1zg7p","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build the project to check for errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":322,"cache_read_input_tokens":135509,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":322},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4bfd09ac-6518-4acb-9418-3c441d27b242"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MXPdaTrfsFpbP1G2D1zg7p","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b1e99049-bea7-4cef-ae90-9197b522cb1a","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JbXM7nvKUaMQo1i1XvuBAB","type":"message","role":"assistant","content":[{"type":"text","text":"The build succeeded silently. Let me run the tests."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":346,"cache_read_input_tokens":135831,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":346},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"33198538-1d5a-40f0-96e9-e4499fc1778b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JbXM7nvKUaMQo1i1XvuBAB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011RysDZ9dCAcx3pyo2Xohyc","name":"Bash","input":{"command":"zig build test 2>&1 | tail -30","description":"Run tests to verify changes","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":346,"cache_read_input_tokens":135831,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":346},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e2a43aa7-1ae6-4e56-a408-c74449832d07"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011RysDZ9dCAcx3pyo2Xohyc","type":"tool_result","content":"657/678 tests.cli_test.test.bz create returns ID...OK\n658/678 tests.cli_test.test.bz q returns ID...OK\n659/678 tests.cli_test.test.bz list returns issues...OK\n660/678 tests.cli_test.test.bz list --json returns output...OK\n661/678 tests.cli_test.test.bz show displays issue...OK\n662/678 tests.cli_test.test.bz show not-found returns error...OK\n663/678 tests.cli_test.test.bz close marks issue as closed...OK\n664/678 tests.cli_test.test.bz reopen reopens closed issue...OK\n665/678 tests.cli_test.test.bz delete soft deletes issue...OK\n666/678 tests.cli_test.test.bz search finds matching issues...OK\n667/678 tests.cli_test.test.bz dep add creates dependency...OK\n668/678 tests.cli_test.test.bz dep add rejects cycles...OK\n669/678 tests.cli_test.test.bz ready shows unblocked issues...OK\n670/678 tests.cli_test.test.bz blocked shows blocked issues...OK\n671/678 tests.cli_test.test.bz unknown command returns error...OK\n672/678 tests.cli_test.test.bz without workspace shows error...OK\n673/678 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n674/678 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n675/678 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 69 issues created\nOK\n676/678 tests.stress_test.test.sequential writes: single thread baseline...OK\n677/678 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n678/678 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 678 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7d63ad2a-ca99-438f-86e9-de22f8ec8eb0","tool_use_result":{"stdout":"657/678 tests.cli_test.test.bz create returns ID...OK\n658/678 tests.cli_test.test.bz q returns ID...OK\n659/678 tests.cli_test.test.bz list returns issues...OK\n660/678 tests.cli_test.test.bz list --json returns output...OK\n661/678 tests.cli_test.test.bz show displays issue...OK\n662/678 tests.cli_test.test.bz show not-found returns error...OK\n663/678 tests.cli_test.test.bz close marks issue as closed...OK\n664/678 tests.cli_test.test.bz reopen reopens closed issue...OK\n665/678 tests.cli_test.test.bz delete soft deletes issue...OK\n666/678 tests.cli_test.test.bz search finds matching issues...OK\n667/678 tests.cli_test.test.bz dep add creates dependency...OK\n668/678 tests.cli_test.test.bz dep add rejects cycles...OK\n669/678 tests.cli_test.test.bz ready shows unblocked issues...OK\n670/678 tests.cli_test.test.bz blocked shows blocked issues...OK\n671/678 tests.cli_test.test.bz unknown command returns error...OK\n672/678 tests.cli_test.test.bz without workspace shows error...OK\n673/678 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n674/678 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n675/678 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 69 issues created\nOK\n676/678 tests.stress_test.test.sequential writes: single thread baseline...OK\n677/678 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n678/678 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 678 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QtrKFo88kUk4681FsK5Kep","type":"message","role":"assistant","content":[{"type":"text","text":"All 678 tests passed (4 more than before due to the new backup tests). Let me update the todo list and do a quick manual test of the commands."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":669,"cache_read_input_tokens":136177,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":669},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"52ca2cd0-9da4-46e9-8796-62105e9c39ad"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QtrKFo88kUk4681FsK5Kep","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019gf4nhvNUYc6S8q77Qohm5","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"completed","activeForm":"Adding backup command"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":669,"cache_read_input_tokens":136177,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":669},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"b79d8459-6873-4a53-b7a0-e848e6198857"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019gf4nhvNUYc6S8q77Qohm5","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"98139d38-8ccd-403c-b088-f618c3d8e3d8","tool_use_result":{"oldTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"in_progress","activeForm":"Adding backup command"},{"content":"Add BackupArgs and BackupSubcommand to args.zig","status":"completed","activeForm":"Adding BackupArgs to args.zig"},{"content":"Create src/cli/backup.zig with list/diff/restore/prune","status":"completed","activeForm":"Creating backup.zig"},{"content":"Add backup command to help.zig","status":"completed","activeForm":"Adding backup to help.zig"},{"content":"Wire up backup command in main.zig","status":"in_progress","activeForm":"Wiring backup in main.zig"}],"newTodos":[{"content":"Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)","status":"completed","activeForm":"Adding sync policy options"},{"content":"Task 2: Add backup command for JSONL backup management","status":"completed","activeForm":"Adding backup command"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TZbHnpv43Ms2tZNuGBGdmk","type":"message","role":"assistant","content":[{"type":"text","text":"Let me do a quick test of the new commands in the sandbox directory."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":208,"cache_read_input_tokens":136846,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":208},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4dc5d5ae-503e-4331-b83e-0b31a096b874"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TZbHnpv43Ms2tZNuGBGdmk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VP1UU5i21i2NJRz82ziW5L","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig/sandbox && rm -rf .beads && ../zig-out/bin/bz init && ../zig-out/bin/bz create \"Test issue 1\" && ../zig-out/bin/bz create \"Test issue 2\" && echo \"--- Testing help ---\" && ../zig-out/bin/bz help sync | head -30","description":"Test sync help with new flags"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":208,"cache_read_input_tokens":136846,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":208},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"fd712c70-d18c-4d68-83a3-10701c4bbf22"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VP1UU5i21i2NJRz82ziW5L","type":"tool_result","content":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-hyt\nCreated issue bd-33l\n--- Testing help ---\nsync\n\nSync with JSONL file\n\nUSAGE:\n  bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\n\nDESCRIPTION:\n  Synchronizes in-memory state with the JSONL file. By default, performs\n  bidirectional sync. Use flags to limit to export or import only.\n\nFLAGS:\n      --flush-only\n      Only export (write to JSONL)\n      --import-only\n      Only import (read from JSONL)\n  -s, --status\n      Show sync status without changes\n      --manifest\n      Write manifest.json with export metadata\n  -m, --merge\n      3-way merge with remote JSONL\n      --error-policy <POLICY>\n      Export error handling: strict (default), best-effort, partial\n      --orphans <POLICY>\n      Import orphan handling: strict (default), resurrect, skip\n      --rename-prefix\n      Fix issues with wrong prefix during import\n\nEXAMPLES:","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"626e67d3-1169-4a43-8e8a-2eefc7357626","tool_use_result":{"stdout":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-hyt\nCreated issue bd-33l\n--- Testing help ---\nsync\n\nSync with JSONL file\n\nUSAGE:\n  bz sync [--flush-only] [--import-only] [--status] [--manifest] [--error-policy POLICY] [--orphans POLICY] [--rename-prefix]\n\nDESCRIPTION:\n  Synchronizes in-memory state with the JSONL file. By default, performs\n  bidirectional sync. Use flags to limit to export or import only.\n\nFLAGS:\n      --flush-only\n      Only export (write to JSONL)\n      --import-only\n      Only import (read from JSONL)\n  -s, --status\n      Show sync status without changes\n      --manifest\n      Write manifest.json with export metadata\n  -m, --merge\n      3-way merge with remote JSONL\n      --error-policy <POLICY>\n      Export error handling: strict (default), best-effort, partial\n      --orphans <POLICY>\n      Import orphan handling: strict (default), resurrect, skip\n      --rename-prefix\n      Fix issues with wrong prefix during import\n\nEXAMPLES:","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Go95uUKm9jyGWztqc4qXnG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S7rkbfmFR4utjjAkeMMGLF","name":"Bash","input":{"command":"echo \"--- Testing backup help ---\" && ../zig-out/bin/bz help backup","description":"Test backup help"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":495,"cache_read_input_tokens":137054,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":495},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"629696a3-c265-43e4-9c86-bbcb4f695a81"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S7rkbfmFR4utjjAkeMMGLF","type":"tool_result","content":"--- Testing backup help ---\nbackup (backups)\n\nManage JSONL backup files\n\nUSAGE:\n  bz backup <subcommand> [args]\n\nDESCRIPTION:\n  Manage JSONL backup files. Create backups before major operations, compare\n  backups with current state, restore from backups, and prune old backups.\n\nARGUMENTS:\n  subcommand (required)\n      list, diff, restore, prune, or create\n\nFLAGS:\n  -k, --keep <N>\n      Keep N most recent backups (prune, default: 10)\n  -n, --dry-run\n      Show what would be done without making changes\n\nEXAMPLES:\n  $ bz backup list\n    List available backups\n\n  $ bz backup create\n    Create a new backup\n\n  $ bz backup diff issues.jsonl.bak.123\n    Compare backup with current\n\n  $ bz backup restore issues.jsonl.bak.123\n    Restore from backup\n\n  $ bz backup restore issues.jsonl.bak.123 --dry-run\n    Preview restore\n\n  $ bz backup prune --keep 5\n    Keep only 5 most recent backups\n\nSEE ALSO:\n  sync, import","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"8eaa93cb-719a-472f-9ce5-db4d4aaf89b6","tool_use_result":{"stdout":"--- Testing backup help ---\nbackup (backups)\n\nManage JSONL backup files\n\nUSAGE:\n  bz backup <subcommand> [args]\n\nDESCRIPTION:\n  Manage JSONL backup files. Create backups before major operations, compare\n  backups with current state, restore from backups, and prune old backups.\n\nARGUMENTS:\n  subcommand (required)\n      list, diff, restore, prune, or create\n\nFLAGS:\n  -k, --keep <N>\n      Keep N most recent backups (prune, default: 10)\n  -n, --dry-run\n      Show what would be done without making changes\n\nEXAMPLES:\n  $ bz backup list\n    List available backups\n\n  $ bz backup create\n    Create a new backup\n\n  $ bz backup diff issues.jsonl.bak.123\n    Compare backup with current\n\n  $ bz backup restore issues.jsonl.bak.123\n    Restore from backup\n\n  $ bz backup restore issues.jsonl.bak.123 --dry-run\n    Preview restore\n\n  $ bz backup prune --keep 5\n    Keep only 5 most recent backups\n\nSEE ALSO:\n  sync, import","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011dyY8bFfoVHEkfuC9deXDS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KWTKDVuoKR7dXnrfTYVsdi","name":"Bash","input":{"command":"echo \"--- Testing backup list ---\" && ../zig-out/bin/bz backup list && echo \"--- Testing backup create ---\" && ../zig-out/bin/bz backup create && echo \"--- Testing backup list after create ---\" && ../zig-out/bin/bz backup list","description":"Test backup commands"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":388,"cache_read_input_tokens":137549,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":388},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f995c666-79e8-4eec-82d5-ed20ca32b560"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KWTKDVuoKR7dXnrfTYVsdi","type":"tool_result","content":"--- Testing backup list ---\nNo backups found\n--- Testing backup create ---\nCreated backup: issues.jsonl.bak.1770024589\n--- Testing backup list after create ---\nAvailable backups:\n  issues.jsonl.bak.1770024589 (0 bytes)","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c83bacd8-3b2c-462b-b955-8181272975f5","tool_use_result":{"stdout":"--- Testing backup list ---\nNo backups found\n--- Testing backup create ---\nCreated backup: issues.jsonl.bak.1770024589\n--- Testing backup list after create ---\nAvailable backups:\n  issues.jsonl.bak.1770024589 (0 bytes)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017U2nRvYd6t71CcbXk1n7m3","type":"message","role":"assistant","content":[{"type":"text","text":"The backup commands work. Now let me test the sync flags."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":213,"cache_read_input_tokens":137937,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":213},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ac945a3f-c723-4c01-a466-e74016ad73b3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017U2nRvYd6t71CcbXk1n7m3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NpRYrXsKauuh2oDL3xgytQ","name":"Bash","input":{"command":"echo \"--- Testing sync --flush-only with --error-policy ---\" && ../zig-out/bin/bz sync --flush-only --error-policy best-effort && echo \"--- Testing sync --status ---\" && ../zig-out/bin/bz sync --status","description":"Test sync policy flags"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":213,"cache_read_input_tokens":137937,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":213},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4067e880-57a5-4163-b5ea-a6919401e6cd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NpRYrXsKauuh2oDL3xgytQ","type":"tool_result","content":"--- Testing sync --flush-only with --error-policy ---\nExported 2 issue(s) to JSONL\n--- Testing sync --status ---\nDB: 2 issues, JSONL: 2 issues\nNo pending changes","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"f2b0b6fd-3309-46d3-9992-73b0a078a789","tool_use_result":{"stdout":"--- Testing sync --flush-only with --error-policy ---\nExported 2 issue(s) to JSONL\n--- Testing sync --status ---\nDB: 2 issues, JSONL: 2 issues\nNo pending changes","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KHga2Ygc7uVzTZ5Kjqyk1j","type":"message","role":"assistant","content":[{"type":"text","text":"All commands work. Now let me commit the changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":214,"cache_read_input_tokens":138150,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":214},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ca7e67d8-962a-4b63-888a-ae5cafcd7600"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KHga2Ygc7uVzTZ5Kjqyk1j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011apJzkwhXjYPoN7QpuYkBk","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":214,"cache_read_input_tokens":138150,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":214},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"7c9eea68-7183-4e6a-a152-8a4abd745c54"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011apJzkwhXjYPoN7QpuYkBk","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 34 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/help.zig\n\tmodified:   src/cli/mod.zig\n\tmodified:   src/cli/sync.zig\n\tmodified:   src/main.zig\n\tmodified:   src/storage/store.zig\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tsrc/cli/backup.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"4fdca434-582f-428a-8dee-58c4139b2ce3","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 34 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/help.zig\n\tmodified:   src/cli/mod.zig\n\tmodified:   src/cli/sync.zig\n\tmodified:   src/main.zig\n\tmodified:   src/storage/store.zig\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tsrc/cli/backup.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VweBuWroyc8k2tmggXLzqV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QwiBMEM7RDHR43KUoGAocc","name":"Bash","input":{"command":"git diff src/cli/args.zig | head -100","description":"View args.zig changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":359,"cache_read_input_tokens":138364,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":359},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"6adc5a1c-f0b8-46f0-8b96-516265a7e6e6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QwiBMEM7RDHR43KUoGAocc","type":"tool_result","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 1171dd8..1a80844 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -91,6 +91,9 @@ pub const Command = union(enum) {\n     // Sync\n     sync: SyncArgs,\n \n+    // Backup\n+    backup: BackupArgs,\n+\n     // System\n     version: void,\n     schema: void,\n@@ -484,6 +487,34 @@ pub const ChangelogArgs = struct {\n     group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n };\n \n+/// Error policy for export operations.\n+pub const ErrorPolicy = enum {\n+    strict, // Fail on any error\n+    best_effort, // Continue on errors, report at end\n+    partial, // Export what we can, skip errors silently\n+\n+    pub fn fromString(s: []const u8) ?ErrorPolicy {\n+        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n+        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n+        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n+        return null;\n+    }\n+};\n+\n+/// Orphan handling policy for import operations.\n+pub const OrphanPolicy = enum {\n+    strict, // Fail if orphans detected\n+    resurrect, // Create placeholder parents for orphans\n+    skip, // Skip orphaned issues silently\n+\n+    pub fn fromString(s: []const u8) ?OrphanPolicy {\n+        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n+        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n+        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n+        return null;\n+    }\n+};\n+\n /// Sync command arguments.\n pub const SyncArgs = struct {\n     flush_only: bool = false,\n@@ -491,6 +522,31 @@ pub const SyncArgs = struct {\n     merge: bool = false,\n     status: bool = false,\n     manifest: bool = false,\n+    error_policy: ErrorPolicy = .strict,\n+    orphan_policy: OrphanPolicy = .strict,\n+    rename_prefix: bool = false,\n+};\n+\n+/// Backup subcommand variants.\n+pub const BackupSubcommand = union(enum) {\n+    list: void,\n+    diff: struct {\n+        file: []const u8,\n+    },\n+    restore: struct {\n+        file: []const u8,\n+        dry_run: bool = false,\n+    },\n+    prune: struct {\n+        keep: u32 = 10,\n+        dry_run: bool = false,\n+    },\n+    create: void,\n+};\n+\n+/// Backup command arguments.\n+pub const BackupArgs = struct {\n+    subcommand: BackupSubcommand,\n };\n \n /// Shell completion types.\n@@ -864,6 +920,11 @@ pub const ArgParser = struct {\n             return .{ .sync = try self.parseSyncArgs() };\n         }\n \n+        // Backup\n+        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n+            return .{ .backup = try self.parseBackupArgs() };\n+        }\n+\n         // System\n         if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n             return .{ .version = {} };\n@@ -1527,11 +1588,58 @@ pub const ArgParser = struct {\n                 result.status = true;\n             } else if (self.consumeFlag(null, \"--manifest\")) {\n                 result.manifest = true;\n+            } else if (self.consumeFlag(null, \"--error-policy\")) {\n+                const policy_str = self.next() orelse return error.MissingFlagValue;\n+                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"ba87930d-cd42-4cb5-9674-8aa7c48846d8","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 1171dd8..1a80844 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -91,6 +91,9 @@ pub const Command = union(enum) {\n     // Sync\n     sync: SyncArgs,\n \n+    // Backup\n+    backup: BackupArgs,\n+\n     // System\n     version: void,\n     schema: void,\n@@ -484,6 +487,34 @@ pub const ChangelogArgs = struct {\n     group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n };\n \n+/// Error policy for export operations.\n+pub const ErrorPolicy = enum {\n+    strict, // Fail on any error\n+    best_effort, // Continue on errors, report at end\n+    partial, // Export what we can, skip errors silently\n+\n+    pub fn fromString(s: []const u8) ?ErrorPolicy {\n+        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n+        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n+        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n+        return null;\n+    }\n+};\n+\n+/// Orphan handling policy for import operations.\n+pub const OrphanPolicy = enum {\n+    strict, // Fail if orphans detected\n+    resurrect, // Create placeholder parents for orphans\n+    skip, // Skip orphaned issues silently\n+\n+    pub fn fromString(s: []const u8) ?OrphanPolicy {\n+        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n+        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n+        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n+        return null;\n+    }\n+};\n+\n /// Sync command arguments.\n pub const SyncArgs = struct {\n     flush_only: bool = false,\n@@ -491,6 +522,31 @@ pub const SyncArgs = struct {\n     merge: bool = false,\n     status: bool = false,\n     manifest: bool = false,\n+    error_policy: ErrorPolicy = .strict,\n+    orphan_policy: OrphanPolicy = .strict,\n+    rename_prefix: bool = false,\n+};\n+\n+/// Backup subcommand variants.\n+pub const BackupSubcommand = union(enum) {\n+    list: void,\n+    diff: struct {\n+        file: []const u8,\n+    },\n+    restore: struct {\n+        file: []const u8,\n+        dry_run: bool = false,\n+    },\n+    prune: struct {\n+        keep: u32 = 10,\n+        dry_run: bool = false,\n+    },\n+    create: void,\n+};\n+\n+/// Backup command arguments.\n+pub const BackupArgs = struct {\n+    subcommand: BackupSubcommand,\n };\n \n /// Shell completion types.\n@@ -864,6 +920,11 @@ pub const ArgParser = struct {\n             return .{ .sync = try self.parseSyncArgs() };\n         }\n \n+        // Backup\n+        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n+            return .{ .backup = try self.parseBackupArgs() };\n+        }\n+\n         // System\n         if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n             return .{ .version = {} };\n@@ -1527,11 +1588,58 @@ pub const ArgParser = struct {\n                 result.status = true;\n             } else if (self.consumeFlag(null, \"--manifest\")) {\n                 result.manifest = true;\n+            } else if (self.consumeFlag(null, \"--error-policy\")) {\n+                const policy_str = self.next() orelse return error.MissingFlagValue;\n+                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ViDcemPwMU8QcczK7f5iSR","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the changed files and create a commit."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1256,"cache_read_input_tokens":138723,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1256},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"fdd258a8-1dbb-4735-8aef-8e4f300f0eea"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ViDcemPwMU8QcczK7f5iSR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DWevdiCoREczVimnhH5Xqf","name":"Bash","input":{"command":"git add src/cli/args.zig src/cli/help.zig src/cli/mod.zig src/cli/sync.zig src/cli/backup.zig src/main.zig src/storage/store.zig","description":"Add changed files to staging"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1256,"cache_read_input_tokens":138723,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1256},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"e86c2016-134e-4a24-8b9a-f0cb671e00b1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DWevdiCoREczVimnhH5Xqf","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"5fdb52bc-4909-4ed8-9481-166801162e8a","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E1otX51MMA24JZkeWT3y6M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Rw7DE6wzBHQTjSPQjTmC4T","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nfeat(sync,backup): add sync policy options and backup command\n\nTask 1: Add sync policy options\n- Add --error-policy flag for export error handling (strict/best-effort/partial)\n- Add --orphans flag for import orphan handling (strict/resurrect/skip)\n- Add --rename-prefix flag to fix wrong prefixes during import\n- Add ErrorPolicy and OrphanPolicy enums to args.zig\n- Update runFlush to respect error_policy\n- Update runImport to handle orphans and rename prefixes\n- Add getPrefix() and rebuildIndex() helpers to IssueStore\n\nTask 2: Add backup command for JSONL backup management\n- Add BackupArgs and BackupSubcommand to args.zig\n- Create backup.zig with list/diff/restore/prune/create subcommands\n- Wire up backup command in main.zig and cli/mod.zig\n- Add backup command help documentation\n\nTests: All 678 tests pass (4 new backup tests added)\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Create commit with all changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":254,"cache_read_input_tokens":139979,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":254},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"2f77e215-46a1-4ccc-9793-e63c14bad983"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Rw7DE6wzBHQTjSPQjTmC4T","type":"tool_result","content":"[dev-hotschmoe bd756fc] feat(sync,backup): add sync policy options and backup command\n 7 files changed, 834 insertions(+), 14 deletions(-)\n create mode 100644 src/cli/backup.zig","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"9282d0a1-e7ed-4d59-81ee-4b2062f5583a","tool_use_result":{"stdout":"[dev-hotschmoe bd756fc] feat(sync,backup): add sync policy options and backup command\n 7 files changed, 834 insertions(+), 14 deletions(-)\n create mode 100644 src/cli/backup.zig","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FuCma3y3gWhHQ24a1iDET7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YVcXofZUAwUekReSmVo7MH","name":"Bash","input":{"command":"git status","description":"Verify git status after commit"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":418,"cache_read_input_tokens":140233,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":418},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"c20b9f51-d523-40d6-ab25-599ca222aed1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YVcXofZUAwUekReSmVo7MH","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 35 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"73c95e11-4b64-401d-99de-a6ed632524d2","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 35 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014hLJm2XdqYDoSruxqsmkce","type":"message","role":"assistant","content":[{"type":"text","text":"Both tasks have been completed successfully. Here's the summary:\n\n## Task Status Report\n\n### Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)\n**Status: SUCCESS**\n\nImplemented:\n- `--error-policy <strict|best-effort|partial>` - Controls export error handling\n- `--orphans <strict|resurrect|skip>` - Controls orphan handling on import\n- `--rename-prefix` - Fixes issues with wrong ID prefix during import\n\nChanges made:\n- `src/cli/args.zig`: Added `ErrorPolicy`, `OrphanPolicy` enums and updated `SyncArgs` struct\n- `src/cli/sync.zig`: Updated `runFlush` and `runImport` to use the new policies\n- `src/cli/help.zig`: Added documentation for new flags\n- `src/storage/store.zig`: Added `getPrefix()` and `rebuildIndex()` helper methods\n\n### Task 2: Add backup command for JSONL backup management\n**Status: SUCCESS**\n\nImplemented subcommands:\n- `bz backup list` - List available backups\n- `bz backup create` - Create a new backup\n- `bz backup diff <file>` - Compare backup with current state\n- `bz backup restore <file> [--dry-run]` - Restore from backup\n- `bz backup prune [--keep N] [--dry-run]` - Remove old backups keeping N most recent\n\nChanges made:\n- `src/cli/args.zig`: Added `BackupArgs`, `BackupSubcommand`\n- `src/cli/backup.zig`: New file with full backup command implementation\n- `src/cli/mod.zig`: Added backup exports\n- `src/cli/help.zig`: Added backup command documentation\n- `src/main.zig`: Wired up backup command dispatch\n\n**Tests:** All 678 tests passed (4 new backup tests added)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":223,"cache_read_input_tokens":140651,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":223},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","uuid":"428e7153-b0b4-4d38-b480-587a5e2a1def"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":564155,"duration_api_ms":574531,"num_turns":76,"result":"Both tasks have been completed successfully. Here's the summary:\n\n## Task Status Report\n\n### Task 1: Add sync policy options (--error-policy, --orphans, --rename-prefix)\n**Status: SUCCESS**\n\nImplemented:\n- `--error-policy <strict|best-effort|partial>` - Controls export error handling\n- `--orphans <strict|resurrect|skip>` - Controls orphan handling on import\n- `--rename-prefix` - Fixes issues with wrong ID prefix during import\n\nChanges made:\n- `src/cli/args.zig`: Added `ErrorPolicy`, `OrphanPolicy` enums and updated `SyncArgs` struct\n- `src/cli/sync.zig`: Updated `runFlush` and `runImport` to use the new policies\n- `src/cli/help.zig`: Added documentation for new flags\n- `src/storage/store.zig`: Added `getPrefix()` and `rebuildIndex()` helper methods\n\n### Task 2: Add backup command for JSONL backup management\n**Status: SUCCESS**\n\nImplemented subcommands:\n- `bz backup list` - List available backups\n- `bz backup create` - Create a new backup\n- `bz backup diff <file>` - Compare backup with current state\n- `bz backup restore <file> [--dry-run]` - Restore from backup\n- `bz backup prune [--keep N] [--dry-run]` - Remove old backups keeping N most recent\n\nChanges made:\n- `src/cli/args.zig`: Added `BackupArgs`, `BackupSubcommand`\n- `src/cli/backup.zig`: New file with full backup command implementation\n- `src/cli/mod.zig`: Added backup exports\n- `src/cli/help.zig`: Added backup command documentation\n- `src/main.zig`: Wired up backup command dispatch\n\n**Tests:** All 678 tests passed (4 new backup tests added)","session_id":"32d43a1b-6f50-4ceb-9167-f3168bbcddbe","total_cost_usd":5.4327833,"usage":{"input_tokens":2,"cache_creation_input_tokens":122898,"cache_read_input_tokens":7630754,"output_tokens":27528,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":122898,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":27528,"cacheReadInputTokens":7630754,"cacheCreationInputTokens":122898,"webSearchRequests":0,"costUSD":5.271699500000001,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":40502,"outputTokens":6597,"cacheReadInputTokens":501318,"cacheCreationInputTokens":29972,"webSearchRequests":0,"costUSD":0.16108379999999994,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"e32ca170-ac0e-4623-ab3d-a3d642f24f85"}
