{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"33516885-2901-4530-a8d8-dd93127430a3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XQbFtMqCWhau3Q6rbcDXCA","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement these two tasks in order. Let me start by understanding the current codebase structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21141,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21141},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"165e84b7-6076-495d-9678-2f660c7868e7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XQbFtMqCWhau3Q6rbcDXCA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FzQD7bJQEqgX7uDmpzz7kF","name":"TodoWrite","input":{"todos":[{"content":"Add 'where' command - show active .beads directory","status":"in_progress","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"pending","activeForm":"Adding missing issue fields"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21141,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21141},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"602999e6-88b6-459a-ad30-a72ffcfb58c8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FzQD7bJQEqgX7uDmpzz7kF","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"88e7ed35-86e6-4495-9b1a-d968914312a4","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Add 'where' command - show active .beads directory","status":"in_progress","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"pending","activeForm":"Adding missing issue fields"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XNEbmUsFsFwrCtuDZihdmC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HaXttjfjLRcwnBbDVxfT5A","name":"Glob","input":{"pattern":"src/cli/*.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":195,"cache_read_input_tokens":39117,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":195},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"97495bf1-957e-4f6c-b016-ad0fd4df49e9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HaXttjfjLRcwnBbDVxfT5A","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/label.zig\n/home/hotschmoe/beads_zig/src/cli/close.zig\n/home/hotschmoe/beads_zig/src/cli/help.zig\n/home/hotschmoe/beads_zig/src/cli/delete.zig\n/home/hotschmoe/beads_zig/src/cli/audit.zig\n/home/hotschmoe/beads_zig/src/cli/common.zig\n/home/hotschmoe/beads_zig/src/cli/comments.zig\n/home/hotschmoe/beads_zig/src/cli/batch.zig\n/home/hotschmoe/beads_zig/src/cli/list.zig\n/home/hotschmoe/beads_zig/src/cli/metrics.zig\n/home/hotschmoe/beads_zig/src/cli/doctor.zig\n/home/hotschmoe/beads_zig/src/cli/epic.zig\n/home/hotschmoe/beads_zig/src/cli/config.zig\n/home/hotschmoe/beads_zig/src/cli/lint.zig\n/home/hotschmoe/beads_zig/src/cli/dep.zig\n/home/hotschmoe/beads_zig/src/cli/changelog.zig\n/home/hotschmoe/beads_zig/src/cli/history.zig\n/home/hotschmoe/beads_zig/src/cli/init.zig\n/home/hotschmoe/beads_zig/src/cli/defer.zig\n/home/hotschmoe/beads_zig/src/cli/completions.zig\n/home/hotschmoe/beads_zig/src/cli/info.zig\n/home/hotschmoe/beads_zig/src/cli/graph.zig\n/home/hotschmoe/beads_zig/src/cli/count.zig\n/home/hotschmoe/beads_zig/src/cli/update.zig\n/home/hotschmoe/beads_zig/src/cli/version.zig\n/home/hotschmoe/beads_zig/src/cli/schema.zig\n/home/hotschmoe/beads_zig/src/cli/stats.zig\n/home/hotschmoe/beads_zig/src/cli/sync.zig\n/home/hotschmoe/beads_zig/src/cli/show.zig\n/home/hotschmoe/beads_zig/src/cli/orphans.zig\n/home/hotschmoe/beads_zig/src/cli/ready.zig\n/home/hotschmoe/beads_zig/src/cli/search.zig\n/home/hotschmoe/beads_zig/src/cli/stale.zig\n/home/hotschmoe/beads_zig/src/cli/create.zig\n/home/hotschmoe/beads_zig/src/cli/args.zig\n/home/hotschmoe/beads_zig/src/cli/upgrade.zig\n/home/hotschmoe/beads_zig/src/cli/mod.zig\n/home/hotschmoe/beads_zig/src/cli/query.zig"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d7ac7c3b-8db2-49f4-a950-929cd778be37","tool_use_result":{"filenames":["/home/hotschmoe/beads_zig/src/cli/label.zig","/home/hotschmoe/beads_zig/src/cli/close.zig","/home/hotschmoe/beads_zig/src/cli/help.zig","/home/hotschmoe/beads_zig/src/cli/delete.zig","/home/hotschmoe/beads_zig/src/cli/audit.zig","/home/hotschmoe/beads_zig/src/cli/common.zig","/home/hotschmoe/beads_zig/src/cli/comments.zig","/home/hotschmoe/beads_zig/src/cli/batch.zig","/home/hotschmoe/beads_zig/src/cli/list.zig","/home/hotschmoe/beads_zig/src/cli/metrics.zig","/home/hotschmoe/beads_zig/src/cli/doctor.zig","/home/hotschmoe/beads_zig/src/cli/epic.zig","/home/hotschmoe/beads_zig/src/cli/config.zig","/home/hotschmoe/beads_zig/src/cli/lint.zig","/home/hotschmoe/beads_zig/src/cli/dep.zig","/home/hotschmoe/beads_zig/src/cli/changelog.zig","/home/hotschmoe/beads_zig/src/cli/history.zig","/home/hotschmoe/beads_zig/src/cli/init.zig","/home/hotschmoe/beads_zig/src/cli/defer.zig","/home/hotschmoe/beads_zig/src/cli/completions.zig","/home/hotschmoe/beads_zig/src/cli/info.zig","/home/hotschmoe/beads_zig/src/cli/graph.zig","/home/hotschmoe/beads_zig/src/cli/count.zig","/home/hotschmoe/beads_zig/src/cli/update.zig","/home/hotschmoe/beads_zig/src/cli/version.zig","/home/hotschmoe/beads_zig/src/cli/schema.zig","/home/hotschmoe/beads_zig/src/cli/stats.zig","/home/hotschmoe/beads_zig/src/cli/sync.zig","/home/hotschmoe/beads_zig/src/cli/show.zig","/home/hotschmoe/beads_zig/src/cli/orphans.zig","/home/hotschmoe/beads_zig/src/cli/ready.zig","/home/hotschmoe/beads_zig/src/cli/search.zig","/home/hotschmoe/beads_zig/src/cli/stale.zig","/home/hotschmoe/beads_zig/src/cli/create.zig","/home/hotschmoe/beads_zig/src/cli/args.zig","/home/hotschmoe/beads_zig/src/cli/upgrade.zig","/home/hotschmoe/beads_zig/src/cli/mod.zig","/home/hotschmoe/beads_zig/src/cli/query.zig"],"durationMs":330,"numFiles":38,"truncated":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XNEbmUsFsFwrCtuDZihdmC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T7oE7DAKRycCNQ9RdvXDpD","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":195,"cache_read_input_tokens":39117,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":195},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f5fdaef8-6fda-462c-baff-f8153bbf1239"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (25263 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01T7oE7DAKRycCNQ9RdvXDpD"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"48895293-fc1f-45f4-8bd6-7b25d5923349","tool_use_result":"Error: File content (25263 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xi3tAZ4dTMHhhTk9aiofHK","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the args.zig file in portions, along with looking at an existing simple command for reference."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1092,"cache_read_input_tokens":39312,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1092},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9db7851d-cc91-4851-8ea1-669719c0817b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xi3tAZ4dTMHhhTk9aiofHK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0199BJbw8AZEahdz9ZrR4iXD","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1092,"cache_read_input_tokens":39312,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1092},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8e2aa3e1-10eb-4c9a-89c6-ecb7347e3238"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0199BJbw8AZEahdz9ZrR4iXD","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    quiet: bool = false,\n    13→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    14→    verbose: u8 = 0,\n    15→    no_color: bool = false,\n    16→    data_path: ?[]const u8 = null,\n    17→    actor: ?[]const u8 = null,\n    18→    lock_timeout: u32 = 5000,\n    19→    no_auto_flush: bool = false,\n    20→    no_auto_import: bool = false,\n    21→\n    22→    /// Returns true if structured output (JSON or TOON) is enabled.\n    23→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    24→        return self.json or self.toon;\n    25→    }\n    26→};\n    27→\n    28→/// All available subcommands.\n    29→pub const Command = union(enum) {\n    30→    // Workspace\n    31→    init: InitArgs,\n    32→    info: void,\n    33→    stats: void,\n    34→    doctor: void,\n    35→    config: ConfigArgs,\n    36→    orphans: OrphansArgs,\n    37→    lint: LintArgs,\n    38→\n    39→    // Issue CRUD\n    40→    create: CreateArgs,\n    41→    q: QuickArgs,\n    42→    show: ShowArgs,\n    43→    update: UpdateArgs,\n    44→    close: CloseArgs,\n    45→    reopen: ReopenArgs,\n    46→    delete: DeleteArgs,\n    47→\n    48→    // Batch Operations\n    49→    add_batch: AddBatchArgs,\n    50→    import_cmd: ImportArgs,\n    51→\n    52→    // Query\n    53→    list: ListArgs,\n    54→    ready: ReadyArgs,\n    55→    blocked: BlockedArgs,\n    56→    search: SearchArgs,\n    57→    stale: StaleArgs,\n    58→    count: CountArgs,\n    59→    defer_cmd: DeferArgs,\n    60→    undefer: UndeferArgs,\n    61→\n    62→    // Dependencies\n    63→    dep: DepArgs,\n    64→    graph: GraphArgs,\n    65→\n    66→    // Epics\n    67→    epic: EpicArgs,\n    68→\n    69→    // Labels\n    70→    label: LabelArgs,\n    71→\n    72→    // Comments\n    73→    comments: CommentsArgs,\n    74→\n    75→    // Audit\n    76→    history: HistoryArgs,\n    77→    audit: AuditArgs,\n    78→\n    79→    // Changelog\n    80→    changelog: ChangelogArgs,\n    81→\n    82→    // Sync\n    83→    sync: SyncArgs,\n    84→\n    85→    // System\n    86→    version: void,\n    87→    schema: void,\n    88→    completions: CompletionsArgs,\n    89→    metrics: MetricsArgs,\n    90→\n    91→    // Saved Queries\n    92→    query: QueryArgs,\n    93→\n    94→    // Self-upgrade\n    95→    upgrade: UpgradeArgs,\n    96→\n    97→    // Help\n    98→    help: HelpArgs,\n    99→};\n   100→\n   101→/// Init command arguments.\n   102→pub const InitArgs = struct {\n   103→    prefix: []const u8 = \"bd\",\n   104→};\n   105→\n   106→/// Create command arguments.\n   107→pub const CreateArgs = struct {\n   108→    title: []const u8,\n   109→    description: ?[]const u8 = null,\n   110→    issue_type: ?[]const u8 = null,\n   111→    priority: ?[]const u8 = null,\n   112→    assignee: ?[]const u8 = null,\n   113→    labels: []const []const u8 = &[_][]const u8{},\n   114→    deps: []const []const u8 = &[_][]const u8{},\n   115→    due: ?[]const u8 = null,\n   116→    estimate: ?i32 = null,\n   117→};\n   118→\n   119→/// Quick capture command arguments.\n   120→pub const QuickArgs = struct {\n   121→    title: []const u8,\n   122→    priority: ?[]const u8 = null,\n   123→};\n   124→\n   125→/// Show command arguments.\n   126→pub const ShowArgs = struct {\n   127→    id: []const u8,\n   128→    with_comments: bool = true,\n   129→    with_history: bool = false,\n   130→};\n   131→\n   132→/// Update command arguments.\n   133→pub const UpdateArgs = struct {\n   134→    id: []const u8,\n   135→    title: ?[]const u8 = null,\n   136→    description: ?[]const u8 = null,\n   137→    issue_type: ?[]const u8 = null,\n   138→    priority: ?[]const u8 = null,\n   139→    assignee: ?[]const u8 = null,\n   140→    status: ?[]const u8 = null,\n   141→    /// Expected version for optimistic locking (compare-and-swap).\n   142→    expected_version: ?u64 = null,\n   143→};\n   144→\n   145→/// Close command arguments.\n   146→pub const CloseArgs = struct {\n   147→    id: []const u8,\n   148→    reason: ?[]const u8 = null,\n   149→};\n   150→\n   151→/// Reopen command arguments.\n   152→pub const ReopenArgs = struct {\n   153→    id: []const u8,\n   154→};\n   155→\n   156→/// Delete command arguments.\n   157→pub const DeleteArgs = struct {\n   158→    id: []const u8,\n   159→};\n   160→\n   161→/// Add-batch command arguments.\n   162→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   163→pub const AddBatchArgs = struct {\n   164→    file: ?[]const u8 = null, // Read from file instead of stdin\n   165→    format: BatchFormat = .titles, // Input format\n   166→};\n   167→\n   168→/// Batch input format.\n   169→pub const BatchFormat = enum {\n   170→    titles, // One title per line\n   171→    jsonl, // Full JSONL format (one issue per line)\n   172→\n   173→    pub fn fromString(s: []const u8) ?BatchFormat {\n   174→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   175→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   176→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   177→        return null;\n   178→    }\n   179→};\n   180→\n   181→/// Import command arguments.\n   182→/// Imports issues from a JSONL file with single lock acquisition.\n   183→pub const ImportArgs = struct {\n   184→    file: []const u8, // Path to JSONL file (required)\n   185→    merge: bool = false, // Merge instead of replace\n   186→    dry_run: bool = false, // Show what would be imported without importing\n   187→};\n   188→\n   189→/// Sort field options for list command.\n   190→pub const SortField = enum {\n   191→    created_at,\n   192→    updated_at,\n   193→    priority,\n   194→\n   195→    pub fn fromString(s: []const u8) ?SortField {\n   196→        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n   197→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   198→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   199→        return null;\n   200→    }\n   201→};\n   202→\n   203→/// List command arguments.\n   204→pub const ListArgs = struct {\n   205→    status: ?[]const u8 = null,\n   206→    priority: ?[]const u8 = null,\n   207→    issue_type: ?[]const u8 = null,\n   208→    assignee: ?[]const u8 = null,\n   209→    label: ?[]const u8 = null,\n   210→    limit: ?u32 = null,\n   211→    all: bool = false,\n   212→    sort: SortField = .created_at,\n   213→    sort_desc: bool = true,\n   214→};\n   215→\n   216→/// Ready command arguments.\n   217→pub const ReadyArgs = struct {\n   218→    limit: ?u32 = null,\n   219→};\n   220→\n   221→/// Blocked command arguments.\n   222→pub const BlockedArgs = struct {\n   223→    limit: ?u32 = null,\n   224→};\n   225→\n   226→/// Search command arguments.\n   227→pub const SearchArgs = struct {\n   228→    query: []const u8,\n   229→    limit: ?u32 = null,\n   230→};\n   231→\n   232→/// Stale command arguments.\n   233→pub const StaleArgs = struct {\n   234→    days: u32 = 30,\n   235→    limit: ?u32 = null,\n   236→};\n   237→\n   238→/// Count command arguments.\n   239→pub const CountArgs = struct {\n   240→    group_by: ?[]const u8 = null,\n   241→};\n   242→\n   243→/// Defer command arguments.\n   244→pub const DeferArgs = struct {\n   245→    id: []const u8,\n   246→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   247→    reason: ?[]const u8 = null,\n   248→};\n   249→\n   250→/// Undefer command arguments.\n   251→pub const UndeferArgs = struct {\n   252→    id: []const u8,\n   253→};\n   254→\n   255→/// Epic subcommand variants.\n   256→pub const EpicSubcommand = union(enum) {\n   257→    create: struct {\n   258→        title: []const u8,\n   259→        description: ?[]const u8 = null,\n   260→        priority: ?[]const u8 = null,\n   261→    },\n   262→    add: struct {\n   263→        epic_id: []const u8,\n   264→        issue_id: []const u8,\n   265→    },\n   266→    remove: struct {\n   267→        epic_id: []const u8,\n   268→        issue_id: []const u8,\n   269→    },\n   270→    list: struct {\n   271→        epic_id: []const u8,\n   272→    },\n   273→};\n   274→\n   275→/// Epic command arguments.\n   276→pub const EpicArgs = struct {\n   277→    subcommand: EpicSubcommand,\n   278→};\n   279→\n   280→/// Dependency subcommand variants.\n   281→pub const DepSubcommand = union(enum) {\n   282→    add: struct {\n   283→        child: []const u8,\n   284→        parent: []const u8,\n   285→        dep_type: []const u8 = \"blocks\",\n   286→    },\n   287→    remove: struct {\n   288→        child: []const u8,\n   289→        parent: []const u8,\n   290→    },\n   291→    list: struct {\n   292→        id: []const u8,\n   293→    },\n   294→    tree: struct {\n   295→        id: []const u8,\n   296→    },\n   297→    cycles: void,\n   298→};\n   299→\n   300→/// Dependency command arguments.\n   301→pub const DepArgs = struct {\n   302→    subcommand: DepSubcommand,\n   303→};\n   304→\n   305→/// Graph command output formats.\n   306→pub const GraphFormat = enum {\n   307→    ascii,\n   308→    dot,\n   309→\n   310→    pub fn fromString(s: []const u8) ?GraphFormat {\n   311→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   312→        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n   313→        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n   314→        return null;\n   315→    }\n   316→};\n   317→\n   318→/// Graph command arguments.\n   319→pub const GraphArgs = struct {\n   320→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   321→    format: GraphFormat = .ascii,\n   322→    depth: ?u32 = null, // Max depth for tree traversal\n   323→};\n   324→\n   325→/// Label subcommand variants.\n   326→pub const LabelSubcommand = union(enum) {\n   327→    add: struct {\n   328→        id: []const u8,\n   329→        labels: []const []const u8,\n   330→    },\n   331→    remove: struct {\n   332→        id: []const u8,\n   333→        labels: []const []const u8,\n   334→    },\n   335→    list: struct {\n   336→        id: []const u8,\n   337→    },\n   338→    list_all: void,\n   339→};\n   340→\n   341→/// Label command arguments.\n   342→pub const LabelArgs = struct {\n   343→    subcommand: LabelSubcommand,\n   344→};\n   345→\n   346→/// Comments subcommand variants.\n   347→pub const CommentsSubcommand = union(enum) {\n   348→    add: struct {\n   349→        id: []const u8,\n   350→        text: []const u8,\n   351→    },\n   352→    list: struct {\n   353→        id: []const u8,\n   354→    },\n   355→};\n   356→\n   357→/// Comments command arguments.\n   358→pub const CommentsArgs = struct {\n   359→    subcommand: CommentsSubcommand,\n   360→};\n   361→\n   362→/// History command arguments.\n   363→pub const HistoryArgs = struct {\n   364→    id: []const u8,\n   365→};\n   366→\n   367→/// Audit command arguments.\n   368→pub const AuditArgs = struct {\n   369→    limit: ?u32 = null,\n   370→};\n   371→\n   372→/// Changelog command arguments.\n   373→pub const ChangelogArgs = struct {\n   374→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   375→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   376→    limit: ?u32 = null,\n   377→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   378→};\n   379→\n   380→/// Sync command arguments.\n   381→pub const SyncArgs = struct {\n   382→    flush_only: bool = false,\n   383→    import_only: bool = false,\n   384→};\n   385→\n   386→/// Shell completion types.\n   387→pub const Shell = enum {\n   388→    bash,\n   389→    zsh,\n   390→    fish,\n   391→    powershell,\n   392→\n   393→    pub fn fromString(s: []const u8) ?Shell {\n   394→        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n   395→        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n   396→        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n   397→        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n   398→        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n   399→        return null;\n   400→    }\n   401→};\n   402→\n   403→/// Completions command arguments.\n   404→pub const CompletionsArgs = struct {\n   405→    shell: Shell,\n   406→};\n   407→\n   408→/// Metrics command arguments.\n   409→pub const MetricsArgs = struct {\n   410→    reset: bool = false, // Reset metrics after displaying\n   411→};\n   412→\n   413→/// Help command arguments.\n   414→pub const HelpArgs = struct {\n   415→    topic: ?[]const u8 = null,\n   416→};\n   417→\n   418→/// Config subcommand variants.\n   419→pub const ConfigSubcommand = union(enum) {\n   420→    get: struct {\n   421→        key: []const u8,\n   422→    },\n   423→    set: struct {\n   424→        key: []const u8,\n   425→        value: []const u8,\n   426→    },\n   427→    list: void,\n   428→};\n   429→\n   430→/// Config command arguments.\n   431→pub const ConfigArgs = struct {\n   432→    subcommand: ConfigSubcommand,\n   433→};\n   434→\n   435→/// Query subcommand variants.\n   436→pub const QuerySubcommand = union(enum) {\n   437→    save: struct {\n   438→        name: []const u8,\n   439→        status: ?[]const u8 = null,\n   440→        priority: ?[]const u8 = null,\n   441→        issue_type: ?[]const u8 = null,\n   442→        assignee: ?[]const u8 = null,\n   443→        label: ?[]const u8 = null,\n   444→        limit: ?u32 = null,\n   445→    },\n   446→    run: struct {\n   447→        name: []const u8,\n   448→    },\n   449→    list: void,\n   450→    delete: struct {\n   451→        name: []const u8,\n   452→    },\n   453→};\n   454→\n   455→/// Query command arguments.\n   456→pub const QueryArgs = struct {\n   457→    subcommand: QuerySubcommand,\n   458→};\n   459→\n   460→/// Upgrade command arguments.\n   461→pub const UpgradeArgs = struct {\n   462→    check_only: bool = false,\n   463→    version: ?[]const u8 = null,\n   464→};\n   465→\n   466→/// Orphans command arguments.\n   467→pub const OrphansArgs = struct {\n   468→    limit: ?u32 = null,\n   469→    hierarchy_only: bool = false,\n   470→    deps_only: bool = false,\n   471→};\n   472→\n   473→/// Lint command arguments.\n   474→pub const LintArgs = struct {\n   475→    limit: ?u32 = null,\n   476→};\n   477→\n   478→/// Result of parsing command-line arguments.\n   479→pub const ParseResult = struct {\n   480→    global: GlobalOptions,\n   481→    command: Command,\n   482→\n   483→    /// Free any memory allocated during parsing (labels, deps slices).\n   484→    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n   485→        switch (self.command) {\n   486→            .create => |create| {\n   487→                if (create.labels.len > 0) allocator.free(create.labels);\n   488→                if (create.deps.len > 0) allocator.free(create.deps);\n   489→            },\n   490→            .label => |label_cmd| {\n   491→                switch (label_cmd.subcommand) {\n   492→                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n   493→                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n   494→                    else => {},\n   495→                }\n   496→            },\n   497→            else => {},\n   498→        }\n   499→    }\n   500→};\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d3b2f37d-b56c-46c2-9572-9cd4c48d3a70","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};","numLines":500,"startLine":1,"totalLines":2276}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xi3tAZ4dTMHhhTk9aiofHK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016BfmcWqRG3WzdTaYjDqDu7","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/version.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1092,"cache_read_input_tokens":39312,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1092},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"dc16bac7-fd35-4ef8-873c-b75fa5f0f55a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016BfmcWqRG3WzdTaYjDqDu7","type":"tool_result","content":"     1→//! Version command for beads_zig.\n     2→//!\n     3→//! Displays version information about the bz binary.\n     4→\n     5→const std = @import(\"std\");\n     6→const builtin = @import(\"builtin\");\n     7→const output = @import(\"../output/mod.zig\");\n     8→\n     9→pub const VERSION = \"0.1.5\";\n    10→\n    11→pub const VersionError = error{\n    12→    WriteError,\n    13→};\n    14→\n    15→pub const VersionResult = struct {\n    16→    version: []const u8,\n    17→    zig_version: []const u8,\n    18→    target: []const u8,\n    19→};\n    20→\n    21→pub fn run(global: anytype, allocator: std.mem.Allocator) VersionError!VersionResult {\n    22→    var out = output.Output.init(allocator, .{\n    23→        .json = global.json,\n    24→        .toon = global.toon,\n    25→        .quiet = global.quiet,\n    26→        .no_color = global.no_color,\n    27→    });\n    28→\n    29→    const zig_version = builtin.zig_version_string;\n    30→    const target = @tagName(builtin.target.os.tag) ++ \"-\" ++ @tagName(builtin.target.cpu.arch);\n    31→\n    32→    if (global.json) {\n    33→        const version_info = .{\n    34→            .version = VERSION,\n    35→            .zig_version = zig_version,\n    36→            .target = target,\n    37→        };\n    38→        out.printJson(version_info) catch return VersionError.WriteError;\n    39→    } else {\n    40→        out.print(\"bz {s}\\n\", .{VERSION}) catch return VersionError.WriteError;\n    41→        out.print(\"zig {s}\\n\", .{zig_version}) catch return VersionError.WriteError;\n    42→        out.print(\"{s}\\n\", .{target}) catch return VersionError.WriteError;\n    43→    }\n    44→\n    45→    return .{\n    46→        .version = VERSION,\n    47→        .zig_version = zig_version,\n    48→        .target = target,\n    49→    };\n    50→}\n    51→\n    52→// --- Tests ---\n    53→\n    54→test \"VERSION is valid semver\" {\n    55→    try std.testing.expect(VERSION.len > 0);\n    56→    try std.testing.expect(std.mem.indexOf(u8, VERSION, \".\") != null);\n    57→}\n    58→\n    59→test \"run returns version info\" {\n    60→    const allocator = std.testing.allocator;\n    61→\n    62→    const result = try run(.{\n    63→        .json = false,\n    64→        .toon = false,\n    65→        .quiet = true,\n    66→        .no_color = true,\n    67→    }, allocator);\n    68→\n    69→    try std.testing.expectEqualStrings(VERSION, result.version);\n    70→    try std.testing.expect(result.zig_version.len > 0);\n    71→    try std.testing.expect(result.target.len > 0);\n    72→}\n    73→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"4632a36f-7d62-449a-920a-a3b27a481830","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/version.zig","content":"//! Version command for beads_zig.\n//!\n//! Displays version information about the bz binary.\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst output = @import(\"../output/mod.zig\");\n\npub const VERSION = \"0.1.5\";\n\npub const VersionError = error{\n    WriteError,\n};\n\npub const VersionResult = struct {\n    version: []const u8,\n    zig_version: []const u8,\n    target: []const u8,\n};\n\npub fn run(global: anytype, allocator: std.mem.Allocator) VersionError!VersionResult {\n    var out = output.Output.init(allocator, .{\n        .json = global.json,\n        .toon = global.toon,\n        .quiet = global.quiet,\n        .no_color = global.no_color,\n    });\n\n    const zig_version = builtin.zig_version_string;\n    const target = @tagName(builtin.target.os.tag) ++ \"-\" ++ @tagName(builtin.target.cpu.arch);\n\n    if (global.json) {\n        const version_info = .{\n            .version = VERSION,\n            .zig_version = zig_version,\n            .target = target,\n        };\n        out.printJson(version_info) catch return VersionError.WriteError;\n    } else {\n        out.print(\"bz {s}\\n\", .{VERSION}) catch return VersionError.WriteError;\n        out.print(\"zig {s}\\n\", .{zig_version}) catch return VersionError.WriteError;\n        out.print(\"{s}\\n\", .{target}) catch return VersionError.WriteError;\n    }\n\n    return .{\n        .version = VERSION,\n        .zig_version = zig_version,\n        .target = target,\n    };\n}\n\n// --- Tests ---\n\ntest \"VERSION is valid semver\" {\n    try std.testing.expect(VERSION.len > 0);\n    try std.testing.expect(std.mem.indexOf(u8, VERSION, \".\") != null);\n}\n\ntest \"run returns version info\" {\n    const allocator = std.testing.allocator;\n\n    const result = try run(.{\n        .json = false,\n        .toon = false,\n        .quiet = true,\n        .no_color = true,\n    }, allocator);\n\n    try std.testing.expectEqualStrings(VERSION, result.version);\n    try std.testing.expect(result.zig_version.len > 0);\n    try std.testing.expect(result.target.len > 0);\n}\n","numLines":73,"startLine":1,"totalLines":73}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xi3tAZ4dTMHhhTk9aiofHK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V85PCM78GTUwy4V1zujAKu","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/info.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1092,"cache_read_input_tokens":39312,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1092},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"1684ba73-c679-4ab8-abee-d5940dbe5f81"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V85PCM78GTUwy4V1zujAKu","type":"tool_result","content":"     1→//! Info command for beads_zig.\n     2→//!\n     3→//! `bz info` - Show workspace information\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const InfoError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const InfoResult = struct {\n    18→    success: bool,\n    19→    beads_dir: ?[]const u8 = null,\n    20→    jsonl_path: ?[]const u8 = null,\n    21→    issue_count: ?usize = null,\n    22→    jsonl_size: ?u64 = null,\n    23→    wal_size: ?u64 = null,\n    24→    message: ?[]const u8 = null,\n    25→};\n    26→\n    27→pub fn run(\n    28→    global: args.GlobalOptions,\n    29→    allocator: std.mem.Allocator,\n    30→) !void {\n    31→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    32→        return InfoError.WorkspaceNotInitialized;\n    33→    };\n    34→    defer ctx.deinit();\n    35→\n    36→    const beads_dir = global.data_path orelse \".beads\";\n    37→    const jsonl_size = getFileSize(ctx.issues_path);\n    38→\n    39→    const wal_path = try std.fs.path.join(allocator, &.{ beads_dir, \"beads.wal\" });\n    40→    defer allocator.free(wal_path);\n    41→    const wal_size = getFileSize(wal_path);\n    42→\n    43→    const issue_count = ctx.store.countTotal();\n    44→\n    45→    if (global.isStructuredOutput()) {\n    46→        try ctx.output.printJson(InfoResult{\n    47→            .success = true,\n    48→            .beads_dir = beads_dir,\n    49→            .jsonl_path = ctx.issues_path,\n    50→            .issue_count = issue_count,\n    51→            .jsonl_size = jsonl_size,\n    52→            .wal_size = wal_size,\n    53→        });\n    54→    } else if (!global.quiet) {\n    55→        try ctx.output.println(\"beads_zig workspace\", .{});\n    56→        try ctx.output.print(\"\\n\", .{});\n    57→        try ctx.output.print(\"Directory:     {s}\\n\", .{beads_dir});\n    58→        try ctx.output.print(\"JSONL:         {s} ({s})\\n\", .{ ctx.issues_path, formatBytes(jsonl_size) });\n    59→        try ctx.output.print(\"WAL:           {s} ({s})\\n\", .{ wal_path, formatBytes(wal_size) });\n    60→        try ctx.output.print(\"Total issues:  {d}\\n\", .{issue_count});\n    61→    }\n    62→}\n    63→\n    64→fn getFileSize(path: []const u8) u64 {\n    65→    const file = std.fs.cwd().openFile(path, .{}) catch return 0;\n    66→    defer file.close();\n    67→    const stat = file.stat() catch return 0;\n    68→    return stat.size;\n    69→}\n    70→\n    71→fn formatBytes(bytes: u64) []const u8 {\n    72→    if (bytes == 0) return \"0 B\";\n    73→    if (bytes < 1024) return \"<1 KB\";\n    74→    if (bytes < 1024 * 1024) return \"<1 MB\";\n    75→    return \">1 MB\";\n    76→}\n    77→\n    78→// --- Tests ---\n    79→\n    80→test \"InfoError enum exists\" {\n    81→    const err: InfoError = InfoError.WorkspaceNotInitialized;\n    82→    try std.testing.expect(err == InfoError.WorkspaceNotInitialized);\n    83→}\n    84→\n    85→test \"InfoResult struct works\" {\n    86→    const result = InfoResult{\n    87→        .success = true,\n    88→        .beads_dir = \".beads\",\n    89→        .issue_count = 5,\n    90→    };\n    91→    try std.testing.expect(result.success);\n    92→    try std.testing.expectEqualStrings(\".beads\", result.beads_dir.?);\n    93→    try std.testing.expectEqual(@as(usize, 5), result.issue_count.?);\n    94→}\n    95→\n    96→test \"run detects uninitialized workspace\" {\n    97→    const allocator = std.testing.allocator;\n    98→\n    99→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   100→\n   101→    const result = run(global, allocator);\n   102→    try std.testing.expectError(InfoError.WorkspaceNotInitialized, result);\n   103→}\n   104→\n   105→test \"formatBytes handles zero\" {\n   106→    try std.testing.expectEqualStrings(\"0 B\", formatBytes(0));\n   107→}\n   108→\n   109→test \"formatBytes handles small values\" {\n   110→    try std.testing.expectEqualStrings(\"<1 KB\", formatBytes(500));\n   111→}\n   112→\n   113→test \"getFileSize returns 0 for missing file\" {\n   114→    const size = getFileSize(\"/nonexistent/file.txt\");\n   115→    try std.testing.expectEqual(@as(u64, 0), size);\n   116→}\n   117→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"2b26cc57-ca58-4e5d-b972-27dcdb6c1df1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/info.zig","content":"//! Info command for beads_zig.\n//!\n//! `bz info` - Show workspace information\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const InfoError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const InfoResult = struct {\n    success: bool,\n    beads_dir: ?[]const u8 = null,\n    jsonl_path: ?[]const u8 = null,\n    issue_count: ?usize = null,\n    jsonl_size: ?u64 = null,\n    wal_size: ?u64 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return InfoError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const beads_dir = global.data_path orelse \".beads\";\n    const jsonl_size = getFileSize(ctx.issues_path);\n\n    const wal_path = try std.fs.path.join(allocator, &.{ beads_dir, \"beads.wal\" });\n    defer allocator.free(wal_path);\n    const wal_size = getFileSize(wal_path);\n\n    const issue_count = ctx.store.countTotal();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(InfoResult{\n            .success = true,\n            .beads_dir = beads_dir,\n            .jsonl_path = ctx.issues_path,\n            .issue_count = issue_count,\n            .jsonl_size = jsonl_size,\n            .wal_size = wal_size,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"beads_zig workspace\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Directory:     {s}\\n\", .{beads_dir});\n        try ctx.output.print(\"JSONL:         {s} ({s})\\n\", .{ ctx.issues_path, formatBytes(jsonl_size) });\n        try ctx.output.print(\"WAL:           {s} ({s})\\n\", .{ wal_path, formatBytes(wal_size) });\n        try ctx.output.print(\"Total issues:  {d}\\n\", .{issue_count});\n    }\n}\n\nfn getFileSize(path: []const u8) u64 {\n    const file = std.fs.cwd().openFile(path, .{}) catch return 0;\n    defer file.close();\n    const stat = file.stat() catch return 0;\n    return stat.size;\n}\n\nfn formatBytes(bytes: u64) []const u8 {\n    if (bytes == 0) return \"0 B\";\n    if (bytes < 1024) return \"<1 KB\";\n    if (bytes < 1024 * 1024) return \"<1 MB\";\n    return \">1 MB\";\n}\n\n// --- Tests ---\n\ntest \"InfoError enum exists\" {\n    const err: InfoError = InfoError.WorkspaceNotInitialized;\n    try std.testing.expect(err == InfoError.WorkspaceNotInitialized);\n}\n\ntest \"InfoResult struct works\" {\n    const result = InfoResult{\n        .success = true,\n        .beads_dir = \".beads\",\n        .issue_count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\".beads\", result.beads_dir.?);\n    try std.testing.expectEqual(@as(usize, 5), result.issue_count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(global, allocator);\n    try std.testing.expectError(InfoError.WorkspaceNotInitialized, result);\n}\n\ntest \"formatBytes handles zero\" {\n    try std.testing.expectEqualStrings(\"0 B\", formatBytes(0));\n}\n\ntest \"formatBytes handles small values\" {\n    try std.testing.expectEqualStrings(\"<1 KB\", formatBytes(500));\n}\n\ntest \"getFileSize returns 0 for missing file\" {\n    const size = getFileSize(\"/nonexistent/file.txt\");\n    try std.testing.expectEqual(@as(u64, 0), size);\n}\n","numLines":117,"startLine":1,"totalLines":117}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VnUYt5q6nD4nXFksgoUUYY","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to see how commands are registered in the Command union and where they get dispatched. Let me also check the common.zig for workspace resolution and the mod.zig for exports."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8511,"cache_read_input_tokens":40404,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8511},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"ad3d1c52-501d-4158-8587-b3bcbf3b0c36"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VnUYt5q6nD4nXFksgoUUYY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016BgUYQHhkjihkFkCgxq9qH","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8511,"cache_read_input_tokens":40404,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8511},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"67a18c60-35f2-4b64-add1-e074db99bd7f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016BgUYQHhkjihkFkCgxq9qH","type":"tool_result","content":"     1→//! CLI command implementations for beads_zig.\n     2→//!\n     3→//! This module handles argument parsing and dispatches to the appropriate\n     4→//! command handlers (create, list, show, update, close, sync, etc.).\n     5→//!\n     6→//! All commands support --json output for machine-readable responses.\n     7→\n     8→const std = @import(\"std\");\n     9→\n    10→pub const args = @import(\"args.zig\");\n    11→pub const common = @import(\"common.zig\");\n    12→pub const init = @import(\"init.zig\");\n    13→pub const create = @import(\"create.zig\");\n    14→pub const list = @import(\"list.zig\");\n    15→pub const show = @import(\"show.zig\");\n    16→pub const update = @import(\"update.zig\");\n    17→pub const close = @import(\"close.zig\");\n    18→pub const delete = @import(\"delete.zig\");\n    19→pub const ready = @import(\"ready.zig\");\n    20→pub const dep = @import(\"dep.zig\");\n    21→pub const graph = @import(\"graph.zig\");\n    22→pub const epic = @import(\"epic.zig\");\n    23→pub const sync = @import(\"sync.zig\");\n    24→pub const batch = @import(\"batch.zig\");\n    25→pub const search = @import(\"search.zig\");\n    26→pub const stale = @import(\"stale.zig\");\n    27→pub const count = @import(\"count.zig\");\n    28→pub const defer_cmd = @import(\"defer.zig\");\n    29→pub const label = @import(\"label.zig\");\n    30→pub const comments = @import(\"comments.zig\");\n    31→pub const history = @import(\"history.zig\");\n    32→pub const audit = @import(\"audit.zig\");\n    33→pub const changelog = @import(\"changelog.zig\");\n    34→pub const info = @import(\"info.zig\");\n    35→pub const stats = @import(\"stats.zig\");\n    36→pub const doctor = @import(\"doctor.zig\");\n    37→pub const config = @import(\"config.zig\");\n    38→pub const orphans = @import(\"orphans.zig\");\n    39→pub const lint = @import(\"lint.zig\");\n    40→pub const version = @import(\"version.zig\");\n    41→pub const schema = @import(\"schema.zig\");\n    42→pub const completions = @import(\"completions.zig\");\n    43→pub const metrics_cmd = @import(\"metrics.zig\");\n    44→pub const help = @import(\"help.zig\");\n    45→pub const query = @import(\"query.zig\");\n    46→pub const upgrade = @import(\"upgrade.zig\");\n    47→\n    48→pub const ArgParser = args.ArgParser;\n    49→pub const ParseResult = args.ParseResult;\n    50→pub const ParseError = args.ParseError;\n    51→pub const GlobalOptions = args.GlobalOptions;\n    52→pub const Command = args.Command;\n    53→pub const InitArgs = args.InitArgs;\n    54→pub const CreateArgs = args.CreateArgs;\n    55→pub const QuickArgs = args.QuickArgs;\n    56→\n    57→pub const InitError = init.InitError;\n    58→pub const InitResult = init.InitResult;\n    59→pub const runInit = init.run;\n    60→\n    61→pub const CreateError = create.CreateError;\n    62→pub const CreateResult = create.CreateResult;\n    63→pub const runCreate = create.run;\n    64→pub const runQuick = create.runQuick;\n    65→\n    66→pub const ListError = list.ListError;\n    67→pub const ListResult = list.ListResult;\n    68→pub const runList = list.run;\n    69→\n    70→pub const ShowError = show.ShowError;\n    71→pub const ShowResult = show.ShowResult;\n    72→pub const runShow = show.run;\n    73→\n    74→pub const UpdateError = update.UpdateError;\n    75→pub const UpdateResult = update.UpdateResult;\n    76→pub const runUpdate = update.run;\n    77→\n    78→pub const CloseError = close.CloseError;\n    79→pub const CloseResult = close.CloseResult;\n    80→pub const runClose = close.run;\n    81→pub const runReopen = close.runReopen;\n    82→\n    83→pub const DeleteError = delete.DeleteError;\n    84→pub const DeleteResult = delete.DeleteResult;\n    85→pub const runDelete = delete.run;\n    86→\n    87→pub const ReadyError = ready.ReadyError;\n    88→pub const ReadyResult = ready.ReadyResult;\n    89→pub const runReady = ready.run;\n    90→pub const runBlocked = ready.runBlocked;\n    91→\n    92→pub const DepError = dep.DepError;\n    93→pub const DepResult = dep.DepResult;\n    94→pub const runDep = dep.run;\n    95→\n    96→pub const GraphError = graph.GraphError;\n    97→pub const GraphResult = graph.GraphResult;\n    98→pub const runGraph = graph.run;\n    99→\n   100→pub const EpicError = epic.EpicError;\n   101→pub const EpicResult = epic.EpicResult;\n   102→pub const runEpic = epic.run;\n   103→\n   104→pub const SyncError = sync.SyncError;\n   105→pub const SyncResult = sync.SyncResult;\n   106→pub const runSync = sync.run;\n   107→\n   108→pub const BatchError = batch.BatchError;\n   109→pub const BatchResult = batch.BatchResult;\n   110→pub const ImportResult = batch.ImportResult;\n   111→pub const runAddBatch = batch.runAddBatch;\n   112→pub const runImportCmd = batch.runImport;\n   113→\n   114→pub const AddBatchArgs = args.AddBatchArgs;\n   115→pub const BatchFormat = args.BatchFormat;\n   116→pub const ImportArgs = args.ImportArgs;\n   117→pub const EpicArgs = args.EpicArgs;\n   118→pub const SortField = args.SortField;\n   119→\n   120→pub const SearchError = search.SearchError;\n   121→pub const SearchResult = search.SearchResult;\n   122→pub const runSearch = search.run;\n   123→\n   124→pub const runStale = stale.run;\n   125→\n   126→pub const runCount = count.run;\n   127→\n   128→pub const runDefer = defer_cmd.run;\n   129→pub const runUndefer = defer_cmd.runUndefer;\n   130→\n   131→pub const LabelError = label.LabelError;\n   132→pub const LabelResult = label.LabelResult;\n   133→pub const runLabel = label.run;\n   134→\n   135→pub const CommentsError = comments.CommentsError;\n   136→pub const CommentsResult = comments.CommentsResult;\n   137→pub const runComments = comments.run;\n   138→\n   139→pub const HistoryError = history.HistoryError;\n   140→pub const HistoryResult = history.HistoryResult;\n   141→pub const runHistory = history.run;\n   142→\n   143→pub const AuditError = audit.AuditError;\n   144→pub const AuditResult = audit.AuditResult;\n   145→pub const runAudit = audit.run;\n   146→\n   147→pub const ChangelogError = changelog.ChangelogError;\n   148→pub const ChangelogResult = changelog.ChangelogResult;\n   149→pub const runChangelog = changelog.run;\n   150→pub const ChangelogArgs = args.ChangelogArgs;\n   151→\n   152→pub const InfoError = info.InfoError;\n   153→pub const InfoResult = info.InfoResult;\n   154→pub const runInfo = info.run;\n   155→\n   156→pub const StatsError = stats.StatsError;\n   157→pub const StatsResult = stats.StatsResult;\n   158→pub const runStats = stats.run;\n   159→\n   160→pub const DoctorError = doctor.DoctorError;\n   161→pub const DoctorResult = doctor.DoctorResult;\n   162→pub const runDoctor = doctor.run;\n   163→\n   164→pub const ConfigError = config.ConfigError;\n   165→pub const ConfigResult = config.ConfigResult;\n   166→pub const runConfig = config.run;\n   167→\n   168→pub const OrphansError = orphans.OrphansError;\n   169→pub const OrphansResult = orphans.OrphansResult;\n   170→pub const runOrphans = orphans.run;\n   171→\n   172→pub const LintError = lint.LintError;\n   173→pub const LintResult = lint.LintResult;\n   174→pub const runLint = lint.run;\n   175→\n   176→pub const OrphansArgs = args.OrphansArgs;\n   177→pub const LintArgs = args.LintArgs;\n   178→\n   179→pub const VersionError = version.VersionError;\n   180→pub const VersionResult = version.VersionResult;\n   181→pub const runVersion = version.run;\n   182→pub const VERSION = version.VERSION;\n   183→\n   184→pub const SchemaError = schema.SchemaError;\n   185→pub const SchemaResult = schema.SchemaResult;\n   186→pub const runSchema = schema.run;\n   187→\n   188→pub const CompletionsError = completions.CompletionsError;\n   189→pub const CompletionsResult = completions.CompletionsResult;\n   190→pub const runCompletions = completions.run;\n   191→pub const Shell = completions.Shell;\n   192→\n   193→pub const MetricsError = metrics_cmd.MetricsError;\n   194→pub const MetricsResult = metrics_cmd.MetricsResult;\n   195→pub const runMetrics = metrics_cmd.run;\n   196→pub const MetricsArgs = args.MetricsArgs;\n   197→\n   198→pub const HelpError = help.HelpError;\n   199→pub const HelpResult = help.HelpResult;\n   200→pub const runHelp = help.run;\n   201→\n   202→pub const QueryError = query.QueryError;\n   203→pub const QueryResult = query.QueryResult;\n   204→pub const runQuery = query.run;\n   205→pub const QueryArgs = args.QueryArgs;\n   206→\n   207→pub const UpgradeError = upgrade.UpgradeError;\n   208→pub const UpgradeResult = upgrade.UpgradeResult;\n   209→pub const runUpgrade = upgrade.run;\n   210→pub const UpgradeArgs = args.UpgradeArgs;\n   211→\n   212→test {\n   213→    std.testing.refAllDecls(@This());\n   214→}\n   215→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"53fff66f-0353-486b-9fdd-92d6b3e654e5","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","content":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","numLines":215,"startLine":1,"totalLines":215}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VnUYt5q6nD4nXFksgoUUYY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014nC6pMg7HW5GP3mBjuZ3Bq","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/common.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8511,"cache_read_input_tokens":40404,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8511},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"c449658d-9767-4157-bc2c-fce40a6eaa9c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014nC6pMg7HW5GP3mBjuZ3Bq","type":"tool_result","content":"     1→//! Common CLI utilities shared across commands.\n     2→//!\n     3→//! Provides workspace loading, error handling, and shared result types\n     4→//! to reduce duplication across command implementations.\n     5→\n     6→const std = @import(\"std\");\n     7→const storage = @import(\"../storage/mod.zig\");\n     8→const output_mod = @import(\"../output/mod.zig\");\n     9→const args = @import(\"args.zig\");\n    10→\n    11→pub const Output = output_mod.Output;\n    12→pub const OutputOptions = output_mod.OutputOptions;\n    13→pub const IssueStore = storage.IssueStore;\n    14→pub const IssueStoreError = storage.IssueStoreError;\n    15→pub const DependencyGraph = storage.DependencyGraph;\n    16→pub const EventStore = storage.EventStore;\n    17→pub const StoreLoadResult = storage.StoreLoadResult;\n    18→\n    19→/// Common errors shared across CLI commands.\n    20→pub const CommandError = error{\n    21→    WorkspaceNotInitialized,\n    22→    StorageError,\n    23→    OutOfMemory,\n    24→};\n    25→\n    26→/// Context for executing a CLI command with an initialized workspace.\n    27→pub const CommandContext = struct {\n    28→    allocator: std.mem.Allocator,\n    29→    output: Output,\n    30→    store: IssueStore,\n    31→    event_store: EventStore,\n    32→    beads_dir: []const u8,\n    33→    issues_path: []const u8,\n    34→    events_path: []const u8,\n    35→    global: args.GlobalOptions,\n    36→    /// Number of corrupt entries skipped during load.\n    37→    corruption_count: usize = 0,\n    38→    /// Line numbers of corrupt JSONL entries (owned memory).\n    39→    corrupt_lines: []const usize = &.{},\n    40→    /// Number of WAL entries replayed during load.\n    41→    wal_entries_replayed: usize = 0,\n    42→\n    43→    /// Initialize a command context by loading the workspace.\n    44→    /// Returns null and outputs an error if workspace is not initialized.\n    45→    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    46→    /// Replays WAL entries after loading main file for consistency.\n    47→    pub fn init(\n    48→        allocator: std.mem.Allocator,\n    49→        global: args.GlobalOptions,\n    50→    ) CommandError!?CommandContext {\n    51→        var output = Output.init(allocator, .{\n    52→            .json = global.json,\n    53→            .toon = global.toon,\n    54→            .quiet = global.quiet,\n    55→            .silent = global.silent,\n    56→            .no_color = global.no_color,\n    57→        });\n    58→\n    59→        const beads_dir_str = global.data_path orelse \".beads\";\n    60→        const beads_dir = allocator.dupe(u8, beads_dir_str) catch {\n    61→            return CommandError.OutOfMemory;\n    62→        };\n    63→        const issues_path = std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" }) catch {\n    64→            allocator.free(beads_dir);\n    65→            return CommandError.OutOfMemory;\n    66→        };\n    67→        const events_path = std.fs.path.join(allocator, &.{ beads_dir, \"events.jsonl\" }) catch {\n    68→            allocator.free(issues_path);\n    69→            allocator.free(beads_dir);\n    70→            return CommandError.OutOfMemory;\n    71→        };\n    72→\n    73→        std.fs.cwd().access(issues_path, .{}) catch |err| {\n    74→            if (err == error.FileNotFound) {\n    75→                outputErrorGeneric(&output, global.isStructuredOutput(), \"workspace not initialized. Run 'bz init' first.\") catch {};\n    76→                allocator.free(issues_path);\n    77→                allocator.free(events_path);\n    78→                allocator.free(beads_dir);\n    79→                return null;\n    80→            }\n    81→            outputErrorGeneric(&output, global.isStructuredOutput(), \"cannot access workspace\") catch {};\n    82→            allocator.free(issues_path);\n    83→            allocator.free(events_path);\n    84→            allocator.free(beads_dir);\n    85→            return CommandError.StorageError;\n    86→        };\n    87→\n    88→        var store = IssueStore.init(allocator, issues_path);\n    89→        var corruption_count: usize = 0;\n    90→        var corrupt_lines: []const usize = &.{};\n    91→\n    92→        // Use recovery mode: log and skip corrupt entries instead of failing\n    93→        const load_result = store.loadFromFileWithRecovery() catch |err| {\n    94→            if (err != error.FileNotFound) {\n    95→                outputErrorGeneric(&output, global.isStructuredOutput(), \"failed to load issues\") catch {};\n    96→                store.deinit();\n    97→                allocator.free(issues_path);\n    98→                allocator.free(events_path);\n    99→                allocator.free(beads_dir);\n   100→                return CommandError.StorageError;\n   101→            }\n   102→            // File not found is OK - empty workspace\n   103→            var event_store_empty = EventStore.init(allocator, events_path);\n   104→            event_store_empty.loadNextId() catch {};\n   105→            return CommandContext{\n   106→                .allocator = allocator,\n   107→                .output = output,\n   108→                .store = store,\n   109→                .event_store = event_store_empty,\n   110→                .beads_dir = beads_dir,\n   111→                .issues_path = issues_path,\n   112→                .events_path = events_path,\n   113→                .global = global,\n   114→                .corruption_count = 0,\n   115→                .corrupt_lines = &.{},\n   116→                .wal_entries_replayed = 0,\n   117→            };\n   118→        };\n   119→\n   120→        corruption_count = load_result.jsonl_corruption_count;\n   121→        corrupt_lines = load_result.jsonl_corrupt_lines;\n   122→\n   123→        // Replay WAL entries onto the store for consistency\n   124→        var wal_entries_replayed: usize = 0;\n   125→        wal_replay: {\n   126→            var wal_obj = storage.Wal.init(beads_dir, allocator) catch {\n   127→                break :wal_replay;\n   128→            };\n   129→            defer wal_obj.deinit();\n   130→\n   131→            var replay_stats = wal_obj.replay(&store) catch {\n   132→                break :wal_replay;\n   133→            };\n   134→            defer replay_stats.deinit(allocator);\n   135→            wal_entries_replayed = replay_stats.applied;\n   136→        }\n   137→\n   138→        // Warn user about corruption (unless quiet/silent mode)\n   139→        if (corruption_count > 0 and !global.quiet and !global.silent and !global.isStructuredOutput()) {\n   140→            output.print(\"warning: {d} corrupt entries skipped during load\\n\", .{corruption_count}) catch {};\n   141→            output.print(\"         Run 'bz doctor' for details, 'bz compact' to rebuild.\\n\", .{}) catch {};\n   142→        }\n   143→\n   144→        // Initialize event store and load next ID\n   145→        var event_store = EventStore.init(allocator, events_path);\n   146→        event_store.loadNextId() catch {}; // OK if events file doesn't exist\n   147→\n   148→        return CommandContext{\n   149→            .allocator = allocator,\n   150→            .output = output,\n   151→            .store = store,\n   152→            .event_store = event_store,\n   153→            .beads_dir = beads_dir,\n   154→            .issues_path = issues_path,\n   155→            .events_path = events_path,\n   156→            .global = global,\n   157→            .corruption_count = corruption_count,\n   158→            .corrupt_lines = corrupt_lines,\n   159→            .wal_entries_replayed = wal_entries_replayed,\n   160→        };\n   161→    }\n   162→\n   163→    /// Clean up resources.\n   164→    pub fn deinit(self: *CommandContext) void {\n   165→        self.store.deinit();\n   166→        self.allocator.free(self.beads_dir);\n   167→        self.allocator.free(self.issues_path);\n   168→        self.allocator.free(self.events_path);\n   169→        if (self.corrupt_lines.len > 0) {\n   170→            self.allocator.free(self.corrupt_lines);\n   171→        }\n   172→    }\n   173→\n   174→    /// Check if corruption was detected during load.\n   175→    pub fn hasCorruption(self: *const CommandContext) bool {\n   176→        return self.corruption_count > 0;\n   177→    }\n   178→\n   179→    /// Save the store to file if auto-flush is enabled.\n   180→    /// Note: For single-issue writes, prefer appendToWal() for better performance.\n   181→    pub fn saveIfAutoFlush(self: *CommandContext) CommandError!void {\n   182→        if (!self.global.no_auto_flush) {\n   183→            self.store.saveToFile() catch {\n   184→                outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to save issues\") catch {};\n   185→                return CommandError.StorageError;\n   186→            };\n   187→        }\n   188→    }\n   189→\n   190→    /// Append an issue to the WAL for fast persistence.\n   191→    /// Use this for single-issue creates/updates instead of saveToFile().\n   192→    pub fn appendToWal(self: *CommandContext, issue: @import(\"../models/issue.zig\").Issue, op: storage.WalOp) CommandError!void {\n   193→        if (self.global.no_auto_flush) return;\n   194→\n   195→        var wal_obj = storage.Wal.init(self.beads_dir, self.allocator) catch {\n   196→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to initialize WAL\") catch {};\n   197→            return CommandError.StorageError;\n   198→        };\n   199→        defer wal_obj.deinit();\n   200→\n   201→        wal_obj.appendEntry(.{\n   202→            .op = op,\n   203→            .ts = std.time.timestamp(),\n   204→            .id = issue.id,\n   205→            .data = issue,\n   206→        }) catch {\n   207→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to write to WAL\") catch {};\n   208→            return CommandError.StorageError;\n   209→        };\n   210→    }\n   211→\n   212→    /// Create a dependency graph from the store.\n   213→    pub fn createGraph(self: *CommandContext) DependencyGraph {\n   214→        return DependencyGraph.init(&self.store, self.allocator);\n   215→    }\n   216→\n   217→    /// Record an audit event. Silently ignores errors (audit is best-effort).\n   218→    pub fn recordEvent(self: *CommandContext, event: @import(\"../models/event.zig\").Event) void {\n   219→        _ = self.event_store.append(event) catch {};\n   220→    }\n   221→};\n   222→\n   223→/// Output a generic error message in the appropriate format.\n   224→pub fn outputErrorGeneric(output: *Output, json_mode: bool, message: []const u8) !void {\n   225→    if (json_mode) {\n   226→        try output.printJson(.{\n   227→            .success = false,\n   228→            .message = message,\n   229→        });\n   230→    } else {\n   231→        try output.err(\"{s}\", .{message});\n   232→    }\n   233→}\n   234→\n   235→/// Output an error with a specific result type for JSON mode.\n   236→pub fn outputErrorTyped(\n   237→    comptime T: type,\n   238→    output: *Output,\n   239→    json_mode: bool,\n   240→    message: []const u8,\n   241→) !void {\n   242→    if (json_mode) {\n   243→        const result = T{ .success = false, .message = message };\n   244→        try output.printJson(result);\n   245→    } else {\n   246→        try output.err(\"{s}\", .{message});\n   247→    }\n   248→}\n   249→\n   250→/// Output a \"not found\" error for an issue.\n   251→pub fn outputNotFoundError(\n   252→    comptime T: type,\n   253→    output: *Output,\n   254→    json_mode: bool,\n   255→    id: []const u8,\n   256→    allocator: std.mem.Allocator,\n   257→) !void {\n   258→    const msg = try std.fmt.allocPrint(allocator, \"issue not found: {s}\", .{id});\n   259→    defer allocator.free(msg);\n   260→    try outputErrorTyped(T, output, json_mode, msg);\n   261→}\n   262→\n   263→/// Initialize just the output without loading workspace.\n   264→/// Useful for commands that do their own workspace handling.\n   265→pub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Output {\n   266→    return Output.init(allocator, .{\n   267→        .json = global.json,\n   268→        .toon = global.toon,\n   269→        .quiet = global.quiet,\n   270→        .silent = global.silent,\n   271→        .no_color = global.no_color,\n   272→    });\n   273→}\n   274→\n   275→/// Get the default actor name from environment.\n   276→pub fn getDefaultActor() ?[]const u8 {\n   277→    const builtin = @import(\"builtin\");\n   278→    if (builtin.os.tag == .windows) return null;\n   279→    return std.posix.getenv(\"USER\") orelse std.posix.getenv(\"USERNAME\");\n   280→}\n   281→\n   282→/// Read the ID prefix from config.yaml, defaulting to \"bd\".\n   283→pub fn getConfigPrefix(allocator: std.mem.Allocator, beads_dir: []const u8) ![]u8 {\n   284→    const config_path = try std.fs.path.join(allocator, &.{ beads_dir, \"config.yaml\" });\n   285→    defer allocator.free(config_path);\n   286→\n   287→    const file = std.fs.cwd().openFile(config_path, .{}) catch {\n   288→        return try allocator.dupe(u8, \"bd\");\n   289→    };\n   290→    defer file.close();\n   291→\n   292→    const content = file.readToEndAlloc(allocator, 4096) catch {\n   293→        return try allocator.dupe(u8, \"bd\");\n   294→    };\n   295→    defer allocator.free(content);\n   296→\n   297→    if (std.mem.indexOf(u8, content, \"prefix:\")) |prefix_pos| {\n   298→        const after_prefix = content[prefix_pos + 7 ..];\n   299→        var i: usize = 0;\n   300→        while (i < after_prefix.len and (after_prefix[i] == ' ' or after_prefix[i] == '\\t')) {\n   301→            i += 1;\n   302→        }\n   303→\n   304→        if (i < after_prefix.len) {\n   305→            if (after_prefix[i] == '\"') {\n   306→                i += 1;\n   307→                const start = i;\n   308→                while (i < after_prefix.len and after_prefix[i] != '\"' and after_prefix[i] != '\\n') {\n   309→                    i += 1;\n   310→                }\n   311→                if (i > start) {\n   312→                    return try allocator.dupe(u8, after_prefix[start..i]);\n   313→                }\n   314→            } else {\n   315→                const start = i;\n   316→                while (i < after_prefix.len and after_prefix[i] != '\\n' and after_prefix[i] != ' ' and after_prefix[i] != '\\t') {\n   317→                    i += 1;\n   318→                }\n   319→                if (i > start) {\n   320→                    return try allocator.dupe(u8, after_prefix[start..i]);\n   321→                }\n   322→            }\n   323→        }\n   324→    }\n   325→\n   326→    return try allocator.dupe(u8, \"bd\");\n   327→}\n   328→\n   329→// --- Tests ---\n   330→\n   331→test \"CommandContext returns null for uninitialized workspace\" {\n   332→    const allocator = std.testing.allocator;\n   333→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   334→\n   335→    const ctx = try CommandContext.init(allocator, global);\n   336→    try std.testing.expect(ctx == null);\n   337→}\n   338→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d9b2ac01-8e74-4eb3-8db9-196341043123","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/common.zig","content":"//! Common CLI utilities shared across commands.\n//!\n//! Provides workspace loading, error handling, and shared result types\n//! to reduce duplication across command implementations.\n\nconst std = @import(\"std\");\nconst storage = @import(\"../storage/mod.zig\");\nconst output_mod = @import(\"../output/mod.zig\");\nconst args = @import(\"args.zig\");\n\npub const Output = output_mod.Output;\npub const OutputOptions = output_mod.OutputOptions;\npub const IssueStore = storage.IssueStore;\npub const IssueStoreError = storage.IssueStoreError;\npub const DependencyGraph = storage.DependencyGraph;\npub const EventStore = storage.EventStore;\npub const StoreLoadResult = storage.StoreLoadResult;\n\n/// Common errors shared across CLI commands.\npub const CommandError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\n/// Context for executing a CLI command with an initialized workspace.\npub const CommandContext = struct {\n    allocator: std.mem.Allocator,\n    output: Output,\n    store: IssueStore,\n    event_store: EventStore,\n    beads_dir: []const u8,\n    issues_path: []const u8,\n    events_path: []const u8,\n    global: args.GlobalOptions,\n    /// Number of corrupt entries skipped during load.\n    corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (owned memory).\n    corrupt_lines: []const usize = &.{},\n    /// Number of WAL entries replayed during load.\n    wal_entries_replayed: usize = 0,\n\n    /// Initialize a command context by loading the workspace.\n    /// Returns null and outputs an error if workspace is not initialized.\n    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    /// Replays WAL entries after loading main file for consistency.\n    pub fn init(\n        allocator: std.mem.Allocator,\n        global: args.GlobalOptions,\n    ) CommandError!?CommandContext {\n        var output = Output.init(allocator, .{\n            .json = global.json,\n            .toon = global.toon,\n            .quiet = global.quiet,\n            .silent = global.silent,\n            .no_color = global.no_color,\n        });\n\n        const beads_dir_str = global.data_path orelse \".beads\";\n        const beads_dir = allocator.dupe(u8, beads_dir_str) catch {\n            return CommandError.OutOfMemory;\n        };\n        const issues_path = std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" }) catch {\n            allocator.free(beads_dir);\n            return CommandError.OutOfMemory;\n        };\n        const events_path = std.fs.path.join(allocator, &.{ beads_dir, \"events.jsonl\" }) catch {\n            allocator.free(issues_path);\n            allocator.free(beads_dir);\n            return CommandError.OutOfMemory;\n        };\n\n        std.fs.cwd().access(issues_path, .{}) catch |err| {\n            if (err == error.FileNotFound) {\n                outputErrorGeneric(&output, global.isStructuredOutput(), \"workspace not initialized. Run 'bz init' first.\") catch {};\n                allocator.free(issues_path);\n                allocator.free(events_path);\n                allocator.free(beads_dir);\n                return null;\n            }\n            outputErrorGeneric(&output, global.isStructuredOutput(), \"cannot access workspace\") catch {};\n            allocator.free(issues_path);\n            allocator.free(events_path);\n            allocator.free(beads_dir);\n            return CommandError.StorageError;\n        };\n\n        var store = IssueStore.init(allocator, issues_path);\n        var corruption_count: usize = 0;\n        var corrupt_lines: []const usize = &.{};\n\n        // Use recovery mode: log and skip corrupt entries instead of failing\n        const load_result = store.loadFromFileWithRecovery() catch |err| {\n            if (err != error.FileNotFound) {\n                outputErrorGeneric(&output, global.isStructuredOutput(), \"failed to load issues\") catch {};\n                store.deinit();\n                allocator.free(issues_path);\n                allocator.free(events_path);\n                allocator.free(beads_dir);\n                return CommandError.StorageError;\n            }\n            // File not found is OK - empty workspace\n            var event_store_empty = EventStore.init(allocator, events_path);\n            event_store_empty.loadNextId() catch {};\n            return CommandContext{\n                .allocator = allocator,\n                .output = output,\n                .store = store,\n                .event_store = event_store_empty,\n                .beads_dir = beads_dir,\n                .issues_path = issues_path,\n                .events_path = events_path,\n                .global = global,\n                .corruption_count = 0,\n                .corrupt_lines = &.{},\n                .wal_entries_replayed = 0,\n            };\n        };\n\n        corruption_count = load_result.jsonl_corruption_count;\n        corrupt_lines = load_result.jsonl_corrupt_lines;\n\n        // Replay WAL entries onto the store for consistency\n        var wal_entries_replayed: usize = 0;\n        wal_replay: {\n            var wal_obj = storage.Wal.init(beads_dir, allocator) catch {\n                break :wal_replay;\n            };\n            defer wal_obj.deinit();\n\n            var replay_stats = wal_obj.replay(&store) catch {\n                break :wal_replay;\n            };\n            defer replay_stats.deinit(allocator);\n            wal_entries_replayed = replay_stats.applied;\n        }\n\n        // Warn user about corruption (unless quiet/silent mode)\n        if (corruption_count > 0 and !global.quiet and !global.silent and !global.isStructuredOutput()) {\n            output.print(\"warning: {d} corrupt entries skipped during load\\n\", .{corruption_count}) catch {};\n            output.print(\"         Run 'bz doctor' for details, 'bz compact' to rebuild.\\n\", .{}) catch {};\n        }\n\n        // Initialize event store and load next ID\n        var event_store = EventStore.init(allocator, events_path);\n        event_store.loadNextId() catch {}; // OK if events file doesn't exist\n\n        return CommandContext{\n            .allocator = allocator,\n            .output = output,\n            .store = store,\n            .event_store = event_store,\n            .beads_dir = beads_dir,\n            .issues_path = issues_path,\n            .events_path = events_path,\n            .global = global,\n            .corruption_count = corruption_count,\n            .corrupt_lines = corrupt_lines,\n            .wal_entries_replayed = wal_entries_replayed,\n        };\n    }\n\n    /// Clean up resources.\n    pub fn deinit(self: *CommandContext) void {\n        self.store.deinit();\n        self.allocator.free(self.beads_dir);\n        self.allocator.free(self.issues_path);\n        self.allocator.free(self.events_path);\n        if (self.corrupt_lines.len > 0) {\n            self.allocator.free(self.corrupt_lines);\n        }\n    }\n\n    /// Check if corruption was detected during load.\n    pub fn hasCorruption(self: *const CommandContext) bool {\n        return self.corruption_count > 0;\n    }\n\n    /// Save the store to file if auto-flush is enabled.\n    /// Note: For single-issue writes, prefer appendToWal() for better performance.\n    pub fn saveIfAutoFlush(self: *CommandContext) CommandError!void {\n        if (!self.global.no_auto_flush) {\n            self.store.saveToFile() catch {\n                outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to save issues\") catch {};\n                return CommandError.StorageError;\n            };\n        }\n    }\n\n    /// Append an issue to the WAL for fast persistence.\n    /// Use this for single-issue creates/updates instead of saveToFile().\n    pub fn appendToWal(self: *CommandContext, issue: @import(\"../models/issue.zig\").Issue, op: storage.WalOp) CommandError!void {\n        if (self.global.no_auto_flush) return;\n\n        var wal_obj = storage.Wal.init(self.beads_dir, self.allocator) catch {\n            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to initialize WAL\") catch {};\n            return CommandError.StorageError;\n        };\n        defer wal_obj.deinit();\n\n        wal_obj.appendEntry(.{\n            .op = op,\n            .ts = std.time.timestamp(),\n            .id = issue.id,\n            .data = issue,\n        }) catch {\n            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to write to WAL\") catch {};\n            return CommandError.StorageError;\n        };\n    }\n\n    /// Create a dependency graph from the store.\n    pub fn createGraph(self: *CommandContext) DependencyGraph {\n        return DependencyGraph.init(&self.store, self.allocator);\n    }\n\n    /// Record an audit event. Silently ignores errors (audit is best-effort).\n    pub fn recordEvent(self: *CommandContext, event: @import(\"../models/event.zig\").Event) void {\n        _ = self.event_store.append(event) catch {};\n    }\n};\n\n/// Output a generic error message in the appropriate format.\npub fn outputErrorGeneric(output: *Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(.{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n/// Output an error with a specific result type for JSON mode.\npub fn outputErrorTyped(\n    comptime T: type,\n    output: *Output,\n    json_mode: bool,\n    message: []const u8,\n) !void {\n    if (json_mode) {\n        const result = T{ .success = false, .message = message };\n        try output.printJson(result);\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n/// Output a \"not found\" error for an issue.\npub fn outputNotFoundError(\n    comptime T: type,\n    output: *Output,\n    json_mode: bool,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    const msg = try std.fmt.allocPrint(allocator, \"issue not found: {s}\", .{id});\n    defer allocator.free(msg);\n    try outputErrorTyped(T, output, json_mode, msg);\n}\n\n/// Initialize just the output without loading workspace.\n/// Useful for commands that do their own workspace handling.\npub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Output {\n    return Output.init(allocator, .{\n        .json = global.json,\n        .toon = global.toon,\n        .quiet = global.quiet,\n        .silent = global.silent,\n        .no_color = global.no_color,\n    });\n}\n\n/// Get the default actor name from environment.\npub fn getDefaultActor() ?[]const u8 {\n    const builtin = @import(\"builtin\");\n    if (builtin.os.tag == .windows) return null;\n    return std.posix.getenv(\"USER\") orelse std.posix.getenv(\"USERNAME\");\n}\n\n/// Read the ID prefix from config.yaml, defaulting to \"bd\".\npub fn getConfigPrefix(allocator: std.mem.Allocator, beads_dir: []const u8) ![]u8 {\n    const config_path = try std.fs.path.join(allocator, &.{ beads_dir, \"config.yaml\" });\n    defer allocator.free(config_path);\n\n    const file = std.fs.cwd().openFile(config_path, .{}) catch {\n        return try allocator.dupe(u8, \"bd\");\n    };\n    defer file.close();\n\n    const content = file.readToEndAlloc(allocator, 4096) catch {\n        return try allocator.dupe(u8, \"bd\");\n    };\n    defer allocator.free(content);\n\n    if (std.mem.indexOf(u8, content, \"prefix:\")) |prefix_pos| {\n        const after_prefix = content[prefix_pos + 7 ..];\n        var i: usize = 0;\n        while (i < after_prefix.len and (after_prefix[i] == ' ' or after_prefix[i] == '\\t')) {\n            i += 1;\n        }\n\n        if (i < after_prefix.len) {\n            if (after_prefix[i] == '\"') {\n                i += 1;\n                const start = i;\n                while (i < after_prefix.len and after_prefix[i] != '\"' and after_prefix[i] != '\\n') {\n                    i += 1;\n                }\n                if (i > start) {\n                    return try allocator.dupe(u8, after_prefix[start..i]);\n                }\n            } else {\n                const start = i;\n                while (i < after_prefix.len and after_prefix[i] != '\\n' and after_prefix[i] != ' ' and after_prefix[i] != '\\t') {\n                    i += 1;\n                }\n                if (i > start) {\n                    return try allocator.dupe(u8, after_prefix[start..i]);\n                }\n            }\n        }\n    }\n\n    return try allocator.dupe(u8, \"bd\");\n}\n\n// --- Tests ---\n\ntest \"CommandContext returns null for uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const ctx = try CommandContext.init(allocator, global);\n    try std.testing.expect(ctx == null);\n}\n","numLines":338,"startLine":1,"totalLines":338}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GZXzj47eCV142rNxxNKccX","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me look at the main.zig to see how commands are dispatched:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7912,"cache_read_input_tokens":48915,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7912},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0ea92b04-4041-4e2a-a759-72fc37fd88e4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GZXzj47eCV142rNxxNKccX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0117KyNSbF5mmdMo9AyyYV1H","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7912,"cache_read_input_tokens":48915,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7912},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9da8bb57-e33b-43ac-b10a-2f3e8a8fc5dc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0117KyNSbF5mmdMo9AyyYV1H","type":"tool_result","content":"     1→//! beads_zig CLI entry point.\n     2→//!\n     3→//! Binary name: bz (beads-zig)\n     4→\n     5→const std = @import(\"std\");\n     6→const beads_zig = @import(\"beads_zig\");\n     7→const cli = beads_zig.cli;\n     8→const output = beads_zig.output;\n     9→\n    10→pub fn main() !void {\n    11→    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    12→    defer _ = gpa.deinit();\n    13→    const allocator = gpa.allocator();\n    14→\n    15→    run(allocator) catch |err| {\n    16→        const stderr = std.fs.File.stderr();\n    17→        stderr.writeAll(\"error: \") catch {};\n    18→        stderr.writeAll(@errorName(err)) catch {};\n    19→        stderr.writeAll(\"\\n\") catch {};\n    20→        std.process.exit(1);\n    21→    };\n    22→}\n    23→\n    24→fn run(allocator: std.mem.Allocator) !void {\n    25→    const args = try std.process.argsAlloc(allocator);\n    26→    defer std.process.argsFree(allocator, args);\n    27→\n    28→    // Skip program name\n    29→    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n    30→\n    31→    var parser = cli.ArgParser.init(allocator, cmd_args);\n    32→    var result = parser.parse() catch |err| {\n    33→        return handleParseError(err, allocator);\n    34→    };\n    35→    defer result.deinit(allocator);\n    36→\n    37→    try dispatch(result, allocator);\n    38→}\n    39→\n    40→fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    41→    switch (result.command) {\n    42→        .init => |init_args| {\n    43→            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n    44→                error.AlreadyInitialized => std.process.exit(1),\n    45→                else => return err,\n    46→            };\n    47→        },\n    48→        .create => |create_args| {\n    49→            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n    50→                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n    51→                else => return err,\n    52→            };\n    53→        },\n    54→        .q => |quick_args| {\n    55→            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n    56→                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n    57→                else => return err,\n    58→            };\n    59→        },\n    60→        .list => |list_args| {\n    61→            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n    62→                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n    63→                else => return err,\n    64→            };\n    65→        },\n    66→        .show => |show_args| {\n    67→            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n    68→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n    69→                else => return err,\n    70→            };\n    71→        },\n    72→        .update => |update_args| {\n    73→            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n    74→                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n    75→                else => return err,\n    76→            };\n    77→        },\n    78→        .close => |close_args| {\n    79→            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n    80→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n    81→                else => return err,\n    82→            };\n    83→        },\n    84→        .reopen => |reopen_args| {\n    85→            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n    86→                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n    87→                else => return err,\n    88→            };\n    89→        },\n    90→        .delete => |delete_args| {\n    91→            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n    92→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n    93→                else => return err,\n    94→            };\n    95→        },\n    96→        .add_batch => |batch_args| {\n    97→            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n    98→                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n    99→                else => return err,\n   100→            };\n   101→        },\n   102→        .import_cmd => |import_args| {\n   103→            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n   104→                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n   105→                else => return err,\n   106→            };\n   107→        },\n   108→        .ready => |ready_args| {\n   109→            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n   110→                error.WorkspaceNotInitialized => std.process.exit(1),\n   111→                else => return err,\n   112→            };\n   113→        },\n   114→        .blocked => |blocked_args| {\n   115→            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n   116→                error.WorkspaceNotInitialized => std.process.exit(1),\n   117→                else => return err,\n   118→            };\n   119→        },\n   120→        .dep => |dep_args| {\n   121→            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n   122→                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n   123→                else => return err,\n   124→            };\n   125→        },\n   126→        .graph => |graph_args| {\n   127→            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n   128→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n   129→                else => return err,\n   130→            };\n   131→        },\n   132→        .epic => |epic_args| {\n   133→            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n   134→                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n   135→                else => return err,\n   136→            };\n   137→        },\n   138→        .sync => |sync_args| {\n   139→            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n   140→                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n   141→                else => return err,\n   142→            };\n   143→        },\n   144→        .search => |search_args| {\n   145→            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n   146→                error.WorkspaceNotInitialized => std.process.exit(1),\n   147→                else => return err,\n   148→            };\n   149→        },\n   150→        .stale => |stale_args| {\n   151→            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n   152→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   153→                else => return err,\n   154→            };\n   155→        },\n   156→        .count => |count_args| {\n   157→            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n   158→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   159→                else => return err,\n   160→            };\n   161→        },\n   162→        .defer_cmd => |defer_args| {\n   163→            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n   164→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n   165→                else => return err,\n   166→            };\n   167→        },\n   168→        .undefer => |undefer_args| {\n   169→            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n   170→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n   171→                else => return err,\n   172→            };\n   173→        },\n   174→        .help => |help_args| {\n   175→            cli.runHelp(help_args.topic, allocator) catch {\n   176→                std.process.exit(1);\n   177→            };\n   178→        },\n   179→        .version => {\n   180→            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n   181→                error.WriteError => std.process.exit(1),\n   182→            };\n   183→        },\n   184→        .schema => {\n   185→            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n   186→                error.WriteError, error.OutOfMemory => std.process.exit(1),\n   187→            };\n   188→        },\n   189→        .completions => |comp_args| {\n   190→            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n   191→                error.WriteError => std.process.exit(1),\n   192→            };\n   193→        },\n   194→        .metrics => |metrics_args| {\n   195→            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n   196→                error.WriteError, error.OutOfMemory => std.process.exit(1),\n   197→            };\n   198→        },\n   199→        .info => {\n   200→            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n   201→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   202→                else => return err,\n   203→            };\n   204→        },\n   205→        .stats => {\n   206→            cli.runStats(result.global, allocator) catch |err| switch (err) {\n   207→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   208→                else => return err,\n   209→            };\n   210→        },\n   211→        .doctor => {\n   212→            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n   213→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   214→                else => return err,\n   215→            };\n   216→        },\n   217→        .config => |config_args| {\n   218→            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n   219→                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n   220→                else => return err,\n   221→            };\n   222→        },\n   223→        .orphans => |orphans_args| {\n   224→            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n   225→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   226→                else => return err,\n   227→            };\n   228→        },\n   229→        .lint => |lint_args| {\n   230→            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n   231→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   232→                else => return err,\n   233→            };\n   234→        },\n   235→        .label => |label_args| {\n   236→            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n   237→                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n   238→                else => return err,\n   239→            };\n   240→        },\n   241→        .comments => |comments_args| {\n   242→            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n   243→                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n   244→                else => return err,\n   245→            };\n   246→        },\n   247→        .history => |history_args| {\n   248→            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n   249→                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n   250→                else => return err,\n   251→            };\n   252→        },\n   253→        .audit => |audit_args| {\n   254→            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n   255→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   256→                else => return err,\n   257→            };\n   258→        },\n   259→        .changelog => |changelog_args| {\n   260→            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n   261→                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n   262→                else => return err,\n   263→            };\n   264→        },\n   265→        .query => |query_args| {\n   266→            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n   267→                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n   268→                else => return err,\n   269→            };\n   270→        },\n   271→        .upgrade => |upgrade_args| {\n   272→            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n   273→                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n   274→                else => return err,\n   275→            };\n   276→        },\n   277→    }\n   278→}\n   279→\n   280→fn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n   281→    var out = output.Output.init(allocator, .{});\n   282→    switch (err) {\n   283→        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n   284→        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n   285→        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n   286→        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n   287→        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n   288→        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n   289→        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n   290→        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n   291→    }\n   292→    std.process.exit(1);\n   293→}\n   294→\n   295→test \"library imports compile\" {\n   296→    // Verify all modules are accessible\n   297→    _ = beads_zig.cli;\n   298→    _ = beads_zig.storage;\n   299→    _ = beads_zig.models;\n   300→    _ = beads_zig.sync;\n   301→    _ = beads_zig.id;\n   302→    _ = beads_zig.config;\n   303→    _ = beads_zig.output;\n   304→}\n   305→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"bd2c7bf2-d7e4-408c-a8c0-138ba72c8799","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","content":"//! beads_zig CLI entry point.\n//!\n//! Binary name: bz (beads-zig)\n\nconst std = @import(\"std\");\nconst beads_zig = @import(\"beads_zig\");\nconst cli = beads_zig.cli;\nconst output = beads_zig.output;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    run(allocator) catch |err| {\n        const stderr = std.fs.File.stderr();\n        stderr.writeAll(\"error: \") catch {};\n        stderr.writeAll(@errorName(err)) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        std.process.exit(1);\n    };\n}\n\nfn run(allocator: std.mem.Allocator) !void {\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    // Skip program name\n    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n\n    var parser = cli.ArgParser.init(allocator, cmd_args);\n    var result = parser.parse() catch |err| {\n        return handleParseError(err, allocator);\n    };\n    defer result.deinit(allocator);\n\n    try dispatch(result, allocator);\n}\n\nfn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    switch (result.command) {\n        .init => |init_args| {\n            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n                error.AlreadyInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .create => |create_args| {\n            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .q => |quick_args| {\n            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .list => |list_args| {\n            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .show => |show_args| {\n            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .update => |update_args| {\n            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .close => |close_args| {\n            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .reopen => |reopen_args| {\n            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .delete => |delete_args| {\n            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .add_batch => |batch_args| {\n            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .import_cmd => |import_args| {\n            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .ready => |ready_args| {\n            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .blocked => |blocked_args| {\n            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .dep => |dep_args| {\n            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .graph => |graph_args| {\n            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .epic => |epic_args| {\n            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .orphans => |orphans_args| {\n            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .lint => |lint_args| {\n            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .label => |label_args| {\n            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .comments => |comments_args| {\n            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .history => |history_args| {\n            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n    }\n    std.process.exit(1);\n}\n\ntest \"library imports compile\" {\n    // Verify all modules are accessible\n    _ = beads_zig.cli;\n    _ = beads_zig.storage;\n    _ = beads_zig.models;\n    _ = beads_zig.sync;\n    _ = beads_zig.id;\n    _ = beads_zig.config;\n    _ = beads_zig.output;\n}\n","numLines":305,"startLine":1,"totalLines":305}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GZXzj47eCV142rNxxNKccX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013hDWYDTxY7rxpTrCm9VfbL","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":500,"limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7912,"cache_read_input_tokens":48915,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7912},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"64fb7e96-51ce-444c-b96f-61186b7fb39f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013hDWYDTxY7rxpTrCm9VfbL","type":"tool_result","content":"   500→};\n   501→\n   502→/// Errors that can occur during argument parsing.\n   503→pub const ParseError = error{\n   504→    UnknownCommand,\n   505→    MissingRequiredArgument,\n   506→    InvalidArgument,\n   507→    UnknownFlag,\n   508→    MissingFlagValue,\n   509→    InvalidFlagValue,\n   510→    InvalidShell,\n   511→    UnknownSubcommand,\n   512→};\n   513→\n   514→/// Command-line argument parser.\n   515→pub const ArgParser = struct {\n   516→    allocator: std.mem.Allocator,\n   517→    args: []const []const u8,\n   518→    index: usize = 0,\n   519→\n   520→    const Self = @This();\n   521→\n   522→    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n   523→        return .{\n   524→            .allocator = allocator,\n   525→            .args = args,\n   526→        };\n   527→    }\n   528→\n   529→    /// Parse all arguments into a ParseResult.\n   530→    pub fn parse(self: *Self) ParseError!ParseResult {\n   531→        var global = GlobalOptions{};\n   532→\n   533→        // Parse global flags first\n   534→        while (self.hasNext()) {\n   535→            const arg = self.peek().?;\n   536→            if (std.mem.startsWith(u8, arg, \"-\")) {\n   537→                if (self.parseGlobalFlag(&global)) |consumed| {\n   538→                    if (!consumed) break;\n   539→                } else |_| {\n   540→                    break;\n   541→                }\n   542→            } else {\n   543→                break;\n   544→            }\n   545→        }\n   546→\n   547→        // Parse subcommand\n   548→        const cmd_str = self.next() orelse {\n   549→            return .{\n   550→                .global = global,\n   551→                .command = .{ .help = .{ .topic = null } },\n   552→            };\n   553→        };\n   554→\n   555→        const command = try self.parseCommand(cmd_str);\n   556→\n   557→        return .{\n   558→            .global = global,\n   559→            .command = command,\n   560→        };\n   561→    }\n   562→\n   563→    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n   564→        const arg = self.next().?;\n   565→\n   566→        if (std.mem.eql(u8, arg, \"--json\")) {\n   567→            global.json = true;\n   568→            return true;\n   569→        }\n   570→        if (std.mem.eql(u8, arg, \"--toon\")) {\n   571→            global.toon = true;\n   572→            return true;\n   573→        }\n   574→        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   575→            global.quiet = true;\n   576→            return true;\n   577→        }\n   578→        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   579→            global.verbose +|= 1;\n   580→            return true;\n   581→        }\n   582→        if (std.mem.eql(u8, arg, \"-vv\")) {\n   583→            global.verbose +|= 2;\n   584→            return true;\n   585→        }\n   586→        if (std.mem.eql(u8, arg, \"--no-color\")) {\n   587→            global.no_color = true;\n   588→            return true;\n   589→        }\n   590→        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n   591→            global.no_auto_flush = true;\n   592→            return true;\n   593→        }\n   594→        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n   595→            global.no_auto_import = true;\n   596→            return true;\n   597→        }\n   598→        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n   599→            global.data_path = self.next() orelse return error.MissingFlagValue;\n   600→            return true;\n   601→        }\n   602→        if (std.mem.eql(u8, arg, \"--actor\")) {\n   603→            global.actor = self.next() orelse return error.MissingFlagValue;\n   604→            return true;\n   605→        }\n   606→        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n   607→            const val = self.next() orelse return error.MissingFlagValue;\n   608→            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n   609→            return true;\n   610→        }\n   611→\n   612→        // Put back if not recognized\n   613→        self.index -= 1;\n   614→        return error.UnknownFlag;\n   615→    }\n   616→\n   617→    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n   618→        // Workspace\n   619→        if (std.mem.eql(u8, cmd, \"init\")) {\n   620→            return .{ .init = try self.parseInitArgs() };\n   621→        }\n   622→        if (std.mem.eql(u8, cmd, \"info\")) {\n   623→            return .{ .info = {} };\n   624→        }\n   625→        if (std.mem.eql(u8, cmd, \"stats\")) {\n   626→            return .{ .stats = {} };\n   627→        }\n   628→        if (std.mem.eql(u8, cmd, \"doctor\")) {\n   629→            return .{ .doctor = {} };\n   630→        }\n   631→        if (std.mem.eql(u8, cmd, \"config\")) {\n   632→            return .{ .config = try self.parseConfigArgs() };\n   633→        }\n   634→        if (std.mem.eql(u8, cmd, \"orphans\")) {\n   635→            return .{ .orphans = try self.parseOrphansArgs() };\n   636→        }\n   637→        if (std.mem.eql(u8, cmd, \"lint\")) {\n   638→            return .{ .lint = try self.parseLintArgs() };\n   639→        }\n   640→\n   641→        // Issue CRUD\n   642→        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n   643→            return .{ .create = try self.parseCreateArgs() };\n   644→        }\n   645→        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n   646→            return .{ .q = try self.parseQuickArgs() };\n   647→        }\n   648→        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n   649→            return .{ .show = try self.parseShowArgs() };\n   650→        }\n   651→        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n   652→            return .{ .update = try self.parseUpdateArgs() };\n   653→        }\n   654→        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n   655→            return .{ .close = try self.parseCloseArgs() };\n   656→        }\n   657→        if (std.mem.eql(u8, cmd, \"reopen\")) {\n   658→            return .{ .reopen = try self.parseReopenArgs() };\n   659→        }\n   660→        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n   661→            return .{ .delete = try self.parseDeleteArgs() };\n   662→        }\n   663→\n   664→        // Batch Operations\n   665→        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n   666→            return .{ .add_batch = try self.parseAddBatchArgs() };\n   667→        }\n   668→        if (std.mem.eql(u8, cmd, \"import\")) {\n   669→            return .{ .import_cmd = try self.parseImportArgs() };\n   670→        }\n   671→\n   672→        // Query\n   673→        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n   674→            return .{ .list = try self.parseListArgs() };\n   675→        }\n   676→        if (std.mem.eql(u8, cmd, \"ready\")) {\n   677→            return .{ .ready = try self.parseReadyArgs() };\n   678→        }\n   679→        if (std.mem.eql(u8, cmd, \"blocked\")) {\n   680→            return .{ .blocked = try self.parseBlockedArgs() };\n   681→        }\n   682→        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n   683→            return .{ .search = try self.parseSearchArgs() };\n   684→        }\n   685→        if (std.mem.eql(u8, cmd, \"stale\")) {\n   686→            return .{ .stale = try self.parseStaleArgs() };\n   687→        }\n   688→        if (std.mem.eql(u8, cmd, \"count\")) {\n   689→            return .{ .count = try self.parseCountArgs() };\n   690→        }\n   691→        if (std.mem.eql(u8, cmd, \"defer\")) {\n   692→            return .{ .defer_cmd = try self.parseDeferArgs() };\n   693→        }\n   694→        if (std.mem.eql(u8, cmd, \"undefer\")) {\n   695→            return .{ .undefer = try self.parseUndeferArgs() };\n   696→        }\n   697→\n   698→        // Dependencies\n   699→        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n   700→            return .{ .dep = try self.parseDepArgs() };\n   701→        }\n   702→        if (std.mem.eql(u8, cmd, \"graph\")) {\n   703→            return .{ .graph = try self.parseGraphArgs() };\n   704→        }\n   705→\n   706→        // Epics\n   707→        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n   708→            return .{ .epic = try self.parseEpicArgs() };\n   709→        }\n   710→\n   711→        // Labels\n   712→        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n   713→            return .{ .label = try self.parseLabelArgs() };\n   714→        }\n   715→\n   716→        // Comments\n   717→        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n   718→            return .{ .comments = try self.parseCommentsArgs() };\n   719→        }\n   720→\n   721→        // Audit\n   722→        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n   723→            return .{ .history = try self.parseHistoryArgs() };\n   724→        }\n   725→        if (std.mem.eql(u8, cmd, \"audit\")) {\n   726→            return .{ .audit = try self.parseAuditArgs() };\n   727→        }\n   728→\n   729→        // Changelog\n   730→        if (std.mem.eql(u8, cmd, \"changelog\")) {\n   731→            return .{ .changelog = try self.parseChangelogArgs() };\n   732→        }\n   733→\n   734→        // Sync\n   735→        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n   736→            return .{ .sync = try self.parseSyncArgs() };\n   737→        }\n   738→\n   739→        // System\n   740→        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n   741→            return .{ .version = {} };\n   742→        }\n   743→        if (std.mem.eql(u8, cmd, \"schema\")) {\n   744→            return .{ .schema = {} };\n   745→        }\n   746→        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n   747→            return .{ .completions = try self.parseCompletionsArgs() };\n   748→        }\n   749→        if (std.mem.eql(u8, cmd, \"metrics\")) {\n   750→            return .{ .metrics = try self.parseMetricsArgs() };\n   751→        }\n   752→\n   753→        // Saved Queries\n   754→        if (std.mem.eql(u8, cmd, \"query\")) {\n   755→            return .{ .query = try self.parseQueryArgs() };\n   756→        }\n   757→\n   758→        // Self-upgrade\n   759→        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n   760→            return .{ .upgrade = try self.parseUpgradeArgs() };\n   761→        }\n   762→\n   763→        // Help\n   764→        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n   765→            return .{ .help = try self.parseHelpArgs() };\n   766→        }\n   767→\n   768→        return error.UnknownCommand;\n   769→    }\n   770→\n   771→    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n   772→        var result = InitArgs{};\n   773→        while (self.hasNext()) {\n   774→            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n   775→                result.prefix = self.next() orelse return error.MissingFlagValue;\n   776→            } else if (self.peekPositional()) |_| {\n   777→                result.prefix = self.next().?;\n   778→            } else break;\n   779→        }\n   780→        return result;\n   781→    }\n   782→\n   783→    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n   784→        var result = CreateArgs{ .title = undefined };\n   785→        var title_set = false;\n   786→        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n   787→        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n   788→\n   789→        while (self.hasNext()) {\n   790→            if (self.consumeFlag(\"-d\", \"--description\")) {\n   791→                result.description = self.next() orelse return error.MissingFlagValue;\n   792→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   793→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   794→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   795→                result.priority = self.next() orelse return error.MissingFlagValue;\n   796→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   797→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   798→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n   799→                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n   800→            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n   801→                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n   802→            } else if (self.consumeFlag(null, \"--due\")) {\n   803→                result.due = self.next() orelse return error.MissingFlagValue;\n   804→            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n   805→                const val = self.next() orelse return error.MissingFlagValue;\n   806→                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n   807→            } else if (self.peekPositional()) |_| {\n   808→                if (!title_set) {\n   809→                    result.title = self.next().?;\n   810→                    title_set = true;\n   811→                } else break;\n   812→            } else break;\n   813→        }\n   814→\n   815→        if (!title_set) return error.MissingRequiredArgument;\n   816→\n   817→        if (labels.items.len > 0) {\n   818→            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n   819→        }\n   820→        if (deps.items.len > 0) {\n   821→            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n   822→        }\n   823→\n   824→        return result;\n   825→    }\n   826→\n   827→    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n   828→        var result = QuickArgs{ .title = undefined };\n   829→        var title_set = false;\n   830→\n   831→        while (self.hasNext()) {\n   832→            if (self.consumeFlag(\"-p\", \"--priority\")) {\n   833→                result.priority = self.next() orelse return error.MissingFlagValue;\n   834→            } else if (self.peekPositional()) |_| {\n   835→                if (!title_set) {\n   836→                    result.title = self.next().?;\n   837→                    title_set = true;\n   838→                } else break;\n   839→            } else break;\n   840→        }\n   841→\n   842→        if (!title_set) return error.MissingRequiredArgument;\n   843→        return result;\n   844→    }\n   845→\n   846→    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n   847→        var result = ShowArgs{ .id = undefined };\n   848→        var id_set = false;\n   849→\n   850→        while (self.hasNext()) {\n   851→            if (self.consumeFlag(null, \"--no-comments\")) {\n   852→                result.with_comments = false;\n   853→            } else if (self.consumeFlag(null, \"--with-history\")) {\n   854→                result.with_history = true;\n   855→            } else if (self.peekPositional()) |_| {\n   856→                if (!id_set) {\n   857→                    result.id = self.next().?;\n   858→                    id_set = true;\n   859→                } else break;\n   860→            } else break;\n   861→        }\n   862→\n   863→        if (!id_set) return error.MissingRequiredArgument;\n   864→        return result;\n   865→    }\n   866→\n   867→    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n   868→        var result = UpdateArgs{ .id = undefined };\n   869→        var id_set = false;\n   870→\n   871→        while (self.hasNext()) {\n   872→            if (self.consumeFlag(null, \"--title\")) {\n   873→                result.title = self.next() orelse return error.MissingFlagValue;\n   874→            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n   875→                result.description = self.next() orelse return error.MissingFlagValue;\n   876→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   877→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   878→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   879→                result.priority = self.next() orelse return error.MissingFlagValue;\n   880→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   881→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   882→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n   883→                result.status = self.next() orelse return error.MissingFlagValue;\n   884→            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n   885→                const version_str = self.next() orelse return error.MissingFlagValue;\n   886→                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n   887→            } else if (self.peekPositional()) |_| {\n   888→                if (!id_set) {\n   889→                    result.id = self.next().?;\n   890→                    id_set = true;\n   891→                } else break;\n   892→            } else break;\n   893→        }\n   894→\n   895→        if (!id_set) return error.MissingRequiredArgument;\n   896→        return result;\n   897→    }\n   898→\n   899→    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n   900→        var result = CloseArgs{ .id = undefined };\n   901→        var id_set = false;\n   902→\n   903→        while (self.hasNext()) {\n   904→            if (self.consumeFlag(\"-r\", \"--reason\")) {\n   905→                result.reason = self.next() orelse return error.MissingFlagValue;\n   906→            } else if (self.peekPositional()) |_| {\n   907→                if (!id_set) {\n   908→                    result.id = self.next().?;\n   909→                    id_set = true;\n   910→                } else break;\n   911→            } else break;\n   912→        }\n   913→\n   914→        if (!id_set) return error.MissingRequiredArgument;\n   915→        return result;\n   916→    }\n   917→\n   918→    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n   919→        const id = self.next() orelse return error.MissingRequiredArgument;\n   920→        return .{ .id = id };\n   921→    }\n   922→\n   923→    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n   924→        const id = self.next() orelse return error.MissingRequiredArgument;\n   925→        return .{ .id = id };\n   926→    }\n   927→\n   928→    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n   929→        var result = AddBatchArgs{};\n   930→        while (self.hasNext()) {\n   931→            if (self.consumeFlag(\"-f\", \"--file\")) {\n   932→                result.file = self.next() orelse return error.MissingFlagValue;\n   933→            } else if (self.consumeFlag(null, \"--format\")) {\n   934→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n   935→                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n   936→            } else if (self.peekPositional()) |_| {\n   937→                // Positional argument is treated as file path\n   938→                if (result.file == null) {\n   939→                    result.file = self.next().?;\n   940→                } else break;\n   941→            } else break;\n   942→        }\n   943→        return result;\n   944→    }\n   945→\n   946→    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n   947→        var result = ImportArgs{ .file = undefined };\n   948→        var file_set = false;\n   949→\n   950→        while (self.hasNext()) {\n   951→            if (self.consumeFlag(\"-m\", \"--merge\")) {\n   952→                result.merge = true;\n   953→            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n   954→                result.dry_run = true;\n   955→            } else if (self.peekPositional()) |_| {\n   956→                if (!file_set) {\n   957→                    result.file = self.next().?;\n   958→                    file_set = true;\n   959→                } else break;\n   960→            } else break;\n   961→        }\n   962→\n   963→        if (!file_set) return error.MissingRequiredArgument;\n   964→        return result;\n   965→    }\n   966→\n   967→    fn parseListArgs(self: *Self) ParseError!ListArgs {\n   968→        var result = ListArgs{};\n   969→        while (self.hasNext()) {\n   970→            if (self.consumeFlag(\"-s\", \"--status\")) {\n   971→                result.status = self.next() orelse return error.MissingFlagValue;\n   972→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   973→                result.priority = self.next() orelse return error.MissingFlagValue;\n   974→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   975→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   976→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   977→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   978→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n   979→                result.label = self.next() orelse return error.MissingFlagValue;\n   980→            } else if (try self.parseLimitFlag()) |limit| {\n   981→                result.limit = limit;\n   982→            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n   983→                result.all = true;\n   984→            } else if (self.consumeFlag(null, \"--sort\")) {\n   985→                const sort_str = self.next() orelse return error.MissingFlagValue;\n   986→                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n   987→            } else if (self.consumeFlag(null, \"--asc\")) {\n   988→                result.sort_desc = false;\n   989→            } else if (self.consumeFlag(null, \"--desc\")) {\n   990→                result.sort_desc = true;\n   991→            } else break;\n   992→        }\n   993→        return result;\n   994→    }\n   995→\n   996→    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n   997→        var result = ReadyArgs{};\n   998→        while (self.hasNext()) {\n   999→            if (try self.parseLimitFlag()) |limit| {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8c0eec11-c608-499f-8d45-8d932f8fda2a","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {","numLines":500,"startLine":500,"totalLines":2276}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BekgYNwN15mCVAnrLmoVVW","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the structure. Let me check the Issue model to understand task 2 requirements:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13083,"cache_read_input_tokens":56827,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13083},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"bdc6c094-60cc-4514-95a9-d50b17680019"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BekgYNwN15mCVAnrLmoVVW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JQYXfRuyDQzQVQxTxRsxnh","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/issue.zig","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13083,"cache_read_input_tokens":56827,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13083},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"5ac8f695-0e9b-4c03-81dc-800622ed7b11"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JQYXfRuyDQzQVQxTxRsxnh","type":"tool_result","content":"     1→//! Issue struct - the primary entity in beads_zig.\n     2→//!\n     3→//! Issues track tasks, bugs, features, and other work items. All fields align\n     4→//! with beads_rust for JSONL compatibility. Timestamps are Unix epoch internally\n     5→//! but serialize to RFC3339 format in JSON for JSONL export.\n     6→\n     7→const std = @import(\"std\");\n     8→const Status = @import(\"status.zig\").Status;\n     9→const Priority = @import(\"priority.zig\").Priority;\n    10→const IssueType = @import(\"issue_type.zig\").IssueType;\n    11→const Dependency = @import(\"dependency.zig\").Dependency;\n    12→const Comment = @import(\"comment.zig\").Comment;\n    13→const timestamp = @import(\"timestamp.zig\");\n    14→\n    15→/// Validation errors for Issue.\n    16→pub const IssueError = error{\n    17→    EmptyTitle,\n    18→    TitleTooLong,\n    19→    EmptyId,\n    20→};\n    21→\n    22→/// RFC3339 timestamp wrapper for JSON serialization.\n    23→/// Stores Unix epoch internally but serializes as RFC3339 string.\n    24→pub const Rfc3339Timestamp = struct {\n    25→    value: i64,\n    26→\n    27→    const Self = @This();\n    28→\n    29→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    30→        const epoch_seconds = std.time.epoch.EpochSeconds{ .secs = @intCast(self.value) };\n    31→        const day_seconds = epoch_seconds.getDaySeconds();\n    32→        const epoch_day = epoch_seconds.getEpochDay();\n    33→        const year_day = epoch_day.calculateYearDay();\n    34→        const month_day = year_day.calculateMonthDay();\n    35→\n    36→        var buf: [25]u8 = undefined;\n    37→        const formatted = std.fmt.bufPrint(&buf, \"{d:0>4}-{d:0>2}-{d:0>2}T{d:0>2}:{d:0>2}:{d:0>2}Z\", .{\n    38→            year_day.year,\n    39→            @as(u32, month_day.month.numeric()),\n    40→            @as(u32, month_day.day_index) + 1,\n    41→            day_seconds.getHoursIntoDay(),\n    42→            day_seconds.getMinutesIntoHour(),\n    43→            day_seconds.getSecondsIntoMinute(),\n    44→        }) catch unreachable;\n    45→\n    46→        try jws.write(formatted);\n    47→    }\n    48→\n    49→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    50→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    51→        const str = switch (token) {\n    52→            .string, .allocated_string => |s| s,\n    53→            else => return error.UnexpectedToken,\n    54→        };\n    55→        return Self{ .value = timestamp.parseRfc3339(str) orelse return error.InvalidCharacter };\n    56→    }\n    57→\n    58→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    59→        _ = allocator;\n    60→        _ = options;\n    61→        return switch (source) {\n    62→            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    63→            .integer => |i| Self{ .value = i },\n    64→            else => error.UnexpectedToken,\n    65→        };\n    66→    }\n    67→};\n    68→\n    69→/// Optional RFC3339 timestamp wrapper for nullable timestamp fields.\n    70→pub const OptionalRfc3339Timestamp = struct {\n    71→    value: ?i64,\n    72→\n    73→    const Self = @This();\n    74→\n    75→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    76→        if (self.value) |v| {\n    77→            const ts = Rfc3339Timestamp{ .value = v };\n    78→            try ts.jsonStringify(jws);\n    79→        } else {\n    80→            try jws.write(null);\n    81→        }\n    82→    }\n    83→\n    84→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    85→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    86→        return switch (token) {\n    87→            .null => Self{ .value = null },\n    88→            .string, .allocated_string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    89→            else => error.UnexpectedToken,\n    90→        };\n    91→    }\n    92→\n    93→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    94→        _ = allocator;\n    95→        _ = options;\n    96→        return switch (source) {\n    97→            .null => Self{ .value = null },\n    98→            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    99→            .integer => |i| Self{ .value = i },\n   100→            else => error.UnexpectedToken,\n   101→        };\n   102→    }\n   103→};\n   104→\n   105→/// The primary issue entity. All fields align with beads_rust for JSONL compatibility.\n   106→pub const Issue = struct {\n   107→    // Identity\n   108→    id: []const u8,\n   109→    content_hash: ?[]const u8,\n   110→\n   111→    // Content\n   112→    title: []const u8,\n   113→    description: ?[]const u8,\n   114→    design: ?[]const u8,\n   115→    acceptance_criteria: ?[]const u8,\n   116→    notes: ?[]const u8,\n   117→\n   118→    // Classification\n   119→    status: Status,\n   120→    priority: Priority,\n   121→    issue_type: IssueType,\n   122→\n   123→    // Assignment\n   124→    assignee: ?[]const u8,\n   125→    owner: ?[]const u8,\n   126→\n   127→    // Timestamps (Unix epoch seconds, serialized as RFC3339)\n   128→    created_at: Rfc3339Timestamp,\n   129→    created_by: ?[]const u8,\n   130→    updated_at: Rfc3339Timestamp,\n   131→    closed_at: OptionalRfc3339Timestamp,\n   132→    close_reason: ?[]const u8,\n   133→\n   134→    // Scheduling\n   135→    due_at: OptionalRfc3339Timestamp,\n   136→    defer_until: OptionalRfc3339Timestamp,\n   137→    estimated_minutes: ?i32,\n   138→\n   139→    // External references\n   140→    external_ref: ?[]const u8,\n   141→    source_system: ?[]const u8,\n   142→\n   143→    // Flags\n   144→    pinned: bool,\n   145→    is_template: bool,\n   146→\n   147→    // Version for optimistic locking (incremented on every update)\n   148→    version: u64 = 1,\n   149→\n   150→    // Embedded relations (populated on read, not stored in issues table)\n   151→    labels: []const []const u8,\n   152→    dependencies: []const Dependency,\n   153→    comments: []const Comment,\n   154→\n   155→    const Self = @This();\n   156→\n   157→    /// Validate that the issue has all required fields and constraints.\n   158→    pub fn validate(self: Self) IssueError!void {\n   159→        if (self.id.len == 0) return IssueError.EmptyId;\n   160→        if (self.title.len == 0) return IssueError.EmptyTitle;\n   161→        if (self.title.len > 500) return IssueError.TitleTooLong;\n   162→    }\n   163→\n   164→    /// Check equality between two Issues (compares all fields except embedded relations).\n   165→    pub fn eql(a: Self, b: Self) bool {\n   166→        if (!std.mem.eql(u8, a.id, b.id)) return false;\n   167→        if (!optionalStrEql(a.content_hash, b.content_hash)) return false;\n   168→        if (!std.mem.eql(u8, a.title, b.title)) return false;\n   169→        if (!optionalStrEql(a.description, b.description)) return false;\n   170→        if (!optionalStrEql(a.design, b.design)) return false;\n   171→        if (!optionalStrEql(a.acceptance_criteria, b.acceptance_criteria)) return false;\n   172→        if (!optionalStrEql(a.notes, b.notes)) return false;\n   173→        if (!statusEql(a.status, b.status)) return false;\n   174→        if (a.priority.value != b.priority.value) return false;\n   175→        if (!issueTypeEql(a.issue_type, b.issue_type)) return false;\n   176→        if (!optionalStrEql(a.assignee, b.assignee)) return false;\n   177→        if (!optionalStrEql(a.owner, b.owner)) return false;\n   178→        if (a.created_at.value != b.created_at.value) return false;\n   179→        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n   180→        if (a.updated_at.value != b.updated_at.value) return false;\n   181→        if (a.closed_at.value != b.closed_at.value) return false;\n   182→        if (!optionalStrEql(a.close_reason, b.close_reason)) return false;\n   183→        if (a.due_at.value != b.due_at.value) return false;\n   184→        if (a.defer_until.value != b.defer_until.value) return false;\n   185→        if (a.estimated_minutes != b.estimated_minutes) return false;\n   186→        if (!optionalStrEql(a.external_ref, b.external_ref)) return false;\n   187→        if (!optionalStrEql(a.source_system, b.source_system)) return false;\n   188→        if (a.pinned != b.pinned) return false;\n   189→        if (a.is_template != b.is_template) return false;\n   190→        if (a.version != b.version) return false;\n   191→        return true;\n   192→    }\n   193→\n   194→    /// Clone the issue with deep copy of all allocated strings.\n   195→    pub fn clone(self: Self, allocator: std.mem.Allocator) !Self {\n   196→        var result: Self = undefined;\n   197→\n   198→        result.id = try allocator.dupe(u8, self.id);\n   199→        errdefer allocator.free(result.id);\n   200→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"c38ad7eb-20cb-45e9-a768-3aa602487f92","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/models/issue.zig","content":"//! Issue struct - the primary entity in beads_zig.\n//!\n//! Issues track tasks, bugs, features, and other work items. All fields align\n//! with beads_rust for JSONL compatibility. Timestamps are Unix epoch internally\n//! but serialize to RFC3339 format in JSON for JSONL export.\n\nconst std = @import(\"std\");\nconst Status = @import(\"status.zig\").Status;\nconst Priority = @import(\"priority.zig\").Priority;\nconst IssueType = @import(\"issue_type.zig\").IssueType;\nconst Dependency = @import(\"dependency.zig\").Dependency;\nconst Comment = @import(\"comment.zig\").Comment;\nconst timestamp = @import(\"timestamp.zig\");\n\n/// Validation errors for Issue.\npub const IssueError = error{\n    EmptyTitle,\n    TitleTooLong,\n    EmptyId,\n};\n\n/// RFC3339 timestamp wrapper for JSON serialization.\n/// Stores Unix epoch internally but serializes as RFC3339 string.\npub const Rfc3339Timestamp = struct {\n    value: i64,\n\n    const Self = @This();\n\n    pub fn jsonStringify(self: Self, jws: anytype) !void {\n        const epoch_seconds = std.time.epoch.EpochSeconds{ .secs = @intCast(self.value) };\n        const day_seconds = epoch_seconds.getDaySeconds();\n        const epoch_day = epoch_seconds.getEpochDay();\n        const year_day = epoch_day.calculateYearDay();\n        const month_day = year_day.calculateMonthDay();\n\n        var buf: [25]u8 = undefined;\n        const formatted = std.fmt.bufPrint(&buf, \"{d:0>4}-{d:0>2}-{d:0>2}T{d:0>2}:{d:0>2}:{d:0>2}Z\", .{\n            year_day.year,\n            @as(u32, month_day.month.numeric()),\n            @as(u32, month_day.day_index) + 1,\n            day_seconds.getHoursIntoDay(),\n            day_seconds.getMinutesIntoHour(),\n            day_seconds.getSecondsIntoMinute(),\n        }) catch unreachable;\n\n        try jws.write(formatted);\n    }\n\n    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n        const str = switch (token) {\n            .string, .allocated_string => |s| s,\n            else => return error.UnexpectedToken,\n        };\n        return Self{ .value = timestamp.parseRfc3339(str) orelse return error.InvalidCharacter };\n    }\n\n    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n        _ = allocator;\n        _ = options;\n        return switch (source) {\n            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n            .integer => |i| Self{ .value = i },\n            else => error.UnexpectedToken,\n        };\n    }\n};\n\n/// Optional RFC3339 timestamp wrapper for nullable timestamp fields.\npub const OptionalRfc3339Timestamp = struct {\n    value: ?i64,\n\n    const Self = @This();\n\n    pub fn jsonStringify(self: Self, jws: anytype) !void {\n        if (self.value) |v| {\n            const ts = Rfc3339Timestamp{ .value = v };\n            try ts.jsonStringify(jws);\n        } else {\n            try jws.write(null);\n        }\n    }\n\n    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n        return switch (token) {\n            .null => Self{ .value = null },\n            .string, .allocated_string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n            else => error.UnexpectedToken,\n        };\n    }\n\n    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n        _ = allocator;\n        _ = options;\n        return switch (source) {\n            .null => Self{ .value = null },\n            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n            .integer => |i| Self{ .value = i },\n            else => error.UnexpectedToken,\n        };\n    }\n};\n\n/// The primary issue entity. All fields align with beads_rust for JSONL compatibility.\npub const Issue = struct {\n    // Identity\n    id: []const u8,\n    content_hash: ?[]const u8,\n\n    // Content\n    title: []const u8,\n    description: ?[]const u8,\n    design: ?[]const u8,\n    acceptance_criteria: ?[]const u8,\n    notes: ?[]const u8,\n\n    // Classification\n    status: Status,\n    priority: Priority,\n    issue_type: IssueType,\n\n    // Assignment\n    assignee: ?[]const u8,\n    owner: ?[]const u8,\n\n    // Timestamps (Unix epoch seconds, serialized as RFC3339)\n    created_at: Rfc3339Timestamp,\n    created_by: ?[]const u8,\n    updated_at: Rfc3339Timestamp,\n    closed_at: OptionalRfc3339Timestamp,\n    close_reason: ?[]const u8,\n\n    // Scheduling\n    due_at: OptionalRfc3339Timestamp,\n    defer_until: OptionalRfc3339Timestamp,\n    estimated_minutes: ?i32,\n\n    // External references\n    external_ref: ?[]const u8,\n    source_system: ?[]const u8,\n\n    // Flags\n    pinned: bool,\n    is_template: bool,\n\n    // Version for optimistic locking (incremented on every update)\n    version: u64 = 1,\n\n    // Embedded relations (populated on read, not stored in issues table)\n    labels: []const []const u8,\n    dependencies: []const Dependency,\n    comments: []const Comment,\n\n    const Self = @This();\n\n    /// Validate that the issue has all required fields and constraints.\n    pub fn validate(self: Self) IssueError!void {\n        if (self.id.len == 0) return IssueError.EmptyId;\n        if (self.title.len == 0) return IssueError.EmptyTitle;\n        if (self.title.len > 500) return IssueError.TitleTooLong;\n    }\n\n    /// Check equality between two Issues (compares all fields except embedded relations).\n    pub fn eql(a: Self, b: Self) bool {\n        if (!std.mem.eql(u8, a.id, b.id)) return false;\n        if (!optionalStrEql(a.content_hash, b.content_hash)) return false;\n        if (!std.mem.eql(u8, a.title, b.title)) return false;\n        if (!optionalStrEql(a.description, b.description)) return false;\n        if (!optionalStrEql(a.design, b.design)) return false;\n        if (!optionalStrEql(a.acceptance_criteria, b.acceptance_criteria)) return false;\n        if (!optionalStrEql(a.notes, b.notes)) return false;\n        if (!statusEql(a.status, b.status)) return false;\n        if (a.priority.value != b.priority.value) return false;\n        if (!issueTypeEql(a.issue_type, b.issue_type)) return false;\n        if (!optionalStrEql(a.assignee, b.assignee)) return false;\n        if (!optionalStrEql(a.owner, b.owner)) return false;\n        if (a.created_at.value != b.created_at.value) return false;\n        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n        if (a.updated_at.value != b.updated_at.value) return false;\n        if (a.closed_at.value != b.closed_at.value) return false;\n        if (!optionalStrEql(a.close_reason, b.close_reason)) return false;\n        if (a.due_at.value != b.due_at.value) return false;\n        if (a.defer_until.value != b.defer_until.value) return false;\n        if (a.estimated_minutes != b.estimated_minutes) return false;\n        if (!optionalStrEql(a.external_ref, b.external_ref)) return false;\n        if (!optionalStrEql(a.source_system, b.source_system)) return false;\n        if (a.pinned != b.pinned) return false;\n        if (a.is_template != b.is_template) return false;\n        if (a.version != b.version) return false;\n        return true;\n    }\n\n    /// Clone the issue with deep copy of all allocated strings.\n    pub fn clone(self: Self, allocator: std.mem.Allocator) !Self {\n        var result: Self = undefined;\n\n        result.id = try allocator.dupe(u8, self.id);\n        errdefer allocator.free(result.id);\n","numLines":200,"startLine":1,"totalLines":864}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015NLBjLxH5QmZbWnkV3m9bK","type":"message","role":"assistant","content":[{"type":"text","text":"I can see that the Issue model already has the fields `owner`, `design`, `acceptance_criteria`, and `external_ref`. Task 2 is asking me to add CLI flags to set these fields, not the model fields themselves. Let me verify by checking the SPEC.md fields and looking at the create command to see what flags are currently available:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3299,"cache_read_input_tokens":69910,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3299},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e1655d49-ee39-4e11-810f-c41a411a1ccf"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015NLBjLxH5QmZbWnkV3m9bK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MYudR1JirfV2zexgU6fTJ2","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/create.zig","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3299,"cache_read_input_tokens":69910,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3299},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0c5a66ba-239a-4c64-a1a7-3d408a31ee63"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MYudR1JirfV2zexgU6fTJ2","type":"tool_result","content":"     1→//! Create and Quick capture commands for beads_zig.\n     2→//!\n     3→//! - `bz create <title>` - Full issue creation with all optional fields\n     4→//! - `bz q <title>` - Quick capture (create + print ID only)\n     5→\n     6→const std = @import(\"std\");\n     7→const models = @import(\"../models/mod.zig\");\n     8→const storage = @import(\"../storage/mod.zig\");\n     9→const id_gen = @import(\"../id/mod.zig\");\n    10→const common = @import(\"common.zig\");\n    11→const args = @import(\"args.zig\");\n    12→const test_util = @import(\"../test_util.zig\");\n    13→\n    14→const Issue = models.Issue;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = storage.IssueStore;\n    18→const IdGenerator = id_gen.IdGenerator;\n    19→\n    20→pub const CreateError = error{\n    21→    EmptyTitle,\n    22→    TitleTooLong,\n    23→    InvalidPriority,\n    24→    InvalidIssueType,\n    25→    WorkspaceNotInitialized,\n    26→    StorageError,\n    27→    OutOfMemory,\n    28→};\n    29→\n    30→pub const CreateResult = struct {\n    31→    success: bool,\n    32→    id: ?[]const u8 = null,\n    33→    title: ?[]const u8 = null,\n    34→    message: ?[]const u8 = null,\n    35→};\n    36→\n    37→/// Run the create command.\n    38→pub fn run(\n    39→    create_args: args.CreateArgs,\n    40→    global: args.GlobalOptions,\n    41→    allocator: std.mem.Allocator,\n    42→) !void {\n    43→    var output = common.initOutput(allocator, global);\n    44→    const structured_output = global.isStructuredOutput();\n    45→\n    46→    // Validate title\n    47→    if (create_args.title.len == 0) {\n    48→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title cannot be empty\");\n    49→        return CreateError.EmptyTitle;\n    50→    }\n    51→    if (create_args.title.len > 500) {\n    52→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title exceeds 500 character limit\");\n    53→        return CreateError.TitleTooLong;\n    54→    }\n    55→\n    56→    // Determine workspace path\n    57→    const beads_dir = global.data_path orelse \".beads\";\n    58→    const issues_path = try std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" });\n    59→    defer allocator.free(issues_path);\n    60→\n    61→    // Check if workspace is initialized\n    62→    std.fs.cwd().access(issues_path, .{}) catch |err| {\n    63→        if (err == error.FileNotFound) {\n    64→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"workspace not initialized. Run 'bz init' first.\");\n    65→            return CreateError.WorkspaceNotInitialized;\n    66→        }\n    67→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"cannot access workspace\");\n    68→        return CreateError.StorageError;\n    69→    };\n    70→\n    71→    // Load existing issues\n    72→    var store = IssueStore.init(allocator, issues_path);\n    73→    defer store.deinit();\n    74→\n    75→    store.loadFromFile() catch |err| {\n    76→        if (err != error.FileNotFound) {\n    77→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to load issues\");\n    78→            return CreateError.StorageError;\n    79→        }\n    80→    };\n    81→\n    82→    // Parse optional fields\n    83→    const priority = if (create_args.priority) |p|\n    84→        Priority.fromString(p) catch {\n    85→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"invalid priority value\");\n    86→            return CreateError.InvalidPriority;\n    87→        }\n    88→    else\n    89→        Priority.MEDIUM;\n    90→\n    91→    const issue_type = if (create_args.issue_type) |t|\n    92→        IssueType.fromString(t)\n    93→    else\n    94→        .task;\n    95→\n    96→    // Parse due date if provided\n    97→    const due_at: ?i64 = if (create_args.due) |due_str|\n    98→        parseDateString(due_str)\n    99→    else\n   100→        null;\n   101→\n   102→    // Get actor (from flag, env, or default)\n   103→    const actor = global.actor orelse getDefaultActor();\n   104→\n   105→    // Get config prefix (read from config.yaml or use default)\n   106→    const prefix = try getConfigPrefix(allocator, beads_dir);\n   107→    defer allocator.free(prefix);\n   108→\n   109→    // Generate ID\n   110→    var generator = IdGenerator.init(prefix);\n   111→    const issue_count = store.countTotal();\n   112→    const issue_id = try generator.generate(allocator, issue_count);\n   113→    defer allocator.free(issue_id);\n   114→\n   115→    // Create issue\n   116→    const now = std.time.timestamp();\n   117→    var issue = Issue.init(issue_id, create_args.title, now);\n   118→    issue.description = create_args.description;\n   119→    issue.priority = priority;\n   120→    issue.issue_type = issue_type;\n   121→    issue.assignee = create_args.assignee;\n   122→    issue.created_by = actor;\n   123→    issue.due_at = .{ .value = due_at };\n   124→    issue.estimated_minutes = create_args.estimate;\n   125→\n   126→    // Set labels on issue (will be persisted via WAL)\n   127→    if (create_args.labels.len > 0) {\n   128→        issue.labels = create_args.labels;\n   129→    }\n   130→\n   131→    // Insert into store (for in-memory state and duplicate check)\n   132→    store.insert(issue) catch {\n   133→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to create issue\");\n   134→        return CreateError.StorageError;\n   135→    };\n   136→\n   137→    // Append to WAL for fast persistence (instead of full file rewrite)\n   138→    if (!global.no_auto_flush) {\n   139→        var wal = storage.Wal.init(beads_dir, allocator) catch {\n   140→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to initialize WAL\");\n   141→            return CreateError.StorageError;\n   142→        };\n   143→        defer wal.deinit();\n   144→\n   145→        wal.addIssue(issue) catch {\n   146→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to write to WAL\");\n   147→            return CreateError.StorageError;\n   148→        };\n   149→    }\n   150→\n   151→    // Output result\n   152→    if (structured_output) {\n   153→        try output.printJson(CreateResult{\n   154→            .success = true,\n   155→            .id = issue_id,\n   156→            .title = create_args.title,\n   157→        });\n   158→    } else if (global.quiet) {\n   159→        try output.raw(issue_id);\n   160→        try output.raw(\"\\n\");\n   161→    } else {\n   162→        try output.success(\"Created issue {s}\", .{issue_id});\n   163→    }\n   164→}\n   165→\n   166→/// Run the quick capture command (create + print ID only).\n   167→pub fn runQuick(\n   168→    quick_args: args.QuickArgs,\n   169→    global: args.GlobalOptions,\n   170→    allocator: std.mem.Allocator,\n   171→) !void {\n   172→    // Convert QuickArgs to CreateArgs\n   173→    const create_args = args.CreateArgs{\n   174→        .title = quick_args.title,\n   175→        .priority = quick_args.priority,\n   176→    };\n   177→\n   178→    // Force quiet mode for q command unless structured output is specified\n   179→    var modified_global = global;\n   180→    if (!global.isStructuredOutput()) {\n   181→        modified_global.quiet = true;\n   182→    }\n   183→\n   184→    try run(create_args, modified_global, allocator);\n   185→}\n   186→\n   187→/// Parse a date string in various formats to Unix timestamp.\n   188→/// Supports: YYYY-MM-DD, YYYY-MM-DDTHH:MM:SSZ\n   189→fn parseDateString(date_str: []const u8) ?i64 {\n   190→    // Try RFC3339 format first\n   191→    if (@import(\"../models/timestamp.zig\").parseRfc3339(date_str)) |ts| {\n   192→        return ts;\n   193→    }\n   194→\n   195→    // Try YYYY-MM-DD format\n   196→    if (date_str.len == 10 and date_str[4] == '-' and date_str[7] == '-') {\n   197→        const year = std.fmt.parseInt(i32, date_str[0..4], 10) catch return null;\n   198→        const month = std.fmt.parseInt(u4, date_str[5..7], 10) catch return null;\n   199→        const day = std.fmt.parseInt(u5, date_str[8..10], 10) catch return null;\n   200→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"6cf9b545-0100-41c5-944b-eb6b44659c00","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/create.zig","content":"//! Create and Quick capture commands for beads_zig.\n//!\n//! - `bz create <title>` - Full issue creation with all optional fields\n//! - `bz q <title>` - Quick capture (create + print ID only)\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst id_gen = @import(\"../id/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = storage.IssueStore;\nconst IdGenerator = id_gen.IdGenerator;\n\npub const CreateError = error{\n    EmptyTitle,\n    TitleTooLong,\n    InvalidPriority,\n    InvalidIssueType,\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const CreateResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    title: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Run the create command.\npub fn run(\n    create_args: args.CreateArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var output = common.initOutput(allocator, global);\n    const structured_output = global.isStructuredOutput();\n\n    // Validate title\n    if (create_args.title.len == 0) {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title cannot be empty\");\n        return CreateError.EmptyTitle;\n    }\n    if (create_args.title.len > 500) {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title exceeds 500 character limit\");\n        return CreateError.TitleTooLong;\n    }\n\n    // Determine workspace path\n    const beads_dir = global.data_path orelse \".beads\";\n    const issues_path = try std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    // Check if workspace is initialized\n    std.fs.cwd().access(issues_path, .{}) catch |err| {\n        if (err == error.FileNotFound) {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"workspace not initialized. Run 'bz init' first.\");\n            return CreateError.WorkspaceNotInitialized;\n        }\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"cannot access workspace\");\n        return CreateError.StorageError;\n    };\n\n    // Load existing issues\n    var store = IssueStore.init(allocator, issues_path);\n    defer store.deinit();\n\n    store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to load issues\");\n            return CreateError.StorageError;\n        }\n    };\n\n    // Parse optional fields\n    const priority = if (create_args.priority) |p|\n        Priority.fromString(p) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"invalid priority value\");\n            return CreateError.InvalidPriority;\n        }\n    else\n        Priority.MEDIUM;\n\n    const issue_type = if (create_args.issue_type) |t|\n        IssueType.fromString(t)\n    else\n        .task;\n\n    // Parse due date if provided\n    const due_at: ?i64 = if (create_args.due) |due_str|\n        parseDateString(due_str)\n    else\n        null;\n\n    // Get actor (from flag, env, or default)\n    const actor = global.actor orelse getDefaultActor();\n\n    // Get config prefix (read from config.yaml or use default)\n    const prefix = try getConfigPrefix(allocator, beads_dir);\n    defer allocator.free(prefix);\n\n    // Generate ID\n    var generator = IdGenerator.init(prefix);\n    const issue_count = store.countTotal();\n    const issue_id = try generator.generate(allocator, issue_count);\n    defer allocator.free(issue_id);\n\n    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)\n    if (create_args.labels.len > 0) {\n        issue.labels = create_args.labels;\n    }\n\n    // Insert into store (for in-memory state and duplicate check)\n    store.insert(issue) catch {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to create issue\");\n        return CreateError.StorageError;\n    };\n\n    // Append to WAL for fast persistence (instead of full file rewrite)\n    if (!global.no_auto_flush) {\n        var wal = storage.Wal.init(beads_dir, allocator) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to initialize WAL\");\n            return CreateError.StorageError;\n        };\n        defer wal.deinit();\n\n        wal.addIssue(issue) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to write to WAL\");\n            return CreateError.StorageError;\n        };\n    }\n\n    // Output result\n    if (structured_output) {\n        try output.printJson(CreateResult{\n            .success = true,\n            .id = issue_id,\n            .title = create_args.title,\n        });\n    } else if (global.quiet) {\n        try output.raw(issue_id);\n        try output.raw(\"\\n\");\n    } else {\n        try output.success(\"Created issue {s}\", .{issue_id});\n    }\n}\n\n/// Run the quick capture command (create + print ID only).\npub fn runQuick(\n    quick_args: args.QuickArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    // Convert QuickArgs to CreateArgs\n    const create_args = args.CreateArgs{\n        .title = quick_args.title,\n        .priority = quick_args.priority,\n    };\n\n    // Force quiet mode for q command unless structured output is specified\n    var modified_global = global;\n    if (!global.isStructuredOutput()) {\n        modified_global.quiet = true;\n    }\n\n    try run(create_args, modified_global, allocator);\n}\n\n/// Parse a date string in various formats to Unix timestamp.\n/// Supports: YYYY-MM-DD, YYYY-MM-DDTHH:MM:SSZ\nfn parseDateString(date_str: []const u8) ?i64 {\n    // Try RFC3339 format first\n    if (@import(\"../models/timestamp.zig\").parseRfc3339(date_str)) |ts| {\n        return ts;\n    }\n\n    // Try YYYY-MM-DD format\n    if (date_str.len == 10 and date_str[4] == '-' and date_str[7] == '-') {\n        const year = std.fmt.parseInt(i32, date_str[0..4], 10) catch return null;\n        const month = std.fmt.parseInt(u4, date_str[5..7], 10) catch return null;\n        const day = std.fmt.parseInt(u5, date_str[8..10], 10) catch return null;\n","numLines":200,"startLine":1,"totalLines":444}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014L1KSXfoKVNokuYyab4tDQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand. The Issue model already has the fields, but the CLI doesn't have flags to set them during creation or update. Let me implement Task 1 first (the `where` command), then Task 2 (adding CLI flags for the missing fields).\n\n## Task 1: Add `where` command"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2955,"cache_read_input_tokens":73209,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2955},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"586b81a3-7e44-41df-a820-d7cf8d0c8142"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014L1KSXfoKVNokuYyab4tDQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011716KEiiKtASeNWRY5526j","name":"Write","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/where.zig","content":"//! Where command for beads_zig.\n//!\n//! `bz where` - Show the resolved .beads directory path\n//!\n//! Useful when .beads redirects are in play or to verify which workspace is active.\n\nconst std = @import(\"std\");\nconst output_mod = @import(\"../output/mod.zig\");\nconst args = @import(\"args.zig\");\n\npub const WhereError = error{\n    WriteError,\n    WorkspaceNotFound,\n};\n\npub const WhereResult = struct {\n    success: bool,\n    path: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Run the where command.\npub fn run(global: args.GlobalOptions, allocator: std.mem.Allocator) WhereError!WhereResult {\n    var out = output_mod.Output.init(allocator, .{\n        .json = global.json,\n        .toon = global.toon,\n        .quiet = global.quiet,\n        .silent = global.silent,\n        .no_color = global.no_color,\n    });\n\n    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // Copy to allocated buffer for stable return (abs_path points to stack buffer)\n    _ = &abs_path_buf; // suppress unused warning\n    const path_slice = abs_path[0..std.mem.len(abs_path)];\n\n    if (global.json) {\n        out.printJson(WhereResult{\n            .success = true,\n            .path = path_slice,\n        }) catch return WhereError.WriteError;\n    } else if (!global.quiet) {\n        out.print(\"{s}\\n\", .{path_slice}) catch return WhereError.WriteError;\n    }\n\n    return WhereResult{\n        .success = true,\n        .path = path_slice,\n    };\n}\n\n// --- Tests ---\n\ntest \"WhereError enum exists\" {\n    const err: WhereError = WhereError.WriteError;\n    try std.testing.expect(err == WhereError.WriteError);\n}\n\ntest \"WhereResult struct works\" {\n    const result = WhereResult{\n        .success = true,\n        .path = \"/home/user/project/.beads\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"/home/user/project/.beads\", result.path.?);\n}\n\ntest \"run returns path for nonexistent workspace\" {\n    const allocator = std.testing.allocator;\n\n    const result = try run(.{\n        .silent = true,\n        .data_path = \"/nonexistent/path\",\n    }, allocator);\n\n    try std.testing.expect(!result.success);\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2955,"cache_read_input_tokens":73209,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2955},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f5e34deb-caf2-4dd1-9113-b75c7772f89b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011716KEiiKtASeNWRY5526j","type":"tool_result","content":"File created successfully at: /home/hotschmoe/beads_zig/src/cli/where.zig"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"68f54d8c-80c0-4bbb-8d25-7a88eb8915ae","tool_use_result":{"type":"create","filePath":"/home/hotschmoe/beads_zig/src/cli/where.zig","content":"//! Where command for beads_zig.\n//!\n//! `bz where` - Show the resolved .beads directory path\n//!\n//! Useful when .beads redirects are in play or to verify which workspace is active.\n\nconst std = @import(\"std\");\nconst output_mod = @import(\"../output/mod.zig\");\nconst args = @import(\"args.zig\");\n\npub const WhereError = error{\n    WriteError,\n    WorkspaceNotFound,\n};\n\npub const WhereResult = struct {\n    success: bool,\n    path: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Run the where command.\npub fn run(global: args.GlobalOptions, allocator: std.mem.Allocator) WhereError!WhereResult {\n    var out = output_mod.Output.init(allocator, .{\n        .json = global.json,\n        .toon = global.toon,\n        .quiet = global.quiet,\n        .silent = global.silent,\n        .no_color = global.no_color,\n    });\n\n    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // Copy to allocated buffer for stable return (abs_path points to stack buffer)\n    _ = &abs_path_buf; // suppress unused warning\n    const path_slice = abs_path[0..std.mem.len(abs_path)];\n\n    if (global.json) {\n        out.printJson(WhereResult{\n            .success = true,\n            .path = path_slice,\n        }) catch return WhereError.WriteError;\n    } else if (!global.quiet) {\n        out.print(\"{s}\\n\", .{path_slice}) catch return WhereError.WriteError;\n    }\n\n    return WhereResult{\n        .success = true,\n        .path = path_slice,\n    };\n}\n\n// --- Tests ---\n\ntest \"WhereError enum exists\" {\n    const err: WhereError = WhereError.WriteError;\n    try std.testing.expect(err == WhereError.WriteError);\n}\n\ntest \"WhereResult struct works\" {\n    const result = WhereResult{\n        .success = true,\n        .path = \"/home/user/project/.beads\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"/home/user/project/.beads\", result.path.?);\n}\n\ntest \"run returns path for nonexistent workspace\" {\n    const allocator = std.testing.allocator;\n\n    const result = try run(.{\n        .silent = true,\n        .data_path = \"/nonexistent/path\",\n    }, allocator);\n\n    try std.testing.expect(!result.success);\n}\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GujmcYGFaaQkTQ7GhJzczp","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the `where` command to args.zig, mod.zig, and main.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1229,"cache_read_input_tokens":76164,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1229},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"52c7ddb5-4d09-45fc-984c-164e67e368fc"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GujmcYGFaaQkTQ7GhJzczp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SCkBig12GhNLULzi39Pibn","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":28,"limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1229,"cache_read_input_tokens":76164,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1229},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0230397a-a4cf-41bd-8f15-7180fd15d283"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SCkBig12GhNLULzi39Pibn","type":"tool_result","content":"    28→/// All available subcommands.\n    29→pub const Command = union(enum) {\n    30→    // Workspace\n    31→    init: InitArgs,\n    32→    info: void,\n    33→    stats: void,\n    34→    doctor: void,\n    35→    config: ConfigArgs,\n    36→    orphans: OrphansArgs,\n    37→    lint: LintArgs,\n    38→\n    39→    // Issue CRUD\n    40→    create: CreateArgs,\n    41→    q: QuickArgs,\n    42→    show: ShowArgs,\n    43→    update: UpdateArgs,\n    44→    close: CloseArgs,\n    45→    reopen: ReopenArgs,\n    46→    delete: DeleteArgs,\n    47→\n    48→    // Batch Operations\n    49→    add_batch: AddBatchArgs,\n    50→    import_cmd: ImportArgs,\n    51→\n    52→    // Query\n    53→    list: ListArgs,\n    54→    ready: ReadyArgs,\n    55→    blocked: BlockedArgs,\n    56→    search: SearchArgs,\n    57→    stale: StaleArgs,\n    58→    count: CountArgs,\n    59→    defer_cmd: DeferArgs,\n    60→    undefer: UndeferArgs,\n    61→\n    62→    // Dependencies\n    63→    dep: DepArgs,\n    64→    graph: GraphArgs,\n    65→\n    66→    // Epics\n    67→    epic: EpicArgs,\n    68→\n    69→    // Labels\n    70→    label: LabelArgs,\n    71→\n    72→    // Comments\n    73→    comments: CommentsArgs,\n    74→\n    75→    // Audit\n    76→    history: HistoryArgs,\n    77→    audit: AuditArgs,\n    78→\n    79→    // Changelog\n    80→    changelog: ChangelogArgs,\n    81→\n    82→    // Sync\n    83→    sync: SyncArgs,\n    84→\n    85→    // System\n    86→    version: void,\n    87→    schema: void,\n    88→    completions: CompletionsArgs,\n    89→    metrics: MetricsArgs,\n    90→\n    91→    // Saved Queries\n    92→    query: QueryArgs,\n    93→\n    94→    // Self-upgrade\n    95→    upgrade: UpgradeArgs,\n    96→\n    97→    // Help\n    98→    help: HelpArgs,\n    99→};\n   100→\n   101→/// Init command arguments.\n   102→pub const InitArgs = struct {\n   103→    prefix: []const u8 = \"bd\",\n   104→};\n   105→\n   106→/// Create command arguments.\n   107→pub const CreateArgs = struct {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0c4be418-9a46-49fd-87c0-40eccc580da7","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {","numLines":80,"startLine":28,"totalLines":2276}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01K3eY9jKydHFrutVD4EctaW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BwS7jiCESFN6kGZ5UoHzXF","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,","new_string":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":943,"cache_read_input_tokens":77393,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":943},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a171f69d-9c2c-4638-8635-8b414b95f79e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BwS7jiCESFN6kGZ5UoHzXF","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9c4fb3f5-1db2-4b5b-8cda-2773e3c2300e","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,","newString":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":35,"oldLines":6,"newStart":35,"newLines":7,"lines":["     config: ConfigArgs,","     orphans: OrphansArgs,","     lint: LintArgs,","+    where: void,"," ","     // Issue CRUD","     create: CreateArgs,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01P68ZKKFRHwfQGCQUaYFnrW","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the command parsing for `where`. Let me find where other simple commands like `info` are parsed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":283,"cache_read_input_tokens":78336,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":283},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"b0af25f1-780d-4542-93ae-d2568998d89c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01P68ZKKFRHwfQGCQUaYFnrW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C6c3xxb23TC2UTv6CHTCXn","name":"Grep","input":{"pattern":"if \\(std.mem.eql\\(u8, cmd, \"info\"\\)\\)","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":283,"cache_read_input_tokens":78336,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":283},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8adefa3d-04e3-4252-baf7-ed3926c6fb48"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C6c3xxb23TC2UTv6CHTCXn","type":"tool_result","content":"623:        if (std.mem.eql(u8, cmd, \"info\")) {"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f024e38d-ae67-434e-bd55-871a691cc7a9","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"623:        if (std.mem.eql(u8, cmd, \"info\")) {","numLines":1}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FmXHa3oNWtUwuj4TjgLfkV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018Ndhyu7zZwkaxixDcJZQC2","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":617,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":347,"cache_read_input_tokens":78619,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":347},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"7415b856-fded-4333-97a6-aba470af8918"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018Ndhyu7zZwkaxixDcJZQC2","type":"tool_result","content":"   617→\n   618→    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n   619→        // Workspace\n   620→        if (std.mem.eql(u8, cmd, \"init\")) {\n   621→            return .{ .init = try self.parseInitArgs() };\n   622→        }\n   623→        if (std.mem.eql(u8, cmd, \"info\")) {\n   624→            return .{ .info = {} };\n   625→        }\n   626→        if (std.mem.eql(u8, cmd, \"stats\")) {\n   627→            return .{ .stats = {} };\n   628→        }\n   629→        if (std.mem.eql(u8, cmd, \"doctor\")) {\n   630→            return .{ .doctor = {} };\n   631→        }\n   632→        if (std.mem.eql(u8, cmd, \"config\")) {\n   633→            return .{ .config = try self.parseConfigArgs() };\n   634→        }\n   635→        if (std.mem.eql(u8, cmd, \"orphans\")) {\n   636→            return .{ .orphans = try self.parseOrphansArgs() };\n   637→        }\n   638→        if (std.mem.eql(u8, cmd, \"lint\")) {\n   639→            return .{ .lint = try self.parseLintArgs() };\n   640→        }\n   641→\n   642→        // Issue CRUD\n   643→        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n   644→            return .{ .create = try self.parseCreateArgs() };\n   645→        }\n   646→        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"135c0b54-d3ad-4bb3-8461-9399878d7ff1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {","numLines":30,"startLine":617,"totalLines":2277}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014p928veDFZp2gZpAUpFHKB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017e25N54ujj3yUXeEXXsGFH","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n\n        // Issue CRUD","new_string":"        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":692,"cache_read_input_tokens":78966,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":692},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"244e9f1a-09e0-42d2-ba56-1b401e9b474c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017e25N54ujj3yUXeEXXsGFH","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"aa314455-2742-4c58-8542-9e92918663e8","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n\n        // Issue CRUD","newString":"        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":638,"oldLines":6,"newStart":638,"newLines":9,"lines":["         if (std.mem.eql(u8, cmd, \"lint\")) {","             return .{ .lint = try self.parseLintArgs() };","         }","+        if (std.mem.eql(u8, cmd, \"where\")) {","+            return .{ .where = {} };","+        }"," ","         // Issue CRUD","         if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ABYYRoYvy5YRkRYfxtnqPM","type":"message","role":"assistant","content":[{"type":"text","text":"Now update mod.zig to export the where module:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":292,"cache_read_input_tokens":79658,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":292},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"4f04746a-bfeb-455b-afd0-202f2ceccbd5"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ABYYRoYvy5YRkRYfxtnqPM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VxHboCcuwJp4tHZmpceTma","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","old_string":"pub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");","new_string":"pub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":292,"cache_read_input_tokens":79658,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":292},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"78c8d1f1-9347-41c0-8844-ad52eb8d83c9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VxHboCcuwJp4tHZmpceTma","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"7bc87c03-4103-4437-8d64-34aac6220a60","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","oldString":"pub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");","newString":"pub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");","originalFile":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","structuredPatch":[{"oldStart":44,"oldLines":6,"newStart":44,"newLines":7,"lines":[" pub const help = @import(\"help.zig\");"," pub const query = @import(\"query.zig\");"," pub const upgrade = @import(\"upgrade.zig\");","+pub const where = @import(\"where.zig\");"," "," pub const ArgParser = args.ArgParser;"," pub const ParseResult = args.ParseResult;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016N7b3S569tL2VA7AFeBsW4","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the exports for the where command at the end of mod.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":245,"cache_read_input_tokens":79950,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":245},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"534ab73b-8f08-4c30-95f8-82ea8b28488b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016N7b3S569tL2VA7AFeBsW4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QFAbNar9AGX5GJ4HZ3CrCa","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","offset":200,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":245,"cache_read_input_tokens":79950,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":245},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"44bce3dd-d5f1-427c-97dc-62eb298e09c7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QFAbNar9AGX5GJ4HZ3CrCa","type":"tool_result","content":"   200→pub const HelpResult = help.HelpResult;\n   201→pub const runHelp = help.run;\n   202→\n   203→pub const QueryError = query.QueryError;\n   204→pub const QueryResult = query.QueryResult;\n   205→pub const runQuery = query.run;\n   206→pub const QueryArgs = args.QueryArgs;\n   207→\n   208→pub const UpgradeError = upgrade.UpgradeError;\n   209→pub const UpgradeResult = upgrade.UpgradeResult;\n   210→pub const runUpgrade = upgrade.run;\n   211→pub const UpgradeArgs = args.UpgradeArgs;\n   212→\n   213→test {\n   214→    std.testing.refAllDecls(@This());\n   215→}\n   216→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"db17df5f-d574-4a85-bccf-34e61863c789","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","content":"pub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","numLines":17,"startLine":200,"totalLines":216}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012G2Pk2RurW4yG2UzZKBX2S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CwuPAmqhunAxY3ZuyQxodk","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","old_string":"pub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\ntest {","new_string":"pub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\npub const WhereError = where.WhereError;\npub const WhereResult = where.WhereResult;\npub const runWhere = where.run;\n\ntest {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":422,"cache_read_input_tokens":80195,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":422},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"77151e42-c35e-4863-8151-f6a2c30a27fc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CwuPAmqhunAxY3ZuyQxodk","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"560ba5d5-3a9b-4486-a389-ac63448a992c","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","oldString":"pub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\ntest {","newString":"pub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\npub const WhereError = where.WhereError;\npub const WhereResult = where.WhereResult;\npub const runWhere = where.run;\n\ntest {","originalFile":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","structuredPatch":[{"oldStart":210,"oldLines":6,"newStart":210,"newLines":10,"lines":[" pub const runUpgrade = upgrade.run;"," pub const UpgradeArgs = args.UpgradeArgs;"," ","+pub const WhereError = where.WhereError;","+pub const WhereResult = where.WhereResult;","+pub const runWhere = where.run;","+"," test {","     std.testing.refAllDecls(@This());"," }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0151gsksLB23LgUBBq1fi9bk","type":"message","role":"assistant","content":[{"type":"text","text":"Now update main.zig to dispatch the where command:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":334,"cache_read_input_tokens":80617,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":334},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d19ee9b7-7031-4a0a-a100-a6d1a1479be4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0151gsksLB23LgUBBq1fi9bk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FSuMGRWREYRrD7kAgqA74C","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig","offset":265,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":334,"cache_read_input_tokens":80617,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":334},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"fce4d88d-0a08-4474-8887-93e41fa3dc9b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FSuMGRWREYRrD7kAgqA74C","type":"tool_result","content":"   265→        .query => |query_args| {\n   266→            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n   267→                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n   268→                else => return err,\n   269→            };\n   270→        },\n   271→        .upgrade => |upgrade_args| {\n   272→            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n   273→                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n   274→                else => return err,\n   275→            };\n   276→        },\n   277→    }\n   278→}\n   279→\n   280→fn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n   281→    var out = output.Output.init(allocator, .{});\n   282→    switch (err) {\n   283→        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n   284→        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"4e9d12f5-53f5-4d8d-b6a8-ca3c89641c1c","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","content":"        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),","numLines":20,"startLine":265,"totalLines":305}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014zkini791BApiXwEz89RJg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WRvhKkKrxTyio35gUjSfgr","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/main.zig","old_string":"        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n    }\n}","new_string":"        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .where => {\n            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n            };\n        },\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":567,"cache_read_input_tokens":80951,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":567},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"3637aa81-d8cf-405b-9e94-69eefb5e766a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WRvhKkKrxTyio35gUjSfgr","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/main.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"87c173f9-9363-4625-a932-915ea719a165","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","oldString":"        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n    }\n}","newString":"        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .where => {\n            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n            };\n        },\n    }\n}","originalFile":"//! beads_zig CLI entry point.\n//!\n//! Binary name: bz (beads-zig)\n\nconst std = @import(\"std\");\nconst beads_zig = @import(\"beads_zig\");\nconst cli = beads_zig.cli;\nconst output = beads_zig.output;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    run(allocator) catch |err| {\n        const stderr = std.fs.File.stderr();\n        stderr.writeAll(\"error: \") catch {};\n        stderr.writeAll(@errorName(err)) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        std.process.exit(1);\n    };\n}\n\nfn run(allocator: std.mem.Allocator) !void {\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    // Skip program name\n    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n\n    var parser = cli.ArgParser.init(allocator, cmd_args);\n    var result = parser.parse() catch |err| {\n        return handleParseError(err, allocator);\n    };\n    defer result.deinit(allocator);\n\n    try dispatch(result, allocator);\n}\n\nfn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    switch (result.command) {\n        .init => |init_args| {\n            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n                error.AlreadyInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .create => |create_args| {\n            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .q => |quick_args| {\n            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .list => |list_args| {\n            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .show => |show_args| {\n            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .update => |update_args| {\n            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .close => |close_args| {\n            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .reopen => |reopen_args| {\n            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .delete => |delete_args| {\n            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .add_batch => |batch_args| {\n            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .import_cmd => |import_args| {\n            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .ready => |ready_args| {\n            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .blocked => |blocked_args| {\n            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .dep => |dep_args| {\n            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .graph => |graph_args| {\n            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .epic => |epic_args| {\n            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .orphans => |orphans_args| {\n            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .lint => |lint_args| {\n            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .label => |label_args| {\n            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .comments => |comments_args| {\n            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .history => |history_args| {\n            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n    }\n    std.process.exit(1);\n}\n\ntest \"library imports compile\" {\n    // Verify all modules are accessible\n    _ = beads_zig.cli;\n    _ = beads_zig.storage;\n    _ = beads_zig.models;\n    _ = beads_zig.sync;\n    _ = beads_zig.id;\n    _ = beads_zig.config;\n    _ = beads_zig.output;\n}\n","structuredPatch":[{"oldStart":274,"oldLines":6,"newStart":274,"newLines":11,"lines":["                 else => return err,","             };","         },","+        .where => {","+            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {","+                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),","+            };","+        },","     }"," }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016p5zQd1XaoMD3DunMXjqiq","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me build to check if Task 1 compiles correctly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":556,"cache_read_input_tokens":81518,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":556},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"ff7dc0fb-663d-4d5c-974c-839d936a1e61"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016p5zQd1XaoMD3DunMXjqiq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NW5ojsAx4LzhNoqW8SxNTR","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build beads_zig to check for compilation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":556,"cache_read_input_tokens":81518,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":556},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"1d8165c6-2812-4e7c-941a-dd2d2da11693"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NW5ojsAx4LzhNoqW8SxNTR","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/where.zig:37:34: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 2 argument(s), found 1\n\u001b[0m    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n                     \u001b[32m~~~~~~~~~~~~^~~~~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/fs/Dir.zig:1320:5: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0mpub fn realpathZ(self: Dir, pathname: [*:0]const u8, out_buffer: []u8) RealPathError![]u8 {\n\u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    dispatch: src/main.zig:278:29\n    run: src/main.zig:37:17\n    6 reference(s) hidden; use '-freference-trace=8' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xc22377d4 -Z8653c0ca9ed9e69b","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"2eb2f0e7-ae91-4878-ac36-e70b2a437697","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/where.zig:37:34: \u001b[31merror: \u001b[0m\u001b[1mmember function expected 2 argument(s), found 1\n\u001b[0m    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n                     \u001b[32m~~~~~~~~~~~~^~~~~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/fs/Dir.zig:1320:5: \u001b[36mnote: \u001b[0m\u001b[1mfunction declared here\n\u001b[0mpub fn realpathZ(self: Dir, pathname: [*:0]const u8, out_buffer: []u8) RealPathError![]u8 {\n\u001b[32m~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    dispatch: src/main.zig:278:29\n    run: src/main.zig:37:17\n    6 reference(s) hidden; use '-freference-trace=8' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xc22377d4 -Z8653c0ca9ed9e69b","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VRwDNwA43qYayYu17Mob5H","type":"message","role":"assistant","content":[{"type":"text","text":"I need to fix the realpath call - it needs a buffer. Let me fix the where.zig file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":834,"cache_read_input_tokens":82074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":834},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"29223c32-5106-4dea-a5a2-ed3d7100e7f7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VRwDNwA43qYayYu17Mob5H","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FXpT8fzD12oMLF7t3khvJZ","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/where.zig","old_string":"    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // Copy to allocated buffer for stable return (abs_path points to stack buffer)\n    _ = &abs_path_buf; // suppress unused warning\n    const path_slice = abs_path[0..std.mem.len(abs_path)];","new_string":"    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpath(beads_dir, &abs_path_buf) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // abs_path is a slice into abs_path_buf with the resolved path\n    const path_slice = abs_path;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":834,"cache_read_input_tokens":82074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":834},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a36d1744-d12f-428e-9f73-38e81802508a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FXpT8fzD12oMLF7t3khvJZ","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/where.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"766693f4-0c2a-45f5-bc97-6bb465b38a51","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/where.zig","oldString":"    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // Copy to allocated buffer for stable return (abs_path points to stack buffer)\n    _ = &abs_path_buf; // suppress unused warning\n    const path_slice = abs_path[0..std.mem.len(abs_path)];","newString":"    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpath(beads_dir, &abs_path_buf) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // abs_path is a slice into abs_path_buf with the resolved path\n    const path_slice = abs_path;","originalFile":"//! Where command for beads_zig.\n//!\n//! `bz where` - Show the resolved .beads directory path\n//!\n//! Useful when .beads redirects are in play or to verify which workspace is active.\n\nconst std = @import(\"std\");\nconst output_mod = @import(\"../output/mod.zig\");\nconst args = @import(\"args.zig\");\n\npub const WhereError = error{\n    WriteError,\n    WorkspaceNotFound,\n};\n\npub const WhereResult = struct {\n    success: bool,\n    path: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Run the where command.\npub fn run(global: args.GlobalOptions, allocator: std.mem.Allocator) WhereError!WhereResult {\n    var out = output_mod.Output.init(allocator, .{\n        .json = global.json,\n        .toon = global.toon,\n        .quiet = global.quiet,\n        .silent = global.silent,\n        .no_color = global.no_color,\n    });\n\n    // Determine the beads directory path\n    const beads_dir = global.data_path orelse \".beads\";\n\n    // Try to get absolute path\n    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;\n    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {\n        if (err == error.FileNotFound) {\n            if (global.json) {\n                out.printJson(WhereResult{\n                    .success = false,\n                    .message = \"workspace not initialized\",\n                }) catch return WhereError.WriteError;\n            } else if (!global.quiet) {\n                out.err(\"workspace not initialized. Run 'bz init' first.\", .{}) catch return WhereError.WriteError;\n            }\n            return WhereResult{\n                .success = false,\n                .message = \"workspace not initialized\",\n            };\n        }\n        // Fall back to relative path if realpath fails for other reasons\n        if (global.json) {\n            out.printJson(WhereResult{\n                .success = true,\n                .path = beads_dir,\n            }) catch return WhereError.WriteError;\n        } else if (!global.quiet) {\n            out.print(\"{s}\\n\", .{beads_dir}) catch return WhereError.WriteError;\n        }\n        return WhereResult{\n            .success = true,\n            .path = beads_dir,\n        };\n    };\n\n    // Copy to allocated buffer for stable return (abs_path points to stack buffer)\n    _ = &abs_path_buf; // suppress unused warning\n    const path_slice = abs_path[0..std.mem.len(abs_path)];\n\n    if (global.json) {\n        out.printJson(WhereResult{\n            .success = true,\n            .path = path_slice,\n        }) catch return WhereError.WriteError;\n    } else if (!global.quiet) {\n        out.print(\"{s}\\n\", .{path_slice}) catch return WhereError.WriteError;\n    }\n\n    return WhereResult{\n        .success = true,\n        .path = path_slice,\n    };\n}\n\n// --- Tests ---\n\ntest \"WhereError enum exists\" {\n    const err: WhereError = WhereError.WriteError;\n    try std.testing.expect(err == WhereError.WriteError);\n}\n\ntest \"WhereResult struct works\" {\n    const result = WhereResult{\n        .success = true,\n        .path = \"/home/user/project/.beads\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"/home/user/project/.beads\", result.path.?);\n}\n\ntest \"run returns path for nonexistent workspace\" {\n    const allocator = std.testing.allocator;\n\n    const result = try run(.{\n        .silent = true,\n        .data_path = \"/nonexistent/path\",\n    }, allocator);\n\n    try std.testing.expect(!result.success);\n}\n","structuredPatch":[{"oldStart":34,"oldLines":7,"newStart":34,"newLines":7,"lines":[" ","     // Try to get absolute path","     var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;","-    const abs_path = std.fs.cwd().realpathZ(@ptrCast(beads_dir.ptr)) catch |err| {","+    const abs_path = std.fs.cwd().realpath(beads_dir, &abs_path_buf) catch |err| {","         if (err == error.FileNotFound) {","             if (global.json) {","                 out.printJson(WhereResult{"]},{"oldStart":64,"oldLines":9,"newStart":64,"newLines":8,"lines":["         };","     };"," ","-    // Copy to allocated buffer for stable return (abs_path points to stack buffer)","-    _ = &abs_path_buf; // suppress unused warning","-    const path_slice = abs_path[0..std.mem.len(abs_path)];","+    // abs_path is a slice into abs_path_buf with the resolved path","+    const path_slice = abs_path;"," ","     if (global.json) {","         out.printJson(WhereResult{"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ANpNogEH8vvisCNK9ZbaRr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VL4K8mpR59eFHeR1PBmhTn","name":"Bash","input":{"command":"zig build 2>&1","description":"Build beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1020,"cache_read_input_tokens":82908,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1020},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"54e7d0c8-11bc-443b-a337-c9742c8cd2c4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VL4K8mpR59eFHeR1PBmhTn","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"262de846-d845-464b-8a3f-e4487373a394","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019YER1qG9m62vUxmyr9QkXm","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me test the where command in the sandbox:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":106,"cache_read_input_tokens":83928,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":106},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"c2c2d06c-94ef-4dc0-92bc-48d23b18e427"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019YER1qG9m62vUxmyr9QkXm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KCfCFikwr3qR1xGLjtHbBK","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig/sandbox && rm -rf .beads && ../zig-out/bin/bz init && ../zig-out/bin/bz where","description":"Test the where command"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":106,"cache_read_input_tokens":83928,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":106},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"7ae1aefc-b88f-4c87-bc4d-5827fc8a153e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KCfCFikwr3qR1xGLjtHbBK","type":"tool_result","content":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\n/home/hotschmoe/beads_zig/sandbox/.beads","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"33a9dc67-bbd2-4f4f-bc1b-08e3cef10d2a","tool_use_result":{"stdout":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\n/home/hotschmoe/beads_zig/sandbox/.beads","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LKZsgYfGcp77AvWVkv58h1","type":"message","role":"assistant","content":[{"type":"text","text":"The where command works. Let me also test it with --json:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":190,"cache_read_input_tokens":84034,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":190},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"18a57457-e373-4e7d-8123-8012247cc94b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LKZsgYfGcp77AvWVkv58h1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019Ym3U7iPpWUgktZtnzYjak","name":"Bash","input":{"command":"../zig-out/bin/bz where --json","description":"Test where command with JSON output"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":190,"cache_read_input_tokens":84034,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":190},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"eeb97b5c-c323-40e8-8020-6e487ddc87fb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019Ym3U7iPpWUgktZtnzYjak","type":"tool_result","content":"/home/hotschmoe/beads_zig/sandbox/.beads","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"97b2362c-aa34-43b9-9b8a-9539ec1c4a41","tool_use_result":{"stdout":"/home/hotschmoe/beads_zig/sandbox/.beads","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ZVpwMkdESpM9WeqdgkSzo","type":"message","role":"assistant","content":[{"type":"text","text":"It seems the --json flag isn't being processed because it comes after the command. Let me check how global flags are parsed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":130,"cache_read_input_tokens":84224,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":130},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"c6aef9c6-ca62-4966-9bd7-3591be8f907a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ZVpwMkdESpM9WeqdgkSzo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AnBLrZy7EtLUzMkSmW6EPZ","name":"Bash","input":{"command":"../zig-out/bin/bz --json where","description":"Test where command with JSON flag before command"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":130,"cache_read_input_tokens":84224,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":130},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9b761a08-78a2-4569-b137-cfb9d0188904"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AnBLrZy7EtLUzMkSmW6EPZ","type":"tool_result","content":"{\"success\":true,\"path\":\"/home/hotschmoe/beads_zig/sandbox/.beads\",\"message\":null}","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f76fb142-ec0d-481f-a4a3-7001fb77959b","tool_use_result":{"stdout":"{\"success\":true,\"path\":\"/home/hotschmoe/beads_zig/sandbox/.beads\",\"message\":null}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01URWmFdMZ853U2kY2pBsESM","type":"message","role":"assistant","content":[{"type":"text","text":"Task 1 is complete. Let me test the error case as well:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":316,"cache_read_input_tokens":84354,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":316},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"21ac06b4-4cb2-4929-a606-86d1cd703e33"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01URWmFdMZ853U2kY2pBsESM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P8Pwn31oySNdAqemB9A5gx","name":"Bash","input":{"command":"../zig-out/bin/bz --data /nonexistent/path where","description":"Test where command with nonexistent workspace"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":316,"cache_read_input_tokens":84354,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":316},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"07c43b17-5070-4a8d-98eb-09fe5338c15b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P8Pwn31oySNdAqemB9A5gx","type":"tool_result","content":"error: workspace not initialized. Run 'bz init' first.","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"1910e837-3ad6-4ab3-a37c-c658b94ba229","tool_use_result":{"stdout":"error: workspace not initialized. Run 'bz init' first.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SikYMa5ebSG9EZrqF4znAn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DfmZByWMFoMCibnf2ZZpss","name":"TodoWrite","input":{"todos":[{"content":"Add 'where' command - show active .beads directory","status":"completed","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"in_progress","activeForm":"Adding missing issue fields CLI flags"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":137,"cache_read_input_tokens":84670,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":137},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8cbec9ab-d614-4106-b7f6-8d6827321522"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DfmZByWMFoMCibnf2ZZpss","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"6510eae3-7060-42cc-804c-06cc517ae2da","tool_use_result":{"oldTodos":[{"content":"Add 'where' command - show active .beads directory","status":"in_progress","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"pending","activeForm":"Adding missing issue fields"}],"newTodos":[{"content":"Add 'where' command - show active .beads directory","status":"completed","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"in_progress","activeForm":"Adding missing issue fields CLI flags"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qy5dfTHdmuh7c393ynz6cu","type":"message","role":"assistant","content":[{"type":"text","text":"## Task 2: Add CLI flags for missing issue fields\n\nNow I need to add CLI flags for `--owner`, `--design`, `--acceptance-criteria`, and `--external-ref` to both `create` and `update` commands."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":173,"cache_read_input_tokens":84807,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":173},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d05edf89-d1af-4682-a666-710651d4fb25"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Qy5dfTHdmuh7c393ynz6cu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DwVq6Mu9rXqG2FQ2J24mfA","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":105,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":173,"cache_read_input_tokens":84807,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":173},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"79e73001-d050-44f4-8412-84859071898a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DwVq6Mu9rXqG2FQ2J24mfA","type":"tool_result","content":"   105→};\n   106→\n   107→/// Create command arguments.\n   108→pub const CreateArgs = struct {\n   109→    title: []const u8,\n   110→    description: ?[]const u8 = null,\n   111→    issue_type: ?[]const u8 = null,\n   112→    priority: ?[]const u8 = null,\n   113→    assignee: ?[]const u8 = null,\n   114→    labels: []const []const u8 = &[_][]const u8{},\n   115→    deps: []const []const u8 = &[_][]const u8{},\n   116→    due: ?[]const u8 = null,\n   117→    estimate: ?i32 = null,\n   118→};\n   119→\n   120→/// Quick capture command arguments.\n   121→pub const QuickArgs = struct {\n   122→    title: []const u8,\n   123→    priority: ?[]const u8 = null,\n   124→};\n   125→\n   126→/// Show command arguments.\n   127→pub const ShowArgs = struct {\n   128→    id: []const u8,\n   129→    with_comments: bool = true,\n   130→    with_history: bool = false,\n   131→};\n   132→\n   133→/// Update command arguments.\n   134→pub const UpdateArgs = struct {\n   135→    id: []const u8,\n   136→    title: ?[]const u8 = null,\n   137→    description: ?[]const u8 = null,\n   138→    issue_type: ?[]const u8 = null,\n   139→    priority: ?[]const u8 = null,\n   140→    assignee: ?[]const u8 = null,\n   141→    status: ?[]const u8 = null,\n   142→    /// Expected version for optimistic locking (compare-and-swap).\n   143→    expected_version: ?u64 = null,\n   144→};\n   145→\n   146→/// Close command arguments.\n   147→pub const CloseArgs = struct {\n   148→    id: []const u8,\n   149→    reason: ?[]const u8 = null,\n   150→};\n   151→\n   152→/// Reopen command arguments.\n   153→pub const ReopenArgs = struct {\n   154→    id: []const u8,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"09a529f9-b6b9-4137-9be1-66d136595504","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,","numLines":50,"startLine":105,"totalLines":2280}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016L18KZzKXcj8AhogRRtEAd","type":"message","role":"assistant","content":[{"type":"text","text":"First, update the CreateArgs struct to include the new fields:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":846,"cache_read_input_tokens":84980,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":846},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"4e0d39e5-f468-4968-916c-8253d6ef4e95"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016L18KZzKXcj8AhogRRtEAd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y3Sr2dYohaPoZV9YQxEHSC","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};","new_string":"/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":846,"cache_read_input_tokens":84980,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":846},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a33f03cc-9f54-4b03-9a93-ba7a5e872f64"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y3Sr2dYohaPoZV9YQxEHSC","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"c05b175c-d844-4a50-8bbf-a7bb68f8cdf3","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};","newString":"/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":111,"oldLines":6,"newStart":111,"newLines":10,"lines":["     issue_type: ?[]const u8 = null,","     priority: ?[]const u8 = null,","     assignee: ?[]const u8 = null,","+    owner: ?[]const u8 = null,","+    design: ?[]const u8 = null,","+    acceptance_criteria: ?[]const u8 = null,","+    external_ref: ?[]const u8 = null,","     labels: []const []const u8 = &[_][]const u8{},","     deps: []const []const u8 = &[_][]const u8{},","     due: ?[]const u8 = null,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QG6eb1qE7RvXJ6X9qCec4M","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the UpdateArgs struct:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":533,"cache_read_input_tokens":85826,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":533},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9481404a-d100-428a-ba22-6039ed4eb74e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QG6eb1qE7RvXJ6X9qCec4M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013MKybgnzsDMvJ1FFEfaQPA","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};","new_string":"/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":533,"cache_read_input_tokens":85826,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":533},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a913dd7a-f521-476c-aeb8-f16e4c55acd1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013MKybgnzsDMvJ1FFEfaQPA","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e8f85c43-5f60-4dda-ab28-ab211f1d4da6","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};","newString":"/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":142,"oldLines":6,"newStart":142,"newLines":10,"lines":["     issue_type: ?[]const u8 = null,","     priority: ?[]const u8 = null,","     assignee: ?[]const u8 = null,","+    owner: ?[]const u8 = null,","+    design: ?[]const u8 = null,","+    acceptance_criteria: ?[]const u8 = null,","+    external_ref: ?[]const u8 = null,","     status: ?[]const u8 = null,","     /// Expected version for optimistic locking (compare-and-swap).","     expected_version: ?u64 = null,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XRYLpCFVp9pyacanjqzLeC","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the argument parsing functions. Let me find and update parseCreateArgs:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":503,"cache_read_input_tokens":86359,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":503},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d4687dbe-8771-48d0-9ad0-f03bc30c13de"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XRYLpCFVp9pyacanjqzLeC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WCsqfN4M6oj9xeN4fuBr6C","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":791,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":503,"cache_read_input_tokens":86359,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":503},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"42f99e95-50be-4127-bb17-477428384db6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WCsqfN4M6oj9xeN4fuBr6C","type":"tool_result","content":"   791→        }\n   792→        return result;\n   793→    }\n   794→\n   795→    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n   796→        var result = CreateArgs{ .title = undefined };\n   797→        var title_set = false;\n   798→        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n   799→        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n   800→\n   801→        while (self.hasNext()) {\n   802→            if (self.consumeFlag(\"-d\", \"--description\")) {\n   803→                result.description = self.next() orelse return error.MissingFlagValue;\n   804→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   805→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   806→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   807→                result.priority = self.next() orelse return error.MissingFlagValue;\n   808→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   809→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   810→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n   811→                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n   812→            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n   813→                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n   814→            } else if (self.consumeFlag(null, \"--due\")) {\n   815→                result.due = self.next() orelse return error.MissingFlagValue;\n   816→            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n   817→                const val = self.next() orelse return error.MissingFlagValue;\n   818→                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n   819→            } else if (self.peekPositional()) |_| {\n   820→                if (!title_set) {\n   821→                    result.title = self.next().?;\n   822→                    title_set = true;\n   823→                } else break;\n   824→            } else break;\n   825→        }\n   826→\n   827→        if (!title_set) return error.MissingRequiredArgument;\n   828→\n   829→        if (labels.items.len > 0) {\n   830→            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n   831→        }\n   832→        if (deps.items.len > 0) {\n   833→            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n   834→        }\n   835→\n   836→        return result;\n   837→    }\n   838→\n   839→    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n   840→        var result = QuickArgs{ .title = undefined };\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"37614200-574c-46cc-ad10-3433ea0ce735","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };","numLines":50,"startLine":791,"totalLines":2288}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YAiMRqpm88H3pj5eJzdvoi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RLSjKb45CakXkstyzmFkrT","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }","new_string":"    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1072,"cache_read_input_tokens":86862,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1072},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"7ce2d596-0a4a-45c3-8c96-9bfac9140692"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RLSjKb45CakXkstyzmFkrT","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"2fcc4342-d4bf-45f6-8add-68a67fe47ec9","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }","newString":"    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":807,"oldLines":6,"newStart":807,"newLines":14,"lines":["                 result.priority = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-a\", \"--assignee\")) {","                 result.assignee = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(\"-o\", \"--owner\")) {","+                result.owner = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--design\")) {","+                result.design = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {","+                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--external-ref\")) {","+                result.external_ref = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-l\", \"--label\")) {","                 labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;","             } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013vh5hMPWLXM8qHgKjTFgMZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now update parseUpdateArgs:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1639,"cache_read_input_tokens":87934,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1639},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"6f3470b3-605e-4956-b48d-f3f04a69c970"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013vh5hMPWLXM8qHgKjTFgMZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018PYNK6TePHBxqusZhDd4KP","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":880,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1639,"cache_read_input_tokens":87934,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1639},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8fe3cc4d-dbf3-48ce-8551-e73791edde9a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018PYNK6TePHBxqusZhDd4KP","type":"tool_result","content":"   880→            } else break;\n   881→        }\n   882→\n   883→        if (!id_set) return error.MissingRequiredArgument;\n   884→        return result;\n   885→    }\n   886→\n   887→    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n   888→        var result = UpdateArgs{ .id = undefined };\n   889→        var id_set = false;\n   890→\n   891→        while (self.hasNext()) {\n   892→            if (self.consumeFlag(null, \"--title\")) {\n   893→                result.title = self.next() orelse return error.MissingFlagValue;\n   894→            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n   895→                result.description = self.next() orelse return error.MissingFlagValue;\n   896→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   897→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   898→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   899→                result.priority = self.next() orelse return error.MissingFlagValue;\n   900→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   901→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   902→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n   903→                result.status = self.next() orelse return error.MissingFlagValue;\n   904→            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n   905→                const version_str = self.next() orelse return error.MissingFlagValue;\n   906→                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n   907→            } else if (self.peekPositional()) |_| {\n   908→                if (!id_set) {\n   909→                    result.id = self.next().?;\n   910→                    id_set = true;\n   911→                } else break;\n   912→            } else break;\n   913→        }\n   914→\n   915→        if (!id_set) return error.MissingRequiredArgument;\n   916→        return result;\n   917→    }\n   918→\n   919→    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"68cd77b9-0f21-4bcf-8a26-ce74dd764bb1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {","numLines":40,"startLine":880,"totalLines":2296}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D5dAfNXNxrP7yTKataWV8P","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013nXhAiCAEA852wV7F9ePYP","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }","new_string":"    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1000,"cache_read_input_tokens":89573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1000},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"cb202b6a-a6db-46ec-b2ae-e97febd484d6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013nXhAiCAEA852wV7F9ePYP","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f790eae5-4791-483c-a3fc-f9e6b3b0fccd","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }","newString":"    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":899,"oldLines":6,"newStart":899,"newLines":14,"lines":["                 result.priority = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-a\", \"--assignee\")) {","                 result.assignee = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(\"-o\", \"--owner\")) {","+                result.owner = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--design\")) {","+                result.design = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {","+                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(null, \"--external-ref\")) {","+                result.external_ref = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-s\", \"--status\")) {","                 result.status = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-v\", \"--version\")) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PFxapxj5CtU7WN4mcdnehb","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the create.zig command to actually use these new fields:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1247,"cache_read_input_tokens":90573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1247},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"2e09d506-d4e9-498b-ac26-daa4e97c5e7b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PFxapxj5CtU7WN4mcdnehb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EPQa1a4ABdBn43simNFFtY","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/create.zig","offset":110,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1247,"cache_read_input_tokens":90573,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1247},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"49e9a485-ccf6-42fe-a11a-5a0b47464ed9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EPQa1a4ABdBn43simNFFtY","type":"tool_result","content":"   110→    var generator = IdGenerator.init(prefix);\n   111→    const issue_count = store.countTotal();\n   112→    const issue_id = try generator.generate(allocator, issue_count);\n   113→    defer allocator.free(issue_id);\n   114→\n   115→    // Create issue\n   116→    const now = std.time.timestamp();\n   117→    var issue = Issue.init(issue_id, create_args.title, now);\n   118→    issue.description = create_args.description;\n   119→    issue.priority = priority;\n   120→    issue.issue_type = issue_type;\n   121→    issue.assignee = create_args.assignee;\n   122→    issue.created_by = actor;\n   123→    issue.due_at = .{ .value = due_at };\n   124→    issue.estimated_minutes = create_args.estimate;\n   125→\n   126→    // Set labels on issue (will be persisted via WAL)\n   127→    if (create_args.labels.len > 0) {\n   128→        issue.labels = create_args.labels;\n   129→    }\n   130→\n   131→    // Insert into store (for in-memory state and duplicate check)\n   132→    store.insert(issue) catch {\n   133→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to create issue\");\n   134→        return CreateError.StorageError;\n   135→    };\n   136→\n   137→    // Append to WAL for fast persistence (instead of full file rewrite)\n   138→    if (!global.no_auto_flush) {\n   139→        var wal = storage.Wal.init(beads_dir, allocator) catch {\n   140→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to initialize WAL\");\n   141→            return CreateError.StorageError;\n   142→        };\n   143→        defer wal.deinit();\n   144→\n   145→        wal.addIssue(issue) catch {\n   146→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to write to WAL\");\n   147→            return CreateError.StorageError;\n   148→        };\n   149→    }\n   150→\n   151→    // Output result\n   152→    if (structured_output) {\n   153→        try output.printJson(CreateResult{\n   154→            .success = true,\n   155→            .id = issue_id,\n   156→            .title = create_args.title,\n   157→        });\n   158→    } else if (global.quiet) {\n   159→        try output.raw(issue_id);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"73ff20c7-425f-4652-8088-c4a4abb70954","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/create.zig","content":"    var generator = IdGenerator.init(prefix);\n    const issue_count = store.countTotal();\n    const issue_id = try generator.generate(allocator, issue_count);\n    defer allocator.free(issue_id);\n\n    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)\n    if (create_args.labels.len > 0) {\n        issue.labels = create_args.labels;\n    }\n\n    // Insert into store (for in-memory state and duplicate check)\n    store.insert(issue) catch {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to create issue\");\n        return CreateError.StorageError;\n    };\n\n    // Append to WAL for fast persistence (instead of full file rewrite)\n    if (!global.no_auto_flush) {\n        var wal = storage.Wal.init(beads_dir, allocator) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to initialize WAL\");\n            return CreateError.StorageError;\n        };\n        defer wal.deinit();\n\n        wal.addIssue(issue) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to write to WAL\");\n            return CreateError.StorageError;\n        };\n    }\n\n    // Output result\n    if (structured_output) {\n        try output.printJson(CreateResult{\n            .success = true,\n            .id = issue_id,\n            .title = create_args.title,\n        });\n    } else if (global.quiet) {\n        try output.raw(issue_id);","numLines":50,"startLine":110,"totalLines":444}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014xYx1AWHps56VSDWvCMDQh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014RJoGx5cMZXxzB2PzEHRqk","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/create.zig","old_string":"    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)","new_string":"    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.owner = create_args.owner;\n    issue.design = create_args.design;\n    issue.acceptance_criteria = create_args.acceptance_criteria;\n    issue.external_ref = create_args.external_ref;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":906,"cache_read_input_tokens":91820,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":906},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"bc9bccfe-febd-4dcb-a8a0-f06148437341"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014RJoGx5cMZXxzB2PzEHRqk","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/create.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"fd477df9-6d01-4e08-872e-1606aaf4c2b0","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/create.zig","oldString":"    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)","newString":"    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.owner = create_args.owner;\n    issue.design = create_args.design;\n    issue.acceptance_criteria = create_args.acceptance_criteria;\n    issue.external_ref = create_args.external_ref;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)","originalFile":"//! Create and Quick capture commands for beads_zig.\n//!\n//! - `bz create <title>` - Full issue creation with all optional fields\n//! - `bz q <title>` - Quick capture (create + print ID only)\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst id_gen = @import(\"../id/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = storage.IssueStore;\nconst IdGenerator = id_gen.IdGenerator;\n\npub const CreateError = error{\n    EmptyTitle,\n    TitleTooLong,\n    InvalidPriority,\n    InvalidIssueType,\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const CreateResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    title: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\n/// Run the create command.\npub fn run(\n    create_args: args.CreateArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var output = common.initOutput(allocator, global);\n    const structured_output = global.isStructuredOutput();\n\n    // Validate title\n    if (create_args.title.len == 0) {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title cannot be empty\");\n        return CreateError.EmptyTitle;\n    }\n    if (create_args.title.len > 500) {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title exceeds 500 character limit\");\n        return CreateError.TitleTooLong;\n    }\n\n    // Determine workspace path\n    const beads_dir = global.data_path orelse \".beads\";\n    const issues_path = try std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    // Check if workspace is initialized\n    std.fs.cwd().access(issues_path, .{}) catch |err| {\n        if (err == error.FileNotFound) {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"workspace not initialized. Run 'bz init' first.\");\n            return CreateError.WorkspaceNotInitialized;\n        }\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"cannot access workspace\");\n        return CreateError.StorageError;\n    };\n\n    // Load existing issues\n    var store = IssueStore.init(allocator, issues_path);\n    defer store.deinit();\n\n    store.loadFromFile() catch |err| {\n        if (err != error.FileNotFound) {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to load issues\");\n            return CreateError.StorageError;\n        }\n    };\n\n    // Parse optional fields\n    const priority = if (create_args.priority) |p|\n        Priority.fromString(p) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"invalid priority value\");\n            return CreateError.InvalidPriority;\n        }\n    else\n        Priority.MEDIUM;\n\n    const issue_type = if (create_args.issue_type) |t|\n        IssueType.fromString(t)\n    else\n        .task;\n\n    // Parse due date if provided\n    const due_at: ?i64 = if (create_args.due) |due_str|\n        parseDateString(due_str)\n    else\n        null;\n\n    // Get actor (from flag, env, or default)\n    const actor = global.actor orelse getDefaultActor();\n\n    // Get config prefix (read from config.yaml or use default)\n    const prefix = try getConfigPrefix(allocator, beads_dir);\n    defer allocator.free(prefix);\n\n    // Generate ID\n    var generator = IdGenerator.init(prefix);\n    const issue_count = store.countTotal();\n    const issue_id = try generator.generate(allocator, issue_count);\n    defer allocator.free(issue_id);\n\n    // Create issue\n    const now = std.time.timestamp();\n    var issue = Issue.init(issue_id, create_args.title, now);\n    issue.description = create_args.description;\n    issue.priority = priority;\n    issue.issue_type = issue_type;\n    issue.assignee = create_args.assignee;\n    issue.created_by = actor;\n    issue.due_at = .{ .value = due_at };\n    issue.estimated_minutes = create_args.estimate;\n\n    // Set labels on issue (will be persisted via WAL)\n    if (create_args.labels.len > 0) {\n        issue.labels = create_args.labels;\n    }\n\n    // Insert into store (for in-memory state and duplicate check)\n    store.insert(issue) catch {\n        try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to create issue\");\n        return CreateError.StorageError;\n    };\n\n    // Append to WAL for fast persistence (instead of full file rewrite)\n    if (!global.no_auto_flush) {\n        var wal = storage.Wal.init(beads_dir, allocator) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to initialize WAL\");\n            return CreateError.StorageError;\n        };\n        defer wal.deinit();\n\n        wal.addIssue(issue) catch {\n            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to write to WAL\");\n            return CreateError.StorageError;\n        };\n    }\n\n    // Output result\n    if (structured_output) {\n        try output.printJson(CreateResult{\n            .success = true,\n            .id = issue_id,\n            .title = create_args.title,\n        });\n    } else if (global.quiet) {\n        try output.raw(issue_id);\n        try output.raw(\"\\n\");\n    } else {\n        try output.success(\"Created issue {s}\", .{issue_id});\n    }\n}\n\n/// Run the quick capture command (create + print ID only).\npub fn runQuick(\n    quick_args: args.QuickArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    // Convert QuickArgs to CreateArgs\n    const create_args = args.CreateArgs{\n        .title = quick_args.title,\n        .priority = quick_args.priority,\n    };\n\n    // Force quiet mode for q command unless structured output is specified\n    var modified_global = global;\n    if (!global.isStructuredOutput()) {\n        modified_global.quiet = true;\n    }\n\n    try run(create_args, modified_global, allocator);\n}\n\n/// Parse a date string in various formats to Unix timestamp.\n/// Supports: YYYY-MM-DD, YYYY-MM-DDTHH:MM:SSZ\nfn parseDateString(date_str: []const u8) ?i64 {\n    // Try RFC3339 format first\n    if (@import(\"../models/timestamp.zig\").parseRfc3339(date_str)) |ts| {\n        return ts;\n    }\n\n    // Try YYYY-MM-DD format\n    if (date_str.len == 10 and date_str[4] == '-' and date_str[7] == '-') {\n        const year = std.fmt.parseInt(i32, date_str[0..4], 10) catch return null;\n        const month = std.fmt.parseInt(u4, date_str[5..7], 10) catch return null;\n        const day = std.fmt.parseInt(u5, date_str[8..10], 10) catch return null;\n\n        if (month < 1 or month > 12) return null;\n        if (day < 1 or day > 31) return null;\n\n        // Convert to days since epoch\n        const epoch_day = epochDayFromYMD(year, month, day) catch return null;\n\n        // Convert to seconds (midnight UTC)\n        return @as(i64, epoch_day) * 86400;\n    }\n\n    return null;\n}\n\n/// Calculate epoch day from year/month/day.\nfn epochDayFromYMD(year: i32, month: u4, day: u5) !i32 {\n    // Algorithm from Howard Hinnant's date algorithms\n    const y: i32 = if (month <= 2) year - 1 else year;\n    const era: i32 = @divTrunc(if (y >= 0) y else y - 399, 400);\n    const yoe: u32 = @intCast(y - era * 400);\n    const m: u32 = month;\n    const doy: u32 = (153 * (if (m > 2) m - 3 else m + 9) + 2) / 5 + day - 1;\n    const doe: u32 = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n    return era * 146097 + @as(i32, @intCast(doe)) - 719468;\n}\n\n/// Get the default actor name from environment.\n/// On Windows, returns null (env var access requires allocation).\n/// Use --actor flag to specify the actor on Windows.\nfn getDefaultActor() ?[]const u8 {\n    const builtin = @import(\"builtin\");\n    if (builtin.os.tag == .windows) return null;\n    return std.posix.getenv(\"USER\") orelse std.posix.getenv(\"USERNAME\");\n}\n\n/// Read the ID prefix from config.yaml, defaulting to \"bd\".\nfn getConfigPrefix(allocator: std.mem.Allocator, beads_dir: []const u8) ![]u8 {\n    const config_path = try std.fs.path.join(allocator, &.{ beads_dir, \"config.yaml\" });\n    defer allocator.free(config_path);\n\n    const file = std.fs.cwd().openFile(config_path, .{}) catch {\n        return try allocator.dupe(u8, \"bd\");\n    };\n    defer file.close();\n\n    const content = file.readToEndAlloc(allocator, 4096) catch {\n        return try allocator.dupe(u8, \"bd\");\n    };\n    defer allocator.free(content);\n\n    // Simple YAML parsing for prefix: \"value\"\n    if (std.mem.indexOf(u8, content, \"prefix:\")) |prefix_pos| {\n        const after_prefix = content[prefix_pos + 7 ..];\n        // Find the value (skip whitespace, handle quotes)\n        var i: usize = 0;\n        while (i < after_prefix.len and (after_prefix[i] == ' ' or after_prefix[i] == '\\t')) {\n            i += 1;\n        }\n\n        if (i < after_prefix.len) {\n            if (after_prefix[i] == '\"') {\n                // Quoted value\n                i += 1;\n                const start = i;\n                while (i < after_prefix.len and after_prefix[i] != '\"' and after_prefix[i] != '\\n') {\n                    i += 1;\n                }\n                if (i > start) {\n                    return try allocator.dupe(u8, after_prefix[start..i]);\n                }\n            } else {\n                // Unquoted value\n                const start = i;\n                while (i < after_prefix.len and after_prefix[i] != '\\n' and after_prefix[i] != ' ' and after_prefix[i] != '\\t') {\n                    i += 1;\n                }\n                if (i > start) {\n                    return try allocator.dupe(u8, after_prefix[start..i]);\n                }\n            }\n        }\n    }\n\n    return try allocator.dupe(u8, \"bd\");\n}\n\n// --- Tests ---\n\ntest \"parseDateString parses YYYY-MM-DD\" {\n    const result = parseDateString(\"2024-01-29\");\n    try std.testing.expect(result != null);\n    // 2024-01-29 00:00:00 UTC should be around 1706486400\n    const ts = result.?;\n    try std.testing.expect(ts > 1706400000 and ts < 1706600000);\n}\n\ntest \"parseDateString parses RFC3339\" {\n    const result = parseDateString(\"2024-01-29T14:53:20Z\");\n    try std.testing.expect(result != null);\n    try std.testing.expectEqual(@as(i64, 1706540000), result.?);\n}\n\ntest \"parseDateString returns null for invalid format\" {\n    try std.testing.expect(parseDateString(\"invalid\") == null);\n    try std.testing.expect(parseDateString(\"01-29-2024\") == null);\n    try std.testing.expect(parseDateString(\"2024/01/29\") == null);\n}\n\ntest \"getConfigPrefix returns default when file missing\" {\n    const allocator = std.testing.allocator;\n    const prefix = try getConfigPrefix(allocator, \"/nonexistent/path\");\n    defer allocator.free(prefix);\n    try std.testing.expectEqualStrings(\"bd\", prefix);\n}\n\ntest \"CreateError enum exists\" {\n    // Just verify the error set compiles\n    const err: CreateError = CreateError.EmptyTitle;\n    try std.testing.expect(err == CreateError.EmptyTitle);\n}\n\ntest \"CreateResult struct works\" {\n    const result = CreateResult{\n        .success = true,\n        .id = \"bd-abc123\",\n        .title = \"Test issue\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n}\n\ntest \"run validates empty title\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"create_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const create_args = args.CreateArgs{ .title = \"\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    const result = run(create_args, global, allocator);\n    try std.testing.expectError(CreateError.EmptyTitle, result);\n}\n\ntest \"run validates title length\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"create_long\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const long_title = \"x\" ** 501;\n    const create_args = args.CreateArgs{ .title = long_title };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    const result = run(create_args, global, allocator);\n    try std.testing.expectError(CreateError.TitleTooLong, result);\n}\n\ntest \"run creates issue successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"create_success\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const create_args = args.CreateArgs{\n        .title = \"Test issue\",\n        .description = \"A description\",\n        .priority = \"high\",\n        .issue_type = \"bug\",\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(create_args, global, allocator);\n\n    // Verify issue was created by loading via IssueStore (which replays WAL)\n    var store = IssueStore.init(allocator, issues_path);\n    defer store.deinit();\n    try store.loadFromFile();\n\n    // Replay WAL to get the created issue\n    var wal = try storage.Wal.init(data_path, allocator);\n    defer wal.deinit();\n    _ = try wal.replay(&store);\n\n    // Find the created issue\n    const issues = store.getAllRef();\n    try std.testing.expect(issues.len > 0);\n\n    var found = false;\n    for (issues) |issue| {\n        if (std.mem.indexOf(u8, issue.title, \"Test issue\") != null) {\n            found = true;\n            try std.testing.expectEqual(models.IssueType.bug, issue.issue_type);\n            break;\n        }\n    }\n    try std.testing.expect(found);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const create_args = args.CreateArgs{ .title = \"Test\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(create_args, global, allocator);\n    try std.testing.expectError(CreateError.WorkspaceNotInitialized, result);\n}\n","structuredPatch":[{"oldStart":119,"oldLines":6,"newStart":119,"newLines":10,"lines":["     issue.priority = priority;","     issue.issue_type = issue_type;","     issue.assignee = create_args.assignee;","+    issue.owner = create_args.owner;","+    issue.design = create_args.design;","+    issue.acceptance_criteria = create_args.acceptance_criteria;","+    issue.external_ref = create_args.external_ref;","     issue.created_by = actor;","     issue.due_at = .{ .value = due_at };","     issue.estimated_minutes = create_args.estimate;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Jr5UVQR3SgBqQGW7dKfhwu","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the update.zig command:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":501,"cache_read_input_tokens":92726,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":501},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a05da1c3-53e5-475f-af3d-7349ea3b80cf"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Jr5UVQR3SgBqQGW7dKfhwu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LZuCViWsaXNM159DHG7BTG","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/update.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":501,"cache_read_input_tokens":92726,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":501},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"19ee03b7-d9d5-422a-8b2a-ca55030708b5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LZuCViWsaXNM159DHG7BTG","type":"tool_result","content":"     1→//! Update command for beads_zig.\n     2→//!\n     3→//! `bz update <id> [--status X] [--priority X] [--title X] [--description X] [--assignee X] [--type X]`\n     4→//!\n     5→//! Modifies an existing issue.\n     6→\n     7→const std = @import(\"std\");\n     8→const models = @import(\"../models/mod.zig\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const test_util = @import(\"../test_util.zig\");\n    12→\n    13→const Status = models.Status;\n    14→const Priority = models.Priority;\n    15→const IssueType = models.IssueType;\n    16→const IssueStore = common.IssueStore;\n    17→const IssueStoreError = common.IssueStoreError;\n    18→const CommandContext = common.CommandContext;\n    19→\n    20→pub const UpdateError = error{\n    21→    WorkspaceNotInitialized,\n    22→    IssueNotFound,\n    23→    InvalidArgument,\n    24→    StorageError,\n    25→    VersionMismatch,\n    26→    OutOfMemory,\n    27→};\n    28→\n    29→pub const UpdateResult = struct {\n    30→    success: bool,\n    31→    id: ?[]const u8 = null,\n    32→    message: ?[]const u8 = null,\n    33→};\n    34→\n    35→pub fn run(\n    36→    update_args: args.UpdateArgs,\n    37→    global: args.GlobalOptions,\n    38→    allocator: std.mem.Allocator,\n    39→) !void {\n    40→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    41→        return UpdateError.WorkspaceNotInitialized;\n    42→    };\n    43→    defer ctx.deinit();\n    44→\n    45→    const structured_output = global.isStructuredOutput();\n    46→    if (!try ctx.store.exists(update_args.id)) {\n    47→        try common.outputNotFoundError(UpdateResult, &ctx.output, structured_output, update_args.id, allocator);\n    48→        return UpdateError.IssueNotFound;\n    49→    }\n    50→\n    51→    var updates = IssueStore.IssueUpdate{};\n    52→\n    53→    if (update_args.title) |t| {\n    54→        updates.title = t;\n    55→    }\n    56→\n    57→    if (update_args.description) |d| {\n    58→        updates.description = d;\n    59→    }\n    60→\n    61→    if (update_args.status) |s| {\n    62→        updates.status = Status.fromString(s);\n    63→    }\n    64→\n    65→    if (update_args.priority) |p| {\n    66→        updates.priority = Priority.fromString(p) catch {\n    67→            try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"invalid priority value\");\n    68→            return UpdateError.InvalidArgument;\n    69→        };\n    70→    }\n    71→\n    72→    if (update_args.issue_type) |t| {\n    73→        updates.issue_type = IssueType.fromString(t);\n    74→    }\n    75→\n    76→    if (update_args.assignee) |a| {\n    77→        updates.assignee = a;\n    78→    }\n    79→\n    80→    // Optimistic locking: pass expected version for compare-and-swap\n    81→    if (update_args.expected_version) |v| {\n    82→        updates.expected_version = v;\n    83→    }\n    84→\n    85→    const now = std.time.timestamp();\n    86→    ctx.store.update(update_args.id, updates, now) catch |err| {\n    87→        if (err == IssueStoreError.VersionMismatch) {\n    88→            try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"version mismatch: issue was modified by another process\");\n    89→            return UpdateError.VersionMismatch;\n    90→        }\n    91→        try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"failed to update issue\");\n    92→        return UpdateError.StorageError;\n    93→    };\n    94→\n    95→    try ctx.saveIfAutoFlush();\n    96→\n    97→    if (structured_output) {\n    98→        try ctx.output.printJson(UpdateResult{\n    99→            .success = true,\n   100→            .id = update_args.id,\n   101→        });\n   102→    } else if (global.quiet) {\n   103→        try ctx.output.raw(update_args.id);\n   104→        try ctx.output.raw(\"\\n\");\n   105→    } else {\n   106→        try ctx.output.success(\"Updated issue {s}\", .{update_args.id});\n   107→    }\n   108→}\n   109→\n   110→// --- Tests ---\n   111→\n   112→test \"UpdateError enum exists\" {\n   113→    const err: UpdateError = UpdateError.IssueNotFound;\n   114→    try std.testing.expect(err == UpdateError.IssueNotFound);\n   115→}\n   116→\n   117→test \"UpdateResult struct works\" {\n   118→    const result = UpdateResult{\n   119→        .success = true,\n   120→        .id = \"bd-abc123\",\n   121→    };\n   122→    try std.testing.expect(result.success);\n   123→    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n   124→}\n   125→\n   126→test \"run detects uninitialized workspace\" {\n   127→    const allocator = std.testing.allocator;\n   128→\n   129→    const update_args = args.UpdateArgs{ .id = \"bd-test\" };\n   130→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   131→\n   132→    const result = run(update_args, global, allocator);\n   133→    try std.testing.expectError(UpdateError.WorkspaceNotInitialized, result);\n   134→}\n   135→\n   136→test \"run returns error for missing issue\" {\n   137→    const allocator = std.testing.allocator;\n   138→\n   139→    const tmp_dir_path = try test_util.createTestDir(allocator, \"update_missing\");\n   140→    defer allocator.free(tmp_dir_path);\n   141→    defer test_util.cleanupTestDir(tmp_dir_path);\n   142→\n   143→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   144→    defer allocator.free(data_path);\n   145→\n   146→    try std.fs.cwd().makeDir(data_path);\n   147→\n   148→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   149→    defer allocator.free(issues_path);\n   150→\n   151→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   152→    f.close();\n   153→\n   154→    const update_args = args.UpdateArgs{ .id = \"bd-nonexistent\", .title = \"New title\" };\n   155→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   156→\n   157→    const result = run(update_args, global, allocator);\n   158→    try std.testing.expectError(UpdateError.IssueNotFound, result);\n   159→}\n   160→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f2b98428-95d9-4ea9-92a6-2ce57fa3cd6f","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/update.zig","content":"//! Update command for beads_zig.\n//!\n//! `bz update <id> [--status X] [--priority X] [--title X] [--description X] [--assignee X] [--type X]`\n//!\n//! Modifies an existing issue.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst IssueStoreError = common.IssueStoreError;\nconst CommandContext = common.CommandContext;\n\npub const UpdateError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    InvalidArgument,\n    StorageError,\n    VersionMismatch,\n    OutOfMemory,\n};\n\npub const UpdateResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    update_args: args.UpdateArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return UpdateError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(update_args.id)) {\n        try common.outputNotFoundError(UpdateResult, &ctx.output, structured_output, update_args.id, allocator);\n        return UpdateError.IssueNotFound;\n    }\n\n    var updates = IssueStore.IssueUpdate{};\n\n    if (update_args.title) |t| {\n        updates.title = t;\n    }\n\n    if (update_args.description) |d| {\n        updates.description = d;\n    }\n\n    if (update_args.status) |s| {\n        updates.status = Status.fromString(s);\n    }\n\n    if (update_args.priority) |p| {\n        updates.priority = Priority.fromString(p) catch {\n            try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"invalid priority value\");\n            return UpdateError.InvalidArgument;\n        };\n    }\n\n    if (update_args.issue_type) |t| {\n        updates.issue_type = IssueType.fromString(t);\n    }\n\n    if (update_args.assignee) |a| {\n        updates.assignee = a;\n    }\n\n    // Optimistic locking: pass expected version for compare-and-swap\n    if (update_args.expected_version) |v| {\n        updates.expected_version = v;\n    }\n\n    const now = std.time.timestamp();\n    ctx.store.update(update_args.id, updates, now) catch |err| {\n        if (err == IssueStoreError.VersionMismatch) {\n            try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"version mismatch: issue was modified by another process\");\n            return UpdateError.VersionMismatch;\n        }\n        try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"failed to update issue\");\n        return UpdateError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(UpdateResult{\n            .success = true,\n            .id = update_args.id,\n        });\n    } else if (global.quiet) {\n        try ctx.output.raw(update_args.id);\n        try ctx.output.raw(\"\\n\");\n    } else {\n        try ctx.output.success(\"Updated issue {s}\", .{update_args.id});\n    }\n}\n\n// --- Tests ---\n\ntest \"UpdateError enum exists\" {\n    const err: UpdateError = UpdateError.IssueNotFound;\n    try std.testing.expect(err == UpdateError.IssueNotFound);\n}\n\ntest \"UpdateResult struct works\" {\n    const result = UpdateResult{\n        .success = true,\n        .id = \"bd-abc123\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const update_args = args.UpdateArgs{ .id = \"bd-test\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(update_args, global, allocator);\n    try std.testing.expectError(UpdateError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns error for missing issue\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"update_missing\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const update_args = args.UpdateArgs{ .id = \"bd-nonexistent\", .title = \"New title\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    const result = run(update_args, global, allocator);\n    try std.testing.expectError(UpdateError.IssueNotFound, result);\n}\n","numLines":160,"startLine":1,"totalLines":160}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LRmEQuZwCvBhrQincq7qGg","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the update.zig file to handle the new fields. First, let me check what fields are available in IssueUpdate:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2262,"cache_read_input_tokens":93227,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2262},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"ecbc6daf-d6f1-4ffb-8913-0ab29da047d9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LRmEQuZwCvBhrQincq7qGg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012hygZmNEH2kExEArZreNss","name":"Grep","input":{"pattern":"pub const IssueUpdate","path":"/home/hotschmoe/beads_zig/src","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2262,"cache_read_input_tokens":93227,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2262},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0b9aba72-8a22-4e0d-a203-b403e767039e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012hygZmNEH2kExEArZreNss","type":"tool_result","content":"Found 1 file\n/home/hotschmoe/beads_zig/src/storage/store.zig"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"3f2aba9e-b9e9-48dc-8638-715a7bf60a32","tool_use_result":{"mode":"files_with_matches","filenames":["/home/hotschmoe/beads_zig/src/storage/store.zig"],"numFiles":1}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GmPqYamQ5W7VTJgLb7ykpq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GhAF3FV8EpURJweitBaAye","name":"Grep","input":{"pattern":"IssueUpdate = struct","path":"/home/hotschmoe/beads_zig/src/storage/store.zig","output_mode":"content","-A":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":184,"cache_read_input_tokens":95489,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":184},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e1381a38-fc93-43a9-b9bb-5584057757ff"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GhAF3FV8EpURJweitBaAye","type":"tool_result","content":"194:    pub const IssueUpdate = struct {\n195-        title: ?[]const u8 = null,\n196-        description: ?[]const u8 = null,\n197-        design: ?[]const u8 = null,\n198-        acceptance_criteria: ?[]const u8 = null,\n199-        notes: ?[]const u8 = null,\n200-        status: ?Status = null,\n201-        priority: ?Priority = null,\n202-        issue_type: ?IssueType = null,\n203-        assignee: ?[]const u8 = null,\n204-        owner: ?[]const u8 = null,\n205-        estimated_minutes: ?i32 = null,\n206-        closed_at: ?i64 = null,\n207-        close_reason: ?[]const u8 = null,\n208-        due_at: ?i64 = null,\n209-        defer_until: ?i64 = null,\n210-        external_ref: ?[]const u8 = null,\n211-        source_system: ?[]const u8 = null,\n212-        pinned: ?bool = null,\n213-        is_template: ?bool = null,\n214-        content_hash: ?[]const u8 = null,\n215-\n216-        /// Expected version for optimistic locking.\n217-        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n218-        expected_version: ?u64 = null,\n219-    };\n220-\n221-    /// Update an issue with the given fields.\n222-    /// If updates.expected_version is set, performs optimistic locking check.\n223-    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n224-        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"32e50a6f-6a33-4644-88d5-67ab2c43d13c","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"194:    pub const IssueUpdate = struct {\n195-        title: ?[]const u8 = null,\n196-        description: ?[]const u8 = null,\n197-        design: ?[]const u8 = null,\n198-        acceptance_criteria: ?[]const u8 = null,\n199-        notes: ?[]const u8 = null,\n200-        status: ?Status = null,\n201-        priority: ?Priority = null,\n202-        issue_type: ?IssueType = null,\n203-        assignee: ?[]const u8 = null,\n204-        owner: ?[]const u8 = null,\n205-        estimated_minutes: ?i32 = null,\n206-        closed_at: ?i64 = null,\n207-        close_reason: ?[]const u8 = null,\n208-        due_at: ?i64 = null,\n209-        defer_until: ?i64 = null,\n210-        external_ref: ?[]const u8 = null,\n211-        source_system: ?[]const u8 = null,\n212-        pinned: ?bool = null,\n213-        is_template: ?bool = null,\n214-        content_hash: ?[]const u8 = null,\n215-\n216-        /// Expected version for optimistic locking.\n217-        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n218-        expected_version: ?u64 = null,\n219-    };\n220-\n221-    /// Update an issue with the given fields.\n222-    /// If updates.expected_version is set, performs optimistic locking check.\n223-    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n224-        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;","numLines":31}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WjdHKyDz2wHYFCC698WMCc","type":"message","role":"assistant","content":[{"type":"text","text":"The IssueUpdate struct already has all the fields we need. Now I just need to update the update.zig command to use them:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":621,"cache_read_input_tokens":95673,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":621},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a0ac360d-b31e-4500-887a-e116b3af3cec"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WjdHKyDz2wHYFCC698WMCc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013rLu6zmso3XhbViXamCNoV","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/update.zig","old_string":"    if (update_args.assignee) |a| {\n        updates.assignee = a;\n    }\n\n    // Optimistic locking: pass expected version for compare-and-swap","new_string":"    if (update_args.assignee) |a| {\n        updates.assignee = a;\n    }\n\n    if (update_args.owner) |o| {\n        updates.owner = o;\n    }\n\n    if (update_args.design) |d| {\n        updates.design = d;\n    }\n\n    if (update_args.acceptance_criteria) |ac| {\n        updates.acceptance_criteria = ac;\n    }\n\n    if (update_args.external_ref) |er| {\n        updates.external_ref = er;\n    }\n\n    // Optimistic locking: pass expected version for compare-and-swap"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":621,"cache_read_input_tokens":95673,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":621},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9a1ac8cc-270a-4cd0-9c90-a78d2998a82c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013rLu6zmso3XhbViXamCNoV","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/update.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"6a5028e2-56ac-4fbf-b8a8-ea2b51608406","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/update.zig","oldString":"    if (update_args.assignee) |a| {\n        updates.assignee = a;\n    }\n\n    // Optimistic locking: pass expected version for compare-and-swap","newString":"    if (update_args.assignee) |a| {\n        updates.assignee = a;\n    }\n\n    if (update_args.owner) |o| {\n        updates.owner = o;\n    }\n\n    if (update_args.design) |d| {\n        updates.design = d;\n    }\n\n    if (update_args.acceptance_criteria) |ac| {\n        updates.acceptance_criteria = ac;\n    }\n\n    if (update_args.external_ref) |er| {\n        updates.external_ref = er;\n    }\n\n    // Optimistic locking: pass expected version for compare-and-swap","originalFile":"//! Update command for beads_zig.\n//!\n//! `bz update <id> [--status X] [--priority X] [--title X] [--description X] [--assignee X] [--type X]`\n//!\n//! Modifies an existing issue.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst IssueStoreError = common.IssueStoreError;\nconst CommandContext = common.CommandContext;\n\npub const UpdateError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    InvalidArgument,\n    StorageError,\n    VersionMismatch,\n    OutOfMemory,\n};\n\npub const UpdateResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    update_args: args.UpdateArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return UpdateError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(update_args.id)) {\n        try common.outputNotFoundError(UpdateResult, &ctx.output, structured_output, update_args.id, allocator);\n        return UpdateError.IssueNotFound;\n    }\n\n    var updates = IssueStore.IssueUpdate{};\n\n    if (update_args.title) |t| {\n        updates.title = t;\n    }\n\n    if (update_args.description) |d| {\n        updates.description = d;\n    }\n\n    if (update_args.status) |s| {\n        updates.status = Status.fromString(s);\n    }\n\n    if (update_args.priority) |p| {\n        updates.priority = Priority.fromString(p) catch {\n            try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"invalid priority value\");\n            return UpdateError.InvalidArgument;\n        };\n    }\n\n    if (update_args.issue_type) |t| {\n        updates.issue_type = IssueType.fromString(t);\n    }\n\n    if (update_args.assignee) |a| {\n        updates.assignee = a;\n    }\n\n    // Optimistic locking: pass expected version for compare-and-swap\n    if (update_args.expected_version) |v| {\n        updates.expected_version = v;\n    }\n\n    const now = std.time.timestamp();\n    ctx.store.update(update_args.id, updates, now) catch |err| {\n        if (err == IssueStoreError.VersionMismatch) {\n            try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"version mismatch: issue was modified by another process\");\n            return UpdateError.VersionMismatch;\n        }\n        try common.outputErrorTyped(UpdateResult, &ctx.output, structured_output, \"failed to update issue\");\n        return UpdateError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(UpdateResult{\n            .success = true,\n            .id = update_args.id,\n        });\n    } else if (global.quiet) {\n        try ctx.output.raw(update_args.id);\n        try ctx.output.raw(\"\\n\");\n    } else {\n        try ctx.output.success(\"Updated issue {s}\", .{update_args.id});\n    }\n}\n\n// --- Tests ---\n\ntest \"UpdateError enum exists\" {\n    const err: UpdateError = UpdateError.IssueNotFound;\n    try std.testing.expect(err == UpdateError.IssueNotFound);\n}\n\ntest \"UpdateResult struct works\" {\n    const result = UpdateResult{\n        .success = true,\n        .id = \"bd-abc123\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const update_args = args.UpdateArgs{ .id = \"bd-test\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(update_args, global, allocator);\n    try std.testing.expectError(UpdateError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns error for missing issue\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"update_missing\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const update_args = args.UpdateArgs{ .id = \"bd-nonexistent\", .title = \"New title\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    const result = run(update_args, global, allocator);\n    try std.testing.expectError(UpdateError.IssueNotFound, result);\n}\n","structuredPatch":[{"oldStart":77,"oldLines":6,"newStart":77,"newLines":22,"lines":["         updates.assignee = a;","     }"," ","+    if (update_args.owner) |o| {","+        updates.owner = o;","+    }","+","+    if (update_args.design) |d| {","+        updates.design = d;","+    }","+","+    if (update_args.acceptance_criteria) |ac| {","+        updates.acceptance_criteria = ac;","+    }","+","+    if (update_args.external_ref) |er| {","+        updates.external_ref = er;","+    }","+","     // Optimistic locking: pass expected version for compare-and-swap","     if (update_args.expected_version) |v| {","         updates.expected_version = v;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PuYNaDtMAgEGBZo341uX8c","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's build to check for compilation errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":556,"cache_read_input_tokens":96294,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":556},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0c6b1559-6f38-46d3-88a3-214107be6379"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PuYNaDtMAgEGBZo341uX8c","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014vxg2ZgpUQTtgYceLRm6zC","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && zig build 2>&1 | head -50","description":"Build beads_zig to check for compilation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":556,"cache_read_input_tokens":96294,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":556},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"ba6eb235-f637-4e45-8356-d87ed1a61133"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014vxg2ZgpUQTtgYceLRm6zC","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e9bb16e2-6f49-4a9a-9199-1d18df4d72f9","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TUTfywu42q6PXawzwhfEWk","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's test the new flags:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":142,"cache_read_input_tokens":96850,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":142},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0f362877-71c6-4a0c-9632-30e85c9af35a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TUTfywu42q6PXawzwhfEWk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QNPdF1wH7mrspL7THtSQiS","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig/sandbox && rm -rf .beads && ../zig-out/bin/bz init && ../zig-out/bin/bz create \"Test task\" --owner alice@example.com --design \"Use adapter pattern\" --acceptance-criteria \"- [ ] Unit tests pass\" --external-ref \"https://github.com/org/repo/issues/123\" && ../zig-out/bin/bz --json list","description":"Test new CLI flags for create command"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":142,"cache_read_input_tokens":96850,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":142},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8075edab-3bc4-498e-8bf7-3556ab1e5ce0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QNPdF1wH7mrspL7THtSQiS","type":"tool_result","content":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-3te\n{\"success\":true,\"issues\":[{\"id\":\"bd-3te\",\"title\":\"Test task\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"assignee\":null}],\"count\":1,\"message\":null}","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"3b4b77a7-f89a-4873-8003-20496c7ac30a","tool_use_result":{"stdout":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-3te\n{\"success\":true,\"issues\":[{\"id\":\"bd-3te\",\"title\":\"Test task\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"assignee\":null}],\"count\":1,\"message\":null}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XFtwVuTBRQPVzQZbuzqAma","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify the full issue details to check the fields are set:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":291,"cache_read_input_tokens":96992,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":291},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e4c03963-b418-47a3-8566-c8d9db0f7cad"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XFtwVuTBRQPVzQZbuzqAma","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WYgWtythpPFcWfQdPGkNe5","name":"Bash","input":{"command":"../zig-out/bin/bz show bd-3te --json","description":"Show issue with new fields"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":291,"cache_read_input_tokens":96992,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":291},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"ce00678b-5c3b-4f2e-b33d-a725587af951"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WYgWtythpPFcWfQdPGkNe5","type":"tool_result","content":"ID: bd-3te\nTitle: Test task\nStatus: open\nPriority: medium\nType: task\nCreated: 1770018466\nUpdated: 1770018466","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"1b874c33-cf1c-4143-b4b7-08b38da88945","tool_use_result":{"stdout":"ID: bd-3te\nTitle: Test task\nStatus: open\nPriority: medium\nType: task\nCreated: 1770018466\nUpdated: 1770018466","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XAVDq62oPe1uf73c21gQBd","type":"message","role":"assistant","content":[{"type":"text","text":"The JSON flag isn't being processed because it comes after the command. Let me fix that:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":156,"cache_read_input_tokens":97283,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":156},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"d4621c58-3310-4c51-99b7-b211ee9025ec"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XAVDq62oPe1uf73c21gQBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Lx2ZtdWLsc9fnfaL4aAX7R","name":"Bash","input":{"command":"../zig-out/bin/bz --json show bd-3te","description":"Show issue with JSON flag before command"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":156,"cache_read_input_tokens":97283,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":156},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e3b4d0a0-0cd8-489b-ab23-1ab1f60e15f1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Lx2ZtdWLsc9fnfaL4aAX7R","type":"tool_result","content":"{\"success\":true,\"issue\":{\"id\":\"bd-3te\",\"content_hash\":null,\"title\":\"Test task\",\"description\":null,\"design\":\"Use adapter pattern\",\"acceptance_criteria\":\"- [ ] Unit tests pass\",\"notes\":null,\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"assignee\":null,\"owner\":\"alice@example.com\",\"created_at\":\"2026-02-02T07:47:46Z\",\"created_by\":\"hotschmoe\",\"updated_at\":\"2026-02-02T07:47:46Z\",\"closed_at\":null,\"close_reason\":null,\"due_at\":null,\"defer_until\":null,\"estimated_minutes\":null,\"external_ref\":\"https://github.com/org/repo/issues/123\",\"source_system\":null,\"pinned\":false,\"is_template\":false,\"version\":1,\"labels\":[],\"dependencies\":[],\"comments\":[]},\"depends_on\":null,\"blocks\":null,\"message\":null}","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"829ea5de-51b6-4f74-9cb4-10708bd98ba9","tool_use_result":{"stdout":"{\"success\":true,\"issue\":{\"id\":\"bd-3te\",\"content_hash\":null,\"title\":\"Test task\",\"description\":null,\"design\":\"Use adapter pattern\",\"acceptance_criteria\":\"- [ ] Unit tests pass\",\"notes\":null,\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"assignee\":null,\"owner\":\"alice@example.com\",\"created_at\":\"2026-02-02T07:47:46Z\",\"created_by\":\"hotschmoe\",\"updated_at\":\"2026-02-02T07:47:46Z\",\"closed_at\":null,\"close_reason\":null,\"due_at\":null,\"defer_until\":null,\"estimated_minutes\":null,\"external_ref\":\"https://github.com/org/repo/issues/123\",\"source_system\":null,\"pinned\":false,\"is_template\":false,\"version\":1,\"labels\":[],\"dependencies\":[],\"comments\":[]},\"depends_on\":null,\"blocks\":null,\"message\":null}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014XEQRwkgCgxJofmuXMnX4u","type":"message","role":"assistant","content":[{"type":"text","text":"All four fields are properly set:\n- `owner`: \"alice@example.com\"\n- `design`: \"Use adapter pattern\"\n- `acceptance_criteria`: \"- [ ] Unit tests pass\"\n- `external_ref`: \"https://github.com/org/repo/issues/123\"\n\nNow let me test the update command:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":341,"cache_read_input_tokens":97439,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":341},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"7c6a9924-c9ce-41c1-8e07-d1a8569fc6c6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014XEQRwkgCgxJofmuXMnX4u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J6HjyqykUAShQ3uvxCXSwJ","name":"Bash","input":{"command":"../zig-out/bin/bz update bd-3te --owner bob@example.com --design \"Updated design\" && ../zig-out/bin/bz --json show bd-3te","description":"Test update command with new flags"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":341,"cache_read_input_tokens":97439,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":341},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"438061b8-2902-4495-8911-24755e2cb627"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J6HjyqykUAShQ3uvxCXSwJ","type":"tool_result","content":"Updated issue bd-3te\n{\"success\":true,\"issue\":{\"id\":\"bd-3te\",\"content_hash\":null,\"title\":\"Test task\",\"description\":null,\"design\":\"Updated design\",\"acceptance_criteria\":\"- [ ] Unit tests pass\",\"notes\":null,\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"assignee\":null,\"owner\":\"bob@example.com\",\"created_at\":\"2026-02-02T07:47:46Z\",\"created_by\":\"hotschmoe\",\"updated_at\":\"2026-02-02T07:47:59Z\",\"closed_at\":null,\"close_reason\":null,\"due_at\":null,\"defer_until\":null,\"estimated_minutes\":null,\"external_ref\":\"https://github.com/org/repo/issues/123\",\"source_system\":null,\"pinned\":false,\"is_template\":false,\"version\":2,\"labels\":[],\"dependencies\":[],\"comments\":[]},\"depends_on\":null,\"blocks\":null,\"message\":null}","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"847ab4d7-b105-40e3-99cf-5809119b19b0","tool_use_result":{"stdout":"Updated issue bd-3te\n{\"success\":true,\"issue\":{\"id\":\"bd-3te\",\"content_hash\":null,\"title\":\"Test task\",\"description\":null,\"design\":\"Updated design\",\"acceptance_criteria\":\"- [ ] Unit tests pass\",\"notes\":null,\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"assignee\":null,\"owner\":\"bob@example.com\",\"created_at\":\"2026-02-02T07:47:46Z\",\"created_by\":\"hotschmoe\",\"updated_at\":\"2026-02-02T07:47:59Z\",\"closed_at\":null,\"close_reason\":null,\"due_at\":null,\"defer_until\":null,\"estimated_minutes\":null,\"external_ref\":\"https://github.com/org/repo/issues/123\",\"source_system\":null,\"pinned\":false,\"is_template\":false,\"version\":2,\"labels\":[],\"dependencies\":[],\"comments\":[]},\"depends_on\":null,\"blocks\":null,\"message\":null}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Aq3jxTTxxtzFpk91HHejud","type":"message","role":"assistant","content":[{"type":"text","text":"The update command works correctly. The owner changed from \"alice@example.com\" to \"bob@example.com\" and design was updated. Now let me run the tests to make sure everything is working:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":591,"cache_read_input_tokens":97780,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":591},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"dbd8f68d-6b95-4725-acdc-705e7cced34c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Aq3jxTTxxtzFpk91HHejud","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QVp56hAVPPSrQMDmuwMDub","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && zig build test 2>&1 | tail -30","description":"Run tests to verify changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":591,"cache_read_input_tokens":97780,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":591},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"cfe2fc89-34f8-434c-9cb3-478ae507013d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QVp56hAVPPSrQMDmuwMDub","type":"tool_result","content":"640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"98d19ee8-ac34-4769-bcb8-3cdc824403e1","tool_use_result":{"stdout":"640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DE7daioFQNn9jGsFLN4tYK","type":"message","role":"assistant","content":[{"type":"text","text":"All 661 tests passed. Now let's mark the second task as completed and commit the changes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":697,"cache_read_input_tokens":98371,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":697},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"a31a0aef-121f-45ac-8511-2fd3d719ebad"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DE7daioFQNn9jGsFLN4tYK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NErm6AoBpmnEADPo2uRmaW","name":"TodoWrite","input":{"todos":[{"content":"Add 'where' command - show active .beads directory","status":"completed","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"completed","activeForm":"Adding missing issue fields CLI flags"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":697,"cache_read_input_tokens":98371,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":697},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"692f07e6-6cf4-43a1-a4a1-53b71d4f4a24"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NErm6AoBpmnEADPo2uRmaW","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"8604fa5c-2d20-4249-9aa0-072bd54c9247","tool_use_result":{"oldTodos":[{"content":"Add 'where' command - show active .beads directory","status":"completed","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"in_progress","activeForm":"Adding missing issue fields CLI flags"}],"newTodos":[{"content":"Add 'where' command - show active .beads directory","status":"completed","activeForm":"Adding 'where' command"},{"content":"Add missing issue fields (owner, design, acceptance_criteria, external_ref)","status":"completed","activeForm":"Adding missing issue fields CLI flags"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01B25t5UyxgjzrqyRC5u5opN","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's create a git commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":193,"cache_read_input_tokens":99068,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":193},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"21b1ffa5-eb89-40e4-b1a5-a57c94b116f7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01B25t5UyxgjzrqyRC5u5opN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013pmnSUH2E3B35Ek1z24A3u","name":"Bash","input":{"command":"git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":193,"cache_read_input_tokens":99068,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":193},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"2579ccfa-734c-41fe-8ba8-28e2f95bb7cd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013pmnSUH2E3B35Ek1z24A3u","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/create.zig\n\tmodified:   src/cli/mod.zig\n\tmodified:   src/cli/update.zig\n\tmodified:   src/main.zig\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tsrc/cli/where.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0f7e1b5e-1334-4331-bc3f-6f67f907b33b","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/create.zig\n\tmodified:   src/cli/mod.zig\n\tmodified:   src/cli/update.zig\n\tmodified:   src/main.zig\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tsrc/cli/where.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018YSLM3mVNryc5yCy5cNZK4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WvXousVVcmDjvmD3dp1TDF","name":"Bash","input":{"command":"git diff src/cli/args.zig src/cli/create.zig src/cli/mod.zig src/cli/update.zig src/main.zig","description":"Review changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":328,"cache_read_input_tokens":99261,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":328},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"150eaf43-d3ca-4b6f-8771-c6d60350cf71"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WvXousVVcmDjvmD3dp1TDF","type":"tool_result","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex e10a557..ceca200 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -35,6 +35,7 @@ pub const Command = union(enum) {\n     config: ConfigArgs,\n     orphans: OrphansArgs,\n     lint: LintArgs,\n+    where: void,\n \n     // Issue CRUD\n     create: CreateArgs,\n@@ -110,6 +111,10 @@ pub const CreateArgs = struct {\n     issue_type: ?[]const u8 = null,\n     priority: ?[]const u8 = null,\n     assignee: ?[]const u8 = null,\n+    owner: ?[]const u8 = null,\n+    design: ?[]const u8 = null,\n+    acceptance_criteria: ?[]const u8 = null,\n+    external_ref: ?[]const u8 = null,\n     labels: []const []const u8 = &[_][]const u8{},\n     deps: []const []const u8 = &[_][]const u8{},\n     due: ?[]const u8 = null,\n@@ -137,6 +142,10 @@ pub const UpdateArgs = struct {\n     issue_type: ?[]const u8 = null,\n     priority: ?[]const u8 = null,\n     assignee: ?[]const u8 = null,\n+    owner: ?[]const u8 = null,\n+    design: ?[]const u8 = null,\n+    acceptance_criteria: ?[]const u8 = null,\n+    external_ref: ?[]const u8 = null,\n     status: ?[]const u8 = null,\n     /// Expected version for optimistic locking (compare-and-swap).\n     expected_version: ?u64 = null,\n@@ -637,6 +646,9 @@ pub const ArgParser = struct {\n         if (std.mem.eql(u8, cmd, \"lint\")) {\n             return .{ .lint = try self.parseLintArgs() };\n         }\n+        if (std.mem.eql(u8, cmd, \"where\")) {\n+            return .{ .where = {} };\n+        }\n \n         // Issue CRUD\n         if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n@@ -795,6 +807,14 @@ pub const ArgParser = struct {\n                 result.priority = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                 result.assignee = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n+                result.owner = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--design\")) {\n+                result.design = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n+                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--external-ref\")) {\n+                result.external_ref = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                 labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n             } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n@@ -879,6 +899,14 @@ pub const ArgParser = struct {\n                 result.priority = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                 result.assignee = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n+                result.owner = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--design\")) {\n+                result.design = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n+                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--external-ref\")) {\n+                result.external_ref = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                 result.status = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-v\", \"--version\")) {\ndiff --git a/src/cli/create.zig b/src/cli/create.zig\nindex e7a7dd3..f1dab6e 100644\n--- a/src/cli/create.zig\n+++ b/src/cli/create.zig\n@@ -119,6 +119,10 @@ pub fn run(\n     issue.priority = priority;\n     issue.issue_type = issue_type;\n     issue.assignee = create_args.assignee;\n+    issue.owner = create_args.owner;\n+    issue.design = create_args.design;\n+    issue.acceptance_criteria = create_args.acceptance_criteria;\n+    issue.external_ref = create_args.external_ref;\n     issue.created_by = actor;\n     issue.due_at = .{ .value = due_at };\n     issue.estimated_minutes = create_args.estimate;\ndiff --git a/src/cli/mod.zig b/src/cli/mod.zig\nindex 5912341..9332a71 100644\n--- a/src/cli/mod.zig\n+++ b/src/cli/mod.zig\n@@ -44,6 +44,7 @@ pub const metrics_cmd = @import(\"metrics.zig\");\n pub const help = @import(\"help.zig\");\n pub const query = @import(\"query.zig\");\n pub const upgrade = @import(\"upgrade.zig\");\n+pub const where = @import(\"where.zig\");\n \n pub const ArgParser = args.ArgParser;\n pub const ParseResult = args.ParseResult;\n@@ -209,6 +210,10 @@ pub const UpgradeResult = upgrade.UpgradeResult;\n pub const runUpgrade = upgrade.run;\n pub const UpgradeArgs = args.UpgradeArgs;\n \n+pub const WhereError = where.WhereError;\n+pub const WhereResult = where.WhereResult;\n+pub const runWhere = where.run;\n+\n test {\n     std.testing.refAllDecls(@This());\n }\ndiff --git a/src/cli/update.zig b/src/cli/update.zig\nindex ccf420c..5913084 100644\n--- a/src/cli/update.zig\n+++ b/src/cli/update.zig\n@@ -77,6 +77,22 @@ pub fn run(\n         updates.assignee = a;\n     }\n \n+    if (update_args.owner) |o| {\n+        updates.owner = o;\n+    }\n+\n+    if (update_args.design) |d| {\n+        updates.design = d;\n+    }\n+\n+    if (update_args.acceptance_criteria) |ac| {\n+        updates.acceptance_criteria = ac;\n+    }\n+\n+    if (update_args.external_ref) |er| {\n+        updates.external_ref = er;\n+    }\n+\n     // Optimistic locking: pass expected version for compare-and-swap\n     if (update_args.expected_version) |v| {\n         updates.expected_version = v;\ndiff --git a/src/main.zig b/src/main.zig\nindex bb1efbd..179388d 100644\n--- a/src/main.zig\n+++ b/src/main.zig\n@@ -274,6 +274,11 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n                 else => return err,\n             };\n         },\n+        .where => {\n+            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n+                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n+            };\n+        },\n     }\n }","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"0a62baa7-7778-4f71-acb1-c174fb3fec00","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex e10a557..ceca200 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -35,6 +35,7 @@ pub const Command = union(enum) {\n     config: ConfigArgs,\n     orphans: OrphansArgs,\n     lint: LintArgs,\n+    where: void,\n \n     // Issue CRUD\n     create: CreateArgs,\n@@ -110,6 +111,10 @@ pub const CreateArgs = struct {\n     issue_type: ?[]const u8 = null,\n     priority: ?[]const u8 = null,\n     assignee: ?[]const u8 = null,\n+    owner: ?[]const u8 = null,\n+    design: ?[]const u8 = null,\n+    acceptance_criteria: ?[]const u8 = null,\n+    external_ref: ?[]const u8 = null,\n     labels: []const []const u8 = &[_][]const u8{},\n     deps: []const []const u8 = &[_][]const u8{},\n     due: ?[]const u8 = null,\n@@ -137,6 +142,10 @@ pub const UpdateArgs = struct {\n     issue_type: ?[]const u8 = null,\n     priority: ?[]const u8 = null,\n     assignee: ?[]const u8 = null,\n+    owner: ?[]const u8 = null,\n+    design: ?[]const u8 = null,\n+    acceptance_criteria: ?[]const u8 = null,\n+    external_ref: ?[]const u8 = null,\n     status: ?[]const u8 = null,\n     /// Expected version for optimistic locking (compare-and-swap).\n     expected_version: ?u64 = null,\n@@ -637,6 +646,9 @@ pub const ArgParser = struct {\n         if (std.mem.eql(u8, cmd, \"lint\")) {\n             return .{ .lint = try self.parseLintArgs() };\n         }\n+        if (std.mem.eql(u8, cmd, \"where\")) {\n+            return .{ .where = {} };\n+        }\n \n         // Issue CRUD\n         if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n@@ -795,6 +807,14 @@ pub const ArgParser = struct {\n                 result.priority = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                 result.assignee = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n+                result.owner = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--design\")) {\n+                result.design = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n+                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--external-ref\")) {\n+                result.external_ref = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                 labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n             } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n@@ -879,6 +899,14 @@ pub const ArgParser = struct {\n                 result.priority = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                 result.assignee = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n+                result.owner = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--design\")) {\n+                result.design = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n+                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--external-ref\")) {\n+                result.external_ref = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                 result.status = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(\"-v\", \"--version\")) {\ndiff --git a/src/cli/create.zig b/src/cli/create.zig\nindex e7a7dd3..f1dab6e 100644\n--- a/src/cli/create.zig\n+++ b/src/cli/create.zig\n@@ -119,6 +119,10 @@ pub fn run(\n     issue.priority = priority;\n     issue.issue_type = issue_type;\n     issue.assignee = create_args.assignee;\n+    issue.owner = create_args.owner;\n+    issue.design = create_args.design;\n+    issue.acceptance_criteria = create_args.acceptance_criteria;\n+    issue.external_ref = create_args.external_ref;\n     issue.created_by = actor;\n     issue.due_at = .{ .value = due_at };\n     issue.estimated_minutes = create_args.estimate;\ndiff --git a/src/cli/mod.zig b/src/cli/mod.zig\nindex 5912341..9332a71 100644\n--- a/src/cli/mod.zig\n+++ b/src/cli/mod.zig\n@@ -44,6 +44,7 @@ pub const metrics_cmd = @import(\"metrics.zig\");\n pub const help = @import(\"help.zig\");\n pub const query = @import(\"query.zig\");\n pub const upgrade = @import(\"upgrade.zig\");\n+pub const where = @import(\"where.zig\");\n \n pub const ArgParser = args.ArgParser;\n pub const ParseResult = args.ParseResult;\n@@ -209,6 +210,10 @@ pub const UpgradeResult = upgrade.UpgradeResult;\n pub const runUpgrade = upgrade.run;\n pub const UpgradeArgs = args.UpgradeArgs;\n \n+pub const WhereError = where.WhereError;\n+pub const WhereResult = where.WhereResult;\n+pub const runWhere = where.run;\n+\n test {\n     std.testing.refAllDecls(@This());\n }\ndiff --git a/src/cli/update.zig b/src/cli/update.zig\nindex ccf420c..5913084 100644\n--- a/src/cli/update.zig\n+++ b/src/cli/update.zig\n@@ -77,6 +77,22 @@ pub fn run(\n         updates.assignee = a;\n     }\n \n+    if (update_args.owner) |o| {\n+        updates.owner = o;\n+    }\n+\n+    if (update_args.design) |d| {\n+        updates.design = d;\n+    }\n+\n+    if (update_args.acceptance_criteria) |ac| {\n+        updates.acceptance_criteria = ac;\n+    }\n+\n+    if (update_args.external_ref) |er| {\n+        updates.external_ref = er;\n+    }\n+\n     // Optimistic locking: pass expected version for compare-and-swap\n     if (update_args.expected_version) |v| {\n         updates.expected_version = v;\ndiff --git a/src/main.zig b/src/main.zig\nindex bb1efbd..179388d 100644\n--- a/src/main.zig\n+++ b/src/main.zig\n@@ -274,6 +274,11 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n                 else => return err,\n             };\n         },\n+        .where => {\n+            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n+                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n+            };\n+        },\n     }\n }","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01H7EwnxUqmG1q1MeFyyHfPZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ns18RrSWba5FHFfCCe5qyR","name":"Bash","input":{"command":"git add src/cli/args.zig src/cli/create.zig src/cli/mod.zig src/cli/update.zig src/main.zig src/cli/where.zig && git commit -m \"$(cat <<'EOF'\nfeat(cli): add where command and issue field CLI flags\n\nTask 1 (bd-1ec): Add 'where' command to show active .beads directory\n- Returns absolute path of the resolved .beads directory\n- Supports --json output\n- Shows error when workspace not initialized\n\nTask 2 (bd-2oo): Add CLI flags for issue fields\n- --owner (-o): Who's responsible (vs assignee who's working)\n- --design: Dedicated field for design notes\n- --acceptance-criteria: Acceptance criteria checklist\n- --external-ref: Link to external systems (GitHub, Jira)\n\nAll flags work with both 'create' and 'update' commands.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2387,"cache_read_input_tokens":99589,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2387},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f5870a45-63a5-46e7-83ee-b6ce64be170a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ns18RrSWba5FHFfCCe5qyR","type":"tool_result","content":"[dev-hotschmoe a727e8b] feat(cli): add where command and issue field CLI flags\n 6 files changed, 168 insertions(+)\n create mode 100644 src/cli/where.zig","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"f34bd8f3-81b6-4ac6-9e29-f7e6e3e378c6","tool_use_result":{"stdout":"[dev-hotschmoe a727e8b] feat(cli): add where command and issue field CLI flags\n 6 files changed, 168 insertions(+)\n create mode 100644 src/cli/where.zig","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVNXVWuaNCuFfryidNhFZr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GzGxgFzrhKnn7HfLM87u59","name":"Bash","input":{"command":"git status","description":"Verify git status after commit"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":385,"cache_read_input_tokens":101976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":385},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"9a8b41c0-2325-4078-82d9-463fe9253cf8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GzGxgFzrhKnn7HfLM87u59","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 3 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"4c55dab9-0a3a-40a9-980b-fe37ab35cc15","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 3 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HmRhsqYfBKC5cBfYxb3dGU","type":"message","role":"assistant","content":[{"type":"text","text":"Both tasks have been completed successfully.\n\n## Summary\n\n### Task 1: Add `where` command - SUCCESS\n- Created `/home/hotschmoe/beads_zig/src/cli/where.zig` implementing the `bz where` command\n- Shows the absolute path to the active `.beads` directory\n- Supports `--json` output format\n- Returns error when workspace is not initialized\n- Example: `bz where` outputs `/home/hotschmoe/beads_zig/sandbox/.beads`\n\n### Task 2: Add missing issue fields CLI flags - SUCCESS\n- Added four new optional string fields to `CreateArgs` and `UpdateArgs` structs\n- Added argument parsing for the new flags\n- Updated `create.zig` and `update.zig` commands to use these fields\n\n| Field | CLI Flag | Purpose |\n|-------|----------|---------|\n| `owner` | `--owner` / `-o` | Who's responsible (vs assignee who's working) |\n| `design` | `--design` | Dedicated field for design notes |\n| `acceptance_criteria` | `--acceptance-criteria` | Acceptance criteria checklist |\n| `external_ref` | `--external-ref` | Link to external systems (GitHub, Jira) |\n\nExample usage:\n```bash\nbz create \"Task\" --owner alice@example.com --assignee bob\nbz create \"Feature\" --design \"Use adapter pattern...\"\nbz create \"Feature\" --acceptance-criteria \"- [ ] Unit tests pass\"\nbz create \"Bug\" --external-ref \"https://github.com/org/repo/issues/123\"\nbz update bd-xxx --owner newowner@example.com\n```\n\nAll 661 tests pass. Changes committed with a descriptive commit message."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":223,"cache_read_input_tokens":102361,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":223},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","uuid":"e66efea6-22c3-45a0-87f6-3d29bc48283f"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":311992,"duration_api_ms":324977,"num_turns":56,"result":"Both tasks have been completed successfully.\n\n## Summary\n\n### Task 1: Add `where` command - SUCCESS\n- Created `/home/hotschmoe/beads_zig/src/cli/where.zig` implementing the `bz where` command\n- Shows the absolute path to the active `.beads` directory\n- Supports `--json` output format\n- Returns error when workspace is not initialized\n- Example: `bz where` outputs `/home/hotschmoe/beads_zig/sandbox/.beads`\n\n### Task 2: Add missing issue fields CLI flags - SUCCESS\n- Added four new optional string fields to `CreateArgs` and `UpdateArgs` structs\n- Added argument parsing for the new flags\n- Updated `create.zig` and `update.zig` commands to use these fields\n\n| Field | CLI Flag | Purpose |\n|-------|----------|---------|\n| `owner` | `--owner` / `-o` | Who's responsible (vs assignee who's working) |\n| `design` | `--design` | Dedicated field for design notes |\n| `acceptance_criteria` | `--acceptance-criteria` | Acceptance criteria checklist |\n| `external_ref` | `--external-ref` | Link to external systems (GitHub, Jira) |\n\nExample usage:\n```bash\nbz create \"Task\" --owner alice@example.com --assignee bob\nbz create \"Feature\" --design \"Use adapter pattern...\"\nbz create \"Feature\" --acceptance-criteria \"- [ ] Unit tests pass\"\nbz create \"Bug\" --external-ref \"https://github.com/org/repo/issues/123\"\nbz update bd-xxx --owner newowner@example.com\n```\n\nAll 661 tests pass. Changes committed with a descriptive commit message.","session_id":"0c748432-f2b9-475e-a0fb-32e939b9bd99","total_cost_usd":2.99481,"usage":{"input_tokens":2,"cache_creation_input_tokens":84608,"cache_read_input_tokens":4193342,"output_tokens":13620,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":84608,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":13620,"cacheReadInputTokens":4193342,"cacheCreationInputTokens":84608,"webSearchRequests":0,"costUSD":2.9659810000000006,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":24854,"outputTokens":795,"cacheReadInputTokens":0,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.028829000000000007,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"e1db4989-c081-42f9-bbde-1714a77179a7"}
