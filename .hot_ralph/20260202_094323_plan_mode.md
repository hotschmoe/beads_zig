{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"c2d7c5e2-ad27-4fef-bf65-08b7ab1d87b0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011w7wFQqDJibSwwuNEtrhrK","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement these two tasks in order. Let me start by exploring the codebase structure to understand how commands are implemented."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21093,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21093},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"913bf341-9c1c-496f-8e5f-301244dd1ca3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011w7wFQqDJibSwwuNEtrhrK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","name":"Task","input":{"prompt":"Explore the beads_zig codebase to understand:\n1. How CLI commands are structured (look at src/cli/ directory)\n2. How existing commands like `stats` are implemented\n3. What models exist for events/audit logging\n4. How the storage layer works\n\nFocus on finding:\n- src/cli/args.zig - command argument parsing\n- src/cli/stats.zig or similar - existing stats command\n- src/models/ - data models\n- src/storage/ - storage layer\n\nBe thorough - I need to understand the patterns used before implementing new commands.","subagent_type":"Explore","description":"Explore CLI command structure"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21093,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":21093},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e2e641a7-b7d6-49eb-88e5-588aad4a2776"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Explore the beads_zig codebase to understand:\n1. How CLI commands are structured (look at src/cli/ directory)\n2. How existing commands like `stats` are implemented\n3. What models exist for events/audit logging\n4. How the storage layer works\n\nFocus on finding:\n- src/cli/args.zig - command argument parsing\n- src/cli/stats.zig or similar - existing stats command\n- src/models/ - data models\n- src/storage/ - storage layer\n\nBe thorough - I need to understand the patterns used before implementing new commands."}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8436d29b-fcba-4048-ae97-348a9adc3779"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01We8grDaJ2GwtiDPy3TbJTX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WSnz3aortiFqjcJvjFZzPh","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig -type f -name \"*.zig\" | head -20","description":"Get initial overview of Zig files in the project"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3947,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3947},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c3a080fa-3615-43f2-bfdd-aa6199431c56"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WSnz3aortiFqjcJvjFZzPh","type":"tool_result","content":"/home/hotschmoe/beads_zig/bench/main.zig\n/home/hotschmoe/beads_zig/bench/bz_vs_br.zig\n/home/hotschmoe/beads_zig/bench/bz_only.zig\n/home/hotschmoe/beads_zig/build.zig\n/home/hotschmoe/beads_zig/.zig-cache/o/a294bb9987441c646e119f9e71c91c75/dependencies.zig\n/home/hotschmoe/beads_zig/src/errors.zig\n/home/hotschmoe/beads_zig/src/main.zig\n/home/hotschmoe/beads_zig/src/root.zig\n/home/hotschmoe/beads_zig/src/models/mod.zig\n/home/hotschmoe/beads_zig/src/models/issue.zig\n/home/hotschmoe/beads_zig/src/models/priority.zig\n/home/hotschmoe/beads_zig/src/models/issue_type.zig\n/home/hotschmoe/beads_zig/src/models/dependency.zig\n/home/hotschmoe/beads_zig/src/models/comment.zig\n/home/hotschmoe/beads_zig/src/models/event.zig\n/home/hotschmoe/beads_zig/src/models/status.zig\n/home/hotschmoe/beads_zig/src/models/timestamp.zig\n/home/hotschmoe/beads_zig/src/storage/events.zig\n/home/hotschmoe/beads_zig/src/storage/mmap.zig\n/home/hotschmoe/beads_zig/src/storage/txlog.zig","is_error":false}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"24d82f2c-dab0-4b3f-a765-354fddf722a8"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01We8grDaJ2GwtiDPy3TbJTX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012HksXahaU8S5BaNYTwGF32","name":"Glob","input":{"pattern":"src/cli/*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3947,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3947},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"850fe4b7-e025-4a34-9925-9c23faa25099"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01We8grDaJ2GwtiDPy3TbJTX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015dyUMzU8FPpDpT9a5MbmGU","name":"Glob","input":{"pattern":"src/models/*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3947,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3947},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b19419d0-07b1-46cf-b09c-e5272e002644"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012HksXahaU8S5BaNYTwGF32","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/audit.zig\n/home/hotschmoe/beads_zig/src/cli/comments.zig\n/home/hotschmoe/beads_zig/src/cli/batch.zig\n/home/hotschmoe/beads_zig/src/cli/metrics.zig\n/home/hotschmoe/beads_zig/src/cli/doctor.zig\n/home/hotschmoe/beads_zig/src/cli/config.zig\n/home/hotschmoe/beads_zig/src/cli/lint.zig\n/home/hotschmoe/beads_zig/src/cli/changelog.zig\n/home/hotschmoe/beads_zig/src/cli/history.zig\n/home/hotschmoe/beads_zig/src/cli/init.zig\n/home/hotschmoe/beads_zig/src/cli/defer.zig\n/home/hotschmoe/beads_zig/src/cli/completions.zig\n/home/hotschmoe/beads_zig/src/cli/info.zig\n/home/hotschmoe/beads_zig/src/cli/graph.zig\n/home/hotschmoe/beads_zig/src/cli/version.zig\n/home/hotschmoe/beads_zig/src/cli/schema.zig\n/home/hotschmoe/beads_zig/src/cli/stats.zig\n/home/hotschmoe/beads_zig/src/cli/show.zig\n/home/hotschmoe/beads_zig/src/cli/orphans.zig\n/home/hotschmoe/beads_zig/src/cli/search.zig\n/home/hotschmoe/beads_zig/src/cli/stale.zig\n/home/hotschmoe/beads_zig/src/cli/upgrade.zig\n/home/hotschmoe/beads_zig/src/cli/where.zig\n/home/hotschmoe/beads_zig/src/cli/query.zig\n/home/hotschmoe/beads_zig/src/cli/update.zig\n/home/hotschmoe/beads_zig/src/cli/create.zig\n/home/hotschmoe/beads_zig/src/cli/count.zig\n/home/hotschmoe/beads_zig/src/cli/list.zig\n/home/hotschmoe/beads_zig/src/cli/ready.zig\n/home/hotschmoe/beads_zig/src/cli/common.zig\n/home/hotschmoe/beads_zig/src/cli/close.zig\n/home/hotschmoe/beads_zig/src/cli/delete.zig\n/home/hotschmoe/beads_zig/src/cli/dep.zig\n/home/hotschmoe/beads_zig/src/cli/label.zig\n/home/hotschmoe/beads_zig/src/cli/epic.zig\n/home/hotschmoe/beads_zig/src/cli/sync.zig\n/home/hotschmoe/beads_zig/src/cli/args.zig\n/home/hotschmoe/beads_zig/src/cli/help.zig\n/home/hotschmoe/beads_zig/src/cli/mod.zig\n/home/hotschmoe/beads_zig/src/cli/backup.zig"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d4ce14e4-dc4c-4bca-ae43-544537201a6d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01We8grDaJ2GwtiDPy3TbJTX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011e2gxwcffekM9SsvAcQ7B2","name":"Glob","input":{"pattern":"src/storage/*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3947,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3947},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3ffcb9d6-f415-4938-83bf-7cee3b0c36f7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015dyUMzU8FPpDpT9a5MbmGU","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/models/mod.zig\n/home/hotschmoe/beads_zig/src/models/priority.zig\n/home/hotschmoe/beads_zig/src/models/issue_type.zig\n/home/hotschmoe/beads_zig/src/models/dependency.zig\n/home/hotschmoe/beads_zig/src/models/comment.zig\n/home/hotschmoe/beads_zig/src/models/event.zig\n/home/hotschmoe/beads_zig/src/models/status.zig\n/home/hotschmoe/beads_zig/src/models/timestamp.zig\n/home/hotschmoe/beads_zig/src/models/issue.zig"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3bafc02b-67ed-4bff-9832-c869f266347c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011e2gxwcffekM9SsvAcQ7B2","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/storage/events.zig\n/home/hotschmoe/beads_zig/src/storage/mmap.zig\n/home/hotschmoe/beads_zig/src/storage/txlog.zig\n/home/hotschmoe/beads_zig/src/storage/simd.zig\n/home/hotschmoe/beads_zig/src/storage/mod.zig\n/home/hotschmoe/beads_zig/src/storage/issues.zig\n/home/hotschmoe/beads_zig/src/storage/metrics.zig\n/home/hotschmoe/beads_zig/src/storage/generation.zig\n/home/hotschmoe/beads_zig/src/storage/lock.zig\n/home/hotschmoe/beads_zig/src/storage/wal.zig\n/home/hotschmoe/beads_zig/src/storage/compact.zig\n/home/hotschmoe/beads_zig/src/storage/fscheck.zig\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig\n/home/hotschmoe/beads_zig/src/storage/dependencies.zig\n/home/hotschmoe/beads_zig/src/storage/graph.zig\n/home/hotschmoe/beads_zig/src/storage/store.zig"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e6ec119f-d330-4cbf-9edf-50917a1a10b8"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ged7GAdWBCQQAKcF1yqofe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qkmsw4XFftV1aaG7obUDqS","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2459,"cache_read_input_tokens":13163,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2459},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"62b1fe49-3871-4484-84e1-bcb966ccef2d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ged7GAdWBCQQAKcF1yqofe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MjJzxMjdgWJH4bdq8mUzKF","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/common.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2459,"cache_read_input_tokens":13163,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2459},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"04f5e6e6-6933-4985-aae8-98b5ef828260"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (31791 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01Qkmsw4XFftV1aaG7obUDqS"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2c635d6e-d2e1-4bec-8b56-eccabc3cc26d","tool_use_result":"Error: File content (31791 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MjJzxMjdgWJH4bdq8mUzKF","type":"tool_result","content":"     1→//! Common CLI utilities shared across commands.\n     2→//!\n     3→//! Provides workspace loading, error handling, and shared result types\n     4→//! to reduce duplication across command implementations.\n     5→\n     6→const std = @import(\"std\");\n     7→const storage = @import(\"../storage/mod.zig\");\n     8→const output_mod = @import(\"../output/mod.zig\");\n     9→const args = @import(\"args.zig\");\n    10→\n    11→pub const Output = output_mod.Output;\n    12→pub const OutputOptions = output_mod.OutputOptions;\n    13→pub const IssueStore = storage.IssueStore;\n    14→pub const IssueStoreError = storage.IssueStoreError;\n    15→pub const DependencyGraph = storage.DependencyGraph;\n    16→pub const EventStore = storage.EventStore;\n    17→pub const StoreLoadResult = storage.StoreLoadResult;\n    18→\n    19→/// Common errors shared across CLI commands.\n    20→pub const CommandError = error{\n    21→    WorkspaceNotInitialized,\n    22→    StorageError,\n    23→    OutOfMemory,\n    24→};\n    25→\n    26→/// Context for executing a CLI command with an initialized workspace.\n    27→pub const CommandContext = struct {\n    28→    allocator: std.mem.Allocator,\n    29→    output: Output,\n    30→    store: IssueStore,\n    31→    event_store: EventStore,\n    32→    beads_dir: []const u8,\n    33→    issues_path: []const u8,\n    34→    events_path: []const u8,\n    35→    global: args.GlobalOptions,\n    36→    /// Number of corrupt entries skipped during load.\n    37→    corruption_count: usize = 0,\n    38→    /// Line numbers of corrupt JSONL entries (owned memory).\n    39→    corrupt_lines: []const usize = &.{},\n    40→    /// Number of WAL entries replayed during load.\n    41→    wal_entries_replayed: usize = 0,\n    42→\n    43→    /// Initialize a command context by loading the workspace.\n    44→    /// Returns null and outputs an error if workspace is not initialized.\n    45→    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    46→    /// Replays WAL entries after loading main file for consistency.\n    47→    pub fn init(\n    48→        allocator: std.mem.Allocator,\n    49→        global: args.GlobalOptions,\n    50→    ) CommandError!?CommandContext {\n    51→        var output = Output.init(allocator, .{\n    52→            .json = global.json,\n    53→            .toon = global.toon,\n    54→            .robot = global.robot,\n    55→            .quiet = global.quiet,\n    56→            .silent = global.silent,\n    57→            .no_color = global.no_color,\n    58→            .wrap = global.wrap,\n    59→            .stats = global.stats,\n    60→        });\n    61→\n    62→        const beads_dir_str = global.data_path orelse \".beads\";\n    63→        const beads_dir = allocator.dupe(u8, beads_dir_str) catch {\n    64→            return CommandError.OutOfMemory;\n    65→        };\n    66→        const issues_path = std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" }) catch {\n    67→            allocator.free(beads_dir);\n    68→            return CommandError.OutOfMemory;\n    69→        };\n    70→        const events_path = std.fs.path.join(allocator, &.{ beads_dir, \"events.jsonl\" }) catch {\n    71→            allocator.free(issues_path);\n    72→            allocator.free(beads_dir);\n    73→            return CommandError.OutOfMemory;\n    74→        };\n    75→\n    76→        std.fs.cwd().access(issues_path, .{}) catch |err| {\n    77→            if (err == error.FileNotFound) {\n    78→                outputErrorGeneric(&output, global.isStructuredOutput(), \"workspace not initialized. Run 'bz init' first.\") catch {};\n    79→                allocator.free(issues_path);\n    80→                allocator.free(events_path);\n    81→                allocator.free(beads_dir);\n    82→                return null;\n    83→            }\n    84→            outputErrorGeneric(&output, global.isStructuredOutput(), \"cannot access workspace\") catch {};\n    85→            allocator.free(issues_path);\n    86→            allocator.free(events_path);\n    87→            allocator.free(beads_dir);\n    88→            return CommandError.StorageError;\n    89→        };\n    90→\n    91→        var store = IssueStore.init(allocator, issues_path);\n    92→        var corruption_count: usize = 0;\n    93→        var corrupt_lines: []const usize = &.{};\n    94→\n    95→        // Use recovery mode: log and skip corrupt entries instead of failing\n    96→        const load_result = store.loadFromFileWithRecovery() catch |err| {\n    97→            if (err != error.FileNotFound) {\n    98→                outputErrorGeneric(&output, global.isStructuredOutput(), \"failed to load issues\") catch {};\n    99→                store.deinit();\n   100→                allocator.free(issues_path);\n   101→                allocator.free(events_path);\n   102→                allocator.free(beads_dir);\n   103→                return CommandError.StorageError;\n   104→            }\n   105→            // File not found is OK - empty workspace\n   106→            var event_store_empty = EventStore.init(allocator, events_path);\n   107→            event_store_empty.loadNextId() catch {};\n   108→            return CommandContext{\n   109→                .allocator = allocator,\n   110→                .output = output,\n   111→                .store = store,\n   112→                .event_store = event_store_empty,\n   113→                .beads_dir = beads_dir,\n   114→                .issues_path = issues_path,\n   115→                .events_path = events_path,\n   116→                .global = global,\n   117→                .corruption_count = 0,\n   118→                .corrupt_lines = &.{},\n   119→                .wal_entries_replayed = 0,\n   120→            };\n   121→        };\n   122→\n   123→        corruption_count = load_result.jsonl_corruption_count;\n   124→        corrupt_lines = load_result.jsonl_corrupt_lines;\n   125→\n   126→        // Replay WAL entries onto the store for consistency\n   127→        var wal_entries_replayed: usize = 0;\n   128→        wal_replay: {\n   129→            var wal_obj = storage.Wal.init(beads_dir, allocator) catch {\n   130→                break :wal_replay;\n   131→            };\n   132→            defer wal_obj.deinit();\n   133→\n   134→            var replay_stats = wal_obj.replay(&store) catch {\n   135→                break :wal_replay;\n   136→            };\n   137→            defer replay_stats.deinit(allocator);\n   138→            wal_entries_replayed = replay_stats.applied;\n   139→        }\n   140→\n   141→        // Warn user about corruption (unless quiet/silent mode)\n   142→        if (corruption_count > 0 and !global.quiet and !global.silent and !global.isStructuredOutput()) {\n   143→            output.print(\"warning: {d} corrupt entries skipped during load\\n\", .{corruption_count}) catch {};\n   144→            output.print(\"         Run 'bz doctor' for details, 'bz compact' to rebuild.\\n\", .{}) catch {};\n   145→        }\n   146→\n   147→        // Initialize event store and load next ID\n   148→        var event_store = EventStore.init(allocator, events_path);\n   149→        event_store.loadNextId() catch {}; // OK if events file doesn't exist\n   150→\n   151→        return CommandContext{\n   152→            .allocator = allocator,\n   153→            .output = output,\n   154→            .store = store,\n   155→            .event_store = event_store,\n   156→            .beads_dir = beads_dir,\n   157→            .issues_path = issues_path,\n   158→            .events_path = events_path,\n   159→            .global = global,\n   160→            .corruption_count = corruption_count,\n   161→            .corrupt_lines = corrupt_lines,\n   162→            .wal_entries_replayed = wal_entries_replayed,\n   163→        };\n   164→    }\n   165→\n   166→    /// Clean up resources.\n   167→    pub fn deinit(self: *CommandContext) void {\n   168→        self.store.deinit();\n   169→        self.allocator.free(self.beads_dir);\n   170→        self.allocator.free(self.issues_path);\n   171→        self.allocator.free(self.events_path);\n   172→        if (self.corrupt_lines.len > 0) {\n   173→            self.allocator.free(self.corrupt_lines);\n   174→        }\n   175→    }\n   176→\n   177→    /// Check if corruption was detected during load.\n   178→    pub fn hasCorruption(self: *const CommandContext) bool {\n   179→        return self.corruption_count > 0;\n   180→    }\n   181→\n   182→    /// Save the store to file if auto-flush is enabled.\n   183→    /// Note: For single-issue writes, prefer appendToWal() for better performance.\n   184→    pub fn saveIfAutoFlush(self: *CommandContext) CommandError!void {\n   185→        if (!self.global.no_auto_flush) {\n   186→            self.store.saveToFile() catch {\n   187→                outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to save issues\") catch {};\n   188→                return CommandError.StorageError;\n   189→            };\n   190→        }\n   191→    }\n   192→\n   193→    /// Append an issue to the WAL for fast persistence.\n   194→    /// Use this for single-issue creates/updates instead of saveToFile().\n   195→    pub fn appendToWal(self: *CommandContext, issue: @import(\"../models/issue.zig\").Issue, op: storage.WalOp) CommandError!void {\n   196→        if (self.global.no_auto_flush) return;\n   197→\n   198→        var wal_obj = storage.Wal.init(self.beads_dir, self.allocator) catch {\n   199→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to initialize WAL\") catch {};\n   200→            return CommandError.StorageError;\n   201→        };\n   202→        defer wal_obj.deinit();\n   203→\n   204→        wal_obj.appendEntry(.{\n   205→            .op = op,\n   206→            .ts = std.time.timestamp(),\n   207→            .id = issue.id,\n   208→            .data = issue,\n   209→        }) catch {\n   210→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to write to WAL\") catch {};\n   211→            return CommandError.StorageError;\n   212→        };\n   213→    }\n   214→\n   215→    /// Create a dependency graph from the store.\n   216→    pub fn createGraph(self: *CommandContext) DependencyGraph {\n   217→        return DependencyGraph.init(&self.store, self.allocator);\n   218→    }\n   219→\n   220→    /// Record an audit event. Silently ignores errors (audit is best-effort).\n   221→    pub fn recordEvent(self: *CommandContext, event: @import(\"../models/event.zig\").Event) void {\n   222→        _ = self.event_store.append(event) catch {};\n   223→    }\n   224→};\n   225→\n   226→/// Output a generic error message in the appropriate format.\n   227→pub fn outputErrorGeneric(output: *Output, json_mode: bool, message: []const u8) !void {\n   228→    if (json_mode) {\n   229→        try output.printJson(.{\n   230→            .success = false,\n   231→            .message = message,\n   232→        });\n   233→    } else {\n   234→        try output.err(\"{s}\", .{message});\n   235→    }\n   236→}\n   237→\n   238→/// Output an error with a specific result type for JSON mode.\n   239→pub fn outputErrorTyped(\n   240→    comptime T: type,\n   241→    output: *Output,\n   242→    json_mode: bool,\n   243→    message: []const u8,\n   244→) !void {\n   245→    if (json_mode) {\n   246→        const result = T{ .success = false, .message = message };\n   247→        try output.printJson(result);\n   248→    } else {\n   249→        try output.err(\"{s}\", .{message});\n   250→    }\n   251→}\n   252→\n   253→/// Output a \"not found\" error for an issue.\n   254→pub fn outputNotFoundError(\n   255→    comptime T: type,\n   256→    output: *Output,\n   257→    json_mode: bool,\n   258→    id: []const u8,\n   259→    allocator: std.mem.Allocator,\n   260→) !void {\n   261→    const msg = try std.fmt.allocPrint(allocator, \"issue not found: {s}\", .{id});\n   262→    defer allocator.free(msg);\n   263→    try outputErrorTyped(T, output, json_mode, msg);\n   264→}\n   265→\n   266→/// Initialize just the output without loading workspace.\n   267→/// Useful for commands that do their own workspace handling.\n   268→pub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Output {\n   269→    return Output.init(allocator, .{\n   270→        .json = global.json,\n   271→        .toon = global.toon,\n   272→        .robot = global.robot,\n   273→        .quiet = global.quiet,\n   274→        .silent = global.silent,\n   275→        .no_color = global.no_color,\n   276→        .wrap = global.wrap,\n   277→        .stats = global.stats,\n   278→    });\n   279→}\n   280→\n   281→/// Get the default actor name from environment.\n   282→pub fn getDefaultActor() ?[]const u8 {\n   283→    const builtin = @import(\"builtin\");\n   284→    if (builtin.os.tag == .windows) return null;\n   285→    return std.posix.getenv(\"USER\") orelse std.posix.getenv(\"USERNAME\");\n   286→}\n   287→\n   288→/// Read the ID prefix from config.yaml, defaulting to \"bd\".\n   289→pub fn getConfigPrefix(allocator: std.mem.Allocator, beads_dir: []const u8) ![]u8 {\n   290→    const config_path = try std.fs.path.join(allocator, &.{ beads_dir, \"config.yaml\" });\n   291→    defer allocator.free(config_path);\n   292→\n   293→    const file = std.fs.cwd().openFile(config_path, .{}) catch {\n   294→        return try allocator.dupe(u8, \"bd\");\n   295→    };\n   296→    defer file.close();\n   297→\n   298→    const content = file.readToEndAlloc(allocator, 4096) catch {\n   299→        return try allocator.dupe(u8, \"bd\");\n   300→    };\n   301→    defer allocator.free(content);\n   302→\n   303→    if (std.mem.indexOf(u8, content, \"prefix:\")) |prefix_pos| {\n   304→        const after_prefix = content[prefix_pos + 7 ..];\n   305→        var i: usize = 0;\n   306→        while (i < after_prefix.len and (after_prefix[i] == ' ' or after_prefix[i] == '\\t')) {\n   307→            i += 1;\n   308→        }\n   309→\n   310→        if (i < after_prefix.len) {\n   311→            if (after_prefix[i] == '\"') {\n   312→                i += 1;\n   313→                const start = i;\n   314→                while (i < after_prefix.len and after_prefix[i] != '\"' and after_prefix[i] != '\\n') {\n   315→                    i += 1;\n   316→                }\n   317→                if (i > start) {\n   318→                    return try allocator.dupe(u8, after_prefix[start..i]);\n   319→                }\n   320→            } else {\n   321→                const start = i;\n   322→                while (i < after_prefix.len and after_prefix[i] != '\\n' and after_prefix[i] != ' ' and after_prefix[i] != '\\t') {\n   323→                    i += 1;\n   324→                }\n   325→                if (i > start) {\n   326→                    return try allocator.dupe(u8, after_prefix[start..i]);\n   327→                }\n   328→            }\n   329→        }\n   330→    }\n   331→\n   332→    return try allocator.dupe(u8, \"bd\");\n   333→}\n   334→\n   335→// --- Tests ---\n   336→\n   337→test \"CommandContext returns null for uninitialized workspace\" {\n   338→    const allocator = std.testing.allocator;\n   339→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   340→\n   341→    const ctx = try CommandContext.init(allocator, global);\n   342→    try std.testing.expect(ctx == null);\n   343→}\n   344→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"fe16c5bb-b2ff-4d8d-b2de-52b3a1a193b9"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Ged7GAdWBCQQAKcF1yqofe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FZ15APsAYm6VjxvScTV8AA","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/stats.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2459,"cache_read_input_tokens":13163,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2459},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"51699eb1-40b4-45c3-badd-e4d718c60197"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01FZ15APsAYm6VjxvScTV8AA"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"18e5eeb0-5d0f-4fb3-b8fc-1467085d6549","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RxNNcfysLbUGyqzkCGkAhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HzdaKtikCG1TQEsBp6VtrS","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5229,"cache_read_input_tokens":15622,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5229},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7b5954a9-7e78-41f2-a412-d6d851537d60"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HzdaKtikCG1TQEsBp6VtrS","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    robot: bool = false, // Line-oriented machine-readable output for scripting\n    13→    quiet: bool = false,\n    14→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    15→    verbose: u8 = 0,\n    16→    no_color: bool = false,\n    17→    wrap: bool = false, // Wrap long lines in plain text output\n    18→    stats: bool = false, // Show token savings stats for TOON output\n    19→    data_path: ?[]const u8 = null,\n    20→    actor: ?[]const u8 = null,\n    21→    lock_timeout: u32 = 5000,\n    22→    no_auto_flush: bool = false,\n    23→    no_auto_import: bool = false,\n    24→\n    25→    /// Returns true if structured output (JSON or TOON) is enabled.\n    26→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    27→        return self.json or self.toon;\n    28→    }\n    29→\n    30→    /// Returns true if any machine-readable output is enabled.\n    31→    pub fn isMachineOutput(self: GlobalOptions) bool {\n    32→        return self.json or self.toon or self.robot;\n    33→    }\n    34→};\n    35→\n    36→/// All available subcommands.\n    37→pub const Command = union(enum) {\n    38→    // Workspace\n    39→    init: InitArgs,\n    40→    info: void,\n    41→    stats: void,\n    42→    doctor: void,\n    43→    config: ConfigArgs,\n    44→    orphans: OrphansArgs,\n    45→    lint: LintArgs,\n    46→    where: void,\n    47→\n    48→    // Issue CRUD\n    49→    create: CreateArgs,\n    50→    q: QuickArgs,\n    51→    show: ShowArgs,\n    52→    update: UpdateArgs,\n    53→    close: CloseArgs,\n    54→    reopen: ReopenArgs,\n    55→    delete: DeleteArgs,\n    56→\n    57→    // Batch Operations\n    58→    add_batch: AddBatchArgs,\n    59→    import_cmd: ImportArgs,\n    60→\n    61→    // Query\n    62→    list: ListArgs,\n    63→    ready: ReadyArgs,\n    64→    blocked: BlockedArgs,\n    65→    search: SearchArgs,\n    66→    stale: StaleArgs,\n    67→    count: CountArgs,\n    68→    defer_cmd: DeferArgs,\n    69→    undefer: UndeferArgs,\n    70→\n    71→    // Dependencies\n    72→    dep: DepArgs,\n    73→    graph: GraphArgs,\n    74→\n    75→    // Epics\n    76→    epic: EpicArgs,\n    77→\n    78→    // Labels\n    79→    label: LabelArgs,\n    80→\n    81→    // Comments\n    82→    comments: CommentsArgs,\n    83→\n    84→    // Audit\n    85→    history: HistoryArgs,\n    86→    audit: AuditArgs,\n    87→\n    88→    // Changelog\n    89→    changelog: ChangelogArgs,\n    90→\n    91→    // Sync\n    92→    sync: SyncArgs,\n    93→\n    94→    // Backup\n    95→    backup: BackupArgs,\n    96→\n    97→    // System\n    98→    version: void,\n    99→    schema: void,\n   100→    completions: CompletionsArgs,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"099e8db9-8916-49fe-848f-7559ff9f664a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RxNNcfysLbUGyqzkCGkAhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015PcBhth2DwipUH66y71nGd","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/stats.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5229,"cache_read_input_tokens":15622,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5229},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7d779cec-5c78-46d9-ba36-7dd1830bc277"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015PcBhth2DwipUH66y71nGd","type":"tool_result","content":"     1→//! Stats command for beads_zig.\n     2→//!\n     3→//! `bz stats` - Show project statistics\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const StatsError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const StatsResult = struct {\n    18→    success: bool,\n    19→    total: ?usize = null,\n    20→    open: ?usize = null,\n    21→    closed: ?usize = null,\n    22→    by_status: ?[]const CountEntry = null,\n    23→    by_priority: ?[]const CountEntry = null,\n    24→    by_type: ?[]const CountEntry = null,\n    25→    message: ?[]const u8 = null,\n    26→\n    27→    pub const CountEntry = struct {\n    28→        key: []const u8,\n    29→        count: usize,\n    30→    };\n    31→};\n    32→\n    33→pub fn run(\n    34→    global: args.GlobalOptions,\n    35→    allocator: std.mem.Allocator,\n    36→) !void {\n    37→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    38→        return StatsError.WorkspaceNotInitialized;\n    39→    };\n    40→    defer ctx.deinit();\n    41→\n    42→    // Count totals\n    43→    var total: usize = 0;\n    44→    var open: usize = 0;\n    45→    var closed: usize = 0;\n    46→\n    47→    // Count by status\n    48→    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    49→    defer status_counts.deinit(allocator);\n    50→\n    51→    // Count by priority\n    52→    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n    53→\n    54→    // Count by type\n    55→    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    56→    defer type_counts.deinit(allocator);\n    57→\n    58→    for (ctx.store.issues.items) |issue| {\n    59→        if (issue.status.eql(.tombstone)) continue;\n    60→\n    61→        total += 1;\n    62→\n    63→        // Status\n    64→        const status_str = issue.status.toString();\n    65→        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n    66→        status_entry.value_ptr.* += 1;\n    67→\n    68→        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n    69→            open += 1;\n    70→        } else if (issue.status.eql(.closed)) {\n    71→            closed += 1;\n    72→        }\n    73→\n    74→        // Priority\n    75→        if (issue.priority.value <= 4) {\n    76→            priority_counts[issue.priority.value] += 1;\n    77→        }\n    78→\n    79→        // Type\n    80→        const type_str = issue.issue_type.toString();\n    81→        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n    82→        type_entry.value_ptr.* += 1;\n    83→    }\n    84→\n    85→    // Convert to arrays for output\n    86→    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    87→    defer status_list.deinit(allocator);\n    88→\n    89→    var status_it = status_counts.iterator();\n    90→    while (status_it.next()) |entry| {\n    91→        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    92→    }\n    93→\n    94→    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    95→    defer priority_list.deinit(allocator);\n    96→\n    97→    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    98→    for (0..5) |i| {\n    99→        if (priority_counts[i] > 0) {\n   100→            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n   101→        }\n   102→    }\n   103→\n   104→    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n   105→    defer type_list.deinit(allocator);\n   106→\n   107→    var type_it = type_counts.iterator();\n   108→    while (type_it.next()) |entry| {\n   109→        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n   110→    }\n   111→\n   112→    if (global.isStructuredOutput()) {\n   113→        try ctx.output.printJson(StatsResult{\n   114→            .success = true,\n   115→            .total = total,\n   116→            .open = open,\n   117→            .closed = closed,\n   118→            .by_status = status_list.items,\n   119→            .by_priority = priority_list.items,\n   120→            .by_type = type_list.items,\n   121→        });\n   122→    } else if (!global.quiet) {\n   123→        try ctx.output.println(\"Issue Statistics\", .{});\n   124→        try ctx.output.print(\"\\n\", .{});\n   125→        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n   126→        try ctx.output.print(\"\\n\", .{});\n   127→\n   128→        if (status_list.items.len > 0) {\n   129→            try ctx.output.print(\"By Status:\\n\", .{});\n   130→            for (status_list.items) |entry| {\n   131→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   132→            }\n   133→        }\n   134→\n   135→        if (priority_list.items.len > 0) {\n   136→            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n   137→            for (priority_list.items) |entry| {\n   138→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   139→            }\n   140→        }\n   141→\n   142→        if (type_list.items.len > 0) {\n   143→            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n   144→            for (type_list.items) |entry| {\n   145→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   146→            }\n   147→        }\n   148→    }\n   149→}\n   150→\n   151→// --- Tests ---\n   152→\n   153→test \"StatsError enum exists\" {\n   154→    const err: StatsError = StatsError.WorkspaceNotInitialized;\n   155→    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n   156→}\n   157→\n   158→test \"StatsResult struct works\" {\n   159→    const result = StatsResult{\n   160→        .success = true,\n   161→        .total = 10,\n   162→        .open = 5,\n   163→        .closed = 5,\n   164→    };\n   165→    try std.testing.expect(result.success);\n   166→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   167→}\n   168→\n   169→test \"run detects uninitialized workspace\" {\n   170→    const allocator = std.testing.allocator;\n   171→\n   172→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   173→\n   174→    const result = run(global, allocator);\n   175→    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n   176→}\n   177→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5e2a6b1f-08c8-4cc6-99c5-ee56908a95d6"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RxNNcfysLbUGyqzkCGkAhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WiJ1UAQoXezemcqNKMbwV3","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/event.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5229,"cache_read_input_tokens":15622,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5229},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1366a5f7-7a3e-423a-ba3f-55b183183e6b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WiJ1UAQoXezemcqNKMbwV3","type":"tool_result","content":"     1→//! Event struct and EventType enum for the audit log system.\n     2→//!\n     3→//! Events track changes to issues for audit and history purposes.\n     4→//! Each event records who made a change, what changed, and when.\n     5→\n     6→const std = @import(\"std\");\n     7→const Status = @import(\"status.zig\").Status;\n     8→const Priority = @import(\"priority.zig\").Priority;\n     9→\n    10→/// Types of events that can occur on an issue.\n    11→pub const EventType = enum {\n    12→    created,\n    13→    updated,\n    14→    status_changed,\n    15→    priority_changed,\n    16→    assignee_changed,\n    17→    commented,\n    18→    closed,\n    19→    reopened,\n    20→    dependency_added,\n    21→    dependency_removed,\n    22→    label_added,\n    23→    label_removed,\n    24→    compacted,\n    25→    deleted,\n    26→    restored,\n    27→\n    28→    const Self = @This();\n    29→\n    30→    /// Convert EventType to its string representation.\n    31→    pub fn toString(self: Self) []const u8 {\n    32→        return @tagName(self);\n    33→    }\n    34→\n    35→    /// Parse a string into an EventType.\n    36→    /// Returns null for unknown values.\n    37→    pub fn fromString(s: []const u8) ?Self {\n    38→        return std.meta.stringToEnum(Self, s);\n    39→    }\n    40→\n    41→    /// JSON serialization for std.json.\n    42→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    43→        try jws.write(self.toString());\n    44→    }\n    45→\n    46→    /// JSON deserialization for std.json.\n    47→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    48→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    49→        const str = switch (token) {\n    50→            .string, .allocated_string => |s| s,\n    51→            else => return error.UnexpectedToken,\n    52→        };\n    53→        return fromString(str) orelse error.UnexpectedToken;\n    54→    }\n    55→\n    56→    /// JSON deserialization from already-parsed value.\n    57→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    58→        _ = allocator;\n    59→        _ = options;\n    60→        return switch (source) {\n    61→            .string => |s| fromString(s) orelse error.UnexpectedToken,\n    62→            else => error.UnexpectedToken,\n    63→        };\n    64→    }\n    65→};\n    66→\n    67→/// Validation errors for Event.\n    68→pub const EventError = error{\n    69→    EmptyActor,\n    70→    EmptyIssueId,\n    71→};\n    72→\n    73→/// An audit log entry for an issue change.\n    74→pub const Event = struct {\n    75→    id: i64, // Unique identifier, 0 for new events before insert\n    76→    issue_id: []const u8, // The issue this event relates to\n    77→    event_type: EventType, // What kind of change occurred\n    78→    actor: []const u8, // Who performed the action\n    79→    old_value: ?[]const u8, // JSON of previous state (null for creation)\n    80→    new_value: ?[]const u8, // JSON of new state (null for deletion)\n    81→    created_at: i64, // Unix timestamp\n    82→\n    83→    const Self = @This();\n    84→\n    85→    /// Validate that the event has all required fields populated.\n    86→    pub fn validate(self: Self) EventError!void {\n    87→        if (self.actor.len == 0) return EventError.EmptyActor;\n    88→        if (self.issue_id.len == 0) return EventError.EmptyIssueId;\n    89→    }\n    90→\n    91→    /// Check deep equality between two Events.\n    92→    pub fn eql(a: Self, b: Self) bool {\n    93→        return a.id == b.id and\n    94→            a.created_at == b.created_at and\n    95→            a.event_type == b.event_type and\n    96→            std.mem.eql(u8, a.issue_id, b.issue_id) and\n    97→            std.mem.eql(u8, a.actor, b.actor) and\n    98→            optionalStrEql(a.old_value, b.old_value) and\n    99→            optionalStrEql(a.new_value, b.new_value);\n   100→    }\n   101→\n   102→    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n   103→        const av = a orelse return b == null;\n   104→        const bv = b orelse return false;\n   105→        return std.mem.eql(u8, av, bv);\n   106→    }\n   107→\n   108→    /// Create an event for issue creation.\n   109→    pub fn issueCreated(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   110→        return Self{\n   111→            .id = 0,\n   112→            .issue_id = issue_id,\n   113→            .event_type = .created,\n   114→            .actor = actor,\n   115→            .old_value = null,\n   116→            .new_value = null,\n   117→            .created_at = timestamp,\n   118→        };\n   119→    }\n   120→\n   121→    /// Create an event for status change.\n   122→    pub fn statusChange(\n   123→        allocator: std.mem.Allocator,\n   124→        issue_id: []const u8,\n   125→        actor: []const u8,\n   126→        old_status: Status,\n   127→        new_status: Status,\n   128→        timestamp: i64,\n   129→    ) !Self {\n   130→        const old_json = try allocator.dupe(u8, old_status.toString());\n   131→        const new_json = try allocator.dupe(u8, new_status.toString());\n   132→\n   133→        return Self{\n   134→            .id = 0,\n   135→            .issue_id = issue_id,\n   136→            .event_type = .status_changed,\n   137→            .actor = actor,\n   138→            .old_value = old_json,\n   139→            .new_value = new_json,\n   140→            .created_at = timestamp,\n   141→        };\n   142→    }\n   143→\n   144→    /// Create an event for priority change.\n   145→    pub fn priorityChange(\n   146→        allocator: std.mem.Allocator,\n   147→        issue_id: []const u8,\n   148→        actor: []const u8,\n   149→        old_priority: Priority,\n   150→        new_priority: Priority,\n   151→        timestamp: i64,\n   152→    ) !Self {\n   153→        var old_buf: [8]u8 = undefined;\n   154→        var new_buf: [8]u8 = undefined;\n   155→\n   156→        const old_str = std.fmt.bufPrint(&old_buf, \"{d}\", .{old_priority.value}) catch unreachable;\n   157→        const new_str = std.fmt.bufPrint(&new_buf, \"{d}\", .{new_priority.value}) catch unreachable;\n   158→\n   159→        const old_json = try allocator.dupe(u8, old_str);\n   160→        const new_json = try allocator.dupe(u8, new_str);\n   161→\n   162→        return Self{\n   163→            .id = 0,\n   164→            .issue_id = issue_id,\n   165→            .event_type = .priority_changed,\n   166→            .actor = actor,\n   167→            .old_value = old_json,\n   168→            .new_value = new_json,\n   169→            .created_at = timestamp,\n   170→        };\n   171→    }\n   172→\n   173→    /// Create an event for assignee change.\n   174→    pub fn assigneeChange(\n   175→        allocator: std.mem.Allocator,\n   176→        issue_id: []const u8,\n   177→        actor: []const u8,\n   178→        old_assignee: ?[]const u8,\n   179→        new_assignee: ?[]const u8,\n   180→        timestamp: i64,\n   181→    ) !Self {\n   182→        const old_json = if (old_assignee) |a| try allocator.dupe(u8, a) else null;\n   183→        const new_json = if (new_assignee) |a| try allocator.dupe(u8, a) else null;\n   184→\n   185→        return Self{\n   186→            .id = 0,\n   187→            .issue_id = issue_id,\n   188→            .event_type = .assignee_changed,\n   189→            .actor = actor,\n   190→            .old_value = old_json,\n   191→            .new_value = new_json,\n   192→            .created_at = timestamp,\n   193→        };\n   194→    }\n   195→\n   196→    /// Create an event for adding a label.\n   197→    pub fn labelAdded(\n   198→        allocator: std.mem.Allocator,\n   199→        issue_id: []const u8,\n   200→        actor: []const u8,\n   201→        label: []const u8,\n   202→        timestamp: i64,\n   203→    ) !Self {\n   204→        const new_json = try allocator.dupe(u8, label);\n   205→\n   206→        return Self{\n   207→            .id = 0,\n   208→            .issue_id = issue_id,\n   209→            .event_type = .label_added,\n   210→            .actor = actor,\n   211→            .old_value = null,\n   212→            .new_value = new_json,\n   213→            .created_at = timestamp,\n   214→        };\n   215→    }\n   216→\n   217→    /// Create an event for removing a label.\n   218→    pub fn labelRemoved(\n   219→        allocator: std.mem.Allocator,\n   220→        issue_id: []const u8,\n   221→        actor: []const u8,\n   222→        label: []const u8,\n   223→        timestamp: i64,\n   224→    ) !Self {\n   225→        const old_json = try allocator.dupe(u8, label);\n   226→\n   227→        return Self{\n   228→            .id = 0,\n   229→            .issue_id = issue_id,\n   230→            .event_type = .label_removed,\n   231→            .actor = actor,\n   232→            .old_value = old_json,\n   233→            .new_value = null,\n   234→            .created_at = timestamp,\n   235→        };\n   236→    }\n   237→\n   238→    /// Create an event for adding a dependency.\n   239→    pub fn dependencyAdded(\n   240→        allocator: std.mem.Allocator,\n   241→        issue_id: []const u8,\n   242→        actor: []const u8,\n   243→        depends_on_id: []const u8,\n   244→        timestamp: i64,\n   245→    ) !Self {\n   246→        const new_json = try allocator.dupe(u8, depends_on_id);\n   247→\n   248→        return Self{\n   249→            .id = 0,\n   250→            .issue_id = issue_id,\n   251→            .event_type = .dependency_added,\n   252→            .actor = actor,\n   253→            .old_value = null,\n   254→            .new_value = new_json,\n   255→            .created_at = timestamp,\n   256→        };\n   257→    }\n   258→\n   259→    /// Create an event for removing a dependency.\n   260→    pub fn dependencyRemoved(\n   261→        allocator: std.mem.Allocator,\n   262→        issue_id: []const u8,\n   263→        actor: []const u8,\n   264→        depends_on_id: []const u8,\n   265→        timestamp: i64,\n   266→    ) !Self {\n   267→        const old_json = try allocator.dupe(u8, depends_on_id);\n   268→\n   269→        return Self{\n   270→            .id = 0,\n   271→            .issue_id = issue_id,\n   272→            .event_type = .dependency_removed,\n   273→            .actor = actor,\n   274→            .old_value = old_json,\n   275→            .new_value = null,\n   276→            .created_at = timestamp,\n   277→        };\n   278→    }\n   279→\n   280→    /// Create an event for issue closure.\n   281→    pub fn issueClosed(\n   282→        allocator: std.mem.Allocator,\n   283→        issue_id: []const u8,\n   284→        actor: []const u8,\n   285→        close_reason: ?[]const u8,\n   286→        timestamp: i64,\n   287→    ) !Self {\n   288→        const new_json = if (close_reason) |r| try allocator.dupe(u8, r) else null;\n   289→\n   290→        return Self{\n   291→            .id = 0,\n   292→            .issue_id = issue_id,\n   293→            .event_type = .closed,\n   294→            .actor = actor,\n   295→            .old_value = null,\n   296→            .new_value = new_json,\n   297→            .created_at = timestamp,\n   298→        };\n   299→    }\n   300→\n   301→    /// Create an event for issue reopening.\n   302→    pub fn issueReopened(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   303→        return Self{\n   304→            .id = 0,\n   305→            .issue_id = issue_id,\n   306→            .event_type = .reopened,\n   307→            .actor = actor,\n   308→            .old_value = null,\n   309→            .new_value = null,\n   310→            .created_at = timestamp,\n   311→        };\n   312→    }\n   313→\n   314→    /// Create an event for issue deletion (tombstone).\n   315→    pub fn issueDeleted(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   316→        return Self{\n   317→            .id = 0,\n   318→            .issue_id = issue_id,\n   319→            .event_type = .deleted,\n   320→            .actor = actor,\n   321→            .old_value = null,\n   322→            .new_value = null,\n   323→            .created_at = timestamp,\n   324→        };\n   325→    }\n   326→\n   327→    /// Create an event for issue restoration.\n   328→    pub fn issueRestored(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   329→        return Self{\n   330→            .id = 0,\n   331→            .issue_id = issue_id,\n   332→            .event_type = .restored,\n   333→            .actor = actor,\n   334→            .old_value = null,\n   335→            .new_value = null,\n   336→            .created_at = timestamp,\n   337→        };\n   338→    }\n   339→};\n   340→\n   341→// --- EventType Tests ---\n   342→\n   343→test \"EventType.toString returns correct strings\" {\n   344→    try std.testing.expectEqualStrings(\"created\", EventType.created.toString());\n   345→    try std.testing.expectEqualStrings(\"updated\", EventType.updated.toString());\n   346→    try std.testing.expectEqualStrings(\"status_changed\", EventType.status_changed.toString());\n   347→    try std.testing.expectEqualStrings(\"priority_changed\", EventType.priority_changed.toString());\n   348→    try std.testing.expectEqualStrings(\"assignee_changed\", EventType.assignee_changed.toString());\n   349→    try std.testing.expectEqualStrings(\"commented\", EventType.commented.toString());\n   350→    try std.testing.expectEqualStrings(\"closed\", EventType.closed.toString());\n   351→    try std.testing.expectEqualStrings(\"reopened\", EventType.reopened.toString());\n   352→    try std.testing.expectEqualStrings(\"dependency_added\", EventType.dependency_added.toString());\n   353→    try std.testing.expectEqualStrings(\"dependency_removed\", EventType.dependency_removed.toString());\n   354→    try std.testing.expectEqualStrings(\"label_added\", EventType.label_added.toString());\n   355→    try std.testing.expectEqualStrings(\"label_removed\", EventType.label_removed.toString());\n   356→    try std.testing.expectEqualStrings(\"compacted\", EventType.compacted.toString());\n   357→    try std.testing.expectEqualStrings(\"deleted\", EventType.deleted.toString());\n   358→    try std.testing.expectEqualStrings(\"restored\", EventType.restored.toString());\n   359→}\n   360→\n   361→test \"EventType.fromString parses known event types\" {\n   362→    try std.testing.expectEqual(EventType.created, EventType.fromString(\"created\").?);\n   363→    try std.testing.expectEqual(EventType.updated, EventType.fromString(\"updated\").?);\n   364→    try std.testing.expectEqual(EventType.status_changed, EventType.fromString(\"status_changed\").?);\n   365→    try std.testing.expectEqual(EventType.priority_changed, EventType.fromString(\"priority_changed\").?);\n   366→    try std.testing.expectEqual(EventType.assignee_changed, EventType.fromString(\"assignee_changed\").?);\n   367→    try std.testing.expectEqual(EventType.commented, EventType.fromString(\"commented\").?);\n   368→    try std.testing.expectEqual(EventType.closed, EventType.fromString(\"closed\").?);\n   369→    try std.testing.expectEqual(EventType.reopened, EventType.fromString(\"reopened\").?);\n   370→    try std.testing.expectEqual(EventType.dependency_added, EventType.fromString(\"dependency_added\").?);\n   371→    try std.testing.expectEqual(EventType.dependency_removed, EventType.fromString(\"dependency_removed\").?);\n   372→    try std.testing.expectEqual(EventType.label_added, EventType.fromString(\"label_added\").?);\n   373→    try std.testing.expectEqual(EventType.label_removed, EventType.fromString(\"label_removed\").?);\n   374→    try std.testing.expectEqual(EventType.compacted, EventType.fromString(\"compacted\").?);\n   375→    try std.testing.expectEqual(EventType.deleted, EventType.fromString(\"deleted\").?);\n   376→    try std.testing.expectEqual(EventType.restored, EventType.fromString(\"restored\").?);\n   377→}\n   378→\n   379→test \"EventType.fromString returns null for unknown values\" {\n   380→    try std.testing.expect(EventType.fromString(\"unknown\") == null);\n   381→    try std.testing.expect(EventType.fromString(\"\") == null);\n   382→    try std.testing.expect(EventType.fromString(\"CREATED\") == null);\n   383→    try std.testing.expect(EventType.fromString(\"Created\") == null);\n   384→}\n   385→\n   386→test \"EventType toString/fromString roundtrip\" {\n   387→    const event_types = [_]EventType{\n   388→        .created,\n   389→        .updated,\n   390→        .status_changed,\n   391→        .priority_changed,\n   392→        .assignee_changed,\n   393→        .commented,\n   394→        .closed,\n   395→        .reopened,\n   396→        .dependency_added,\n   397→        .dependency_removed,\n   398→        .label_added,\n   399→        .label_removed,\n   400→        .compacted,\n   401→        .deleted,\n   402→        .restored,\n   403→    };\n   404→\n   405→    for (event_types) |et| {\n   406→        const str = et.toString();\n   407→        const parsed = EventType.fromString(str);\n   408→        try std.testing.expect(parsed != null);\n   409→        try std.testing.expectEqual(et, parsed.?);\n   410→    }\n   411→}\n   412→\n   413→test \"EventType JSON serialization roundtrip\" {\n   414→    const allocator = std.testing.allocator;\n   415→\n   416→    const event_types = [_]EventType{\n   417→        .created,\n   418→        .updated,\n   419→        .status_changed,\n   420→        .priority_changed,\n   421→        .assignee_changed,\n   422→        .commented,\n   423→        .closed,\n   424→        .reopened,\n   425→        .dependency_added,\n   426→        .dependency_removed,\n   427→        .label_added,\n   428→        .label_removed,\n   429→        .compacted,\n   430→        .deleted,\n   431→        .restored,\n   432→    };\n   433→\n   434→    for (event_types) |et| {\n   435→        var aw: std.io.Writer.Allocating = .init(allocator);\n   436→        defer aw.deinit();\n   437→\n   438→        try std.json.Stringify.value(et, .{}, &aw.writer);\n   439→        const json_str = aw.written();\n   440→\n   441→        const parsed = try std.json.parseFromSlice(EventType, allocator, json_str, .{});\n   442→        defer parsed.deinit();\n   443→\n   444→        try std.testing.expectEqual(et, parsed.value);\n   445→    }\n   446→}\n   447→\n   448→// --- Event Tests ---\n   449→\n   450→test \"Event.validate accepts valid event\" {\n   451→    const event = Event{\n   452→        .id = 1,\n   453→        .issue_id = \"bd-abc123\",\n   454→        .event_type = .created,\n   455→        .actor = \"alice@example.com\",\n   456→        .old_value = null,\n   457→        .new_value = null,\n   458→        .created_at = 1706540000,\n   459→    };\n   460→\n   461→    try event.validate();\n   462→}\n   463→\n   464→test \"Event.validate rejects empty actor\" {\n   465→    const event = Event{\n   466→        .id = 1,\n   467→        .issue_id = \"bd-abc123\",\n   468→        .event_type = .created,\n   469→        .actor = \"\",\n   470→        .old_value = null,\n   471→        .new_value = null,\n   472→        .created_at = 1706540000,\n   473→    };\n   474→\n   475→    try std.testing.expectError(EventError.EmptyActor, event.validate());\n   476→}\n   477→\n   478→test \"Event.validate rejects empty issue_id\" {\n   479→    const event = Event{\n   480→        .id = 1,\n   481→        .issue_id = \"\",\n   482→        .event_type = .created,\n   483→        .actor = \"alice@example.com\",\n   484→        .old_value = null,\n   485→        .new_value = null,\n   486→        .created_at = 1706540000,\n   487→    };\n   488→\n   489→    try std.testing.expectError(EventError.EmptyIssueId, event.validate());\n   490→}\n   491→\n   492→test \"Event.eql compares all fields\" {\n   493→    const event1 = Event{\n   494→        .id = 1,\n   495→        .issue_id = \"bd-abc123\",\n   496→        .event_type = .status_changed,\n   497→        .actor = \"alice@example.com\",\n   498→        .old_value = \"open\",\n   499→        .new_value = \"closed\",\n   500→        .created_at = 1706540000,\n   501→    };\n   502→\n   503→    const event2 = Event{\n   504→        .id = 1,\n   505→        .issue_id = \"bd-abc123\",\n   506→        .event_type = .status_changed,\n   507→        .actor = \"alice@example.com\",\n   508→        .old_value = \"open\",\n   509→        .new_value = \"closed\",\n   510→        .created_at = 1706540000,\n   511→    };\n   512→\n   513→    try std.testing.expect(Event.eql(event1, event2));\n   514→}\n   515→\n   516→test \"Event.eql detects differences\" {\n   517→    const base = Event{\n   518→        .id = 1,\n   519→        .issue_id = \"bd-abc123\",\n   520→        .event_type = .status_changed,\n   521→        .actor = \"alice@example.com\",\n   522→        .old_value = \"open\",\n   523→        .new_value = \"closed\",\n   524→        .created_at = 1706540000,\n   525→    };\n   526→\n   527→    const diff_id = Event{\n   528→        .id = 2,\n   529→        .issue_id = \"bd-abc123\",\n   530→        .event_type = .status_changed,\n   531→        .actor = \"alice@example.com\",\n   532→        .old_value = \"open\",\n   533→        .new_value = \"closed\",\n   534→        .created_at = 1706540000,\n   535→    };\n   536→    try std.testing.expect(!Event.eql(base, diff_id));\n   537→\n   538→    const diff_event_type = Event{\n   539→        .id = 1,\n   540→        .issue_id = \"bd-abc123\",\n   541→        .event_type = .priority_changed,\n   542→        .actor = \"alice@example.com\",\n   543→        .old_value = \"open\",\n   544→        .new_value = \"closed\",\n   545→        .created_at = 1706540000,\n   546→    };\n   547→    try std.testing.expect(!Event.eql(base, diff_event_type));\n   548→\n   549→    const diff_old_value = Event{\n   550→        .id = 1,\n   551→        .issue_id = \"bd-abc123\",\n   552→        .event_type = .status_changed,\n   553→        .actor = \"alice@example.com\",\n   554→        .old_value = \"in_progress\",\n   555→        .new_value = \"closed\",\n   556→        .created_at = 1706540000,\n   557→    };\n   558→    try std.testing.expect(!Event.eql(base, diff_old_value));\n   559→\n   560→    const null_old_value = Event{\n   561→        .id = 1,\n   562→        .issue_id = \"bd-abc123\",\n   563→        .event_type = .status_changed,\n   564→        .actor = \"alice@example.com\",\n   565→        .old_value = null,\n   566→        .new_value = \"closed\",\n   567→        .created_at = 1706540000,\n   568→    };\n   569→    try std.testing.expect(!Event.eql(base, null_old_value));\n   570→}\n   571→\n   572→test \"Event JSON serialization roundtrip\" {\n   573→    const allocator = std.testing.allocator;\n   574→\n   575→    const event = Event{\n   576→        .id = 42,\n   577→        .issue_id = \"bd-abc123\",\n   578→        .event_type = .status_changed,\n   579→        .actor = \"alice@example.com\",\n   580→        .old_value = \"open\",\n   581→        .new_value = \"closed\",\n   582→        .created_at = 1706540000,\n   583→    };\n   584→\n   585→    var aw: std.io.Writer.Allocating = .init(allocator);\n   586→    defer aw.deinit();\n   587→\n   588→    try std.json.Stringify.value(event, .{}, &aw.writer);\n   589→    const json_str = aw.written();\n   590→\n   591→    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n   592→    defer parsed.deinit();\n   593→\n   594→    try std.testing.expect(Event.eql(event, parsed.value));\n   595→}\n   596→\n   597→test \"Event JSON serialization with null old_value\" {\n   598→    const allocator = std.testing.allocator;\n   599→\n   600→    const event = Event{\n   601→        .id = 1,\n   602→        .issue_id = \"bd-abc123\",\n   603→        .event_type = .created,\n   604→        .actor = \"alice@example.com\",\n   605→        .old_value = null,\n   606→        .new_value = \"initial state\",\n   607→        .created_at = 1706540000,\n   608→    };\n   609→\n   610→    var aw: std.io.Writer.Allocating = .init(allocator);\n   611→    defer aw.deinit();\n   612→\n   613→    try std.json.Stringify.value(event, .{}, &aw.writer);\n   614→    const json_str = aw.written();\n   615→\n   616→    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n   617→    defer parsed.deinit();\n   618→\n   619→    try std.testing.expect(Event.eql(event, parsed.value));\n   620→    try std.testing.expect(parsed.value.old_value == null);\n   621→}\n   622→\n   623→test \"Event JSON serialization with both values null\" {\n   624→    const allocator = std.testing.allocator;\n   625→\n   626→    const event = Event{\n   627→        .id = 1,\n   628→        .issue_id = \"bd-abc123\",\n   629→        .event_type = .deleted,\n   630→        .actor = \"alice@example.com\",\n   631→        .old_value = null,\n   632→        .new_value = null,\n   633→        .created_at = 1706540000,\n   634→    };\n   635→\n   636→    var aw: std.io.Writer.Allocating = .init(allocator);\n   637→    defer aw.deinit();\n   638→\n   639→    try std.json.Stringify.value(event, .{}, &aw.writer);\n   640→    const json_str = aw.written();\n   641→\n   642→    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n   643→    defer parsed.deinit();\n   644→\n   645→    try std.testing.expect(Event.eql(event, parsed.value));\n   646→}\n   647→\n   648→// --- Factory Function Tests ---\n   649→\n   650→test \"Event.issueCreated produces valid event\" {\n   651→    const event = Event.issueCreated(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   652→\n   653→    try std.testing.expectEqualStrings(\"bd-abc123\", event.issue_id);\n   654→    try std.testing.expectEqual(EventType.created, event.event_type);\n   655→    try std.testing.expectEqualStrings(\"alice@example.com\", event.actor);\n   656→    try std.testing.expect(event.old_value == null);\n   657→    try std.testing.expect(event.new_value == null);\n   658→    try std.testing.expectEqual(@as(i64, 1706540000), event.created_at);\n   659→    try std.testing.expectEqual(@as(i64, 0), event.id);\n   660→\n   661→    try event.validate();\n   662→}\n   663→\n   664→test \"Event.statusChange produces valid event\" {\n   665→    const allocator = std.testing.allocator;\n   666→\n   667→    const event = try Event.statusChange(\n   668→        allocator,\n   669→        \"bd-abc123\",\n   670→        \"alice@example.com\",\n   671→        Status.open,\n   672→        Status.closed,\n   673→        1706540000,\n   674→    );\n   675→    defer {\n   676→        if (event.old_value) |v| allocator.free(v);\n   677→        if (event.new_value) |v| allocator.free(v);\n   678→    }\n   679→\n   680→    try std.testing.expectEqual(EventType.status_changed, event.event_type);\n   681→    try std.testing.expectEqualStrings(\"open\", event.old_value.?);\n   682→    try std.testing.expectEqualStrings(\"closed\", event.new_value.?);\n   683→\n   684→    try event.validate();\n   685→}\n   686→\n   687→test \"Event.priorityChange produces valid event\" {\n   688→    const allocator = std.testing.allocator;\n   689→\n   690→    const event = try Event.priorityChange(\n   691→        allocator,\n   692→        \"bd-abc123\",\n   693→        \"alice@example.com\",\n   694→        Priority.LOW,\n   695→        Priority.HIGH,\n   696→        1706540000,\n   697→    );\n   698→    defer {\n   699→        if (event.old_value) |v| allocator.free(v);\n   700→        if (event.new_value) |v| allocator.free(v);\n   701→    }\n   702→\n   703→    try std.testing.expectEqual(EventType.priority_changed, event.event_type);\n   704→    try std.testing.expectEqualStrings(\"3\", event.old_value.?);\n   705→    try std.testing.expectEqualStrings(\"1\", event.new_value.?);\n   706→\n   707→    try event.validate();\n   708→}\n   709→\n   710→test \"Event.assigneeChange produces valid event\" {\n   711→    const allocator = std.testing.allocator;\n   712→\n   713→    const event = try Event.assigneeChange(\n   714→        allocator,\n   715→        \"bd-abc123\",\n   716→        \"admin@example.com\",\n   717→        \"alice@example.com\",\n   718→        \"bob@example.com\",\n   719→        1706540000,\n   720→    );\n   721→    defer {\n   722→        if (event.old_value) |v| allocator.free(v);\n   723→        if (event.new_value) |v| allocator.free(v);\n   724→    }\n   725→\n   726→    try std.testing.expectEqual(EventType.assignee_changed, event.event_type);\n   727→    try std.testing.expectEqualStrings(\"alice@example.com\", event.old_value.?);\n   728→    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n   729→\n   730→    try event.validate();\n   731→}\n   732→\n   733→test \"Event.assigneeChange handles null assignees\" {\n   734→    const allocator = std.testing.allocator;\n   735→\n   736→    const event = try Event.assigneeChange(\n   737→        allocator,\n   738→        \"bd-abc123\",\n   739→        \"admin@example.com\",\n   740→        null,\n   741→        \"bob@example.com\",\n   742→        1706540000,\n   743→    );\n   744→    defer {\n   745→        if (event.old_value) |v| allocator.free(v);\n   746→        if (event.new_value) |v| allocator.free(v);\n   747→    }\n   748→\n   749→    try std.testing.expect(event.old_value == null);\n   750→    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n   751→\n   752→    try event.validate();\n   753→}\n   754→\n   755→test \"Event.labelAdded produces valid event\" {\n   756→    const allocator = std.testing.allocator;\n   757→\n   758→    const event = try Event.labelAdded(\n   759→        allocator,\n   760→        \"bd-abc123\",\n   761→        \"alice@example.com\",\n   762→        \"urgent\",\n   763→        1706540000,\n   764→    );\n   765→    defer {\n   766→        if (event.new_value) |v| allocator.free(v);\n   767→    }\n   768→\n   769→    try std.testing.expectEqual(EventType.label_added, event.event_type);\n   770→    try std.testing.expect(event.old_value == null);\n   771→    try std.testing.expectEqualStrings(\"urgent\", event.new_value.?);\n   772→\n   773→    try event.validate();\n   774→}\n   775→\n   776→test \"Event.labelRemoved produces valid event\" {\n   777→    const allocator = std.testing.allocator;\n   778→\n   779→    const event = try Event.labelRemoved(\n   780→        allocator,\n   781→        \"bd-abc123\",\n   782→        \"alice@example.com\",\n   783→        \"wontfix\",\n   784→        1706540000,\n   785→    );\n   786→    defer {\n   787→        if (event.old_value) |v| allocator.free(v);\n   788→    }\n   789→\n   790→    try std.testing.expectEqual(EventType.label_removed, event.event_type);\n   791→    try std.testing.expectEqualStrings(\"wontfix\", event.old_value.?);\n   792→    try std.testing.expect(event.new_value == null);\n   793→\n   794→    try event.validate();\n   795→}\n   796→\n   797→test \"Event.dependencyAdded produces valid event\" {\n   798→    const allocator = std.testing.allocator;\n   799→\n   800→    const event = try Event.dependencyAdded(\n   801→        allocator,\n   802→        \"bd-abc123\",\n   803→        \"alice@example.com\",\n   804→        \"bd-def456\",\n   805→        1706540000,\n   806→    );\n   807→    defer {\n   808→        if (event.new_value) |v| allocator.free(v);\n   809→    }\n   810→\n   811→    try std.testing.expectEqual(EventType.dependency_added, event.event_type);\n   812→    try std.testing.expect(event.old_value == null);\n   813→    try std.testing.expectEqualStrings(\"bd-def456\", event.new_value.?);\n   814→\n   815→    try event.validate();\n   816→}\n   817→\n   818→test \"Event.dependencyRemoved produces valid event\" {\n   819→    const allocator = std.testing.allocator;\n   820→\n   821→    const event = try Event.dependencyRemoved(\n   822→        allocator,\n   823→        \"bd-abc123\",\n   824→        \"alice@example.com\",\n   825→        \"bd-def456\",\n   826→        1706540000,\n   827→    );\n   828→    defer {\n   829→        if (event.old_value) |v| allocator.free(v);\n   830→    }\n   831→\n   832→    try std.testing.expectEqual(EventType.dependency_removed, event.event_type);\n   833→    try std.testing.expectEqualStrings(\"bd-def456\", event.old_value.?);\n   834→    try std.testing.expect(event.new_value == null);\n   835→\n   836→    try event.validate();\n   837→}\n   838→\n   839→test \"Event.issueClosed produces valid event\" {\n   840→    const allocator = std.testing.allocator;\n   841→\n   842→    const event = try Event.issueClosed(\n   843→        allocator,\n   844→        \"bd-abc123\",\n   845→        \"alice@example.com\",\n   846→        \"completed\",\n   847→        1706540000,\n   848→    );\n   849→    defer {\n   850→        if (event.new_value) |v| allocator.free(v);\n   851→    }\n   852→\n   853→    try std.testing.expectEqual(EventType.closed, event.event_type);\n   854→    try std.testing.expect(event.old_value == null);\n   855→    try std.testing.expectEqualStrings(\"completed\", event.new_value.?);\n   856→\n   857→    try event.validate();\n   858→}\n   859→\n   860→test \"Event.issueClosed handles null close_reason\" {\n   861→    const allocator = std.testing.allocator;\n   862→\n   863→    const event = try Event.issueClosed(\n   864→        allocator,\n   865→        \"bd-abc123\",\n   866→        \"alice@example.com\",\n   867→        null,\n   868→        1706540000,\n   869→    );\n   870→\n   871→    try std.testing.expectEqual(EventType.closed, event.event_type);\n   872→    try std.testing.expect(event.old_value == null);\n   873→    try std.testing.expect(event.new_value == null);\n   874→\n   875→    try event.validate();\n   876→}\n   877→\n   878→test \"Event.issueReopened produces valid event\" {\n   879→    const event = Event.issueReopened(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   880→\n   881→    try std.testing.expectEqual(EventType.reopened, event.event_type);\n   882→    try std.testing.expect(event.old_value == null);\n   883→    try std.testing.expect(event.new_value == null);\n   884→\n   885→    try event.validate();\n   886→}\n   887→\n   888→test \"Event.issueDeleted produces valid event\" {\n   889→    const event = Event.issueDeleted(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   890→\n   891→    try std.testing.expectEqual(EventType.deleted, event.event_type);\n   892→    try std.testing.expect(event.old_value == null);\n   893→    try std.testing.expect(event.new_value == null);\n   894→\n   895→    try event.validate();\n   896→}\n   897→\n   898→test \"Event.issueRestored produces valid event\" {\n   899→    const event = Event.issueRestored(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   900→\n   901→    try std.testing.expectEqual(EventType.restored, event.event_type);\n   902→    try std.testing.expect(event.old_value == null);\n   903→    try std.testing.expect(event.new_value == null);\n   904→\n   905→    try event.validate();\n   906→}\n   907→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"795dd95a-d76e-42d4-813d-38ffd80ca86c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VbiiDdSvFYiSfNSEz72n31","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019RhWsmyCHGnfGFXs5VRfTz","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":100,"offset":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15742,"cache_read_input_tokens":20851,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15742},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"cd072b68-bd95-4995-8915-ddda3bde5c3f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019RhWsmyCHGnfGFXs5VRfTz","type":"tool_result","content":"   100→    completions: CompletionsArgs,\n   101→    metrics: MetricsArgs,\n   102→\n   103→    // Saved Queries\n   104→    query: QueryArgs,\n   105→\n   106→    // Self-upgrade\n   107→    upgrade: UpgradeArgs,\n   108→\n   109→    // Help\n   110→    help: HelpArgs,\n   111→};\n   112→\n   113→/// Init command arguments.\n   114→pub const InitArgs = struct {\n   115→    prefix: []const u8 = \"bd\",\n   116→};\n   117→\n   118→/// Create command arguments.\n   119→pub const CreateArgs = struct {\n   120→    title: []const u8,\n   121→    description: ?[]const u8 = null,\n   122→    issue_type: ?[]const u8 = null,\n   123→    priority: ?[]const u8 = null,\n   124→    assignee: ?[]const u8 = null,\n   125→    owner: ?[]const u8 = null,\n   126→    design: ?[]const u8 = null,\n   127→    acceptance_criteria: ?[]const u8 = null,\n   128→    external_ref: ?[]const u8 = null,\n   129→    labels: []const []const u8 = &[_][]const u8{},\n   130→    deps: []const []const u8 = &[_][]const u8{},\n   131→    due: ?[]const u8 = null,\n   132→    estimate: ?i32 = null,\n   133→    ephemeral: bool = false, // Local-only, not written to JSONL\n   134→};\n   135→\n   136→/// Quick capture command arguments.\n   137→pub const QuickArgs = struct {\n   138→    title: []const u8,\n   139→    priority: ?[]const u8 = null,\n   140→};\n   141→\n   142→/// Show command arguments.\n   143→pub const ShowArgs = struct {\n   144→    id: []const u8,\n   145→    with_comments: bool = true,\n   146→    with_history: bool = false,\n   147→};\n   148→\n   149→/// Update command arguments.\n   150→pub const UpdateArgs = struct {\n   151→    id: []const u8,\n   152→    title: ?[]const u8 = null,\n   153→    description: ?[]const u8 = null,\n   154→    issue_type: ?[]const u8 = null,\n   155→    priority: ?[]const u8 = null,\n   156→    assignee: ?[]const u8 = null,\n   157→    owner: ?[]const u8 = null,\n   158→    design: ?[]const u8 = null,\n   159→    acceptance_criteria: ?[]const u8 = null,\n   160→    external_ref: ?[]const u8 = null,\n   161→    status: ?[]const u8 = null,\n   162→    /// Expected version for optimistic locking (compare-and-swap).\n   163→    expected_version: ?u64 = null,\n   164→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   165→    claim: bool = false,\n   166→};\n   167→\n   168→/// Close command arguments.\n   169→pub const CloseArgs = struct {\n   170→    id: []const u8,\n   171→    reason: ?[]const u8 = null,\n   172→    session: ?[]const u8 = null,\n   173→};\n   174→\n   175→/// Reopen command arguments.\n   176→pub const ReopenArgs = struct {\n   177→    id: []const u8,\n   178→};\n   179→\n   180→/// Delete command arguments.\n   181→pub const DeleteArgs = struct {\n   182→    /// Single issue ID to delete (mutually exclusive with from_file).\n   183→    id: ?[]const u8 = null,\n   184→    /// Path to file containing issue IDs to delete (one per line).\n   185→    from_file: ?[]const u8 = null,\n   186→    /// Delete issue and all its dependents recursively.\n   187→    cascade: bool = false,\n   188→    /// Prune from database immediately instead of marking as tombstone.\n   189→    hard: bool = false,\n   190→    /// Preview what would be deleted without making changes.\n   191→    dry_run: bool = false,\n   192→};\n   193→\n   194→/// Add-batch command arguments.\n   195→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   196→pub const AddBatchArgs = struct {\n   197→    file: ?[]const u8 = null, // Read from file instead of stdin\n   198→    format: BatchFormat = .titles, // Input format\n   199→};\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2f993f60-a8a8-4f47-aed3-30920a1ec4f2"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VbiiDdSvFYiSfNSEz72n31","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TBn7dcxrbNRrjmGUiLK555","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15742,"cache_read_input_tokens":20851,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15742},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0933ef80-a7ff-44b6-aa0c-0b6b5f06b73c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TBn7dcxrbNRrjmGUiLK555","type":"tool_result","content":"     1→//! Audit command for beads_zig.\n     2→//!\n     3→//! `bz audit [--limit N]` - Show project-wide audit log\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const AuditError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const AuditResult = struct {\n    18→    success: bool,\n    19→    events: ?[]const AuditEvent = null,\n    20→    total: ?usize = null,\n    21→    message: ?[]const u8 = null,\n    22→\n    23→    pub const AuditEvent = struct {\n    24→        issue_id: []const u8,\n    25→        event_type: []const u8,\n    26→        actor: []const u8,\n    27→        created_at: i64,\n    28→    };\n    29→};\n    30→\n    31→pub fn run(\n    32→    audit_args: args.AuditArgs,\n    33→    global: args.GlobalOptions,\n    34→    allocator: std.mem.Allocator,\n    35→) !void {\n    36→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    37→        return AuditError.WorkspaceNotInitialized;\n    38→    };\n    39→    defer ctx.deinit();\n    40→\n    41→    const limit = audit_args.limit orelse 100;\n    42→\n    43→    // Build synthetic audit log from all issues\n    44→    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    45→    defer events.deinit(allocator);\n    46→\n    47→    for (ctx.store.issues.items) |issue| {\n    48→        // Created event\n    49→        try events.append(allocator, .{\n    50→            .issue_id = issue.id,\n    51→            .event_type = \"created\",\n    52→            .actor = issue.created_by orelse \"unknown\",\n    53→            .created_at = issue.created_at.value,\n    54→        });\n    55→\n    56→        // Closed event\n    57→        if (issue.closed_at.value) |closed_ts| {\n    58→            try events.append(allocator, .{\n    59→                .issue_id = issue.id,\n    60→                .event_type = \"closed\",\n    61→                .actor = \"unknown\",\n    62→                .created_at = closed_ts,\n    63→            });\n    64→        }\n    65→\n    66→        // If tombstoned\n    67→        if (issue.status.eql(.tombstone)) {\n    68→            try events.append(allocator, .{\n    69→                .issue_id = issue.id,\n    70→                .event_type = \"deleted\",\n    71→                .actor = \"unknown\",\n    72→                .created_at = issue.updated_at.value,\n    73→            });\n    74→        }\n    75→    }\n    76→\n    77→    // Sort by timestamp descending (most recent first)\n    78→    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n    79→        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n    80→            return a.created_at > b.created_at;\n    81→        }\n    82→    }.lessThan);\n    83→\n    84→    // Apply limit\n    85→    const display_count = @min(events.items.len, limit);\n    86→    const display_events = events.items[0..display_count];\n    87→\n    88→    if (global.isStructuredOutput()) {\n    89→        try ctx.output.printJson(AuditResult{\n    90→            .success = true,\n    91→            .events = display_events,\n    92→            .total = events.items.len,\n    93→        });\n    94→    } else if (global.quiet) {\n    95→        for (display_events) |event| {\n    96→            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n    97→        }\n    98→    } else {\n    99→        if (display_events.len == 0) {\n   100→            try ctx.output.info(\"No events found\", .{});\n   101→        } else {\n   102→            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n   103→            try ctx.output.print(\"\\n\", .{});\n   104→\n   105→            for (display_events) |event| {\n   106→                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n   107→                    event.created_at,\n   108→                    event.issue_id,\n   109→                    event.actor,\n   110→                    event.event_type,\n   111→                });\n   112→            }\n   113→\n   114→            if (events.items.len > display_count) {\n   115→                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n   116→                    events.items.len - display_count,\n   117→                });\n   118→            }\n   119→        }\n   120→    }\n   121→}\n   122→\n   123→// --- Tests ---\n   124→\n   125→test \"AuditError enum exists\" {\n   126→    const err: AuditError = AuditError.WorkspaceNotInitialized;\n   127→    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n   128→}\n   129→\n   130→test \"AuditResult struct works\" {\n   131→    const result = AuditResult{\n   132→        .success = true,\n   133→        .total = 10,\n   134→    };\n   135→    try std.testing.expect(result.success);\n   136→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   137→}\n   138→\n   139→test \"run detects uninitialized workspace\" {\n   140→    const allocator = std.testing.allocator;\n   141→\n   142→    const audit_args = args.AuditArgs{};\n   143→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   144→\n   145→    const result = run(audit_args, global, allocator);\n   146→    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n   147→}\n   148→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b98a3a58-861a-499b-a059-c6aa14f91afa"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VbiiDdSvFYiSfNSEz72n31","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RpwLHeTsxE8jUcNSE5mBcz","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/history.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15742,"cache_read_input_tokens":20851,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15742},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e127e1dd-9e4f-4b50-9540-29e0bdb1518b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RpwLHeTsxE8jUcNSE5mBcz","type":"tool_result","content":"     1→//! History command for beads_zig.\n     2→//!\n     3→//! `bz history <id>` - Show history/changelog for an issue\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→const Event = @import(\"../models/event.zig\").Event;\n     9→\n    10→const CommandContext = common.CommandContext;\n    11→\n    12→pub const HistoryError = error{\n    13→    WorkspaceNotInitialized,\n    14→    StorageError,\n    15→    IssueNotFound,\n    16→    OutOfMemory,\n    17→};\n    18→\n    19→pub const HistoryResult = struct {\n    20→    success: bool,\n    21→    id: ?[]const u8 = null,\n    22→    events: ?[]const EventInfo = null,\n    23→    message: ?[]const u8 = null,\n    24→\n    25→    pub const EventInfo = struct {\n    26→        id: i64,\n    27→        event_type: []const u8,\n    28→        actor: []const u8,\n    29→        old_value: ?[]const u8,\n    30→        new_value: ?[]const u8,\n    31→        created_at: i64,\n    32→    };\n    33→};\n    34→\n    35→pub fn run(\n    36→    history_args: args.HistoryArgs,\n    37→    global: args.GlobalOptions,\n    38→    allocator: std.mem.Allocator,\n    39→) !void {\n    40→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    41→        return HistoryError.WorkspaceNotInitialized;\n    42→    };\n    43→    defer ctx.deinit();\n    44→\n    45→    const id = history_args.id;\n    46→\n    47→    // Verify issue exists\n    48→    if (!try ctx.store.exists(id)) {\n    49→        if (global.isStructuredOutput()) {\n    50→            try ctx.output.printJson(HistoryResult{\n    51→                .success = false,\n    52→                .id = id,\n    53→                .message = \"issue not found\",\n    54→            });\n    55→        } else {\n    56→            try ctx.output.err(\"issue not found: {s}\", .{id});\n    57→        }\n    58→        return HistoryError.IssueNotFound;\n    59→    }\n    60→\n    61→    // Get real events from the event store\n    62→    const stored_events = ctx.event_store.getEventsForIssue(id) catch &[_]Event{};\n    63→    defer if (stored_events.len > 0) ctx.event_store.freeEvents(@constCast(stored_events));\n    64→\n    65→    // Convert to output format\n    66→    var events: std.ArrayListUnmanaged(HistoryResult.EventInfo) = .{};\n    67→    defer events.deinit(allocator);\n    68→\n    69→    for (stored_events) |e| {\n    70→        try events.append(allocator, .{\n    71→            .id = e.id,\n    72→            .event_type = e.event_type.toString(),\n    73→            .actor = e.actor,\n    74→            .old_value = e.old_value,\n    75→            .new_value = e.new_value,\n    76→            .created_at = e.created_at,\n    77→        });\n    78→    }\n    79→\n    80→    // If no stored events, generate synthetic events from issue data for backwards compatibility\n    81→    if (events.items.len == 0) {\n    82→        const issue_opt = try ctx.store.get(id);\n    83→        if (issue_opt) |issue_val| {\n    84→            var issue = issue_val;\n    85→            defer issue.deinit(allocator);\n    86→\n    87→            // Created event\n    88→            try events.append(allocator, .{\n    89→                .id = 0,\n    90→                .event_type = \"created\",\n    91→                .actor = issue.created_by orelse \"unknown\",\n    92→                .old_value = null,\n    93→                .new_value = issue.title,\n    94→                .created_at = issue.created_at.value,\n    95→            });\n    96→\n    97→            // If closed, add closed event\n    98→            if (issue.closed_at.value) |closed_ts| {\n    99→                try events.append(allocator, .{\n   100→                    .id = 0,\n   101→                    .event_type = \"closed\",\n   102→                    .actor = \"unknown\",\n   103→                    .old_value = null,\n   104→                    .new_value = issue.close_reason,\n   105→                    .created_at = closed_ts,\n   106→                });\n   107→            }\n   108→\n   109→            // If updated (updated_at != created_at)\n   110→            if (issue.updated_at.value != issue.created_at.value) {\n   111→                try events.append(allocator, .{\n   112→                    .id = 0,\n   113→                    .event_type = \"updated\",\n   114→                    .actor = \"unknown\",\n   115→                    .old_value = null,\n   116→                    .new_value = null,\n   117→                    .created_at = issue.updated_at.value,\n   118→                });\n   119→            }\n   120→        }\n   121→    }\n   122→\n   123→    if (global.isStructuredOutput()) {\n   124→        try ctx.output.printJson(HistoryResult{\n   125→            .success = true,\n   126→            .id = id,\n   127→            .events = events.items,\n   128→        });\n   129→    } else if (global.quiet) {\n   130→        for (events.items) |event| {\n   131→            try ctx.output.print(\"{s}\\n\", .{event.event_type});\n   132→        }\n   133→    } else {\n   134→        if (events.items.len == 0) {\n   135→            try ctx.output.info(\"No history for {s}\", .{id});\n   136→        } else {\n   137→            try ctx.output.println(\"History for {s} ({d} events):\", .{ id, events.items.len });\n   138→            for (events.items) |event| {\n   139→                try ctx.output.print(\"\\n\", .{});\n   140→                if (event.id > 0) {\n   141→                    try ctx.output.print(\"[#{d}] [{d}] {s}  {s}\\n\", .{\n   142→                        event.id,\n   143→                        event.created_at,\n   144→                        event.actor,\n   145→                        event.event_type,\n   146→                    });\n   147→                } else {\n   148→                    try ctx.output.print(\"[ts:{d}] {s}  {s}\\n\", .{\n   149→                        event.created_at,\n   150→                        event.actor,\n   151→                        event.event_type,\n   152→                    });\n   153→                }\n   154→                if (event.old_value != null or event.new_value != null) {\n   155→                    if (event.old_value) |old| {\n   156→                        try ctx.output.print(\"  - {s}\\n\", .{truncate(old, 50)});\n   157→                    }\n   158→                    if (event.new_value) |new| {\n   159→                        try ctx.output.print(\"  + {s}\\n\", .{truncate(new, 50)});\n   160→                    }\n   161→                }\n   162→            }\n   163→        }\n   164→    }\n   165→}\n   166→\n   167→fn truncate(s: []const u8, max_len: usize) []const u8 {\n   168→    if (s.len <= max_len) return s;\n   169→    return s[0..max_len];\n   170→}\n   171→\n   172→// --- Tests ---\n   173→\n   174→test \"HistoryError enum exists\" {\n   175→    const err: HistoryError = HistoryError.WorkspaceNotInitialized;\n   176→    try std.testing.expect(err == HistoryError.WorkspaceNotInitialized);\n   177→}\n   178→\n   179→test \"HistoryResult struct works\" {\n   180→    const result = HistoryResult{\n   181→        .success = true,\n   182→        .id = \"bd-test\",\n   183→    };\n   184→    try std.testing.expect(result.success);\n   185→    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n   186→}\n   187→\n   188→test \"run detects uninitialized workspace\" {\n   189→    const allocator = std.testing.allocator;\n   190→\n   191→    const history_args = args.HistoryArgs{ .id = \"bd-test\" };\n   192→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   193→\n   194→    const result = run(history_args, global, allocator);\n   195→    try std.testing.expectError(HistoryError.WorkspaceNotInitialized, result);\n   196→}\n   197→\n   198→test \"truncate handles short strings\" {\n   199→    const short = \"hello\";\n   200→    try std.testing.expectEqualStrings(\"hello\", truncate(short, 10));\n   201→}\n   202→\n   203→test \"truncate handles long strings\" {\n   204→    const long = \"this is a very long string that should be truncated\";\n   205→    const truncated = truncate(long, 10);\n   206→    try std.testing.expectEqual(@as(usize, 10), truncated.len);\n   207→}\n   208→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"06dfbd82-6199-4032-a1af-3e33a6e94e81"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VbiiDdSvFYiSfNSEz72n31","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CGnKZpKsESPy6sFWJW3vCN","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/events.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":15742,"cache_read_input_tokens":20851,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15742},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7e0ea516-9a0c-45b0-ac18-360caf8dcce6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CGnKZpKsESPy6sFWJW3vCN","type":"tool_result","content":"     1→//! Event storage for beads_zig audit trail.\n     2→//!\n     3→//! Provides persistent storage for audit events, recording all changes\n     4→//! to issues, dependencies, labels, and comments. Events are stored in\n     5→//! a JSONL file (events.jsonl) in chronological order.\n     6→//!\n     7→//! Design:\n     8→//! - Events are append-only (never modified once written)\n     9→//! - Events use auto-incrementing IDs\n    10→//! - Events are stored with the issue ID for efficient filtering\n    11→//! - Events can be replayed to reconstruct issue history\n    12→\n    13→const std = @import(\"std\");\n    14→const fs = std.fs;\n    15→const Event = @import(\"../models/event.zig\").Event;\n    16→const EventType = @import(\"../models/event.zig\").EventType;\n    17→\n    18→pub const EventStoreError = error{\n    19→    WriteError,\n    20→    ParseError,\n    21→    FileNotFound,\n    22→    OutOfMemory,\n    23→};\n    24→\n    25→/// Persistent store for audit events.\n    26→pub const EventStore = struct {\n    27→    allocator: std.mem.Allocator,\n    28→    events_path: []const u8,\n    29→    next_id: i64,\n    30→\n    31→    const Self = @This();\n    32→\n    33→    pub fn init(allocator: std.mem.Allocator, events_path: []const u8) Self {\n    34→        return .{\n    35→            .allocator = allocator,\n    36→            .events_path = events_path,\n    37→            .next_id = 1,\n    38→        };\n    39→    }\n    40→\n    41→    /// Load existing events to determine next ID.\n    42→    /// Call this after init to ensure IDs are unique.\n    43→    pub fn loadNextId(self: *Self) !void {\n    44→        const file = fs.cwd().openFile(self.events_path, .{}) catch |err| switch (err) {\n    45→            error.FileNotFound => return, // Start from 1\n    46→            else => return err,\n    47→        };\n    48→        defer file.close();\n    49→\n    50→        const content = file.readToEndAlloc(self.allocator, 100 * 1024 * 1024) catch return EventStoreError.ParseError;\n    51→        defer self.allocator.free(content);\n    52→\n    53→        var max_id: i64 = 0;\n    54→        var line_start: usize = 0;\n    55→        for (content, 0..) |c, i| {\n    56→            if (c == '\\n') {\n    57→                const line = content[line_start..i];\n    58→                line_start = i + 1;\n    59→\n    60→                if (line.len == 0) continue;\n    61→\n    62→                if (self.parseEventId(line)) |id| {\n    63→                    if (id > max_id) max_id = id;\n    64→                }\n    65→            }\n    66→        }\n    67→\n    68→        // Handle last line\n    69→        if (line_start < content.len) {\n    70→            const line = content[line_start..];\n    71→            if (line.len > 0) {\n    72→                if (self.parseEventId(line)) |id| {\n    73→                    if (id > max_id) max_id = id;\n    74→                }\n    75→            }\n    76→        }\n    77→\n    78→        self.next_id = max_id + 1;\n    79→    }\n    80→\n    81→    /// Parse just the ID from a JSON event line.\n    82→    fn parseEventId(self: *Self, line: []const u8) ?i64 {\n    83→        const parsed = std.json.parseFromSlice(\n    84→            struct { id: i64 },\n    85→            self.allocator,\n    86→            line,\n    87→            .{ .ignore_unknown_fields = true },\n    88→        ) catch return null;\n    89→        defer parsed.deinit();\n    90→        return parsed.value.id;\n    91→    }\n    92→\n    93→    /// Append an event to the store.\n    94→    /// Returns the assigned event ID.\n    95→    pub fn append(self: *Self, event: Event) !i64 {\n    96→        const dir = fs.cwd();\n    97→\n    98→        // Ensure parent directory exists\n    99→        if (std.fs.path.dirname(self.events_path)) |parent| {\n   100→            dir.makePath(parent) catch |err| switch (err) {\n   101→                error.PathAlreadyExists => {},\n   102→                else => return err,\n   103→            };\n   104→        }\n   105→\n   106→        // Open or create file in append mode\n   107→        const file = dir.createFile(self.events_path, .{\n   108→            .truncate = false,\n   109→        }) catch return EventStoreError.WriteError;\n   110→        defer file.close();\n   111→\n   112→        // Seek to end\n   113→        file.seekFromEnd(0) catch return EventStoreError.WriteError;\n   114→\n   115→        // Assign ID\n   116→        const event_id = self.next_id;\n   117→        self.next_id += 1;\n   118→\n   119→        // Create event with assigned ID\n   120→        const stored_event = Event{\n   121→            .id = event_id,\n   122→            .issue_id = event.issue_id,\n   123→            .event_type = event.event_type,\n   124→            .actor = event.actor,\n   125→            .old_value = event.old_value,\n   126→            .new_value = event.new_value,\n   127→            .created_at = event.created_at,\n   128→        };\n   129→\n   130→        // Serialize\n   131→        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, stored_event, .{}) catch return EventStoreError.WriteError;\n   132→        defer self.allocator.free(json_bytes);\n   133→\n   134→        // Write\n   135→        file.writeAll(json_bytes) catch return EventStoreError.WriteError;\n   136→        file.writeAll(\"\\n\") catch return EventStoreError.WriteError;\n   137→\n   138→        // fsync for durability\n   139→        file.sync() catch return EventStoreError.WriteError;\n   140→\n   141→        return event_id;\n   142→    }\n   143→\n   144→    /// Get all events for a specific issue.\n   145→    pub fn getEventsForIssue(self: *Self, issue_id: []const u8) ![]Event {\n   146→        return self.queryEvents(.{ .issue_id = issue_id });\n   147→    }\n   148→\n   149→    /// Get all events (project-wide audit log).\n   150→    pub fn getAllEvents(self: *Self) ![]Event {\n   151→        return self.queryEvents(.{});\n   152→    }\n   153→\n   154→    /// Query parameters for filtering events.\n   155→    pub const QueryParams = struct {\n   156→        issue_id: ?[]const u8 = null,\n   157→        event_type: ?EventType = null,\n   158→        actor: ?[]const u8 = null,\n   159→        since: ?i64 = null, // Events after this timestamp\n   160→        until: ?i64 = null, // Events before this timestamp\n   161→        limit: ?usize = null,\n   162→    };\n   163→\n   164→    /// Query events with optional filters.\n   165→    pub fn queryEvents(self: *Self, params: QueryParams) ![]Event {\n   166→        const file = fs.cwd().openFile(self.events_path, .{}) catch |err| switch (err) {\n   167→            error.FileNotFound => return &[_]Event{},\n   168→            else => return err,\n   169→        };\n   170→        defer file.close();\n   171→\n   172→        const content = file.readToEndAlloc(self.allocator, 100 * 1024 * 1024) catch return EventStoreError.ParseError;\n   173→        defer self.allocator.free(content);\n   174→\n   175→        var events: std.ArrayListUnmanaged(Event) = .{};\n   176→        errdefer {\n   177→            for (events.items) |*e| {\n   178→                self.freeEvent(e);\n   179→            }\n   180→            events.deinit(self.allocator);\n   181→        }\n   182→\n   183→        var line_start: usize = 0;\n   184→        for (content, 0..) |c, i| {\n   185→            if (c == '\\n') {\n   186→                const line = content[line_start..i];\n   187→                line_start = i + 1;\n   188→\n   189→                if (line.len == 0) continue;\n   190→\n   191→                if (self.parseAndFilterEvent(line, params)) |event| {\n   192→                    try events.append(self.allocator, event);\n   193→\n   194→                    // Check limit\n   195→                    if (params.limit) |lim| {\n   196→                        if (events.items.len >= lim) break;\n   197→                    }\n   198→                }\n   199→            }\n   200→        }\n   201→\n   202→        // Handle last line\n   203→        if (line_start < content.len) {\n   204→            const line = content[line_start..];\n   205→            if (line.len > 0) {\n   206→                if (self.parseAndFilterEvent(line, params)) |event| {\n   207→                    const should_add = if (params.limit) |lim| events.items.len < lim else true;\n   208→                    if (should_add) {\n   209→                        try events.append(self.allocator, event);\n   210→                    } else {\n   211→                        var e = event;\n   212→                        self.freeEvent(&e);\n   213→                    }\n   214→                }\n   215→            }\n   216→        }\n   217→\n   218→        return events.toOwnedSlice(self.allocator);\n   219→    }\n   220→\n   221→    /// Parse an event line and check if it matches filters.\n   222→    fn parseAndFilterEvent(self: *Self, line: []const u8, params: QueryParams) ?Event {\n   223→        const parsed = std.json.parseFromSlice(Event, self.allocator, line, .{\n   224→            .ignore_unknown_fields = true,\n   225→            .allocate = .alloc_always,\n   226→        }) catch return null;\n   227→\n   228→        const event = parsed.value;\n   229→\n   230→        // Apply filters\n   231→        if (params.issue_id) |id| {\n   232→            if (!std.mem.eql(u8, event.issue_id, id)) {\n   233→                parsed.deinit();\n   234→                return null;\n   235→            }\n   236→        }\n   237→        if (params.event_type) |et| {\n   238→            if (event.event_type != et) {\n   239→                parsed.deinit();\n   240→                return null;\n   241→            }\n   242→        }\n   243→        if (params.actor) |a| {\n   244→            if (!std.mem.eql(u8, event.actor, a)) {\n   245→                parsed.deinit();\n   246→                return null;\n   247→            }\n   248→        }\n   249→        if (params.since) |s| {\n   250→            if (event.created_at < s) {\n   251→                parsed.deinit();\n   252→                return null;\n   253→            }\n   254→        }\n   255→        if (params.until) |u| {\n   256→            if (event.created_at > u) {\n   257→                parsed.deinit();\n   258→                return null;\n   259→            }\n   260→        }\n   261→\n   262→        // Clone strings since parsed will be freed\n   263→        const issue_id = self.allocator.dupe(u8, event.issue_id) catch {\n   264→            parsed.deinit();\n   265→            return null;\n   266→        };\n   267→        errdefer self.allocator.free(issue_id);\n   268→\n   269→        const actor = self.allocator.dupe(u8, event.actor) catch {\n   270→            parsed.deinit();\n   271→            return null;\n   272→        };\n   273→        errdefer self.allocator.free(actor);\n   274→\n   275→        const old_value = if (event.old_value) |v| self.allocator.dupe(u8, v) catch {\n   276→            parsed.deinit();\n   277→            return null;\n   278→        } else null;\n   279→        errdefer if (old_value) |v| self.allocator.free(v);\n   280→\n   281→        const new_value = if (event.new_value) |v| self.allocator.dupe(u8, v) catch {\n   282→            parsed.deinit();\n   283→            return null;\n   284→        } else null;\n   285→\n   286→        parsed.deinit();\n   287→        return Event{\n   288→            .id = event.id,\n   289→            .issue_id = issue_id,\n   290→            .event_type = event.event_type,\n   291→            .actor = actor,\n   292→            .old_value = old_value,\n   293→            .new_value = new_value,\n   294→            .created_at = event.created_at,\n   295→        };\n   296→    }\n   297→\n   298→    /// Free an event's allocated strings.\n   299→    pub fn freeEvent(self: *Self, event: *Event) void {\n   300→        self.allocator.free(event.issue_id);\n   301→        self.allocator.free(event.actor);\n   302→        if (event.old_value) |v| self.allocator.free(v);\n   303→        if (event.new_value) |v| self.allocator.free(v);\n   304→    }\n   305→\n   306→    /// Free a slice of events.\n   307→    pub fn freeEvents(self: *Self, events: []Event) void {\n   308→        for (events) |*e| {\n   309→            self.freeEvent(e);\n   310→        }\n   311→        self.allocator.free(events);\n   312→    }\n   313→\n   314→    /// Get the total count of events.\n   315→    pub fn count(self: *Self) !usize {\n   316→        const events = try self.getAllEvents();\n   317→        defer self.freeEvents(events);\n   318→        return events.len;\n   319→    }\n   320→\n   321→    /// Check if the events file exists.\n   322→    pub fn exists(self: *Self) bool {\n   323→        fs.cwd().access(self.events_path, .{}) catch return false;\n   324→        return true;\n   325→    }\n   326→};\n   327→\n   328→// --- Tests ---\n   329→\n   330→const test_util = @import(\"../test_util.zig\");\n   331→\n   332→test \"EventStore.init\" {\n   333→    const allocator = std.testing.allocator;\n   334→    const store = EventStore.init(allocator, \"test/events.jsonl\");\n   335→    try std.testing.expectEqual(@as(i64, 1), store.next_id);\n   336→}\n   337→\n   338→test \"EventStore.append and query\" {\n   339→    const allocator = std.testing.allocator;\n   340→    const test_dir = try test_util.createTestDir(allocator, \"events_append\");\n   341→    defer allocator.free(test_dir);\n   342→    defer test_util.cleanupTestDir(test_dir);\n   343→\n   344→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   345→    defer allocator.free(events_path);\n   346→\n   347→    var store = EventStore.init(allocator, events_path);\n   348→\n   349→    // Append an event\n   350→    const event = Event.issueCreated(\"bd-test1\", \"alice@example.com\", 1706540000);\n   351→    const id = try store.append(event);\n   352→\n   353→    try std.testing.expectEqual(@as(i64, 1), id);\n   354→\n   355→    // Query events\n   356→    const events = try store.getEventsForIssue(\"bd-test1\");\n   357→    defer store.freeEvents(events);\n   358→\n   359→    try std.testing.expectEqual(@as(usize, 1), events.len);\n   360→    try std.testing.expectEqualStrings(\"bd-test1\", events[0].issue_id);\n   361→    try std.testing.expectEqual(EventType.created, events[0].event_type);\n   362→}\n   363→\n   364→test \"EventStore.append assigns sequential IDs\" {\n   365→    const allocator = std.testing.allocator;\n   366→    const test_dir = try test_util.createTestDir(allocator, \"events_seq_ids\");\n   367→    defer allocator.free(test_dir);\n   368→    defer test_util.cleanupTestDir(test_dir);\n   369→\n   370→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   371→    defer allocator.free(events_path);\n   372→\n   373→    var store = EventStore.init(allocator, events_path);\n   374→\n   375→    const id1 = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   376→    const id2 = try store.append(Event.issueCreated(\"bd-2\", \"alice\", 1706540001));\n   377→    const id3 = try store.append(Event.issueCreated(\"bd-3\", \"alice\", 1706540002));\n   378→\n   379→    try std.testing.expectEqual(@as(i64, 1), id1);\n   380→    try std.testing.expectEqual(@as(i64, 2), id2);\n   381→    try std.testing.expectEqual(@as(i64, 3), id3);\n   382→}\n   383→\n   384→test \"EventStore.loadNextId resumes from existing events\" {\n   385→    const allocator = std.testing.allocator;\n   386→    const test_dir = try test_util.createTestDir(allocator, \"events_load_id\");\n   387→    defer allocator.free(test_dir);\n   388→    defer test_util.cleanupTestDir(test_dir);\n   389→\n   390→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   391→    defer allocator.free(events_path);\n   392→\n   393→    // Create some events\n   394→    {\n   395→        var store = EventStore.init(allocator, events_path);\n   396→        _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   397→        _ = try store.append(Event.issueCreated(\"bd-2\", \"alice\", 1706540001));\n   398→        _ = try store.append(Event.issueCreated(\"bd-3\", \"alice\", 1706540002));\n   399→    }\n   400→\n   401→    // Reopen store and load next ID\n   402→    {\n   403→        var store = EventStore.init(allocator, events_path);\n   404→        try store.loadNextId();\n   405→\n   406→        try std.testing.expectEqual(@as(i64, 4), store.next_id);\n   407→\n   408→        // Append should use next ID\n   409→        const id = try store.append(Event.issueCreated(\"bd-4\", \"alice\", 1706540003));\n   410→        try std.testing.expectEqual(@as(i64, 4), id);\n   411→    }\n   412→}\n   413→\n   414→test \"EventStore.queryEvents filters by issue_id\" {\n   415→    const allocator = std.testing.allocator;\n   416→    const test_dir = try test_util.createTestDir(allocator, \"events_filter_issue\");\n   417→    defer allocator.free(test_dir);\n   418→    defer test_util.cleanupTestDir(test_dir);\n   419→\n   420→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   421→    defer allocator.free(events_path);\n   422→\n   423→    var store = EventStore.init(allocator, events_path);\n   424→\n   425→    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   426→    _ = try store.append(Event.issueCreated(\"bd-2\", \"bob\", 1706540001));\n   427→    _ = try store.append(Event.issueReopened(\"bd-1\", \"charlie\", 1706540002));\n   428→\n   429→    const events = try store.getEventsForIssue(\"bd-1\");\n   430→    defer store.freeEvents(events);\n   431→\n   432→    try std.testing.expectEqual(@as(usize, 2), events.len);\n   433→    for (events) |e| {\n   434→        try std.testing.expectEqualStrings(\"bd-1\", e.issue_id);\n   435→    }\n   436→}\n   437→\n   438→test \"EventStore.queryEvents filters by event_type\" {\n   439→    const allocator = std.testing.allocator;\n   440→    const test_dir = try test_util.createTestDir(allocator, \"events_filter_type\");\n   441→    defer allocator.free(test_dir);\n   442→    defer test_util.cleanupTestDir(test_dir);\n   443→\n   444→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   445→    defer allocator.free(events_path);\n   446→\n   447→    var store = EventStore.init(allocator, events_path);\n   448→\n   449→    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   450→    _ = try store.append(Event.issueReopened(\"bd-1\", \"bob\", 1706540001));\n   451→    _ = try store.append(Event.issueCreated(\"bd-2\", \"charlie\", 1706540002));\n   452→\n   453→    const events = try store.queryEvents(.{ .event_type = .created });\n   454→    defer store.freeEvents(events);\n   455→\n   456→    try std.testing.expectEqual(@as(usize, 2), events.len);\n   457→    for (events) |e| {\n   458→        try std.testing.expectEqual(EventType.created, e.event_type);\n   459→    }\n   460→}\n   461→\n   462→test \"EventStore.queryEvents returns empty for missing file\" {\n   463→    const allocator = std.testing.allocator;\n   464→\n   465→    var store = EventStore.init(allocator, \"/nonexistent/events.jsonl\");\n   466→    const events = try store.getAllEvents();\n   467→    defer store.freeEvents(events);\n   468→\n   469→    try std.testing.expectEqual(@as(usize, 0), events.len);\n   470→}\n   471→\n   472→test \"EventStore.count\" {\n   473→    const allocator = std.testing.allocator;\n   474→    const test_dir = try test_util.createTestDir(allocator, \"events_count\");\n   475→    defer allocator.free(test_dir);\n   476→    defer test_util.cleanupTestDir(test_dir);\n   477→\n   478→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   479→    defer allocator.free(events_path);\n   480→\n   481→    var store = EventStore.init(allocator, events_path);\n   482→\n   483→    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   484→    _ = try store.append(Event.issueCreated(\"bd-2\", \"bob\", 1706540001));\n   485→    _ = try store.append(Event.issueCreated(\"bd-3\", \"charlie\", 1706540002));\n   486→\n   487→    const total = try store.count();\n   488→    try std.testing.expectEqual(@as(usize, 3), total);\n   489→}\n   490→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"317e8892-09bc-4190-bb75-1cfa9488b646"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01D1iuHqy5YmCFj58ndjpsEr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CeG3778SZXsJG9fDJx9iN1","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/issue.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13190,"cache_read_input_tokens":36593,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13190},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"dd18711f-6c11-4e5a-b57f-9a7850f8387a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CeG3778SZXsJG9fDJx9iN1","type":"tool_result","content":"     1→//! Issue struct - the primary entity in beads_zig.\n     2→//!\n     3→//! Issues track tasks, bugs, features, and other work items. All fields align\n     4→//! with beads_rust for JSONL compatibility. Timestamps are Unix epoch internally\n     5→//! but serialize to RFC3339 format in JSON for JSONL export.\n     6→\n     7→const std = @import(\"std\");\n     8→const Status = @import(\"status.zig\").Status;\n     9→const Priority = @import(\"priority.zig\").Priority;\n    10→const IssueType = @import(\"issue_type.zig\").IssueType;\n    11→const Dependency = @import(\"dependency.zig\").Dependency;\n    12→const Comment = @import(\"comment.zig\").Comment;\n    13→const timestamp = @import(\"timestamp.zig\");\n    14→\n    15→/// Validation errors for Issue.\n    16→pub const IssueError = error{\n    17→    EmptyTitle,\n    18→    TitleTooLong,\n    19→    EmptyId,\n    20→};\n    21→\n    22→/// RFC3339 timestamp wrapper for JSON serialization.\n    23→/// Stores Unix epoch internally but serializes as RFC3339 string.\n    24→pub const Rfc3339Timestamp = struct {\n    25→    value: i64,\n    26→\n    27→    const Self = @This();\n    28→\n    29→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    30→        const epoch_seconds = std.time.epoch.EpochSeconds{ .secs = @intCast(self.value) };\n    31→        const day_seconds = epoch_seconds.getDaySeconds();\n    32→        const epoch_day = epoch_seconds.getEpochDay();\n    33→        const year_day = epoch_day.calculateYearDay();\n    34→        const month_day = year_day.calculateMonthDay();\n    35→\n    36→        var buf: [25]u8 = undefined;\n    37→        const formatted = std.fmt.bufPrint(&buf, \"{d:0>4}-{d:0>2}-{d:0>2}T{d:0>2}:{d:0>2}:{d:0>2}Z\", .{\n    38→            year_day.year,\n    39→            @as(u32, month_day.month.numeric()),\n    40→            @as(u32, month_day.day_index) + 1,\n    41→            day_seconds.getHoursIntoDay(),\n    42→            day_seconds.getMinutesIntoHour(),\n    43→            day_seconds.getSecondsIntoMinute(),\n    44→        }) catch unreachable;\n    45→\n    46→        try jws.write(formatted);\n    47→    }\n    48→\n    49→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    50→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    51→        const str = switch (token) {\n    52→            .string, .allocated_string => |s| s,\n    53→            else => return error.UnexpectedToken,\n    54→        };\n    55→        return Self{ .value = timestamp.parseRfc3339(str) orelse return error.InvalidCharacter };\n    56→    }\n    57→\n    58→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    59→        _ = allocator;\n    60→        _ = options;\n    61→        return switch (source) {\n    62→            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    63→            .integer => |i| Self{ .value = i },\n    64→            else => error.UnexpectedToken,\n    65→        };\n    66→    }\n    67→};\n    68→\n    69→/// Optional RFC3339 timestamp wrapper for nullable timestamp fields.\n    70→pub const OptionalRfc3339Timestamp = struct {\n    71→    value: ?i64,\n    72→\n    73→    const Self = @This();\n    74→\n    75→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    76→        if (self.value) |v| {\n    77→            const ts = Rfc3339Timestamp{ .value = v };\n    78→            try ts.jsonStringify(jws);\n    79→        } else {\n    80→            try jws.write(null);\n    81→        }\n    82→    }\n    83→\n    84→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    85→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    86→        return switch (token) {\n    87→            .null => Self{ .value = null },\n    88→            .string, .allocated_string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    89→            else => error.UnexpectedToken,\n    90→        };\n    91→    }\n    92→\n    93→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    94→        _ = allocator;\n    95→        _ = options;\n    96→        return switch (source) {\n    97→            .null => Self{ .value = null },\n    98→            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    99→            .integer => |i| Self{ .value = i },\n   100→            else => error.UnexpectedToken,\n   101→        };\n   102→    }\n   103→};\n   104→\n   105→/// The primary issue entity. All fields align with beads_rust for JSONL compatibility.\n   106→pub const Issue = struct {\n   107→    // Identity\n   108→    id: []const u8,\n   109→    content_hash: ?[]const u8,\n   110→\n   111→    // Content\n   112→    title: []const u8,\n   113→    description: ?[]const u8,\n   114→    design: ?[]const u8,\n   115→    acceptance_criteria: ?[]const u8,\n   116→    notes: ?[]const u8,\n   117→\n   118→    // Classification\n   119→    status: Status,\n   120→    priority: Priority,\n   121→    issue_type: IssueType,\n   122→\n   123→    // Assignment\n   124→    assignee: ?[]const u8,\n   125→    owner: ?[]const u8,\n   126→\n   127→    // Timestamps (Unix epoch seconds, serialized as RFC3339)\n   128→    created_at: Rfc3339Timestamp,\n   129→    created_by: ?[]const u8,\n   130→    updated_at: Rfc3339Timestamp,\n   131→    closed_at: OptionalRfc3339Timestamp,\n   132→    close_reason: ?[]const u8,\n   133→    closed_by_session: ?[]const u8 = null,\n   134→\n   135→    // Scheduling\n   136→    due_at: OptionalRfc3339Timestamp,\n   137→    defer_until: OptionalRfc3339Timestamp,\n   138→    estimated_minutes: ?i32,\n   139→\n   140→    // External references\n   141→    external_ref: ?[]const u8,\n   142→    source_system: ?[]const u8,\n   143→\n   144→    // Flags\n   145→    pinned: bool,\n   146→    is_template: bool,\n   147→    ephemeral: bool = false, // Local-only, not written to JSONL\n   148→\n   149→    // Version for optimistic locking (incremented on every update)\n   150→    version: u64 = 1,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"61da6697-83b7-4f33-bbde-c62f4ad22640"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01D1iuHqy5YmCFj58ndjpsEr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MGeiGDxHmhE83ia11Jm2wX","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13190,"cache_read_input_tokens":36593,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13190},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2cd72677-aa9f-438e-80bf-a825e5e9c1b4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MGeiGDxHmhE83ia11Jm2wX","type":"tool_result","content":"     1→//! CLI command implementations for beads_zig.\n     2→//!\n     3→//! This module handles argument parsing and dispatches to the appropriate\n     4→//! command handlers (create, list, show, update, close, sync, etc.).\n     5→//!\n     6→//! All commands support --json output for machine-readable responses.\n     7→\n     8→const std = @import(\"std\");\n     9→\n    10→pub const args = @import(\"args.zig\");\n    11→pub const common = @import(\"common.zig\");\n    12→pub const init = @import(\"init.zig\");\n    13→pub const create = @import(\"create.zig\");\n    14→pub const list = @import(\"list.zig\");\n    15→pub const show = @import(\"show.zig\");\n    16→pub const update = @import(\"update.zig\");\n    17→pub const close = @import(\"close.zig\");\n    18→pub const delete = @import(\"delete.zig\");\n    19→pub const ready = @import(\"ready.zig\");\n    20→pub const dep = @import(\"dep.zig\");\n    21→pub const graph = @import(\"graph.zig\");\n    22→pub const epic = @import(\"epic.zig\");\n    23→pub const sync = @import(\"sync.zig\");\n    24→pub const batch = @import(\"batch.zig\");\n    25→pub const search = @import(\"search.zig\");\n    26→pub const stale = @import(\"stale.zig\");\n    27→pub const count = @import(\"count.zig\");\n    28→pub const defer_cmd = @import(\"defer.zig\");\n    29→pub const label = @import(\"label.zig\");\n    30→pub const comments = @import(\"comments.zig\");\n    31→pub const history = @import(\"history.zig\");\n    32→pub const audit = @import(\"audit.zig\");\n    33→pub const changelog = @import(\"changelog.zig\");\n    34→pub const info = @import(\"info.zig\");\n    35→pub const stats = @import(\"stats.zig\");\n    36→pub const doctor = @import(\"doctor.zig\");\n    37→pub const config = @import(\"config.zig\");\n    38→pub const orphans = @import(\"orphans.zig\");\n    39→pub const lint = @import(\"lint.zig\");\n    40→pub const version = @import(\"version.zig\");\n    41→pub const schema = @import(\"schema.zig\");\n    42→pub const completions = @import(\"completions.zig\");\n    43→pub const metrics_cmd = @import(\"metrics.zig\");\n    44→pub const help = @import(\"help.zig\");\n    45→pub const query = @import(\"query.zig\");\n    46→pub const upgrade = @import(\"upgrade.zig\");\n    47→pub const where = @import(\"where.zig\");\n    48→\n    49→pub const ArgParser = args.ArgParser;\n    50→pub const ParseResult = args.ParseResult;\n    51→pub const ParseError = args.ParseError;\n    52→pub const GlobalOptions = args.GlobalOptions;\n    53→pub const Command = args.Command;\n    54→pub const InitArgs = args.InitArgs;\n    55→pub const CreateArgs = args.CreateArgs;\n    56→pub const QuickArgs = args.QuickArgs;\n    57→\n    58→pub const InitError = init.InitError;\n    59→pub const InitResult = init.InitResult;\n    60→pub const runInit = init.run;\n    61→\n    62→pub const CreateError = create.CreateError;\n    63→pub const CreateResult = create.CreateResult;\n    64→pub const runCreate = create.run;\n    65→pub const runQuick = create.runQuick;\n    66→\n    67→pub const ListError = list.ListError;\n    68→pub const ListResult = list.ListResult;\n    69→pub const runList = list.run;\n    70→\n    71→pub const ShowError = show.ShowError;\n    72→pub const ShowResult = show.ShowResult;\n    73→pub const runShow = show.run;\n    74→\n    75→pub const UpdateError = update.UpdateError;\n    76→pub const UpdateResult = update.UpdateResult;\n    77→pub const runUpdate = update.run;\n    78→\n    79→pub const CloseError = close.CloseError;\n    80→pub const CloseResult = close.CloseResult;\n    81→pub const runClose = close.run;\n    82→pub const runReopen = close.runReopen;\n    83→\n    84→pub const DeleteError = delete.DeleteError;\n    85→pub const DeleteResult = delete.DeleteResult;\n    86→pub const runDelete = delete.run;\n    87→\n    88→pub const ReadyError = ready.ReadyError;\n    89→pub const ReadyResult = ready.ReadyResult;\n    90→pub const runReady = ready.run;\n    91→pub const runBlocked = ready.runBlocked;\n    92→\n    93→pub const DepError = dep.DepError;\n    94→pub const DepResult = dep.DepResult;\n    95→pub const runDep = dep.run;\n    96→\n    97→pub const GraphError = graph.GraphError;\n    98→pub const GraphResult = graph.GraphResult;\n    99→pub const runGraph = graph.run;\n   100→\n   101→pub const EpicError = epic.EpicError;\n   102→pub const EpicResult = epic.EpicResult;\n   103→pub const runEpic = epic.run;\n   104→\n   105→pub const SyncError = sync.SyncError;\n   106→pub const SyncResult = sync.SyncResult;\n   107→pub const runSync = sync.run;\n   108→\n   109→pub const backup = @import(\"backup.zig\");\n   110→pub const BackupError = backup.BackupError;\n   111→pub const BackupResult = backup.BackupResult;\n   112→pub const runBackup = backup.run;\n   113→pub const BackupArgs = args.BackupArgs;\n   114→\n   115→pub const BatchError = batch.BatchError;\n   116→pub const BatchResult = batch.BatchResult;\n   117→pub const ImportResult = batch.ImportResult;\n   118→pub const runAddBatch = batch.runAddBatch;\n   119→pub const runImportCmd = batch.runImport;\n   120→\n   121→pub const AddBatchArgs = args.AddBatchArgs;\n   122→pub const BatchFormat = args.BatchFormat;\n   123→pub const ImportArgs = args.ImportArgs;\n   124→pub const EpicArgs = args.EpicArgs;\n   125→pub const SortField = args.SortField;\n   126→\n   127→pub const SearchError = search.SearchError;\n   128→pub const SearchResult = search.SearchResult;\n   129→pub const runSearch = search.run;\n   130→\n   131→pub const runStale = stale.run;\n   132→\n   133→pub const runCount = count.run;\n   134→\n   135→pub const runDefer = defer_cmd.run;\n   136→pub const runUndefer = defer_cmd.runUndefer;\n   137→\n   138→pub const LabelError = label.LabelError;\n   139→pub const LabelResult = label.LabelResult;\n   140→pub const runLabel = label.run;\n   141→\n   142→pub const CommentsError = comments.CommentsError;\n   143→pub const CommentsResult = comments.CommentsResult;\n   144→pub const runComments = comments.run;\n   145→\n   146→pub const HistoryError = history.HistoryError;\n   147→pub const HistoryResult = history.HistoryResult;\n   148→pub const runHistory = history.run;\n   149→\n   150→pub const AuditError = audit.AuditError;\n   151→pub const AuditResult = audit.AuditResult;\n   152→pub const runAudit = audit.run;\n   153→\n   154→pub const ChangelogError = changelog.ChangelogError;\n   155→pub const ChangelogResult = changelog.ChangelogResult;\n   156→pub const runChangelog = changelog.run;\n   157→pub const ChangelogArgs = args.ChangelogArgs;\n   158→\n   159→pub const InfoError = info.InfoError;\n   160→pub const InfoResult = info.InfoResult;\n   161→pub const runInfo = info.run;\n   162→\n   163→pub const StatsError = stats.StatsError;\n   164→pub const StatsResult = stats.StatsResult;\n   165→pub const runStats = stats.run;\n   166→\n   167→pub const DoctorError = doctor.DoctorError;\n   168→pub const DoctorResult = doctor.DoctorResult;\n   169→pub const runDoctor = doctor.run;\n   170→\n   171→pub const ConfigError = config.ConfigError;\n   172→pub const ConfigResult = config.ConfigResult;\n   173→pub const runConfig = config.run;\n   174→\n   175→pub const OrphansError = orphans.OrphansError;\n   176→pub const OrphansResult = orphans.OrphansResult;\n   177→pub const runOrphans = orphans.run;\n   178→\n   179→pub const LintError = lint.LintError;\n   180→pub const LintResult = lint.LintResult;\n   181→pub const runLint = lint.run;\n   182→\n   183→pub const OrphansArgs = args.OrphansArgs;\n   184→pub const LintArgs = args.LintArgs;\n   185→\n   186→pub const VersionError = version.VersionError;\n   187→pub const VersionResult = version.VersionResult;\n   188→pub const runVersion = version.run;\n   189→pub const VERSION = version.VERSION;\n   190→\n   191→pub const SchemaError = schema.SchemaError;\n   192→pub const SchemaResult = schema.SchemaResult;\n   193→pub const runSchema = schema.run;\n   194→\n   195→pub const CompletionsError = completions.CompletionsError;\n   196→pub const CompletionsResult = completions.CompletionsResult;\n   197→pub const runCompletions = completions.run;\n   198→pub const Shell = completions.Shell;\n   199→\n   200→pub const MetricsError = metrics_cmd.MetricsError;\n   201→pub const MetricsResult = metrics_cmd.MetricsResult;\n   202→pub const runMetrics = metrics_cmd.run;\n   203→pub const MetricsArgs = args.MetricsArgs;\n   204→\n   205→pub const HelpError = help.HelpError;\n   206→pub const HelpResult = help.HelpResult;\n   207→pub const runHelp = help.run;\n   208→\n   209→pub const QueryError = query.QueryError;\n   210→pub const QueryResult = query.QueryResult;\n   211→pub const runQuery = query.run;\n   212→pub const QueryArgs = args.QueryArgs;\n   213→\n   214→pub const UpgradeError = upgrade.UpgradeError;\n   215→pub const UpgradeResult = upgrade.UpgradeResult;\n   216→pub const runUpgrade = upgrade.run;\n   217→pub const UpgradeArgs = args.UpgradeArgs;\n   218→\n   219→pub const WhereError = where.WhereError;\n   220→pub const WhereResult = where.WhereResult;\n   221→pub const runWhere = where.run;\n   222→\n   223→test {\n   224→    std.testing.refAllDecls(@This());\n   225→}\n   226→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d4e04f13-759d-4485-a7a9-ddd60285d13d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01D1iuHqy5YmCFj58ndjpsEr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RzwWXKM9iBJfq5qPUNXd3C","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13190,"cache_read_input_tokens":36593,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13190},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a62a1515-731a-43dc-a244-3f04f3a4033f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RzwWXKM9iBJfq5qPUNXd3C","type":"tool_result","content":"     1→//! beads_zig CLI entry point.\n     2→//!\n     3→//! Binary name: bz (beads-zig)\n     4→\n     5→const std = @import(\"std\");\n     6→const beads_zig = @import(\"beads_zig\");\n     7→const cli = beads_zig.cli;\n     8→const output = beads_zig.output;\n     9→\n    10→pub fn main() !void {\n    11→    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    12→    defer _ = gpa.deinit();\n    13→    const allocator = gpa.allocator();\n    14→\n    15→    run(allocator) catch |err| {\n    16→        const stderr = std.fs.File.stderr();\n    17→        stderr.writeAll(\"error: \") catch {};\n    18→        stderr.writeAll(@errorName(err)) catch {};\n    19→        stderr.writeAll(\"\\n\") catch {};\n    20→        std.process.exit(1);\n    21→    };\n    22→}\n    23→\n    24→fn run(allocator: std.mem.Allocator) !void {\n    25→    const args = try std.process.argsAlloc(allocator);\n    26→    defer std.process.argsFree(allocator, args);\n    27→\n    28→    // Skip program name\n    29→    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n    30→\n    31→    var parser = cli.ArgParser.init(allocator, cmd_args);\n    32→    var result = parser.parse() catch |err| {\n    33→        return handleParseError(err, allocator);\n    34→    };\n    35→    defer result.deinit(allocator);\n    36→\n    37→    try dispatch(result, allocator);\n    38→}\n    39→\n    40→fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    41→    switch (result.command) {\n    42→        .init => |init_args| {\n    43→            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n    44→                error.AlreadyInitialized => std.process.exit(1),\n    45→                else => return err,\n    46→            };\n    47→        },\n    48→        .create => |create_args| {\n    49→            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n    50→                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n    51→                else => return err,\n    52→            };\n    53→        },\n    54→        .q => |quick_args| {\n    55→            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n    56→                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n    57→                else => return err,\n    58→            };\n    59→        },\n    60→        .list => |list_args| {\n    61→            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n    62→                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n    63→                else => return err,\n    64→            };\n    65→        },\n    66→        .show => |show_args| {\n    67→            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n    68→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n    69→                else => return err,\n    70→            };\n    71→        },\n    72→        .update => |update_args| {\n    73→            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n    74→                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n    75→                else => return err,\n    76→            };\n    77→        },\n    78→        .close => |close_args| {\n    79→            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n    80→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n    81→                else => return err,\n    82→            };\n    83→        },\n    84→        .reopen => |reopen_args| {\n    85→            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n    86→                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n    87→                else => return err,\n    88→            };\n    89→        },\n    90→        .delete => |delete_args| {\n    91→            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n    92→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n    93→                else => return err,\n    94→            };\n    95→        },\n    96→        .add_batch => |batch_args| {\n    97→            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n    98→                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n    99→                else => return err,\n   100→            };\n   101→        },\n   102→        .import_cmd => |import_args| {\n   103→            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n   104→                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n   105→                else => return err,\n   106→            };\n   107→        },\n   108→        .ready => |ready_args| {\n   109→            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n   110→                error.WorkspaceNotInitialized => std.process.exit(1),\n   111→                else => return err,\n   112→            };\n   113→        },\n   114→        .blocked => |blocked_args| {\n   115→            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n   116→                error.WorkspaceNotInitialized => std.process.exit(1),\n   117→                else => return err,\n   118→            };\n   119→        },\n   120→        .dep => |dep_args| {\n   121→            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n   122→                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n   123→                else => return err,\n   124→            };\n   125→        },\n   126→        .graph => |graph_args| {\n   127→            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n   128→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n   129→                else => return err,\n   130→            };\n   131→        },\n   132→        .epic => |epic_args| {\n   133→            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n   134→                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n   135→                else => return err,\n   136→            };\n   137→        },\n   138→        .sync => |sync_args| {\n   139→            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n   140→                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n   141→                else => return err,\n   142→            };\n   143→        },\n   144→        .backup => |backup_args| {\n   145→            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n   146→                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n   147→                else => return err,\n   148→            };\n   149→        },\n   150→        .search => |search_args| {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e47d8b55-947d-4fc8-8c87-a0d6e176574c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RVfdyNxygkEfUKBd1z2tBL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TgSf7cNSGoYdUNyMCnMwuc","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8147,"cache_read_input_tokens":49783,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8147},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b5d2520c-8567-4429-bc03-6d3150dad5af"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TgSf7cNSGoYdUNyMCnMwuc","type":"tool_result","content":"     1→//! In-memory issue store for beads_zig.\n     2→//!\n     3→//! Provides CRUD operations for issues using in-memory storage with:\n     4→//! - Arena allocator for issue memory management\n     5→//! - ArrayList + StringHashMap for fast ID lookup\n     6→//! - Dirty tracking for sync operations\n     7→//! - JSONL persistence via JsonlFile\n     8→\n     9→const std = @import(\"std\");\n    10→const JsonlFile = @import(\"jsonl.zig\").JsonlFile;\n    11→const Issue = @import(\"../models/issue.zig\").Issue;\n    12→const Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\n    13→const OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\n    14→const Status = @import(\"../models/status.zig\").Status;\n    15→const Priority = @import(\"../models/priority.zig\").Priority;\n    16→const IssueType = @import(\"../models/issue_type.zig\").IssueType;\n    17→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    18→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    19→const Comment = @import(\"../models/comment.zig\").Comment;\n    20→\n    21→pub const IssueStoreError = error{\n    22→    IssueNotFound,\n    23→    DuplicateId,\n    24→    InvalidIssue,\n    25→    VersionMismatch,\n    26→};\n    27→\n    28→/// Result of loading the store with corruption tracking.\n    29→pub const StoreLoadResult = struct {\n    30→    /// Number of corrupt JSONL entries skipped.\n    31→    jsonl_corruption_count: usize = 0,\n    32→    /// Line numbers of corrupt JSONL entries (1-indexed).\n    33→    jsonl_corrupt_lines: []const usize = &.{},\n    34→\n    35→    pub fn hasCorruption(self: StoreLoadResult) bool {\n    36→        return self.jsonl_corruption_count > 0;\n    37→    }\n    38→\n    39→    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n    40→        if (self.jsonl_corrupt_lines.len > 0) {\n    41→            allocator.free(self.jsonl_corrupt_lines);\n    42→        }\n    43→    }\n    44→};\n    45→\n    46→pub const IssueStore = struct {\n    47→    allocator: std.mem.Allocator,\n    48→    issues: std.ArrayListUnmanaged(Issue),\n    49→    id_index: std.StringHashMapUnmanaged(usize),\n    50→    dirty_ids: std.StringHashMapUnmanaged(i64),\n    51→    dirty: bool,\n    52→    jsonl_path: []const u8,\n    53→\n    54→    const Self = @This();\n    55→\n    56→    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n    57→        return .{\n    58→            .allocator = allocator,\n    59→            .issues = .{},\n    60→            .id_index = .{},\n    61→            .dirty_ids = .{},\n    62→            .dirty = false,\n    63→            .jsonl_path = jsonl_path,\n    64→        };\n    65→    }\n    66→\n    67→    pub fn deinit(self: *Self) void {\n    68→        for (self.issues.items) |*issue| {\n    69→            issue.deinit(self.allocator);\n    70→        }\n    71→        self.issues.deinit(self.allocator);\n    72→\n    73→        var id_it = self.id_index.keyIterator();\n    74→        while (id_it.next()) |key| {\n    75→            self.allocator.free(key.*);\n    76→        }\n    77→        self.id_index.deinit(self.allocator);\n    78→\n    79→        var dirty_it = self.dirty_ids.keyIterator();\n    80→        while (dirty_it.next()) |key| {\n    81→            self.allocator.free(key.*);\n    82→        }\n    83→        self.dirty_ids.deinit(self.allocator);\n    84→    }\n    85→\n    86→    /// Load issues from the JSONL file into memory.\n    87→    pub fn loadFromFile(self: *Self) !void {\n    88→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n    89→        const loaded_issues = try jsonl.readAll();\n    90→        defer self.allocator.free(loaded_issues);\n    91→\n    92→        for (loaded_issues) |issue| {\n    93→            const id_copy = try self.allocator.dupe(u8, issue.id);\n    94→            errdefer self.allocator.free(id_copy);\n    95→\n    96→            const idx = self.issues.items.len;\n    97→            try self.issues.append(self.allocator, issue);\n    98→            try self.id_index.put(self.allocator, id_copy, idx);\n    99→        }\n   100→\n   101→        self.dirty = false;\n   102→    }\n   103→\n   104→    /// Load issues from the JSONL file with graceful corruption recovery.\n   105→    /// Logs and skips corrupt entries instead of failing.\n   106→    /// Returns statistics about the load including corruption count.\n   107→    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n   108→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n   109→        var load_result = try jsonl.readAllWithRecovery();\n   110→        // Take ownership of corrupt_lines before freeing issues slice\n   111→        const corrupt_lines = load_result.corrupt_lines;\n   112→        load_result.corrupt_lines = &.{}; // Prevent double-free\n   113→        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n   114→\n   115→        const loaded_issues = load_result.issues;\n   116→        defer self.allocator.free(loaded_issues);\n   117→\n   118→        for (loaded_issues) |issue| {\n   119→            const id_copy = try self.allocator.dupe(u8, issue.id);\n   120→            errdefer self.allocator.free(id_copy);\n   121→\n   122→            const idx = self.issues.items.len;\n   123→            try self.issues.append(self.allocator, issue);\n   124→            try self.id_index.put(self.allocator, id_copy, idx);\n   125→        }\n   126→\n   127→        self.dirty = false;\n   128→\n   129→        return StoreLoadResult{\n   130→            .jsonl_corruption_count = load_result.corruption_count,\n   131→            .jsonl_corrupt_lines = corrupt_lines,\n   132→        };\n   133→    }\n   134→\n   135→    /// Save all issues to the JSONL file.\n   136→    pub fn saveToFile(self: *Self) !void {\n   137→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n   138→        try jsonl.writeAll(self.issues.items);\n   139→        self.dirty = false;\n   140→\n   141→        // Clear dirty tracking\n   142→        var dirty_it = self.dirty_ids.keyIterator();\n   143→        while (dirty_it.next()) |key| {\n   144→            self.allocator.free(key.*);\n   145→        }\n   146→        self.dirty_ids.clearRetainingCapacity();\n   147→    }\n   148→\n   149→    /// Insert a new issue into the store.\n   150→    pub fn insert(self: *Self, issue: Issue) !void {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8dbd1689-48b3-4e6d-b501-0ccd1b220070"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RVfdyNxygkEfUKBd1z2tBL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UBdCyonjjeFse6MwWABp2Q","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/mod.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8147,"cache_read_input_tokens":49783,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8147},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4b0f076b-8569-422f-ba03-2ca42937a18f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UBdCyonjjeFse6MwWABp2Q","type":"tool_result","content":"     1→//! Storage layer for beads_zig.\n     2→//!\n     3→//! Handles all persistence operations including:\n     4→//! - JSONL file I/O (read/write issues)\n     5→//! - In-memory issue storage with indexing\n     6→//! - Dependency graph management\n     7→//! - Dirty tracking for sync\n     8→//! - Write-Ahead Log (WAL) for concurrent writes\n     9→//! - WAL compaction for merging WAL into main file\n    10→//! - Generation numbers for read/compact race safety\n    11→\n    12→const std = @import(\"std\");\n    13→\n    14→pub const jsonl = @import(\"jsonl.zig\");\n    15→pub const store = @import(\"store.zig\");\n    16→pub const graph = @import(\"graph.zig\");\n    17→pub const issues = @import(\"issues.zig\");\n    18→pub const dependencies = @import(\"dependencies.zig\");\n    19→pub const lock = @import(\"lock.zig\");\n    20→pub const wal = @import(\"wal.zig\");\n    21→pub const compact = @import(\"compact.zig\");\n    22→pub const events = @import(\"events.zig\");\n    23→pub const generation = @import(\"generation.zig\");\n    24→pub const metrics = @import(\"metrics.zig\");\n    25→pub const txlog = @import(\"txlog.zig\");\n    26→pub const fscheck = @import(\"fscheck.zig\");\n    27→pub const mmap = @import(\"mmap.zig\");\n    28→pub const simd = @import(\"simd.zig\");\n    29→\n    30→pub const JsonlFile = jsonl.JsonlFile;\n    31→pub const JsonlError = jsonl.JsonlError;\n    32→pub const LoadResult = jsonl.LoadResult;\n    33→\n    34→pub const IssueStore = store.IssueStore;\n    35→pub const IssueStoreError = store.IssueStoreError;\n    36→pub const StoreLoadResult = store.StoreLoadResult;\n    37→\n    38→pub const DependencyGraph = graph.DependencyGraph;\n    39→pub const DependencyGraphError = graph.DependencyGraphError;\n    40→\n    41→pub const DependencyStore = dependencies.DependencyStore;\n    42→pub const DependencyStoreError = dependencies.DependencyStoreError;\n    43→\n    44→pub const BeadsLock = lock.BeadsLock;\n    45→pub const LockError = lock.LockError;\n    46→pub const withLock = lock.withLock;\n    47→pub const withLockContext = lock.withLockContext;\n    48→\n    49→pub const Wal = wal.Wal;\n    50→pub const WalEntry = wal.WalEntry;\n    51→pub const WalOp = wal.WalOp;\n    52→pub const WalError = wal.WalError;\n    53→pub const ReplayStats = wal.ReplayStats;\n    54→\n    55→pub const Compactor = compact.Compactor;\n    56→pub const CompactError = compact.CompactError;\n    57→pub const WalStats = compact.WalStats;\n    58→pub const CompactionThresholds = compact.CompactionThresholds;\n    59→\n    60→pub const EventStore = events.EventStore;\n    61→pub const EventStoreError = events.EventStoreError;\n    62→\n    63→pub const Generation = generation.Generation;\n    64→pub const GenerationError = generation.GenerationError;\n    65→\n    66→pub const LockMetrics = metrics.LockMetrics;\n    67→pub const getMetrics = metrics.getMetrics;\n    68→pub const resetMetrics = metrics.resetMetrics;\n    69→\n    70→pub const TxLog = txlog.TxLog;\n    71→pub const LogEntry = txlog.LogEntry;\n    72→pub const LogLevel = txlog.LogLevel;\n    73→pub const initTxLog = txlog.init;\n    74→pub const deinitTxLog = txlog.deinit;\n    75→pub const beginTx = txlog.begin;\n    76→\n    77→pub const FilesystemCheck = fscheck.FilesystemCheck;\n    78→pub const FsType = fscheck.FsType;\n    79→pub const checkFilesystemSafety = fscheck.checkFilesystemSafety;\n    80→\n    81→pub const MappedFile = mmap.MappedFile;\n    82→pub const MmapError = mmap.MmapError;\n    83→\n    84→pub const NewlineScanner = simd.NewlineScanner;\n    85→pub const LineIterator = simd.LineIterator;\n    86→\n    87→test {\n    88→    std.testing.refAllDecls(@This());\n    89→}\n    90→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"db59b0a6-375b-4cff-9ab8-4fe53d8e4463"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01V4ZmdPEYAJc8LzxtHGMGCo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UgoTRKMrFpTtnkDARaybAu","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/create.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3919,"cache_read_input_tokens":57930,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3919},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"288b15f1-689f-4daf-b3ec-9aa476a430de"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UgoTRKMrFpTtnkDARaybAu","type":"tool_result","content":"     1→//! Create and Quick capture commands for beads_zig.\n     2→//!\n     3→//! - `bz create <title>` - Full issue creation with all optional fields\n     4→//! - `bz q <title>` - Quick capture (create + print ID only)\n     5→\n     6→const std = @import(\"std\");\n     7→const models = @import(\"../models/mod.zig\");\n     8→const storage = @import(\"../storage/mod.zig\");\n     9→const id_gen = @import(\"../id/mod.zig\");\n    10→const common = @import(\"common.zig\");\n    11→const args = @import(\"args.zig\");\n    12→const test_util = @import(\"../test_util.zig\");\n    13→\n    14→const Issue = models.Issue;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = storage.IssueStore;\n    18→const IdGenerator = id_gen.IdGenerator;\n    19→\n    20→pub const CreateError = error{\n    21→    EmptyTitle,\n    22→    TitleTooLong,\n    23→    InvalidPriority,\n    24→    InvalidIssueType,\n    25→    WorkspaceNotInitialized,\n    26→    StorageError,\n    27→    OutOfMemory,\n    28→};\n    29→\n    30→pub const CreateResult = struct {\n    31→    success: bool,\n    32→    id: ?[]const u8 = null,\n    33→    title: ?[]const u8 = null,\n    34→    message: ?[]const u8 = null,\n    35→};\n    36→\n    37→/// Run the create command.\n    38→pub fn run(\n    39→    create_args: args.CreateArgs,\n    40→    global: args.GlobalOptions,\n    41→    allocator: std.mem.Allocator,\n    42→) !void {\n    43→    var output = common.initOutput(allocator, global);\n    44→    const structured_output = global.isStructuredOutput();\n    45→\n    46→    // Validate title\n    47→    if (create_args.title.len == 0) {\n    48→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title cannot be empty\");\n    49→        return CreateError.EmptyTitle;\n    50→    }\n    51→    if (create_args.title.len > 500) {\n    52→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"title exceeds 500 character limit\");\n    53→        return CreateError.TitleTooLong;\n    54→    }\n    55→\n    56→    // Determine workspace path\n    57→    const beads_dir = global.data_path orelse \".beads\";\n    58→    const issues_path = try std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" });\n    59→    defer allocator.free(issues_path);\n    60→\n    61→    // Check if workspace is initialized\n    62→    std.fs.cwd().access(issues_path, .{}) catch |err| {\n    63→        if (err == error.FileNotFound) {\n    64→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"workspace not initialized. Run 'bz init' first.\");\n    65→            return CreateError.WorkspaceNotInitialized;\n    66→        }\n    67→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"cannot access workspace\");\n    68→        return CreateError.StorageError;\n    69→    };\n    70→\n    71→    // Load existing issues\n    72→    var store = IssueStore.init(allocator, issues_path);\n    73→    defer store.deinit();\n    74→\n    75→    store.loadFromFile() catch |err| {\n    76→        if (err != error.FileNotFound) {\n    77→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to load issues\");\n    78→            return CreateError.StorageError;\n    79→        }\n    80→    };\n    81→\n    82→    // Parse optional fields\n    83→    const priority = if (create_args.priority) |p|\n    84→        Priority.fromString(p) catch {\n    85→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"invalid priority value\");\n    86→            return CreateError.InvalidPriority;\n    87→        }\n    88→    else\n    89→        Priority.MEDIUM;\n    90→\n    91→    const issue_type = if (create_args.issue_type) |t|\n    92→        IssueType.fromString(t)\n    93→    else\n    94→        .task;\n    95→\n    96→    // Parse due date if provided\n    97→    const due_at: ?i64 = if (create_args.due) |due_str|\n    98→        parseDateString(due_str)\n    99→    else\n   100→        null;\n   101→\n   102→    // Get actor (from flag, env, or default)\n   103→    const actor = global.actor orelse common.getDefaultActor();\n   104→\n   105→    // Get config prefix (read from config.yaml or use default)\n   106→    const prefix = try getConfigPrefix(allocator, beads_dir);\n   107→    defer allocator.free(prefix);\n   108→\n   109→    // Generate ID\n   110→    var generator = IdGenerator.init(prefix);\n   111→    const issue_count = store.countTotal();\n   112→    const issue_id = try generator.generate(allocator, issue_count);\n   113→    defer allocator.free(issue_id);\n   114→\n   115→    // Create issue\n   116→    const now = std.time.timestamp();\n   117→    var issue = Issue.init(issue_id, create_args.title, now);\n   118→    issue.description = create_args.description;\n   119→    issue.priority = priority;\n   120→    issue.issue_type = issue_type;\n   121→    issue.assignee = create_args.assignee;\n   122→    issue.owner = create_args.owner;\n   123→    issue.design = create_args.design;\n   124→    issue.acceptance_criteria = create_args.acceptance_criteria;\n   125→    issue.external_ref = create_args.external_ref;\n   126→    issue.created_by = actor;\n   127→    issue.due_at = .{ .value = due_at };\n   128→    issue.estimated_minutes = create_args.estimate;\n   129→    issue.ephemeral = create_args.ephemeral;\n   130→\n   131→    // Set labels on issue (will be persisted via WAL)\n   132→    if (create_args.labels.len > 0) {\n   133→        issue.labels = create_args.labels;\n   134→    }\n   135→\n   136→    // Insert into store (for in-memory state and duplicate check)\n   137→    store.insert(issue) catch {\n   138→        try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to create issue\");\n   139→        return CreateError.StorageError;\n   140→    };\n   141→\n   142→    // Append to WAL for fast persistence (instead of full file rewrite)\n   143→    if (!global.no_auto_flush) {\n   144→        var wal = storage.Wal.init(beads_dir, allocator) catch {\n   145→            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to initialize WAL\");\n   146→            return CreateError.StorageError;\n   147→        };\n   148→        defer wal.deinit();\n   149→\n   150→        wal.addIssue(issue) catch {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5007cb5f-3770-4d87-aec5-4890ca0802ef"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01V4ZmdPEYAJc8LzxtHGMGCo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mzv7wRVYcRxNAmxi8msfHP","name":"Bash","input":{"command":"wc -l /home/hotschmoe/beads_zig/src/cli/*.zig | sort -rn | head -20","description":"Get line counts for CLI commands to understand complexity"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3919,"cache_read_input_tokens":57930,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3919},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d8c4ada0-de4d-4454-b333-12cfa09aecdd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mzv7wRVYcRxNAmxi8msfHP","type":"tool_result","content":" 15764 total\n  2745 /home/hotschmoe/beads_zig/src/cli/args.zig\n  1026 /home/hotschmoe/beads_zig/src/cli/help.zig\n   701 /home/hotschmoe/beads_zig/src/cli/dep.zig\n   650 /home/hotschmoe/beads_zig/src/cli/epic.zig\n   645 /home/hotschmoe/beads_zig/src/cli/sync.zig\n   564 /home/hotschmoe/beads_zig/src/cli/batch.zig\n   516 /home/hotschmoe/beads_zig/src/cli/query.zig\n   482 /home/hotschmoe/beads_zig/src/cli/backup.zig\n   473 /home/hotschmoe/beads_zig/src/cli/graph.zig\n   439 /home/hotschmoe/beads_zig/src/cli/create.zig\n   435 /home/hotschmoe/beads_zig/src/cli/label.zig\n   385 /home/hotschmoe/beads_zig/src/cli/config.zig\n   377 /home/hotschmoe/beads_zig/src/cli/completions.zig\n   370 /home/hotschmoe/beads_zig/src/cli/init.zig\n   368 /home/hotschmoe/beads_zig/src/cli/lint.zig\n   367 /home/hotschmoe/beads_zig/src/cli/doctor.zig\n   364 /home/hotschmoe/beads_zig/src/cli/ready.zig\n   348 /home/hotschmoe/beads_zig/src/cli/upgrade.zig\n   343 /home/hotschmoe/beads_zig/src/cli/common.zig","is_error":false}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"9613175b-d7d1-4945-a95f-d04d86cd6647"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VTuxYwnFD21h2UHKLi3rYB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CcXwu25crXutoFyRiy9yNS","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig","limit":120}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2928,"cache_read_input_tokens":61849,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2928},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1d6210a9-5406-4a09-b0d8-6dcba379ed30"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CcXwu25crXutoFyRiy9yNS","type":"tool_result","content":"     1→//! List command for beads_zig.\n     2→//!\n     3→//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n     4→//!\n     5→//! Lists issues with optional filters.\n     6→\n     7→const std = @import(\"std\");\n     8→const models = @import(\"../models/mod.zig\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const test_util = @import(\"../test_util.zig\");\n    12→\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = common.IssueStore;\n    18→const CommandContext = common.CommandContext;\n    19→\n    20→pub const ListError = error{\n    21→    WorkspaceNotInitialized,\n    22→    InvalidFilter,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→};\n    26→\n    27→pub const ListResult = struct {\n    28→    success: bool,\n    29→    issues: ?[]const IssueCompact = null,\n    30→    count: ?usize = null,\n    31→    message: ?[]const u8 = null,\n    32→\n    33→    const IssueCompact = struct {\n    34→        id: []const u8,\n    35→        title: []const u8,\n    36→        status: []const u8,\n    37→        priority: u3,\n    38→        issue_type: []const u8,\n    39→        assignee: ?[]const u8 = null,\n    40→    };\n    41→};\n    42→\n    43→pub fn run(\n    44→    list_args: args.ListArgs,\n    45→    global: args.GlobalOptions,\n    46→    allocator: std.mem.Allocator,\n    47→) !void {\n    48→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    49→        return ListError.WorkspaceNotInitialized;\n    50→    };\n    51→    defer ctx.deinit();\n    52→\n    53→    var filters = IssueStore.ListFilters{};\n    54→\n    55→    if (list_args.status) |s| {\n    56→        filters.status = Status.fromString(s);\n    57→    } else if (!list_args.all) {\n    58→        filters.status = .open;\n    59→    }\n    60→\n    61→    if (list_args.priority) |p| {\n    62→        filters.priority = Priority.fromString(p) catch {\n    63→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n    64→            return ListError.InvalidFilter;\n    65→        };\n    66→    }\n    67→\n    68→    if (list_args.priority_min) |p| {\n    69→        filters.priority_min = Priority.fromString(p) catch {\n    70→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n    71→            return ListError.InvalidFilter;\n    72→        };\n    73→    }\n    74→\n    75→    if (list_args.priority_max) |p| {\n    76→        filters.priority_max = Priority.fromString(p) catch {\n    77→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n    78→            return ListError.InvalidFilter;\n    79→        };\n    80→    }\n    81→\n    82→    if (list_args.issue_type) |t| {\n    83→        filters.issue_type = IssueType.fromString(t);\n    84→    }\n    85→\n    86→    if (list_args.assignee) |a| {\n    87→        filters.assignee = a;\n    88→    }\n    89→\n    90→    if (list_args.label) |l| {\n    91→        filters.label = l;\n    92→    }\n    93→\n    94→    if (list_args.label_any.len > 0) {\n    95→        filters.label_any = list_args.label_any;\n    96→    }\n    97→\n    98→    if (list_args.title_contains) |t| {\n    99→        filters.title_contains = t;\n   100→    }\n   101→\n   102→    if (list_args.desc_contains) |d| {\n   103→        filters.desc_contains = d;\n   104→    }\n   105→\n   106→    if (list_args.notes_contains) |n| {\n   107→        filters.notes_contains = n;\n   108→    }\n   109→\n   110→    if (list_args.limit) |n| {\n   111→        filters.limit = n;\n   112→    }\n   113→\n   114→    // Apply overdue filter\n   115→    filters.overdue = list_args.overdue;\n   116→\n   117→    // Apply include_deferred filter\n   118→    filters.include_deferred = list_args.include_deferred;\n   119→\n   120→    // Apply sort options\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f32125eb-8c82-4dc6-bded-eb5c7dd86776"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VTuxYwnFD21h2UHKLi3rYB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NPFoTNxugUJQyuEKTxcj1d","name":"Grep","input":{"pattern":"pub fn run\\(","path":"/home/hotschmoe/beads_zig/src/cli","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2928,"cache_read_input_tokens":61849,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2928},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"bec31e20-20c7-4bac-a973-bb2de846b729"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NPFoTNxugUJQyuEKTxcj1d","type":"tool_result","content":"Found 36 files\nsrc/cli/backup.zig\nsrc/cli/help.zig\nsrc/cli/sync.zig\nsrc/cli/epic.zig\nsrc/cli/label.zig\nsrc/cli/dep.zig\nsrc/cli/delete.zig\nsrc/cli/close.zig\nsrc/cli/ready.zig\nsrc/cli/list.zig\nsrc/cli/count.zig\nsrc/cli/create.zig\nsrc/cli/update.zig\nsrc/cli/query.zig\nsrc/cli/where.zig\nsrc/cli/upgrade.zig\nsrc/cli/orphans.zig\nsrc/cli/schema.zig\nsrc/cli/search.zig\nsrc/cli/show.zig\nsrc/cli/stale.zig\nsrc/cli/stats.zig\nsrc/cli/version.zig\nsrc/cli/audit.zig\nsrc/cli/changelog.zig\nsrc/cli/comments.zig\nsrc/cli/completions.zig\nsrc/cli/config.zig\nsrc/cli/defer.zig\nsrc/cli/doctor.zig\nsrc/cli/graph.zig\nsrc/cli/history.zig\nsrc/cli/info.zig\nsrc/cli/init.zig\nsrc/cli/lint.zig\nsrc/cli/metrics.zig"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"ee1091e4-ff8f-4b50-a8df-dd9d6b61be95"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KUZy8CVtwDpkCjawDovEj7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RtsVCRFnyBoQ6dFt1qbSmE","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig/src -type f -name \"*.zig\" | wc -l && find /home/hotschmoe/beads_zig/src -type d | head -20","description":"Get overall project structure counts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2115,"cache_read_input_tokens":64777,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2115},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6ef7e23e-7f13-4e1f-889e-cb8c5e492a56"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RtsVCRFnyBoQ6dFt1qbSmE","type":"tool_result","content":"80\n/home/hotschmoe/beads_zig/src\n/home/hotschmoe/beads_zig/src/models\n/home/hotschmoe/beads_zig/src/storage\n/home/hotschmoe/beads_zig/src/output\n/home/hotschmoe/beads_zig/src/cli\n/home/hotschmoe/beads_zig/src/config\n/home/hotschmoe/beads_zig/src/tests\n/home/hotschmoe/beads_zig/src/id\n/home/hotschmoe/beads_zig/src/sync","is_error":false}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3921ca1c-7c34-4b87-961e-3e1799918f10"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KUZy8CVtwDpkCjawDovEj7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bg1xpQoqhNoyHr2Lteupst","name":"Glob","input":{"pattern":"src/output/*.zig","path":"/home/hotschmoe/beads_zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2115,"cache_read_input_tokens":64777,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2115},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7f2d00a8-e8fe-4d7e-9204-a4c0122290ad"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bg1xpQoqhNoyHr2Lteupst","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/output/mod.zig"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"257e78c5-b993-4529-a48a-9b44f1f80b9c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01KUZy8CVtwDpkCjawDovEj7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GcDdVAaM8EQNDmEiU3dV5E","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":50,"offset":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2115,"cache_read_input_tokens":64777,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2115},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3703cec4-6a4e-4665-b658-31a3d730f5a3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GcDdVAaM8EQNDmEiU3dV5E","type":"tool_result","content":"   200→\n   201→/// Batch input format.\n   202→pub const BatchFormat = enum {\n   203→    titles, // One title per line\n   204→    jsonl, // Full JSONL format (one issue per line)\n   205→\n   206→    pub fn fromString(s: []const u8) ?BatchFormat {\n   207→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   208→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   209→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   210→        return null;\n   211→    }\n   212→};\n   213→\n   214→/// Import command arguments.\n   215→/// Imports issues from a JSONL file with single lock acquisition.\n   216→pub const ImportArgs = struct {\n   217→    file: []const u8, // Path to JSONL file (required)\n   218→    merge: bool = false, // Merge instead of replace\n   219→    dry_run: bool = false, // Show what would be imported without importing\n   220→};\n   221→\n   222→/// Output format for list/ready commands.\n   223→pub const OutputFormat = enum {\n   224→    default,\n   225→    csv,\n   226→\n   227→    pub fn fromString(s: []const u8) ?OutputFormat {\n   228→        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n   229→        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n   230→        return null;\n   231→    }\n   232→};\n   233→\n   234→/// Sort field options for list command.\n   235→pub const SortField = enum {\n   236→    created_at,\n   237→    updated_at,\n   238→    priority,\n   239→\n   240→    pub fn fromString(s: []const u8) ?SortField {\n   241→        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n   242→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   243→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   244→        return null;\n   245→    }\n   246→};\n   247→\n   248→/// List command arguments.\n   249→pub const ListArgs = struct {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a3c890e0-6797-4f06-92e7-253827c87693"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016srCBX3ZAzNFYrEivNNjX6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P7WSRrEv12GaAZLiWQk36q","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","limit":100,"offset":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1481,"cache_read_input_tokens":66892,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1481},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"37f578e1-b719-45c4-b8a7-6d8db684ea37"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P7WSRrEv12GaAZLiWQk36q","type":"tool_result","content":"   150→    pub fn insert(self: *Self, issue: Issue) !void {\n   151→        if (self.id_index.contains(issue.id)) {\n   152→            return IssueStoreError.DuplicateId;\n   153→        }\n   154→\n   155→        const cloned = try issue.clone(self.allocator);\n   156→        errdefer {\n   157→            var c = cloned;\n   158→            c.deinit(self.allocator);\n   159→        }\n   160→\n   161→        const id_copy = try self.allocator.dupe(u8, cloned.id);\n   162→        errdefer self.allocator.free(id_copy);\n   163→\n   164→        const idx = self.issues.items.len;\n   165→        try self.issues.append(self.allocator, cloned);\n   166→        try self.id_index.put(self.allocator, id_copy, idx);\n   167→\n   168→        try self.markDirty(issue.id);\n   169→    }\n   170→\n   171→    /// Get an issue by ID (without embedded relations).\n   172→    pub fn get(self: *Self, id: []const u8) !?Issue {\n   173→        const idx = self.id_index.get(id) orelse return null;\n   174→        if (idx >= self.issues.items.len) return null;\n   175→\n   176→        return try self.issues.items[idx].clone(self.allocator);\n   177→    }\n   178→\n   179→    /// Get an issue with all embedded relations (labels, deps, comments).\n   180→    /// Since we store everything in-memory, this just returns the issue as-is.\n   181→    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n   182→        return try self.get(id);\n   183→    }\n   184→\n   185→    /// Get a reference to the stored issue (no clone).\n   186→    /// Caller must NOT free or modify the returned issue.\n   187→    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n   188→        const idx = self.id_index.get(id) orelse return null;\n   189→        if (idx >= self.issues.items.len) return null;\n   190→        return &self.issues.items[idx];\n   191→    }\n   192→\n   193→    /// Fields that can be updated on an issue.\n   194→    pub const IssueUpdate = struct {\n   195→        title: ?[]const u8 = null,\n   196→        description: ?[]const u8 = null,\n   197→        design: ?[]const u8 = null,\n   198→        acceptance_criteria: ?[]const u8 = null,\n   199→        notes: ?[]const u8 = null,\n   200→        status: ?Status = null,\n   201→        priority: ?Priority = null,\n   202→        issue_type: ?IssueType = null,\n   203→        assignee: ?[]const u8 = null,\n   204→        owner: ?[]const u8 = null,\n   205→        estimated_minutes: ?i32 = null,\n   206→        closed_at: ?i64 = null,\n   207→        close_reason: ?[]const u8 = null,\n   208→        closed_by_session: ?[]const u8 = null,\n   209→        due_at: ?i64 = null,\n   210→        defer_until: ?i64 = null,\n   211→        external_ref: ?[]const u8 = null,\n   212→        source_system: ?[]const u8 = null,\n   213→        pinned: ?bool = null,\n   214→        is_template: ?bool = null,\n   215→        content_hash: ?[]const u8 = null,\n   216→\n   217→        /// Expected version for optimistic locking.\n   218→        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n   219→        expected_version: ?u64 = null,\n   220→    };\n   221→\n   222→    /// Update an issue with the given fields.\n   223→    /// If updates.expected_version is set, performs optimistic locking check.\n   224→    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n   225→        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n   226→        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n   227→\n   228→        var issue = &self.issues.items[idx];\n   229→\n   230→        // Optimistic locking check\n   231→        if (updates.expected_version) |expected| {\n   232→            if (issue.version != expected) {\n   233→                return IssueStoreError.VersionMismatch;\n   234→            }\n   235→        }\n   236→\n   237→        // Increment version on every update\n   238→        issue.version += 1;\n   239→\n   240→        // Update timestamp\n   241→        issue.updated_at = Rfc3339Timestamp{ .value = now };\n   242→\n   243→        // Apply updates\n   244→        if (updates.title) |v| {\n   245→            self.allocator.free(issue.title);\n   246→            issue.title = try self.allocator.dupe(u8, v);\n   247→        }\n   248→        if (updates.description) |v| {\n   249→            if (issue.description) |d| self.allocator.free(d);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"525a676d-7c3b-4cb5-b1ac-8e100776f8fe"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016srCBX3ZAzNFYrEivNNjX6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WbJLzVEFrCjYXb5R5viz8Y","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/metrics.zig","limit":80}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1481,"cache_read_input_tokens":66892,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1481},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b3bd494a-ba89-4ce1-a0fe-be11cbb96621"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WbJLzVEFrCjYXb5R5viz8Y","type":"tool_result","content":"     1→//! Metrics command for beads_zig.\n     2→//!\n     3→//! `bz metrics` - Show lock contention and performance metrics\n     4→//!\n     5→//! Reports process-local lock statistics useful for debugging\n     6→//! concurrency issues in multi-agent scenarios.\n     7→\n     8→const std = @import(\"std\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const storage = @import(\"../storage/mod.zig\");\n    12→\n    13→pub const MetricsError = error{\n    14→    WriteError,\n    15→    OutOfMemory,\n    16→};\n    17→\n    18→pub const MetricsResult = struct {\n    19→    success: bool,\n    20→    metrics: ?storage.metrics.JsonMetrics = null,\n    21→    message: ?[]const u8 = null,\n    22→};\n    23→\n    24→pub fn run(\n    25→    metrics_args: args.MetricsArgs,\n    26→    global: args.GlobalOptions,\n    27→    allocator: std.mem.Allocator,\n    28→) MetricsError!void {\n    29→    var output = common.initOutput(allocator, global);\n    30→\n    31→    // Get current metrics\n    32→    const lock_metrics = storage.getMetrics();\n    33→\n    34→    // Handle reset flag\n    35→    if (metrics_args.reset) {\n    36→        storage.resetMetrics();\n    37→        if (global.isStructuredOutput()) {\n    38→            output.printJson(MetricsResult{\n    39→                .success = true,\n    40→                .message = \"Metrics reset successfully\",\n    41→            }) catch return MetricsError.WriteError;\n    42→        } else if (!global.quiet) {\n    43→            output.print(\"Metrics reset successfully.\\n\", .{}) catch return MetricsError.WriteError;\n    44→        }\n    45→        return;\n    46→    }\n    47→\n    48→    // Output metrics\n    49→    if (global.isStructuredOutput()) {\n    50→        output.printJson(MetricsResult{\n    51→            .success = true,\n    52→            .metrics = lock_metrics.toJson(),\n    53→        }) catch return MetricsError.WriteError;\n    54→    } else if (!global.quiet) {\n    55→        const formatted = lock_metrics.format(allocator) catch return MetricsError.OutOfMemory;\n    56→        defer allocator.free(formatted);\n    57→        output.print(\"{s}\\n\", .{formatted}) catch return MetricsError.WriteError;\n    58→    }\n    59→}\n    60→\n    61→// --- Tests ---\n    62→\n    63→test \"MetricsError enum exists\" {\n    64→    const err: MetricsError = MetricsError.WriteError;\n    65→    try std.testing.expect(err == MetricsError.WriteError);\n    66→}\n    67→\n    68→test \"MetricsResult struct works\" {\n    69→    const result = MetricsResult{\n    70→        .success = true,\n    71→        .message = \"test\",\n    72→    };\n    73→    try std.testing.expect(result.success);\n    74→    try std.testing.expectEqualStrings(\"test\", result.message.?);\n    75→}\n    76→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1821de44-35cb-4cd3-8b48-be59594c2926"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MkjPjjYbPAHjzaKvXXmkRu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JaWEjZomkgCtmmCFm5BqSs","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":100,"offset":400}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2811,"cache_read_input_tokens":68373,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2811},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"38b17de3-c0de-4c61-abb7-b4ca424295b6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JaWEjZomkgCtmmCFm5BqSs","type":"tool_result","content":"   400→        id: []const u8,\n   401→        format: TreeFormat = .ascii,\n   402→    },\n   403→    cycles: void,\n   404→};\n   405→\n   406→/// Dependency command arguments.\n   407→pub const DepArgs = struct {\n   408→    subcommand: DepSubcommand,\n   409→};\n   410→\n   411→/// Graph command output formats.\n   412→pub const GraphFormat = enum {\n   413→    ascii,\n   414→    dot,\n   415→\n   416→    pub fn fromString(s: []const u8) ?GraphFormat {\n   417→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   418→        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n   419→        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n   420→        return null;\n   421→    }\n   422→};\n   423→\n   424→/// Graph command arguments.\n   425→pub const GraphArgs = struct {\n   426→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   427→    format: GraphFormat = .ascii,\n   428→    depth: ?u32 = null, // Max depth for tree traversal\n   429→};\n   430→\n   431→/// Label subcommand variants.\n   432→pub const LabelSubcommand = union(enum) {\n   433→    add: struct {\n   434→        id: []const u8,\n   435→        labels: []const []const u8,\n   436→    },\n   437→    remove: struct {\n   438→        id: []const u8,\n   439→        labels: []const []const u8,\n   440→    },\n   441→    list: struct {\n   442→        id: []const u8,\n   443→    },\n   444→    list_all: void,\n   445→    rename: struct {\n   446→        old_name: []const u8,\n   447→        new_name: []const u8,\n   448→    },\n   449→};\n   450→\n   451→/// Label command arguments.\n   452→pub const LabelArgs = struct {\n   453→    subcommand: LabelSubcommand,\n   454→};\n   455→\n   456→/// Comments subcommand variants.\n   457→pub const CommentsSubcommand = union(enum) {\n   458→    add: struct {\n   459→        id: []const u8,\n   460→        text: []const u8,\n   461→    },\n   462→    list: struct {\n   463→        id: []const u8,\n   464→    },\n   465→};\n   466→\n   467→/// Comments command arguments.\n   468→pub const CommentsArgs = struct {\n   469→    subcommand: CommentsSubcommand,\n   470→};\n   471→\n   472→/// History command arguments.\n   473→pub const HistoryArgs = struct {\n   474→    id: []const u8,\n   475→};\n   476→\n   477→/// Audit command arguments.\n   478→pub const AuditArgs = struct {\n   479→    limit: ?u32 = null,\n   480→};\n   481→\n   482→/// Changelog command arguments.\n   483→pub const ChangelogArgs = struct {\n   484→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   485→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   486→    limit: ?u32 = null,\n   487→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   488→};\n   489→\n   490→/// Error policy for export operations.\n   491→pub const ErrorPolicy = enum {\n   492→    strict, // Fail on any error\n   493→    best_effort, // Continue on errors, report at end\n   494→    partial, // Export what we can, skip errors silently\n   495→\n   496→    pub fn fromString(s: []const u8) ?ErrorPolicy {\n   497→        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n   498→        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n   499→        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f2c501b3-681b-4160-a0d9-7c33ab097cc7"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MkjPjjYbPAHjzaKvXXmkRu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DyDR9cCweVMu7R2Pvbgcvd","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/mod.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2811,"cache_read_input_tokens":68373,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2811},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c9ab11e2-d256-4da9-bb7e-90c2c79f398f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DyDR9cCweVMu7R2Pvbgcvd","type":"tool_result","content":"     1→//! Data model definitions for beads_zig.\n     2→//!\n     3→//! Core types:\n     4→//! - Issue: Primary entity with all fields\n     5→//! - Status, Priority, IssueType: Classification enums\n     6→//! - Dependency: Issue relationships\n     7→//! - Comment: Issue comments\n     8→//! - Event: Audit log entries\n     9→//!\n    10→//! Utilities:\n    11→//! - timestamp: RFC3339 parsing/formatting for JSONL compatibility\n    12→//!\n    13→//! All models support JSON serialization for JSONL export.\n    14→\n    15→const std = @import(\"std\");\n    16→\n    17→pub const Status = @import(\"status.zig\").Status;\n    18→pub const Priority = @import(\"priority.zig\").Priority;\n    19→pub const IssueType = @import(\"issue_type.zig\").IssueType;\n    20→pub const DependencyType = @import(\"dependency.zig\").DependencyType;\n    21→pub const Dependency = @import(\"dependency.zig\").Dependency;\n    22→pub const Comment = @import(\"comment.zig\").Comment;\n    23→pub const CommentError = @import(\"comment.zig\").CommentError;\n    24→pub const EventType = @import(\"event.zig\").EventType;\n    25→pub const Event = @import(\"event.zig\").Event;\n    26→pub const EventError = @import(\"event.zig\").EventError;\n    27→pub const Issue = @import(\"issue.zig\").Issue;\n    28→pub const IssueError = @import(\"issue.zig\").IssueError;\n    29→pub const Rfc3339Timestamp = @import(\"issue.zig\").Rfc3339Timestamp;\n    30→pub const OptionalRfc3339Timestamp = @import(\"issue.zig\").OptionalRfc3339Timestamp;\n    31→\n    32→// Timestamp utilities\n    33→pub const timestamp = @import(\"timestamp.zig\");\n    34→pub const TimestampError = timestamp.TimestampError;\n    35→pub const parseRfc3339 = timestamp.parseRfc3339;\n    36→pub const parseRfc3339Strict = timestamp.parseRfc3339Strict;\n    37→pub const formatRfc3339 = timestamp.formatRfc3339;\n    38→pub const formatRfc3339Alloc = timestamp.formatRfc3339Alloc;\n    39→pub const timestampNow = timestamp.now;\n    40→pub const RFC3339_LEN = timestamp.RFC3339_LEN;\n    41→pub const RFC3339_BUFFER_SIZE = timestamp.RFC3339_BUFFER_SIZE;\n    42→\n    43→test {\n    44→    std.testing.refAllDecls(@This());\n    45→}\n    46→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4a09774d-7484-489a-a968-035455f90ac4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G1QhMjB9TnGour2s3V1z8Q","type":"tool_result","content":[{"type":"text","text":"Excellent! Now I have a comprehensive understanding of the codebase. Let me create a detailed summary of my findings:\n\n## Beads_zig Codebase Architecture - Comprehensive Exploration Report\n\nI've thoroughly explored the beads_zig codebase. Here's what I found:\n\n---\n\n## PROJECT STRUCTURE\n\n**80 Zig source files organized into 9 main modules:**\n\n```\n/home/hotschmoe/beads_zig/src/\n├── cli/             [36 command implementation files + infrastructure]\n├── models/          [9 data model files]\n├── storage/         [17 persistence & storage files]\n├── output/          [1 output formatting module]\n├── config/          [configuration handling]\n├── id/              [ID generation]\n├── sync/            [sync operations]\n├── tests/           [test utilities]\n└── main.zig        [CLI entry point]\n```\n\n---\n\n## 1. CLI COMMAND STRUCTURE (src/cli/)\n\n### Key Insight: Commands Follow a Consistent Pattern\n\n**File organization (41 files total):**\n- `args.zig` - Central argument parsing (2,745 lines) - defines all Commands, Args structs, GlobalOptions\n- `common.zig` - Shared utilities (343 lines) - CommandContext, error handling, output helpers\n- `mod.zig` - Module exports for all commands\n- Individual command files (1 per command, 200-1000 lines each)\n\n### The Command Pattern - Every command follows this template:\n\n```zig\n// 1. Error enum\npub const CommandError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    SomeSpecificError,\n};\n\n// 2. Result struct (for JSON output)\npub const CommandResult = struct {\n    success: bool,\n    // ... fields for data\n    message: ?[]const u8 = null,\n};\n\n// 3. Run function\npub fn run(\n    cmd_args: args.CommandArgs,      // Command-specific args\n    global: args.GlobalOptions,      // Global flags (--json, --quiet, etc)\n    allocator: std.mem.Allocator,\n) !void {\n    // Initialize context\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return CommandError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Perform operation\n    // ...\n\n    // Output results (JSON or human-readable based on global.json flag)\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(CommandResult{ .success = true, ... });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"...\", .{});\n    }\n}\n```\n\n### All 34 Commands Listed:\n\n**Workspace Management (6):**\n- `init` - Initialize workspace\n- `info` - Show workspace info\n- `stats` - Project statistics\n- `doctor` - Validate data integrity\n- `config` - Manage configuration\n- `where` - Show `.beads` directory location\n\n**Issue CRUD (6):**\n- `create` - Create new issue\n- `q` - Quick capture (create + print ID)\n- `show` - Display issue details\n- `update` - Modify issue fields\n- `close` - Close issue\n- `delete` - Delete/tombstone issue\n\n**Query & Filtering (6):**\n- `list` - List issues with filters\n- `ready` - Show ready-to-work issues\n- `blocked` - Show blocked issues\n- `search` - Search by title/description\n- `stale` - Find inactive issues\n- `count` - Count matching issues\n\n**Advanced Features (10):**\n- `dep` - Manage dependencies (add/remove/list)\n- `graph` - Display dependency graphs (ASCII/DOT format)\n- `epic` - Create/manage epics with sub-issues\n- `label` - Add/remove/rename labels\n- `comments` - Add/list issue comments\n- `history` - View issue change history\n- `audit` - Project-wide audit log\n- `defer` - Defer issues to future dates\n- `sync` - Sync with remote (planned)\n- `backup` - Backup/restore operations\n\n**Metadata & Reporting (6):**\n- `changelog` - Generate changelog\n- `metrics` - Show lock contention stats\n- `lint` - Validate data consistency\n- `orphans` - Find unreferenced issues\n- `query` - Execute saved queries\n- `completions` - Shell completions\n\n**System (4):**\n- `version` - Show version\n- `schema` - Show JSON schema\n- `help` - Show command help\n- `upgrade` - Self-upgrade\n\n---\n\n## 2. ARGUMENT PARSING (src/cli/args.zig - 2,745 lines)\n\n### GlobalOptions (applied to ALL commands):\n```zig\npub const GlobalOptions = struct {\n    json: bool = false,           // --json\n    toon: bool = false,           // LLM-optimized format\n    robot: bool = false,          // Line-oriented machine output\n    quiet: bool = false,          // --quiet\n    silent: bool = false,         // Suppress all output (for tests)\n    verbose: u8 = 0,              // -v, -vv, -vvv\n    no_color: bool = false,       // --no-color\n    wrap: bool = false,           // Wrap long lines\n    stats: bool = false,          // Show token savings\n    data_path: ?[]const u8 = null, // --data-path .beads\n    actor: ?[]const u8 = null,    // --actor NAME\n    lock_timeout: u32 = 5000,     // --lock-timeout MS\n    no_auto_flush: bool = false,  // Skip persistence\n    no_auto_import: bool = false,\n};\n```\n\n### Command Parsing:\nEach command has its own Args struct. Examples:\n\n```zig\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    priority: ?[]const u8 = null,  // \"critical\", \"high\", \"medium\", \"low\", \"backlog\"\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false,        // Local-only, not persisted\n};\n\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,      // Must have ALL\n    label_any: []const []const u8 = &[_][]const u8{}, // Has ANY\n    title_contains: ?[]const u8 = null,\n    limit: ?usize = null,\n    all: bool = false,              // Include closed\n    overdue: bool = false,\n    sort: ?[]const u8 = null,\n};\n```\n\n---\n\n## 3. COMMAND EXECUTION CONTEXT (src/cli/common.zig)\n\n### CommandContext - Initialized by every command:\n\n```zig\npub const CommandContext = struct {\n    allocator: std.mem.Allocator,\n    output: Output,\n    store: IssueStore,              // In-memory issue store\n    event_store: EventStore,        // Audit event store\n    beads_dir: []const u8,          // Usually \".beads\"\n    issues_path: []const u8,        // \".beads/issues.jsonl\"\n    events_path: []const u8,        // \".beads/events.jsonl\"\n    global: args.GlobalOptions,\n    corruption_count: usize,        // Detected during load\n    corrupt_lines: []const usize,   // Line numbers of corrupt entries\n    wal_entries_replayed: usize,    // WAL entries applied\n};\n```\n\n### CommandContext Initialization Process:\n1. Parse global options\n2. Check if workspace exists (.beads/issues.jsonl)\n3. Load issues from JSONL file with graceful corruption recovery\n4. Replay WAL entries onto store for consistency\n5. Initialize EventStore and load next ID\n6. Return CommandContext or null if workspace not initialized\n\n### Helper Methods:\n- `saveIfAutoFlush()` - Persist if --no-auto-flush not set\n- `appendToWal()` - Fast append for single-issue operations\n- `createGraph()` - Build dependency graph\n- `recordEvent()` - Log audit event (best-effort, errors ignored)\n\n---\n\n## 4. DATA MODELS (src/models/ - 9 files)\n\n### Core Entities:\n\n**Issue** (issue.zig):\n```zig\npub const Issue = struct {\n    // Identity\n    id: []const u8,\n    content_hash: ?[]const u8,\n\n    // Content\n    title: []const u8,\n    description: ?[]const u8,\n    design: ?[]const u8,\n    acceptance_criteria: ?[]const u8,\n    notes: ?[]const u8,\n\n    // Classification\n    status: Status,           // open, in_progress, blocked, closed, tombstone\n    priority: Priority,       // 0=critical, 1=high, 2=medium, 3=low, 4=backlog\n    issue_type: IssueType,    // task, bug, feature, epic, story, spike\n\n    // Assignment\n    assignee: ?[]const u8,\n    owner: ?[]const u8,\n\n    // Timestamps (stored as Unix epoch, serialized as RFC3339)\n    created_at: Rfc3339Timestamp,\n    created_by: ?[]const u8,\n    updated_at: Rfc3339Timestamp,\n    closed_at: OptionalRfc3339Timestamp,\n    close_reason: ?[]const u8,\n    closed_by_session: ?[]const u8,\n\n    // Scheduling\n    due_at: OptionalRfc3339Timestamp,\n    defer_until: OptionalRfc3339Timestamp,\n    estimated_minutes: ?i32,\n\n    // External\n    external_ref: ?[]const u8,\n    source_system: ?[]const u8,\n\n    // Flags\n    pinned: bool,\n    is_template: bool,\n    ephemeral: bool,        // Local-only, not persisted\n    version: u64 = 1,       // For optimistic locking\n};\n```\n\n**Status** (status.zig):\n```zig\npub const Status = enum {\n    open, in_progress, blocked, closed, tombstone\n};\n```\n\n**Priority** (priority.zig):\n```zig\npub const Priority = struct {\n    value: u3,  // 0-4: critical, high, medium, low, backlog\n};\n```\n\n**IssueType** (issue_type.zig):\n- task, bug, feature, epic, story, spike\n\n**Event** (event.zig):\n```zig\npub const EventType = enum {\n    created, updated, status_changed, priority_changed, assignee_changed,\n    commented, closed, reopened, dependency_added, dependency_removed,\n    label_added, label_removed, compacted, deleted, restored\n};\n\npub const Event = struct {\n    id: i64,                    // Auto-incrementing\n    issue_id: []const u8,\n    event_type: EventType,\n    actor: []const u8,\n    old_value: ?[]const u8,     // JSON of previous value\n    new_value: ?[]const u8,     // JSON of new value\n    created_at: i64,            // Unix timestamp\n};\n```\n\n**Dependency** (dependency.zig):\n```zig\npub const DependencyType = enum { blocks, blocked_by, related };\npub const Dependency = struct {\n    id: []const u8,\n    dependency_type: DependencyType,\n    target_id: []const u8,\n};\n```\n\n**Comment** (comment.zig):\n```zig\npub const Comment = struct {\n    id: []const u8,\n    text: []const u8,\n    author: []const u8,\n    created_at: i64,\n};\n```\n\n---\n\n## 5. STORAGE LAYER (src/storage/ - 17 files)\n\n### Architecture:\n\n```\n.beads/\n├── issues.jsonl        Main JSONL file (git-tracked) - compacted state\n├── issues.wal          Write-ahead log (gitignored) - recent changes\n├── .beads.lock         flock file (gitignored) - concurrent write safety\n├── config.yaml         Configuration (issue ID prefix, etc.)\n└── events.jsonl        Audit log (gitignored) - all state changes\n```\n\n### Write Path:\n1. `flock(.beads.lock, LOCK_EX)` - Exclusive lock (~1ms blocking)\n2. Append operation to WAL in append mode\n3. `fsync()` - Durability guarantee\n4. `flock(.beads.lock, LOCK_UN)` - Release lock\n\n### Read Path:\n1. Load main JSONL file (no lock needed)\n2. Replay WAL entries onto store for consistency\n3. No spinning/retry storms\n\n### Key Components:\n\n**IssueStore** (store.zig):\n```zig\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),    // In-memory store\n    id_index: std.StringHashMapUnmanaged(usize), // Fast ID lookup\n    dirty_ids: std.StringHashMapUnmanaged(i64), // Track changes for sync\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    pub fn insert(self: *Self, issue: Issue) !void {}\n    pub fn get(self: *Self, id: []const u8) !?Issue {}\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {}\n    pub fn delete(self: *Self, id: []const u8) !void {}\n    pub fn loadFromFile(self: *Self) !void {}\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {}\n    pub fn saveToFile(self: *Self) !void {}\n};\n\npub const IssueUpdate = struct {\n    title: ?[]const u8 = null,\n    status: ?Status = null,\n    priority: ?Priority = null,\n    expected_version: ?u64 = null,  // Optimistic locking\n    // ... other fields\n};\n```\n\n**ListFilters** - Used by list command:\n```zig\npub const ListFilters = struct {\n    status: ?Status = null,\n    priority: ?Priority = null,\n    priority_min: ?Priority = null,\n    priority_max: ?Priority = null,\n    issue_type: ?IssueType = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,      // Must have all\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: ListSort = .created_at,\n    limit: usize = 50,\n};\n```\n\n**EventStore** (events.zig - 490 lines):\n```zig\npub const EventStore = struct {\n    allocator: std.mem.Allocator,\n    events_path: []const u8,\n    next_id: i64,\n\n    pub fn append(self: *Self, event: Event) !i64 {}\n    pub fn getEventsForIssue(self: *Self, issue_id: []const u8) ![]Event {}\n    pub fn getAllEvents(self: *Self) ![]Event {}\n    pub fn queryEvents(self: *Self, params: QueryParams) ![]Event {}\n};\n\npub const QueryParams = struct {\n    issue_id: ?[]const u8 = null,\n    event_type: ?EventType = null,\n    actor: ?[]const u8 = null,\n    since: ?i64 = null,\n    until: ?i64 = null,\n    limit: ?usize = null,\n};\n```\n\n**WAL** (wal.zig):\n```zig\npub const WalOp = enum { create, update, delete };\npub const WalEntry = struct {\n    op: WalOp,\n    ts: i64,\n    id: []const u8,\n    data: Issue,  // Full issue snapshot\n};\n\npub const Wal = struct {\n    pub fn appendEntry(self: *Self, entry: WalEntry) !void {}\n    pub fn replay(self: *Self, store: *IssueStore) !ReplayStats {}\n};\n```\n\n**DependencyGraph** (graph.zig):\n- Builds in-memory graph from store\n- Cycle detection\n- Path finding\n- ASCII/DOT export\n\n---\n\n## 6. IMPLEMENTATION PATTERNS - HOW TO ADD A COMMAND\n\n### Pattern Overview:\n\n**Step 1: Define Arguments in args.zig**\n```zig\npub const MyCommandArgs = struct {\n    id: []const u8,\n    value: ?[]const u8 = null,\n};\n```\n\n**Step 2: Add to Command union**\n```zig\npub const Command = union(enum) {\n    my_command: MyCommandArgs,\n    // ...\n};\n```\n\n**Step 3: Create src/cli/my_command.zig**\n```zig\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\npub const MyCommandError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    InvalidInput,\n    StorageError,\n};\n\npub const MyCommandResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    value: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    cmd_args: args.MyCommandArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    // 1. Initialize context\n    var ctx = (try common.CommandContext.init(allocator, global)) orelse {\n        return MyCommandError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // 2. Validate input\n    if (cmd_args.id.len == 0) {\n        try common.outputErrorTyped(MyCommandResult, &ctx.output, global.isStructuredOutput(), \"ID required\");\n        return MyCommandError.InvalidInput;\n    }\n\n    // 3. Perform operation\n    const issue = try ctx.store.get(cmd_args.id) orelse {\n        try common.outputNotFoundError(MyCommandResult, &ctx.output, global.isStructuredOutput(), cmd_args.id, allocator);\n        return MyCommandError.IssueNotFound;\n    };\n    defer issue.deinit(allocator);\n\n    // 4. Record event if needed\n    ctx.recordEvent(Event.statusChange(...));\n\n    // 5. Output results\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(MyCommandResult{\n            .success = true,\n            .id = cmd_args.id,\n            .value = \"result\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Operation succeeded\", .{});\n    }\n}\n\n// --- Tests ---\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = args.MyCommandArgs{ .id = \"bd-test\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent\" };\n    try std.testing.expectError(MyCommandError.WorkspaceNotInitialized, run(cmd_args, global, allocator));\n}\n```\n\n**Step 4: Export in mod.zig**\n```zig\npub const my_command = @import(\"my_command.zig\");\npub const MyCommandError = my_command.MyCommandError;\npub const MyCommandResult = my_command.MyCommandResult;\npub const runMyCommand = my_command.run;\n```\n\n**Step 5: Add dispatch in main.zig**\n```zig\n.my_command => |cmd_args| {\n    cli.runMyCommand(cmd_args, result.global, allocator) catch |err| switch (err) {\n        error.IssueNotFound => std.process.exit(1),\n        else => return err,\n    };\n},\n```\n\n---\n\n## 7. KEY PATTERNS & CONVENTIONS\n\n### Error Handling:\n- Every command defines its own Error set\n- Errors that exit with code 1 are caught in main.zig dispatch\n- Unknown errors propagate up\n- Use CommandContext for automatic error output formatting\n\n### Output Modes:\n- `--json` / `--toon` - Structured output (JSON or LLM format)\n- `--quiet` - Suppress output (except errors in normal mode)\n- `--silent` - Suppress ALL output (even errors, for tests)\n- Default - Human-readable terminal output\n\n### Persistence:\n- Single writes use `appendToWal()` for ~1ms latency\n- Bulk operations use `saveToFile()` for full JSONL rewrite\n- Auto-flush controlled by `--no-auto-flush`\n- WAL entries replayed on load for consistency\n\n### Concurrency:\n- flock-based blocking lock (no spinning)\n- Write operations serialize at lock acquisition\n- Read operations don't need locks (load + replay pattern)\n- Lock timeout configurable with `--lock-timeout MS`\n\n### Optimistic Locking:\n- Every issue has `version: u64`\n- Incremented on every update\n- Update can specify `expected_version` for CAS semantics\n- Fails with `VersionMismatch` if concurrent modification detected\n\n### Memory Management:\n- GeneralPurposeAllocator for CLI process\n- Allocations tied to CommandContext lifetime\n- defer cleanup on error paths\n- Arena allocation for issues in store\n\n### Testing:\n- Each module has inline `test` blocks\n- Uses `std.testing.allocator` for tests\n- `test_util` provides helper functions\n- Run with `zig build test` (523 tests total)\n\n---\n\n## 8. EXAMPLE COMMANDS ANALYZED\n\n### stats.zig (177 lines) - SIMPLE DATA COLLECTION PATTERN\nShows statistics: total issues, open/closed counts, groupings by status/priority/type.\n\n**Pattern:**\n1. Load workspace\n2. Iterate through all issues\n3. Count and aggregate (using StringHashMap for status/type)\n4. Convert arrays to output format\n5. Output as JSON or formatted table\n\n### history.zig (208 lines) - EVENT LOG PATTERN\nShows change history for a single issue.\n\n**Pattern:**\n1. Load workspace\n2. Verify issue exists\n3. Query EventStore for events matching issue_id\n4. Fall back to synthetic events from issue timestamps if no stored events\n5. Convert to output format\n6. Display with old/new values highlighted\n\n### audit.zig (148 lines) - PROJECT-WIDE LOG PATTERN\nShows all project events across all issues, sorted by recency.\n\n**Pattern:**\n1. Load workspace (no error if uninitialized - creates empty store)\n2. Build synthetic audit from issue metadata\n3. Sort by timestamp descending\n4. Apply limit and display\n\n### create.zig (439 lines) - CREATION PATTERN WITH PERSISTENCE\nCreates a new issue with all optional fields.\n\n**Pattern:**\n1. Validate required fields (title)\n2. Check workspace initialized\n3. Load existing store (for duplicate check)\n4. Parse optional fields (priority, type, due date, etc.)\n5. Generate unique ID from prefix + counter\n6. Create Issue struct and insert into store\n7. Append to WAL for fast persistence\n8. Record event for audit trail\n9. Output result (ID required for quick capture)\n\n### metrics.zig (76 lines) - SIMPLE STATE QUERY PATTERN\nShows lock contention metrics or resets them.\n\n**Pattern:**\n1. Get global metrics from storage module\n2. Handle --reset flag if set\n3. Format and output\n\n---\n\n## 9. AUDIT/EVENT SYSTEM\n\n### Event Model:\n- Stored separately in `.beads/events.jsonl`\n- Auto-incrementing ID per event\n- Tracks who (actor), what (event_type), when (timestamp)\n- old_value/new_value for state changes\n- Persisted immediately on append with fsync\n\n### Event Recording:\nCommands use `ctx.recordEvent(event)` to log changes. Examples:\n\n```zig\n// In create command\nctx.recordEvent(Event.issueCreated(issue_id, actor, now));\n\n// In close command\nctx.recordEvent(try Event.issueClosed(allocator, issue_id, actor, reason, now));\n\n// In update command\nif (old_priority != new_priority) {\n    ctx.recordEvent(try Event.priorityChange(allocator, id, actor, old, new, now));\n}\n```\n\n### Query Capabilities:\n- By issue_id\n- By event_type\n- By actor\n- By date range (since/until)\n- With limit\n\n---\n\n## 10. CRITICAL FILES & DEPENDENCIES\n\n**Must Read First:**\n1. `/home/hotschmoe/beads_zig/src/cli/args.zig` - All command argument definitions\n2. `/home/hotschmoe/beads_zig/src/cli/common.zig` - Shared utilities and CommandContext\n3. `/home/hotschmoe/beads_zig/src/models/issue.zig` - Primary data model\n4. `/home/hotschmoe/beads_zig/src/models/event.zig` - Event model for audit\n5. `/home/hotschmoe/beads_zig/src/storage/store.zig` - In-memory issue store\n6. `/home/hotschmoe/beads_zig/src/storage/events.zig` - Audit event persistence\n7. `/home/hotschmoe/beads_zig/src/main.zig` - Command dispatch entry point\n\n**Reference Commands (well-written examples):**\n1. `stats.zig` - Simple aggregation without state changes\n2. `history.zig` - Reading from EventStore\n3. `audit.zig` - Project-wide queries\n4. `create.zig` - Creating with WAL persistence and event recording\n5. `list.zig` - Complex filtering and list operations\n\n---\n\n## SUMMARY\n\nThe beads_zig codebase is well-structured with:\n\n- **Clear separation of concerns**: CLI, models, storage, output\n- **Consistent command patterns**: Every command follows the same initialization, execution, error handling flow\n- **Comprehensive event system**: Full audit trail with EventStore\n- **Efficient persistence**: WAL for single writes, JSONL for bulk, graceful corruption recovery\n- **Flexible output**: JSON, TOON (LLM format), plain text, quiet modes\n- **Memory safety**: Zig's memory model with explicit allocation/deallocation\n- **Optimistic locking**: Version-based CAS for concurrent safe updates\n- **Thorough testing**: 523 tests across all modules\n\nThe patterns are highly repeatable - adding new commands is straightforward following the established templates."},{"type":"text","text":"agentId: aba427f (for resuming to continue this agent's work if needed)"}]}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0ff8b8de-3b96-4f89-beff-6a0aa0290d2a","tool_use_result":{"status":"completed","prompt":"Explore the beads_zig codebase to understand:\n1. How CLI commands are structured (look at src/cli/ directory)\n2. How existing commands like `stats` are implemented\n3. What models exist for events/audit logging\n4. How the storage layer works\n\nFocus on finding:\n- src/cli/args.zig - command argument parsing\n- src/cli/stats.zig or similar - existing stats command\n- src/models/ - data models\n- src/storage/ - storage layer\n\nBe thorough - I need to understand the patterns used before implementing new commands.","agentId":"aba427f","content":[{"type":"text","text":"Excellent! Now I have a comprehensive understanding of the codebase. Let me create a detailed summary of my findings:\n\n## Beads_zig Codebase Architecture - Comprehensive Exploration Report\n\nI've thoroughly explored the beads_zig codebase. Here's what I found:\n\n---\n\n## PROJECT STRUCTURE\n\n**80 Zig source files organized into 9 main modules:**\n\n```\n/home/hotschmoe/beads_zig/src/\n├── cli/             [36 command implementation files + infrastructure]\n├── models/          [9 data model files]\n├── storage/         [17 persistence & storage files]\n├── output/          [1 output formatting module]\n├── config/          [configuration handling]\n├── id/              [ID generation]\n├── sync/            [sync operations]\n├── tests/           [test utilities]\n└── main.zig        [CLI entry point]\n```\n\n---\n\n## 1. CLI COMMAND STRUCTURE (src/cli/)\n\n### Key Insight: Commands Follow a Consistent Pattern\n\n**File organization (41 files total):**\n- `args.zig` - Central argument parsing (2,745 lines) - defines all Commands, Args structs, GlobalOptions\n- `common.zig` - Shared utilities (343 lines) - CommandContext, error handling, output helpers\n- `mod.zig` - Module exports for all commands\n- Individual command files (1 per command, 200-1000 lines each)\n\n### The Command Pattern - Every command follows this template:\n\n```zig\n// 1. Error enum\npub const CommandError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    SomeSpecificError,\n};\n\n// 2. Result struct (for JSON output)\npub const CommandResult = struct {\n    success: bool,\n    // ... fields for data\n    message: ?[]const u8 = null,\n};\n\n// 3. Run function\npub fn run(\n    cmd_args: args.CommandArgs,      // Command-specific args\n    global: args.GlobalOptions,      // Global flags (--json, --quiet, etc)\n    allocator: std.mem.Allocator,\n) !void {\n    // Initialize context\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return CommandError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Perform operation\n    // ...\n\n    // Output results (JSON or human-readable based on global.json flag)\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(CommandResult{ .success = true, ... });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"...\", .{});\n    }\n}\n```\n\n### All 34 Commands Listed:\n\n**Workspace Management (6):**\n- `init` - Initialize workspace\n- `info` - Show workspace info\n- `stats` - Project statistics\n- `doctor` - Validate data integrity\n- `config` - Manage configuration\n- `where` - Show `.beads` directory location\n\n**Issue CRUD (6):**\n- `create` - Create new issue\n- `q` - Quick capture (create + print ID)\n- `show` - Display issue details\n- `update` - Modify issue fields\n- `close` - Close issue\n- `delete` - Delete/tombstone issue\n\n**Query & Filtering (6):**\n- `list` - List issues with filters\n- `ready` - Show ready-to-work issues\n- `blocked` - Show blocked issues\n- `search` - Search by title/description\n- `stale` - Find inactive issues\n- `count` - Count matching issues\n\n**Advanced Features (10):**\n- `dep` - Manage dependencies (add/remove/list)\n- `graph` - Display dependency graphs (ASCII/DOT format)\n- `epic` - Create/manage epics with sub-issues\n- `label` - Add/remove/rename labels\n- `comments` - Add/list issue comments\n- `history` - View issue change history\n- `audit` - Project-wide audit log\n- `defer` - Defer issues to future dates\n- `sync` - Sync with remote (planned)\n- `backup` - Backup/restore operations\n\n**Metadata & Reporting (6):**\n- `changelog` - Generate changelog\n- `metrics` - Show lock contention stats\n- `lint` - Validate data consistency\n- `orphans` - Find unreferenced issues\n- `query` - Execute saved queries\n- `completions` - Shell completions\n\n**System (4):**\n- `version` - Show version\n- `schema` - Show JSON schema\n- `help` - Show command help\n- `upgrade` - Self-upgrade\n\n---\n\n## 2. ARGUMENT PARSING (src/cli/args.zig - 2,745 lines)\n\n### GlobalOptions (applied to ALL commands):\n```zig\npub const GlobalOptions = struct {\n    json: bool = false,           // --json\n    toon: bool = false,           // LLM-optimized format\n    robot: bool = false,          // Line-oriented machine output\n    quiet: bool = false,          // --quiet\n    silent: bool = false,         // Suppress all output (for tests)\n    verbose: u8 = 0,              // -v, -vv, -vvv\n    no_color: bool = false,       // --no-color\n    wrap: bool = false,           // Wrap long lines\n    stats: bool = false,          // Show token savings\n    data_path: ?[]const u8 = null, // --data-path .beads\n    actor: ?[]const u8 = null,    // --actor NAME\n    lock_timeout: u32 = 5000,     // --lock-timeout MS\n    no_auto_flush: bool = false,  // Skip persistence\n    no_auto_import: bool = false,\n};\n```\n\n### Command Parsing:\nEach command has its own Args struct. Examples:\n\n```zig\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    priority: ?[]const u8 = null,  // \"critical\", \"high\", \"medium\", \"low\", \"backlog\"\n    assignee: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false,        // Local-only, not persisted\n};\n\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,      // Must have ALL\n    label_any: []const []const u8 = &[_][]const u8{}, // Has ANY\n    title_contains: ?[]const u8 = null,\n    limit: ?usize = null,\n    all: bool = false,              // Include closed\n    overdue: bool = false,\n    sort: ?[]const u8 = null,\n};\n```\n\n---\n\n## 3. COMMAND EXECUTION CONTEXT (src/cli/common.zig)\n\n### CommandContext - Initialized by every command:\n\n```zig\npub const CommandContext = struct {\n    allocator: std.mem.Allocator,\n    output: Output,\n    store: IssueStore,              // In-memory issue store\n    event_store: EventStore,        // Audit event store\n    beads_dir: []const u8,          // Usually \".beads\"\n    issues_path: []const u8,        // \".beads/issues.jsonl\"\n    events_path: []const u8,        // \".beads/events.jsonl\"\n    global: args.GlobalOptions,\n    corruption_count: usize,        // Detected during load\n    corrupt_lines: []const usize,   // Line numbers of corrupt entries\n    wal_entries_replayed: usize,    // WAL entries applied\n};\n```\n\n### CommandContext Initialization Process:\n1. Parse global options\n2. Check if workspace exists (.beads/issues.jsonl)\n3. Load issues from JSONL file with graceful corruption recovery\n4. Replay WAL entries onto store for consistency\n5. Initialize EventStore and load next ID\n6. Return CommandContext or null if workspace not initialized\n\n### Helper Methods:\n- `saveIfAutoFlush()` - Persist if --no-auto-flush not set\n- `appendToWal()` - Fast append for single-issue operations\n- `createGraph()` - Build dependency graph\n- `recordEvent()` - Log audit event (best-effort, errors ignored)\n\n---\n\n## 4. DATA MODELS (src/models/ - 9 files)\n\n### Core Entities:\n\n**Issue** (issue.zig):\n```zig\npub const Issue = struct {\n    // Identity\n    id: []const u8,\n    content_hash: ?[]const u8,\n\n    // Content\n    title: []const u8,\n    description: ?[]const u8,\n    design: ?[]const u8,\n    acceptance_criteria: ?[]const u8,\n    notes: ?[]const u8,\n\n    // Classification\n    status: Status,           // open, in_progress, blocked, closed, tombstone\n    priority: Priority,       // 0=critical, 1=high, 2=medium, 3=low, 4=backlog\n    issue_type: IssueType,    // task, bug, feature, epic, story, spike\n\n    // Assignment\n    assignee: ?[]const u8,\n    owner: ?[]const u8,\n\n    // Timestamps (stored as Unix epoch, serialized as RFC3339)\n    created_at: Rfc3339Timestamp,\n    created_by: ?[]const u8,\n    updated_at: Rfc3339Timestamp,\n    closed_at: OptionalRfc3339Timestamp,\n    close_reason: ?[]const u8,\n    closed_by_session: ?[]const u8,\n\n    // Scheduling\n    due_at: OptionalRfc3339Timestamp,\n    defer_until: OptionalRfc3339Timestamp,\n    estimated_minutes: ?i32,\n\n    // External\n    external_ref: ?[]const u8,\n    source_system: ?[]const u8,\n\n    // Flags\n    pinned: bool,\n    is_template: bool,\n    ephemeral: bool,        // Local-only, not persisted\n    version: u64 = 1,       // For optimistic locking\n};\n```\n\n**Status** (status.zig):\n```zig\npub const Status = enum {\n    open, in_progress, blocked, closed, tombstone\n};\n```\n\n**Priority** (priority.zig):\n```zig\npub const Priority = struct {\n    value: u3,  // 0-4: critical, high, medium, low, backlog\n};\n```\n\n**IssueType** (issue_type.zig):\n- task, bug, feature, epic, story, spike\n\n**Event** (event.zig):\n```zig\npub const EventType = enum {\n    created, updated, status_changed, priority_changed, assignee_changed,\n    commented, closed, reopened, dependency_added, dependency_removed,\n    label_added, label_removed, compacted, deleted, restored\n};\n\npub const Event = struct {\n    id: i64,                    // Auto-incrementing\n    issue_id: []const u8,\n    event_type: EventType,\n    actor: []const u8,\n    old_value: ?[]const u8,     // JSON of previous value\n    new_value: ?[]const u8,     // JSON of new value\n    created_at: i64,            // Unix timestamp\n};\n```\n\n**Dependency** (dependency.zig):\n```zig\npub const DependencyType = enum { blocks, blocked_by, related };\npub const Dependency = struct {\n    id: []const u8,\n    dependency_type: DependencyType,\n    target_id: []const u8,\n};\n```\n\n**Comment** (comment.zig):\n```zig\npub const Comment = struct {\n    id: []const u8,\n    text: []const u8,\n    author: []const u8,\n    created_at: i64,\n};\n```\n\n---\n\n## 5. STORAGE LAYER (src/storage/ - 17 files)\n\n### Architecture:\n\n```\n.beads/\n├── issues.jsonl        Main JSONL file (git-tracked) - compacted state\n├── issues.wal          Write-ahead log (gitignored) - recent changes\n├── .beads.lock         flock file (gitignored) - concurrent write safety\n├── config.yaml         Configuration (issue ID prefix, etc.)\n└── events.jsonl        Audit log (gitignored) - all state changes\n```\n\n### Write Path:\n1. `flock(.beads.lock, LOCK_EX)` - Exclusive lock (~1ms blocking)\n2. Append operation to WAL in append mode\n3. `fsync()` - Durability guarantee\n4. `flock(.beads.lock, LOCK_UN)` - Release lock\n\n### Read Path:\n1. Load main JSONL file (no lock needed)\n2. Replay WAL entries onto store for consistency\n3. No spinning/retry storms\n\n### Key Components:\n\n**IssueStore** (store.zig):\n```zig\npub const IssueStore = struct {\n    allocator: std.mem.Allocator,\n    issues: std.ArrayListUnmanaged(Issue),    // In-memory store\n    id_index: std.StringHashMapUnmanaged(usize), // Fast ID lookup\n    dirty_ids: std.StringHashMapUnmanaged(i64), // Track changes for sync\n    dirty: bool,\n    jsonl_path: []const u8,\n\n    pub fn insert(self: *Self, issue: Issue) !void {}\n    pub fn get(self: *Self, id: []const u8) !?Issue {}\n    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {}\n    pub fn delete(self: *Self, id: []const u8) !void {}\n    pub fn loadFromFile(self: *Self) !void {}\n    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {}\n    pub fn saveToFile(self: *Self) !void {}\n};\n\npub const IssueUpdate = struct {\n    title: ?[]const u8 = null,\n    status: ?Status = null,\n    priority: ?Priority = null,\n    expected_version: ?u64 = null,  // Optimistic locking\n    // ... other fields\n};\n```\n\n**ListFilters** - Used by list command:\n```zig\npub const ListFilters = struct {\n    status: ?Status = null,\n    priority: ?Priority = null,\n    priority_min: ?Priority = null,\n    priority_max: ?Priority = null,\n    issue_type: ?IssueType = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,      // Must have all\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: ListSort = .created_at,\n    limit: usize = 50,\n};\n```\n\n**EventStore** (events.zig - 490 lines):\n```zig\npub const EventStore = struct {\n    allocator: std.mem.Allocator,\n    events_path: []const u8,\n    next_id: i64,\n\n    pub fn append(self: *Self, event: Event) !i64 {}\n    pub fn getEventsForIssue(self: *Self, issue_id: []const u8) ![]Event {}\n    pub fn getAllEvents(self: *Self) ![]Event {}\n    pub fn queryEvents(self: *Self, params: QueryParams) ![]Event {}\n};\n\npub const QueryParams = struct {\n    issue_id: ?[]const u8 = null,\n    event_type: ?EventType = null,\n    actor: ?[]const u8 = null,\n    since: ?i64 = null,\n    until: ?i64 = null,\n    limit: ?usize = null,\n};\n```\n\n**WAL** (wal.zig):\n```zig\npub const WalOp = enum { create, update, delete };\npub const WalEntry = struct {\n    op: WalOp,\n    ts: i64,\n    id: []const u8,\n    data: Issue,  // Full issue snapshot\n};\n\npub const Wal = struct {\n    pub fn appendEntry(self: *Self, entry: WalEntry) !void {}\n    pub fn replay(self: *Self, store: *IssueStore) !ReplayStats {}\n};\n```\n\n**DependencyGraph** (graph.zig):\n- Builds in-memory graph from store\n- Cycle detection\n- Path finding\n- ASCII/DOT export\n\n---\n\n## 6. IMPLEMENTATION PATTERNS - HOW TO ADD A COMMAND\n\n### Pattern Overview:\n\n**Step 1: Define Arguments in args.zig**\n```zig\npub const MyCommandArgs = struct {\n    id: []const u8,\n    value: ?[]const u8 = null,\n};\n```\n\n**Step 2: Add to Command union**\n```zig\npub const Command = union(enum) {\n    my_command: MyCommandArgs,\n    // ...\n};\n```\n\n**Step 3: Create src/cli/my_command.zig**\n```zig\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\npub const MyCommandError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    InvalidInput,\n    StorageError,\n};\n\npub const MyCommandResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    value: ?[]const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    cmd_args: args.MyCommandArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    // 1. Initialize context\n    var ctx = (try common.CommandContext.init(allocator, global)) orelse {\n        return MyCommandError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // 2. Validate input\n    if (cmd_args.id.len == 0) {\n        try common.outputErrorTyped(MyCommandResult, &ctx.output, global.isStructuredOutput(), \"ID required\");\n        return MyCommandError.InvalidInput;\n    }\n\n    // 3. Perform operation\n    const issue = try ctx.store.get(cmd_args.id) orelse {\n        try common.outputNotFoundError(MyCommandResult, &ctx.output, global.isStructuredOutput(), cmd_args.id, allocator);\n        return MyCommandError.IssueNotFound;\n    };\n    defer issue.deinit(allocator);\n\n    // 4. Record event if needed\n    ctx.recordEvent(Event.statusChange(...));\n\n    // 5. Output results\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(MyCommandResult{\n            .success = true,\n            .id = cmd_args.id,\n            .value = \"result\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Operation succeeded\", .{});\n    }\n}\n\n// --- Tests ---\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = args.MyCommandArgs{ .id = \"bd-test\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent\" };\n    try std.testing.expectError(MyCommandError.WorkspaceNotInitialized, run(cmd_args, global, allocator));\n}\n```\n\n**Step 4: Export in mod.zig**\n```zig\npub const my_command = @import(\"my_command.zig\");\npub const MyCommandError = my_command.MyCommandError;\npub const MyCommandResult = my_command.MyCommandResult;\npub const runMyCommand = my_command.run;\n```\n\n**Step 5: Add dispatch in main.zig**\n```zig\n.my_command => |cmd_args| {\n    cli.runMyCommand(cmd_args, result.global, allocator) catch |err| switch (err) {\n        error.IssueNotFound => std.process.exit(1),\n        else => return err,\n    };\n},\n```\n\n---\n\n## 7. KEY PATTERNS & CONVENTIONS\n\n### Error Handling:\n- Every command defines its own Error set\n- Errors that exit with code 1 are caught in main.zig dispatch\n- Unknown errors propagate up\n- Use CommandContext for automatic error output formatting\n\n### Output Modes:\n- `--json` / `--toon` - Structured output (JSON or LLM format)\n- `--quiet` - Suppress output (except errors in normal mode)\n- `--silent` - Suppress ALL output (even errors, for tests)\n- Default - Human-readable terminal output\n\n### Persistence:\n- Single writes use `appendToWal()` for ~1ms latency\n- Bulk operations use `saveToFile()` for full JSONL rewrite\n- Auto-flush controlled by `--no-auto-flush`\n- WAL entries replayed on load for consistency\n\n### Concurrency:\n- flock-based blocking lock (no spinning)\n- Write operations serialize at lock acquisition\n- Read operations don't need locks (load + replay pattern)\n- Lock timeout configurable with `--lock-timeout MS`\n\n### Optimistic Locking:\n- Every issue has `version: u64`\n- Incremented on every update\n- Update can specify `expected_version` for CAS semantics\n- Fails with `VersionMismatch` if concurrent modification detected\n\n### Memory Management:\n- GeneralPurposeAllocator for CLI process\n- Allocations tied to CommandContext lifetime\n- defer cleanup on error paths\n- Arena allocation for issues in store\n\n### Testing:\n- Each module has inline `test` blocks\n- Uses `std.testing.allocator` for tests\n- `test_util` provides helper functions\n- Run with `zig build test` (523 tests total)\n\n---\n\n## 8. EXAMPLE COMMANDS ANALYZED\n\n### stats.zig (177 lines) - SIMPLE DATA COLLECTION PATTERN\nShows statistics: total issues, open/closed counts, groupings by status/priority/type.\n\n**Pattern:**\n1. Load workspace\n2. Iterate through all issues\n3. Count and aggregate (using StringHashMap for status/type)\n4. Convert arrays to output format\n5. Output as JSON or formatted table\n\n### history.zig (208 lines) - EVENT LOG PATTERN\nShows change history for a single issue.\n\n**Pattern:**\n1. Load workspace\n2. Verify issue exists\n3. Query EventStore for events matching issue_id\n4. Fall back to synthetic events from issue timestamps if no stored events\n5. Convert to output format\n6. Display with old/new values highlighted\n\n### audit.zig (148 lines) - PROJECT-WIDE LOG PATTERN\nShows all project events across all issues, sorted by recency.\n\n**Pattern:**\n1. Load workspace (no error if uninitialized - creates empty store)\n2. Build synthetic audit from issue metadata\n3. Sort by timestamp descending\n4. Apply limit and display\n\n### create.zig (439 lines) - CREATION PATTERN WITH PERSISTENCE\nCreates a new issue with all optional fields.\n\n**Pattern:**\n1. Validate required fields (title)\n2. Check workspace initialized\n3. Load existing store (for duplicate check)\n4. Parse optional fields (priority, type, due date, etc.)\n5. Generate unique ID from prefix + counter\n6. Create Issue struct and insert into store\n7. Append to WAL for fast persistence\n8. Record event for audit trail\n9. Output result (ID required for quick capture)\n\n### metrics.zig (76 lines) - SIMPLE STATE QUERY PATTERN\nShows lock contention metrics or resets them.\n\n**Pattern:**\n1. Get global metrics from storage module\n2. Handle --reset flag if set\n3. Format and output\n\n---\n\n## 9. AUDIT/EVENT SYSTEM\n\n### Event Model:\n- Stored separately in `.beads/events.jsonl`\n- Auto-incrementing ID per event\n- Tracks who (actor), what (event_type), when (timestamp)\n- old_value/new_value for state changes\n- Persisted immediately on append with fsync\n\n### Event Recording:\nCommands use `ctx.recordEvent(event)` to log changes. Examples:\n\n```zig\n// In create command\nctx.recordEvent(Event.issueCreated(issue_id, actor, now));\n\n// In close command\nctx.recordEvent(try Event.issueClosed(allocator, issue_id, actor, reason, now));\n\n// In update command\nif (old_priority != new_priority) {\n    ctx.recordEvent(try Event.priorityChange(allocator, id, actor, old, new, now));\n}\n```\n\n### Query Capabilities:\n- By issue_id\n- By event_type\n- By actor\n- By date range (since/until)\n- With limit\n\n---\n\n## 10. CRITICAL FILES & DEPENDENCIES\n\n**Must Read First:**\n1. `/home/hotschmoe/beads_zig/src/cli/args.zig` - All command argument definitions\n2. `/home/hotschmoe/beads_zig/src/cli/common.zig` - Shared utilities and CommandContext\n3. `/home/hotschmoe/beads_zig/src/models/issue.zig` - Primary data model\n4. `/home/hotschmoe/beads_zig/src/models/event.zig` - Event model for audit\n5. `/home/hotschmoe/beads_zig/src/storage/store.zig` - In-memory issue store\n6. `/home/hotschmoe/beads_zig/src/storage/events.zig` - Audit event persistence\n7. `/home/hotschmoe/beads_zig/src/main.zig` - Command dispatch entry point\n\n**Reference Commands (well-written examples):**\n1. `stats.zig` - Simple aggregation without state changes\n2. `history.zig` - Reading from EventStore\n3. `audit.zig` - Project-wide queries\n4. `create.zig` - Creating with WAL persistence and event recording\n5. `list.zig` - Complex filtering and list operations\n\n---\n\n## SUMMARY\n\nThe beads_zig codebase is well-structured with:\n\n- **Clear separation of concerns**: CLI, models, storage, output\n- **Consistent command patterns**: Every command follows the same initialization, execution, error handling flow\n- **Comprehensive event system**: Full audit trail with EventStore\n- **Efficient persistence**: WAL for single writes, JSONL for bulk, graceful corruption recovery\n- **Flexible output**: JSON, TOON (LLM format), plain text, quiet modes\n- **Memory safety**: Zig's memory model with explicit allocation/deallocation\n- **Optimistic locking**: Version-based CAS for concurrent safe updates\n- **Thorough testing**: 523 tests across all modules\n\nThe patterns are highly repeatable - adding new commands is straightforward following the established templates."}],"totalDurationMs":92437,"totalTokens":73523,"totalToolUseCount":30,"usage":{"input_tokens":7,"cache_creation_input_tokens":2328,"cache_read_input_tokens":71184,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2328},"output_tokens":4,"service_tier":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013UvQ6BRVCxf5nyhowbmSFK","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the existing audit command and stats command to understand their current implementation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7165,"cache_read_input_tokens":39069,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7165},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8e486645-d675-45ac-8e03-ed64fdb95613"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013UvQ6BRVCxf5nyhowbmSFK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MD2etX6yMGXQsMLebJADJS","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7165,"cache_read_input_tokens":39069,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7165},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4d73b089-1bb7-4677-be9d-9758610c3744"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MD2etX6yMGXQsMLebJADJS","type":"tool_result","content":"     1→//! Audit command for beads_zig.\n     2→//!\n     3→//! `bz audit [--limit N]` - Show project-wide audit log\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const AuditError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const AuditResult = struct {\n    18→    success: bool,\n    19→    events: ?[]const AuditEvent = null,\n    20→    total: ?usize = null,\n    21→    message: ?[]const u8 = null,\n    22→\n    23→    pub const AuditEvent = struct {\n    24→        issue_id: []const u8,\n    25→        event_type: []const u8,\n    26→        actor: []const u8,\n    27→        created_at: i64,\n    28→    };\n    29→};\n    30→\n    31→pub fn run(\n    32→    audit_args: args.AuditArgs,\n    33→    global: args.GlobalOptions,\n    34→    allocator: std.mem.Allocator,\n    35→) !void {\n    36→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    37→        return AuditError.WorkspaceNotInitialized;\n    38→    };\n    39→    defer ctx.deinit();\n    40→\n    41→    const limit = audit_args.limit orelse 100;\n    42→\n    43→    // Build synthetic audit log from all issues\n    44→    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    45→    defer events.deinit(allocator);\n    46→\n    47→    for (ctx.store.issues.items) |issue| {\n    48→        // Created event\n    49→        try events.append(allocator, .{\n    50→            .issue_id = issue.id,\n    51→            .event_type = \"created\",\n    52→            .actor = issue.created_by orelse \"unknown\",\n    53→            .created_at = issue.created_at.value,\n    54→        });\n    55→\n    56→        // Closed event\n    57→        if (issue.closed_at.value) |closed_ts| {\n    58→            try events.append(allocator, .{\n    59→                .issue_id = issue.id,\n    60→                .event_type = \"closed\",\n    61→                .actor = \"unknown\",\n    62→                .created_at = closed_ts,\n    63→            });\n    64→        }\n    65→\n    66→        // If tombstoned\n    67→        if (issue.status.eql(.tombstone)) {\n    68→            try events.append(allocator, .{\n    69→                .issue_id = issue.id,\n    70→                .event_type = \"deleted\",\n    71→                .actor = \"unknown\",\n    72→                .created_at = issue.updated_at.value,\n    73→            });\n    74→        }\n    75→    }\n    76→\n    77→    // Sort by timestamp descending (most recent first)\n    78→    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n    79→        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n    80→            return a.created_at > b.created_at;\n    81→        }\n    82→    }.lessThan);\n    83→\n    84→    // Apply limit\n    85→    const display_count = @min(events.items.len, limit);\n    86→    const display_events = events.items[0..display_count];\n    87→\n    88→    if (global.isStructuredOutput()) {\n    89→        try ctx.output.printJson(AuditResult{\n    90→            .success = true,\n    91→            .events = display_events,\n    92→            .total = events.items.len,\n    93→        });\n    94→    } else if (global.quiet) {\n    95→        for (display_events) |event| {\n    96→            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n    97→        }\n    98→    } else {\n    99→        if (display_events.len == 0) {\n   100→            try ctx.output.info(\"No events found\", .{});\n   101→        } else {\n   102→            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n   103→            try ctx.output.print(\"\\n\", .{});\n   104→\n   105→            for (display_events) |event| {\n   106→                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n   107→                    event.created_at,\n   108→                    event.issue_id,\n   109→                    event.actor,\n   110→                    event.event_type,\n   111→                });\n   112→            }\n   113→\n   114→            if (events.items.len > display_count) {\n   115→                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n   116→                    events.items.len - display_count,\n   117→                });\n   118→            }\n   119→        }\n   120→    }\n   121→}\n   122→\n   123→// --- Tests ---\n   124→\n   125→test \"AuditError enum exists\" {\n   126→    const err: AuditError = AuditError.WorkspaceNotInitialized;\n   127→    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n   128→}\n   129→\n   130→test \"AuditResult struct works\" {\n   131→    const result = AuditResult{\n   132→        .success = true,\n   133→        .total = 10,\n   134→    };\n   135→    try std.testing.expect(result.success);\n   136→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   137→}\n   138→\n   139→test \"run detects uninitialized workspace\" {\n   140→    const allocator = std.testing.allocator;\n   141→\n   142→    const audit_args = args.AuditArgs{};\n   143→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   144→\n   145→    const result = run(audit_args, global, allocator);\n   146→    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n   147→}\n   148→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"150caf84-e891-4002-9a35-ccb4109ce2d1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","content":"//! Audit command for beads_zig.\n//!\n//! `bz audit [--limit N]` - Show project-wide audit log\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = audit_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n","numLines":148,"startLine":1,"totalLines":148}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013UvQ6BRVCxf5nyhowbmSFK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Cgjc7CjscH9oK4w5kA6BZM","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/stats.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7165,"cache_read_input_tokens":39069,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7165},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"667827ee-d195-42a0-aed7-d9108b59aec4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Cgjc7CjscH9oK4w5kA6BZM","type":"tool_result","content":"     1→//! Stats command for beads_zig.\n     2→//!\n     3→//! `bz stats` - Show project statistics\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const StatsError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const StatsResult = struct {\n    18→    success: bool,\n    19→    total: ?usize = null,\n    20→    open: ?usize = null,\n    21→    closed: ?usize = null,\n    22→    by_status: ?[]const CountEntry = null,\n    23→    by_priority: ?[]const CountEntry = null,\n    24→    by_type: ?[]const CountEntry = null,\n    25→    message: ?[]const u8 = null,\n    26→\n    27→    pub const CountEntry = struct {\n    28→        key: []const u8,\n    29→        count: usize,\n    30→    };\n    31→};\n    32→\n    33→pub fn run(\n    34→    global: args.GlobalOptions,\n    35→    allocator: std.mem.Allocator,\n    36→) !void {\n    37→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    38→        return StatsError.WorkspaceNotInitialized;\n    39→    };\n    40→    defer ctx.deinit();\n    41→\n    42→    // Count totals\n    43→    var total: usize = 0;\n    44→    var open: usize = 0;\n    45→    var closed: usize = 0;\n    46→\n    47→    // Count by status\n    48→    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    49→    defer status_counts.deinit(allocator);\n    50→\n    51→    // Count by priority\n    52→    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n    53→\n    54→    // Count by type\n    55→    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    56→    defer type_counts.deinit(allocator);\n    57→\n    58→    for (ctx.store.issues.items) |issue| {\n    59→        if (issue.status.eql(.tombstone)) continue;\n    60→\n    61→        total += 1;\n    62→\n    63→        // Status\n    64→        const status_str = issue.status.toString();\n    65→        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n    66→        status_entry.value_ptr.* += 1;\n    67→\n    68→        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n    69→            open += 1;\n    70→        } else if (issue.status.eql(.closed)) {\n    71→            closed += 1;\n    72→        }\n    73→\n    74→        // Priority\n    75→        if (issue.priority.value <= 4) {\n    76→            priority_counts[issue.priority.value] += 1;\n    77→        }\n    78→\n    79→        // Type\n    80→        const type_str = issue.issue_type.toString();\n    81→        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n    82→        type_entry.value_ptr.* += 1;\n    83→    }\n    84→\n    85→    // Convert to arrays for output\n    86→    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    87→    defer status_list.deinit(allocator);\n    88→\n    89→    var status_it = status_counts.iterator();\n    90→    while (status_it.next()) |entry| {\n    91→        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    92→    }\n    93→\n    94→    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    95→    defer priority_list.deinit(allocator);\n    96→\n    97→    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    98→    for (0..5) |i| {\n    99→        if (priority_counts[i] > 0) {\n   100→            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n   101→        }\n   102→    }\n   103→\n   104→    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n   105→    defer type_list.deinit(allocator);\n   106→\n   107→    var type_it = type_counts.iterator();\n   108→    while (type_it.next()) |entry| {\n   109→        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n   110→    }\n   111→\n   112→    if (global.isStructuredOutput()) {\n   113→        try ctx.output.printJson(StatsResult{\n   114→            .success = true,\n   115→            .total = total,\n   116→            .open = open,\n   117→            .closed = closed,\n   118→            .by_status = status_list.items,\n   119→            .by_priority = priority_list.items,\n   120→            .by_type = type_list.items,\n   121→        });\n   122→    } else if (!global.quiet) {\n   123→        try ctx.output.println(\"Issue Statistics\", .{});\n   124→        try ctx.output.print(\"\\n\", .{});\n   125→        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n   126→        try ctx.output.print(\"\\n\", .{});\n   127→\n   128→        if (status_list.items.len > 0) {\n   129→            try ctx.output.print(\"By Status:\\n\", .{});\n   130→            for (status_list.items) |entry| {\n   131→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   132→            }\n   133→        }\n   134→\n   135→        if (priority_list.items.len > 0) {\n   136→            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n   137→            for (priority_list.items) |entry| {\n   138→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   139→            }\n   140→        }\n   141→\n   142→        if (type_list.items.len > 0) {\n   143→            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n   144→            for (type_list.items) |entry| {\n   145→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   146→            }\n   147→        }\n   148→    }\n   149→}\n   150→\n   151→// --- Tests ---\n   152→\n   153→test \"StatsError enum exists\" {\n   154→    const err: StatsError = StatsError.WorkspaceNotInitialized;\n   155→    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n   156→}\n   157→\n   158→test \"StatsResult struct works\" {\n   159→    const result = StatsResult{\n   160→        .success = true,\n   161→        .total = 10,\n   162→        .open = 5,\n   163→        .closed = 5,\n   164→    };\n   165→    try std.testing.expect(result.success);\n   166→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   167→}\n   168→\n   169→test \"run detects uninitialized workspace\" {\n   170→    const allocator = std.testing.allocator;\n   171→\n   172→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   173→\n   174→    const result = run(global, allocator);\n   175→    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n   176→}\n   177→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"cb79332d-09b5-4711-b405-4a072643cce5","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/stats.zig","content":"//! Stats command for beads_zig.\n//!\n//! `bz stats` - Show project statistics\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const StatsError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const StatsResult = struct {\n    success: bool,\n    total: ?usize = null,\n    open: ?usize = null,\n    closed: ?usize = null,\n    by_status: ?[]const CountEntry = null,\n    by_priority: ?[]const CountEntry = null,\n    by_type: ?[]const CountEntry = null,\n    message: ?[]const u8 = null,\n\n    pub const CountEntry = struct {\n        key: []const u8,\n        count: usize,\n    };\n};\n\npub fn run(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return StatsError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count totals\n    var total: usize = 0;\n    var open: usize = 0;\n    var closed: usize = 0;\n\n    // Count by status\n    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer status_counts.deinit(allocator);\n\n    // Count by priority\n    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n\n    // Count by type\n    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer type_counts.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        total += 1;\n\n        // Status\n        const status_str = issue.status.toString();\n        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n        status_entry.value_ptr.* += 1;\n\n        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n            open += 1;\n        } else if (issue.status.eql(.closed)) {\n            closed += 1;\n        }\n\n        // Priority\n        if (issue.priority.value <= 4) {\n            priority_counts[issue.priority.value] += 1;\n        }\n\n        // Type\n        const type_str = issue.issue_type.toString();\n        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n        type_entry.value_ptr.* += 1;\n    }\n\n    // Convert to arrays for output\n    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer status_list.deinit(allocator);\n\n    var status_it = status_counts.iterator();\n    while (status_it.next()) |entry| {\n        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer priority_list.deinit(allocator);\n\n    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    for (0..5) |i| {\n        if (priority_counts[i] > 0) {\n            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n        }\n    }\n\n    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer type_list.deinit(allocator);\n\n    var type_it = type_counts.iterator();\n    while (type_it.next()) |entry| {\n        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(StatsResult{\n            .success = true,\n            .total = total,\n            .open = open,\n            .closed = closed,\n            .by_status = status_list.items,\n            .by_priority = priority_list.items,\n            .by_type = type_list.items,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Issue Statistics\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n        try ctx.output.print(\"\\n\", .{});\n\n        if (status_list.items.len > 0) {\n            try ctx.output.print(\"By Status:\\n\", .{});\n            for (status_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (priority_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n            for (priority_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (type_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n            for (type_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"StatsError enum exists\" {\n    const err: StatsError = StatsError.WorkspaceNotInitialized;\n    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n}\n\ntest \"StatsResult struct works\" {\n    const result = StatsResult{\n        .success = true,\n        .total = 10,\n        .open = 5,\n        .closed = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(global, allocator);\n    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n}\n","numLines":177,"startLine":1,"totalLines":177}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013UvQ6BRVCxf5nyhowbmSFK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EHg4ou8EhNC4paXz6ZjCiW","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7165,"cache_read_input_tokens":39069,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7165},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"91f60ed0-7026-4110-8ef9-2cff15399952"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (31791 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01EHg4ou8EhNC4paXz6ZjCiW"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2a55b98e-bfd7-412a-a3c7-7e8d6eba0388","tool_use_result":"Error: File content (31791 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X7UHXmiooNhHUYE4ooGg9B","type":"message","role":"assistant","content":[{"type":"text","text":"The args.zig file is too large. Let me read it in parts to understand the command argument structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4695,"cache_read_input_tokens":46234,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4695},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"bc5813db-b3d2-4699-b5c0-8616b67f92cb"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X7UHXmiooNhHUYE4ooGg9B","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HS9hQwLXB69TCLWEsTUymt","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4695,"cache_read_input_tokens":46234,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4695},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d39458d4-fbf3-43a8-9f80-81181e805471"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HS9hQwLXB69TCLWEsTUymt","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    robot: bool = false, // Line-oriented machine-readable output for scripting\n    13→    quiet: bool = false,\n    14→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    15→    verbose: u8 = 0,\n    16→    no_color: bool = false,\n    17→    wrap: bool = false, // Wrap long lines in plain text output\n    18→    stats: bool = false, // Show token savings stats for TOON output\n    19→    data_path: ?[]const u8 = null,\n    20→    actor: ?[]const u8 = null,\n    21→    lock_timeout: u32 = 5000,\n    22→    no_auto_flush: bool = false,\n    23→    no_auto_import: bool = false,\n    24→\n    25→    /// Returns true if structured output (JSON or TOON) is enabled.\n    26→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    27→        return self.json or self.toon;\n    28→    }\n    29→\n    30→    /// Returns true if any machine-readable output is enabled.\n    31→    pub fn isMachineOutput(self: GlobalOptions) bool {\n    32→        return self.json or self.toon or self.robot;\n    33→    }\n    34→};\n    35→\n    36→/// All available subcommands.\n    37→pub const Command = union(enum) {\n    38→    // Workspace\n    39→    init: InitArgs,\n    40→    info: void,\n    41→    stats: void,\n    42→    doctor: void,\n    43→    config: ConfigArgs,\n    44→    orphans: OrphansArgs,\n    45→    lint: LintArgs,\n    46→    where: void,\n    47→\n    48→    // Issue CRUD\n    49→    create: CreateArgs,\n    50→    q: QuickArgs,\n    51→    show: ShowArgs,\n    52→    update: UpdateArgs,\n    53→    close: CloseArgs,\n    54→    reopen: ReopenArgs,\n    55→    delete: DeleteArgs,\n    56→\n    57→    // Batch Operations\n    58→    add_batch: AddBatchArgs,\n    59→    import_cmd: ImportArgs,\n    60→\n    61→    // Query\n    62→    list: ListArgs,\n    63→    ready: ReadyArgs,\n    64→    blocked: BlockedArgs,\n    65→    search: SearchArgs,\n    66→    stale: StaleArgs,\n    67→    count: CountArgs,\n    68→    defer_cmd: DeferArgs,\n    69→    undefer: UndeferArgs,\n    70→\n    71→    // Dependencies\n    72→    dep: DepArgs,\n    73→    graph: GraphArgs,\n    74→\n    75→    // Epics\n    76→    epic: EpicArgs,\n    77→\n    78→    // Labels\n    79→    label: LabelArgs,\n    80→\n    81→    // Comments\n    82→    comments: CommentsArgs,\n    83→\n    84→    // Audit\n    85→    history: HistoryArgs,\n    86→    audit: AuditArgs,\n    87→\n    88→    // Changelog\n    89→    changelog: ChangelogArgs,\n    90→\n    91→    // Sync\n    92→    sync: SyncArgs,\n    93→\n    94→    // Backup\n    95→    backup: BackupArgs,\n    96→\n    97→    // System\n    98→    version: void,\n    99→    schema: void,\n   100→    completions: CompletionsArgs,\n   101→    metrics: MetricsArgs,\n   102→\n   103→    // Saved Queries\n   104→    query: QueryArgs,\n   105→\n   106→    // Self-upgrade\n   107→    upgrade: UpgradeArgs,\n   108→\n   109→    // Help\n   110→    help: HelpArgs,\n   111→};\n   112→\n   113→/// Init command arguments.\n   114→pub const InitArgs = struct {\n   115→    prefix: []const u8 = \"bd\",\n   116→};\n   117→\n   118→/// Create command arguments.\n   119→pub const CreateArgs = struct {\n   120→    title: []const u8,\n   121→    description: ?[]const u8 = null,\n   122→    issue_type: ?[]const u8 = null,\n   123→    priority: ?[]const u8 = null,\n   124→    assignee: ?[]const u8 = null,\n   125→    owner: ?[]const u8 = null,\n   126→    design: ?[]const u8 = null,\n   127→    acceptance_criteria: ?[]const u8 = null,\n   128→    external_ref: ?[]const u8 = null,\n   129→    labels: []const []const u8 = &[_][]const u8{},\n   130→    deps: []const []const u8 = &[_][]const u8{},\n   131→    due: ?[]const u8 = null,\n   132→    estimate: ?i32 = null,\n   133→    ephemeral: bool = false, // Local-only, not written to JSONL\n   134→};\n   135→\n   136→/// Quick capture command arguments.\n   137→pub const QuickArgs = struct {\n   138→    title: []const u8,\n   139→    priority: ?[]const u8 = null,\n   140→};\n   141→\n   142→/// Show command arguments.\n   143→pub const ShowArgs = struct {\n   144→    id: []const u8,\n   145→    with_comments: bool = true,\n   146→    with_history: bool = false,\n   147→};\n   148→\n   149→/// Update command arguments.\n   150→pub const UpdateArgs = struct {\n   151→    id: []const u8,\n   152→    title: ?[]const u8 = null,\n   153→    description: ?[]const u8 = null,\n   154→    issue_type: ?[]const u8 = null,\n   155→    priority: ?[]const u8 = null,\n   156→    assignee: ?[]const u8 = null,\n   157→    owner: ?[]const u8 = null,\n   158→    design: ?[]const u8 = null,\n   159→    acceptance_criteria: ?[]const u8 = null,\n   160→    external_ref: ?[]const u8 = null,\n   161→    status: ?[]const u8 = null,\n   162→    /// Expected version for optimistic locking (compare-and-swap).\n   163→    expected_version: ?u64 = null,\n   164→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   165→    claim: bool = false,\n   166→};\n   167→\n   168→/// Close command arguments.\n   169→pub const CloseArgs = struct {\n   170→    id: []const u8,\n   171→    reason: ?[]const u8 = null,\n   172→    session: ?[]const u8 = null,\n   173→};\n   174→\n   175→/// Reopen command arguments.\n   176→pub const ReopenArgs = struct {\n   177→    id: []const u8,\n   178→};\n   179→\n   180→/// Delete command arguments.\n   181→pub const DeleteArgs = struct {\n   182→    /// Single issue ID to delete (mutually exclusive with from_file).\n   183→    id: ?[]const u8 = null,\n   184→    /// Path to file containing issue IDs to delete (one per line).\n   185→    from_file: ?[]const u8 = null,\n   186→    /// Delete issue and all its dependents recursively.\n   187→    cascade: bool = false,\n   188→    /// Prune from database immediately instead of marking as tombstone.\n   189→    hard: bool = false,\n   190→    /// Preview what would be deleted without making changes.\n   191→    dry_run: bool = false,\n   192→};\n   193→\n   194→/// Add-batch command arguments.\n   195→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   196→pub const AddBatchArgs = struct {\n   197→    file: ?[]const u8 = null, // Read from file instead of stdin\n   198→    format: BatchFormat = .titles, // Input format\n   199→};\n   200→\n   201→/// Batch input format.\n   202→pub const BatchFormat = enum {\n   203→    titles, // One title per line\n   204→    jsonl, // Full JSONL format (one issue per line)\n   205→\n   206→    pub fn fromString(s: []const u8) ?BatchFormat {\n   207→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   208→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   209→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   210→        return null;\n   211→    }\n   212→};\n   213→\n   214→/// Import command arguments.\n   215→/// Imports issues from a JSONL file with single lock acquisition.\n   216→pub const ImportArgs = struct {\n   217→    file: []const u8, // Path to JSONL file (required)\n   218→    merge: bool = false, // Merge instead of replace\n   219→    dry_run: bool = false, // Show what would be imported without importing\n   220→};\n   221→\n   222→/// Output format for list/ready commands.\n   223→pub const OutputFormat = enum {\n   224→    default,\n   225→    csv,\n   226→\n   227→    pub fn fromString(s: []const u8) ?OutputFormat {\n   228→        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n   229→        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n   230→        return null;\n   231→    }\n   232→};\n   233→\n   234→/// Sort field options for list command.\n   235→pub const SortField = enum {\n   236→    created_at,\n   237→    updated_at,\n   238→    priority,\n   239→\n   240→    pub fn fromString(s: []const u8) ?SortField {\n   241→        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n   242→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   243→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   244→        return null;\n   245→    }\n   246→};\n   247→\n   248→/// List command arguments.\n   249→pub const ListArgs = struct {\n   250→    status: ?[]const u8 = null,\n   251→    priority: ?[]const u8 = null,\n   252→    priority_min: ?[]const u8 = null,\n   253→    priority_max: ?[]const u8 = null,\n   254→    issue_type: ?[]const u8 = null,\n   255→    assignee: ?[]const u8 = null,\n   256→    label: ?[]const u8 = null,\n   257→    label_any: []const []const u8 = &[_][]const u8{},\n   258→    title_contains: ?[]const u8 = null,\n   259→    desc_contains: ?[]const u8 = null,\n   260→    notes_contains: ?[]const u8 = null,\n   261→    limit: ?u32 = null,\n   262→    all: bool = false,\n   263→    overdue: bool = false,\n   264→    include_deferred: bool = false,\n   265→    sort: SortField = .created_at,\n   266→    sort_desc: bool = true,\n   267→    parent: ?[]const u8 = null,\n   268→    recursive: bool = false,\n   269→    format: OutputFormat = .default,\n   270→    fields: ?[]const u8 = null,\n   271→};\n   272→\n   273→/// Ready command arguments.\n   274→pub const ReadyArgs = struct {\n   275→    limit: ?u32 = null,\n   276→    priority_min: ?[]const u8 = null,\n   277→    priority_max: ?[]const u8 = null,\n   278→    title_contains: ?[]const u8 = null,\n   279→    desc_contains: ?[]const u8 = null,\n   280→    notes_contains: ?[]const u8 = null,\n   281→    overdue: bool = false,\n   282→    include_deferred: bool = false,\n   283→    parent: ?[]const u8 = null,\n   284→    recursive: bool = false,\n   285→    format: OutputFormat = .default,\n   286→    fields: ?[]const u8 = null,\n   287→};\n   288→\n   289→/// Blocked command arguments.\n   290→pub const BlockedArgs = struct {\n   291→    limit: ?u32 = null,\n   292→    priority_min: ?[]const u8 = null,\n   293→    priority_max: ?[]const u8 = null,\n   294→    title_contains: ?[]const u8 = null,\n   295→    desc_contains: ?[]const u8 = null,\n   296→    notes_contains: ?[]const u8 = null,\n   297→};\n   298→\n   299→/// Search command arguments.\n   300→pub const SearchArgs = struct {\n   301→    query: []const u8,\n   302→    limit: ?u32 = null,\n   303→};\n   304→\n   305→/// Stale command arguments.\n   306→pub const StaleArgs = struct {\n   307→    days: u32 = 30,\n   308→    limit: ?u32 = null,\n   309→};\n   310→\n   311→/// Count command arguments.\n   312→pub const CountArgs = struct {\n   313→    group_by: ?[]const u8 = null,\n   314→};\n   315→\n   316→/// Defer command arguments.\n   317→pub const DeferArgs = struct {\n   318→    id: []const u8,\n   319→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   320→    reason: ?[]const u8 = null,\n   321→};\n   322→\n   323→/// Undefer command arguments.\n   324→pub const UndeferArgs = struct {\n   325→    id: []const u8,\n   326→};\n   327→\n   328→/// Epic subcommand variants.\n   329→pub const EpicSubcommand = union(enum) {\n   330→    create: struct {\n   331→        title: []const u8,\n   332→        description: ?[]const u8 = null,\n   333→        priority: ?[]const u8 = null,\n   334→    },\n   335→    add: struct {\n   336→        epic_id: []const u8,\n   337→        issue_id: []const u8,\n   338→    },\n   339→    remove: struct {\n   340→        epic_id: []const u8,\n   341→        issue_id: []const u8,\n   342→    },\n   343→    list: struct {\n   344→        epic_id: []const u8,\n   345→    },\n   346→    status: void,\n   347→    close_eligible: struct {\n   348→        dry_run: bool = false,\n   349→    },\n   350→};\n   351→\n   352→/// Epic command arguments.\n   353→pub const EpicArgs = struct {\n   354→    subcommand: EpicSubcommand,\n   355→};\n   356→\n   357→/// Direction filter for dependency listing.\n   358→pub const DepDirection = enum {\n   359→    up, // What depends on this issue (dependents/blocked-by)\n   360→    down, // What this issue depends on\n   361→    both, // Both directions (default)\n   362→\n   363→    pub fn fromString(s: []const u8) ?DepDirection {\n   364→        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n   365→        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n   366→        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n   367→        return null;\n   368→    }\n   369→};\n   370→\n   371→/// Tree output formats for dep tree.\n   372→pub const TreeFormat = enum {\n   373→    ascii,\n   374→    mermaid,\n   375→\n   376→    pub fn fromString(s: []const u8) ?TreeFormat {\n   377→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   378→        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n   379→        return null;\n   380→    }\n   381→};\n   382→\n   383→/// Dependency subcommand variants.\n   384→pub const DepSubcommand = union(enum) {\n   385→    add: struct {\n   386→        child: []const u8,\n   387→        parent: []const u8,\n   388→        dep_type: []const u8 = \"blocks\",\n   389→        metadata: ?[]const u8 = null,\n   390→    },\n   391→    remove: struct {\n   392→        child: []const u8,\n   393→        parent: []const u8,\n   394→    },\n   395→    list: struct {\n   396→        id: []const u8,\n   397→        direction: DepDirection = .both,\n   398→    },\n   399→    tree: struct {\n   400→        id: []const u8,\n   401→        format: TreeFormat = .ascii,\n   402→    },\n   403→    cycles: void,\n   404→};\n   405→\n   406→/// Dependency command arguments.\n   407→pub const DepArgs = struct {\n   408→    subcommand: DepSubcommand,\n   409→};\n   410→\n   411→/// Graph command output formats.\n   412→pub const GraphFormat = enum {\n   413→    ascii,\n   414→    dot,\n   415→\n   416→    pub fn fromString(s: []const u8) ?GraphFormat {\n   417→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   418→        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n   419→        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n   420→        return null;\n   421→    }\n   422→};\n   423→\n   424→/// Graph command arguments.\n   425→pub const GraphArgs = struct {\n   426→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   427→    format: GraphFormat = .ascii,\n   428→    depth: ?u32 = null, // Max depth for tree traversal\n   429→};\n   430→\n   431→/// Label subcommand variants.\n   432→pub const LabelSubcommand = union(enum) {\n   433→    add: struct {\n   434→        id: []const u8,\n   435→        labels: []const []const u8,\n   436→    },\n   437→    remove: struct {\n   438→        id: []const u8,\n   439→        labels: []const []const u8,\n   440→    },\n   441→    list: struct {\n   442→        id: []const u8,\n   443→    },\n   444→    list_all: void,\n   445→    rename: struct {\n   446→        old_name: []const u8,\n   447→        new_name: []const u8,\n   448→    },\n   449→};\n   450→\n   451→/// Label command arguments.\n   452→pub const LabelArgs = struct {\n   453→    subcommand: LabelSubcommand,\n   454→};\n   455→\n   456→/// Comments subcommand variants.\n   457→pub const CommentsSubcommand = union(enum) {\n   458→    add: struct {\n   459→        id: []const u8,\n   460→        text: []const u8,\n   461→    },\n   462→    list: struct {\n   463→        id: []const u8,\n   464→    },\n   465→};\n   466→\n   467→/// Comments command arguments.\n   468→pub const CommentsArgs = struct {\n   469→    subcommand: CommentsSubcommand,\n   470→};\n   471→\n   472→/// History command arguments.\n   473→pub const HistoryArgs = struct {\n   474→    id: []const u8,\n   475→};\n   476→\n   477→/// Audit command arguments.\n   478→pub const AuditArgs = struct {\n   479→    limit: ?u32 = null,\n   480→};\n   481→\n   482→/// Changelog command arguments.\n   483→pub const ChangelogArgs = struct {\n   484→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   485→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   486→    limit: ?u32 = null,\n   487→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   488→};\n   489→\n   490→/// Error policy for export operations.\n   491→pub const ErrorPolicy = enum {\n   492→    strict, // Fail on any error\n   493→    best_effort, // Continue on errors, report at end\n   494→    partial, // Export what we can, skip errors silently\n   495→\n   496→    pub fn fromString(s: []const u8) ?ErrorPolicy {\n   497→        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n   498→        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n   499→        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n   500→        return null;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"81c70749-1f76-42e8-a274-bc97a81fa0dc","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;","numLines":500,"startLine":1,"totalLines":2746}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01X7UHXmiooNhHUYE4ooGg9B","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PSxm8NKcisR2tRwqnsVzCD","name":"Grep","input":{"pattern":"AuditArgs|StatsArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4695,"cache_read_input_tokens":46234,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4695},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2270b3d1-d2c7-45ef-8b66-313a1c4dd355"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PSxm8NKcisR2tRwqnsVzCD","type":"tool_result","content":"76-    epic: EpicArgs,\n77-\n78-    // Labels\n79-    label: LabelArgs,\n80-\n81-    // Comments\n82-    comments: CommentsArgs,\n83-\n84-    // Audit\n85-    history: HistoryArgs,\n86:    audit: AuditArgs,\n87-\n88-    // Changelog\n89-    changelog: ChangelogArgs,\n90-\n91-    // Sync\n92-    sync: SyncArgs,\n93-\n94-    // Backup\n95-    backup: BackupArgs,\n96-\n--\n468-pub const CommentsArgs = struct {\n469-    subcommand: CommentsSubcommand,\n470-};\n471-\n472-/// History command arguments.\n473-pub const HistoryArgs = struct {\n474-    id: []const u8,\n475-};\n476-\n477-/// Audit command arguments.\n478:pub const AuditArgs = struct {\n479-    limit: ?u32 = null,\n480-};\n481-\n482-/// Changelog command arguments.\n483-pub const ChangelogArgs = struct {\n484-    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n485-    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n486-    limit: ?u32 = null,\n487-    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n488-};\n--\n900-        // Comments\n901-        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n902-            return .{ .comments = try self.parseCommentsArgs() };\n903-        }\n904-\n905-        // Audit\n906-        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n907-            return .{ .history = try self.parseHistoryArgs() };\n908-        }\n909-        if (std.mem.eql(u8, cmd, \"audit\")) {\n910:            return .{ .audit = try self.parseAuditArgs() };\n911-        }\n912-\n913-        // Changelog\n914-        if (std.mem.eql(u8, cmd, \"changelog\")) {\n915-            return .{ .changelog = try self.parseChangelogArgs() };\n916-        }\n917-\n918-        // Sync\n919-        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n920-            return .{ .sync = try self.parseSyncArgs() };\n--\n1542-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n1543-        }\n1544-        return error.UnknownSubcommand;\n1545-    }\n1546-\n1547-    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n1548-        const id = self.next() orelse return error.MissingRequiredArgument;\n1549-        return .{ .id = id };\n1550-    }\n1551-\n1552:    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n1553:        var result = AuditArgs{};\n1554-        while (self.hasNext()) {\n1555-            if (try self.parseLimitFlag()) |limit| {\n1556-                result.limit = limit;\n1557-            } else break;\n1558-        }\n1559-        return result;\n1560-    }\n1561-\n1562-    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n1563-        var result = ChangelogArgs{};"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d6fc6b5c-f75b-4248-9dd3-0d9451ed5814","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"76-    epic: EpicArgs,\n77-\n78-    // Labels\n79-    label: LabelArgs,\n80-\n81-    // Comments\n82-    comments: CommentsArgs,\n83-\n84-    // Audit\n85-    history: HistoryArgs,\n86:    audit: AuditArgs,\n87-\n88-    // Changelog\n89-    changelog: ChangelogArgs,\n90-\n91-    // Sync\n92-    sync: SyncArgs,\n93-\n94-    // Backup\n95-    backup: BackupArgs,\n96-\n--\n468-pub const CommentsArgs = struct {\n469-    subcommand: CommentsSubcommand,\n470-};\n471-\n472-/// History command arguments.\n473-pub const HistoryArgs = struct {\n474-    id: []const u8,\n475-};\n476-\n477-/// Audit command arguments.\n478:pub const AuditArgs = struct {\n479-    limit: ?u32 = null,\n480-};\n481-\n482-/// Changelog command arguments.\n483-pub const ChangelogArgs = struct {\n484-    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n485-    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n486-    limit: ?u32 = null,\n487-    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n488-};\n--\n900-        // Comments\n901-        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n902-            return .{ .comments = try self.parseCommentsArgs() };\n903-        }\n904-\n905-        // Audit\n906-        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n907-            return .{ .history = try self.parseHistoryArgs() };\n908-        }\n909-        if (std.mem.eql(u8, cmd, \"audit\")) {\n910:            return .{ .audit = try self.parseAuditArgs() };\n911-        }\n912-\n913-        // Changelog\n914-        if (std.mem.eql(u8, cmd, \"changelog\")) {\n915-            return .{ .changelog = try self.parseChangelogArgs() };\n916-        }\n917-\n918-        // Sync\n919-        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n920-            return .{ .sync = try self.parseSyncArgs() };\n--\n1542-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n1543-        }\n1544-        return error.UnknownSubcommand;\n1545-    }\n1546-\n1547-    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n1548-        const id = self.next() orelse return error.MissingRequiredArgument;\n1549-        return .{ .id = id };\n1550-    }\n1551-\n1552:    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n1553:        var result = AuditArgs{};\n1554-        while (self.hasNext()) {\n1555-            if (try self.parseLimitFlag()) |limit| {\n1556-                result.limit = limit;\n1557-            } else break;\n1558-        }\n1559-        return result;\n1560-    }\n1561-\n1562-    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n1563-        var result = ChangelogArgs{};","numLines":88}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014XbUex58XjX6BPhsgZZE53","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RHZ33mAcf6VFNtY4u4XYPp","name":"TodoWrite","input":{"todos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"in_progress","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"pending","activeForm":"Adding --activity git-based stats to stats command"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7344,"cache_read_input_tokens":50929,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7344},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"13e8c66b-1df1-4737-a72e-c739921e4e5a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RHZ33mAcf6VFNtY4u4XYPp","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1471395e-03ad-4b9b-a3f6-b65adc620d2e","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"in_progress","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"pending","activeForm":"Adding --activity git-based stats to stats command"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018NDyQdFeTChL2FXrAziw7Z","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read more of the args.zig to understand parsing patterns for subcommands and look at the main.zig for command dispatch."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":174,"cache_read_input_tokens":58273,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":174},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"81921f40-e30b-4150-923b-da2764ea4f99"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018NDyQdFeTChL2FXrAziw7Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XfDnCVr3UdK7ZXDwcZBpS5","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1200,"limit":400}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":174,"cache_read_input_tokens":58273,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":174},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d45c9968-528a-48a0-af22-7abaab00af64"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XfDnCVr3UdK7ZXDwcZBpS5","type":"tool_result","content":"  1200→    fn parseListArgs(self: *Self) ParseError!ListArgs {\n  1201→        var result = ListArgs{};\n  1202→        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n  1203→\n  1204→        while (self.hasNext()) {\n  1205→            if (self.consumeFlag(\"-s\", \"--status\")) {\n  1206→                result.status = self.next() orelse return error.MissingFlagValue;\n  1207→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1208→                result.priority = self.next() orelse return error.MissingFlagValue;\n  1209→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1210→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1211→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1212→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1213→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n  1214→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n  1215→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n  1216→                result.assignee = self.next() orelse return error.MissingFlagValue;\n  1217→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n  1218→                result.label = self.next() orelse return error.MissingFlagValue;\n  1219→            } else if (self.consumeFlag(null, \"--label-any\")) {\n  1220→                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n  1221→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1222→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1223→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1224→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1225→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1226→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1227→            } else if (try self.parseLimitFlag()) |limit| {\n  1228→                result.limit = limit;\n  1229→            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n  1230→                result.all = true;\n  1231→            } else if (self.consumeFlag(null, \"--overdue\")) {\n  1232→                result.overdue = true;\n  1233→            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n  1234→                result.include_deferred = true;\n  1235→            } else if (self.consumeFlag(null, \"--sort\")) {\n  1236→                const sort_str = self.next() orelse return error.MissingFlagValue;\n  1237→                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n  1238→            } else if (self.consumeFlag(null, \"--asc\")) {\n  1239→                result.sort_desc = false;\n  1240→            } else if (self.consumeFlag(null, \"--desc\")) {\n  1241→                result.sort_desc = true;\n  1242→            } else if (self.consumeFlag(null, \"--parent\")) {\n  1243→                result.parent = self.next() orelse return error.MissingFlagValue;\n  1244→            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n  1245→                result.recursive = true;\n  1246→            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n  1247→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n  1248→                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n  1249→            } else if (self.consumeFlag(null, \"--fields\")) {\n  1250→                result.fields = self.next() orelse return error.MissingFlagValue;\n  1251→            } else break;\n  1252→        }\n  1253→\n  1254→        if (label_any_list.items.len > 0) {\n  1255→            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1256→        }\n  1257→\n  1258→        return result;\n  1259→    }\n  1260→\n  1261→    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n  1262→        var result = ReadyArgs{};\n  1263→        while (self.hasNext()) {\n  1264→            if (try self.parseLimitFlag()) |limit| {\n  1265→                result.limit = limit;\n  1266→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1267→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1268→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1269→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1270→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1271→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1272→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1273→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1274→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1275→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1276→            } else if (self.consumeFlag(null, \"--overdue\")) {\n  1277→                result.overdue = true;\n  1278→            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n  1279→                result.include_deferred = true;\n  1280→            } else if (self.consumeFlag(null, \"--parent\")) {\n  1281→                result.parent = self.next() orelse return error.MissingFlagValue;\n  1282→            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n  1283→                result.recursive = true;\n  1284→            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n  1285→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n  1286→                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n  1287→            } else if (self.consumeFlag(null, \"--fields\")) {\n  1288→                result.fields = self.next() orelse return error.MissingFlagValue;\n  1289→            } else break;\n  1290→        }\n  1291→        return result;\n  1292→    }\n  1293→\n  1294→    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n  1295→        var result = BlockedArgs{};\n  1296→        while (self.hasNext()) {\n  1297→            if (try self.parseLimitFlag()) |limit| {\n  1298→                result.limit = limit;\n  1299→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1300→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1301→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1302→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1303→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1304→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1305→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1306→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1307→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1308→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1309→            } else break;\n  1310→        }\n  1311→        return result;\n  1312→    }\n  1313→\n  1314→    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n  1315→        var result = SearchArgs{ .query = undefined };\n  1316→        var query_set = false;\n  1317→\n  1318→        while (self.hasNext()) {\n  1319→            if (try self.parseLimitFlag()) |limit| {\n  1320→                result.limit = limit;\n  1321→            } else if (self.peekPositional()) |_| {\n  1322→                if (!query_set) {\n  1323→                    result.query = self.next().?;\n  1324→                    query_set = true;\n  1325→                } else break;\n  1326→            } else break;\n  1327→        }\n  1328→\n  1329→        if (!query_set) return error.MissingRequiredArgument;\n  1330→        return result;\n  1331→    }\n  1332→\n  1333→    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n  1334→        var result = StaleArgs{};\n  1335→        while (self.hasNext()) {\n  1336→            if (self.consumeFlag(\"-d\", \"--days\")) {\n  1337→                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n  1338→            } else if (try self.parseLimitFlag()) |limit| {\n  1339→                result.limit = limit;\n  1340→            } else break;\n  1341→        }\n  1342→        return result;\n  1343→    }\n  1344→\n  1345→    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n  1346→        var result = CountArgs{};\n  1347→        while (self.hasNext()) {\n  1348→            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1349→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1350→            } else break;\n  1351→        }\n  1352→        return result;\n  1353→    }\n  1354→\n  1355→    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n  1356→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1357→        var result = DeferArgs{ .id = id };\n  1358→        while (self.hasNext()) {\n  1359→            if (self.consumeFlag(\"-u\", \"--until\")) {\n  1360→                result.until = self.next() orelse return error.MissingFlagValue;\n  1361→            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n  1362→                result.reason = self.next() orelse return error.MissingFlagValue;\n  1363→            } else break;\n  1364→        }\n  1365→        return result;\n  1366→    }\n  1367→\n  1368→    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n  1369→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1370→        return UndeferArgs{ .id = id };\n  1371→    }\n  1372→\n  1373→    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n  1374→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1375→\n  1376→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1377→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1378→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1379→            var dep_type: []const u8 = \"blocks\";\n  1380→            var metadata: ?[]const u8 = null;\n  1381→            while (self.hasNext()) {\n  1382→                if (self.consumeFlag(\"-t\", \"--type\")) {\n  1383→                    dep_type = self.next() orelse return error.MissingFlagValue;\n  1384→                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n  1385→                    metadata = self.next() orelse return error.MissingFlagValue;\n  1386→                } else break;\n  1387→            }\n  1388→            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n  1389→        }\n  1390→        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1391→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1392→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1393→            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n  1394→        }\n  1395→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1396→            const id = self.next() orelse return error.MissingRequiredArgument;\n  1397→            var direction: DepDirection = .both;\n  1398→            while (self.hasNext()) {\n  1399→                if (self.consumeFlag(\"-d\", \"--direction\")) {\n  1400→                    const dir_str = self.next() orelse return error.MissingFlagValue;\n  1401→                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n  1402→                } else break;\n  1403→            }\n  1404→            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n  1405→        }\n  1406→        if (std.mem.eql(u8, subcmd, \"tree\")) {\n  1407→            const id = self.next() orelse return error.MissingRequiredArgument;\n  1408→            var format: TreeFormat = .ascii;\n  1409→            while (self.hasNext()) {\n  1410→                if (self.consumeFlag(\"-f\", \"--format\")) {\n  1411→                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n  1412→                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n  1413→                } else break;\n  1414→            }\n  1415→            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n  1416→        }\n  1417→        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n  1418→            return .{ .subcommand = .{ .cycles = {} } };\n  1419→        }\n  1420→        return error.UnknownSubcommand;\n  1421→    }\n  1422→\n  1423→    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n  1424→        var result = GraphArgs{};\n  1425→\n  1426→        while (self.hasNext()) {\n  1427→            if (self.consumeFlag(\"-f\", \"--format\")) {\n  1428→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n  1429→                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n  1430→            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n  1431→                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n  1432→            } else if (self.peekPositional()) |_| {\n  1433→                if (result.id == null) {\n  1434→                    result.id = self.next().?;\n  1435→                } else break;\n  1436→            } else break;\n  1437→        }\n  1438→\n  1439→        return result;\n  1440→    }\n  1441→\n  1442→    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n  1443→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1444→\n  1445→        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n  1446→            var title: ?[]const u8 = null;\n  1447→            var description: ?[]const u8 = null;\n  1448→            var priority: ?[]const u8 = null;\n  1449→\n  1450→            while (self.hasNext()) {\n  1451→                if (self.consumeFlag(\"-d\", \"--description\")) {\n  1452→                    description = self.next() orelse return error.MissingFlagValue;\n  1453→                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1454→                    priority = self.next() orelse return error.MissingFlagValue;\n  1455→                } else if (self.peekPositional()) |_| {\n  1456→                    if (title == null) {\n  1457→                        title = self.next().?;\n  1458→                    } else break;\n  1459→                } else break;\n  1460→            }\n  1461→\n  1462→            if (title == null) return error.MissingRequiredArgument;\n  1463→            return .{ .subcommand = .{ .create = .{\n  1464→                .title = title.?,\n  1465→                .description = description,\n  1466→                .priority = priority,\n  1467→            } } };\n  1468→        }\n  1469→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1470→            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n  1471→            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n  1472→            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n  1473→        }\n  1474→        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1475→            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n  1476→            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n  1477→            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n  1478→        }\n  1479→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1480→            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n  1481→        }\n  1482→        if (std.mem.eql(u8, subcmd, \"status\")) {\n  1483→            return .{ .subcommand = .{ .status = {} } };\n  1484→        }\n  1485→        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n  1486→            var dry_run = false;\n  1487→            while (self.hasNext()) {\n  1488→                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n  1489→                    dry_run = true;\n  1490→                } else break;\n  1491→            }\n  1492→            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n  1493→        }\n  1494→        return error.UnknownSubcommand;\n  1495→    }\n  1496→\n  1497→    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n  1498→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1499→\n  1500→        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1501→            const is_add = std.mem.eql(u8, subcmd, \"add\");\n  1502→            const id = self.next() orelse return error.MissingRequiredArgument;\n  1503→            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n  1504→\n  1505→            while (self.peekPositional()) |_| {\n  1506→                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n  1507→            }\n  1508→\n  1509→            if (labels.items.len == 0) return error.MissingRequiredArgument;\n  1510→\n  1511→            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1512→            if (is_add) {\n  1513→                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n  1514→            } else {\n  1515→                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n  1516→            }\n  1517→        }\n  1518→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1519→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1520→        }\n  1521→        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n  1522→            return .{ .subcommand = .{ .list_all = {} } };\n  1523→        }\n  1524→        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n  1525→            const old_name = self.next() orelse return error.MissingRequiredArgument;\n  1526→            const new_name = self.next() orelse return error.MissingRequiredArgument;\n  1527→            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n  1528→        }\n  1529→        return error.UnknownSubcommand;\n  1530→    }\n  1531→\n  1532→    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n  1533→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1534→\n  1535→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1536→            return .{ .subcommand = .{ .add = .{\n  1537→                .id = self.next() orelse return error.MissingRequiredArgument,\n  1538→                .text = self.next() orelse return error.MissingRequiredArgument,\n  1539→            } } };\n  1540→        }\n  1541→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1542→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1543→        }\n  1544→        return error.UnknownSubcommand;\n  1545→    }\n  1546→\n  1547→    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n  1548→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1549→        return .{ .id = id };\n  1550→    }\n  1551→\n  1552→    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n  1553→        var result = AuditArgs{};\n  1554→        while (self.hasNext()) {\n  1555→            if (try self.parseLimitFlag()) |limit| {\n  1556→                result.limit = limit;\n  1557→            } else break;\n  1558→        }\n  1559→        return result;\n  1560→    }\n  1561→\n  1562→    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n  1563→        var result = ChangelogArgs{};\n  1564→        while (self.hasNext()) {\n  1565→            if (self.consumeFlag(null, \"--since\")) {\n  1566→                result.since = self.next() orelse return error.MissingFlagValue;\n  1567→            } else if (self.consumeFlag(null, \"--until\")) {\n  1568→                result.until = self.next() orelse return error.MissingFlagValue;\n  1569→            } else if (try self.parseLimitFlag()) |limit| {\n  1570→                result.limit = limit;\n  1571→            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1572→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1573→            } else break;\n  1574→        }\n  1575→        return result;\n  1576→    }\n  1577→\n  1578→    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n  1579→        var result = SyncArgs{};\n  1580→        while (self.hasNext()) {\n  1581→            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n  1582→                result.flush_only = true;\n  1583→            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n  1584→                result.import_only = true;\n  1585→            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n  1586→                result.merge = true;\n  1587→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n  1588→                result.status = true;\n  1589→            } else if (self.consumeFlag(null, \"--manifest\")) {\n  1590→                result.manifest = true;\n  1591→            } else if (self.consumeFlag(null, \"--error-policy\")) {\n  1592→                const policy_str = self.next() orelse return error.MissingFlagValue;\n  1593→                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n  1594→            } else if (self.consumeFlag(null, \"--orphans\")) {\n  1595→                const policy_str = self.next() orelse return error.MissingFlagValue;\n  1596→                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n  1597→            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n  1598→                result.rename_prefix = true;\n  1599→            } else break;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6f97c62c-7b61-40d9-be4b-d59fe62e18ea","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;","numLines":400,"startLine":1200,"totalLines":2746}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018NDyQdFeTChL2FXrAziw7Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013WvZUgxWQL9qPa9mmQesx3","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":174,"cache_read_input_tokens":58273,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":174},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"96fc33ab-d230-4ac9-b06e-dc54b621cd66"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013WvZUgxWQL9qPa9mmQesx3","type":"tool_result","content":"     1→//! beads_zig CLI entry point.\n     2→//!\n     3→//! Binary name: bz (beads-zig)\n     4→\n     5→const std = @import(\"std\");\n     6→const beads_zig = @import(\"beads_zig\");\n     7→const cli = beads_zig.cli;\n     8→const output = beads_zig.output;\n     9→\n    10→pub fn main() !void {\n    11→    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    12→    defer _ = gpa.deinit();\n    13→    const allocator = gpa.allocator();\n    14→\n    15→    run(allocator) catch |err| {\n    16→        const stderr = std.fs.File.stderr();\n    17→        stderr.writeAll(\"error: \") catch {};\n    18→        stderr.writeAll(@errorName(err)) catch {};\n    19→        stderr.writeAll(\"\\n\") catch {};\n    20→        std.process.exit(1);\n    21→    };\n    22→}\n    23→\n    24→fn run(allocator: std.mem.Allocator) !void {\n    25→    const args = try std.process.argsAlloc(allocator);\n    26→    defer std.process.argsFree(allocator, args);\n    27→\n    28→    // Skip program name\n    29→    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n    30→\n    31→    var parser = cli.ArgParser.init(allocator, cmd_args);\n    32→    var result = parser.parse() catch |err| {\n    33→        return handleParseError(err, allocator);\n    34→    };\n    35→    defer result.deinit(allocator);\n    36→\n    37→    try dispatch(result, allocator);\n    38→}\n    39→\n    40→fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    41→    switch (result.command) {\n    42→        .init => |init_args| {\n    43→            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n    44→                error.AlreadyInitialized => std.process.exit(1),\n    45→                else => return err,\n    46→            };\n    47→        },\n    48→        .create => |create_args| {\n    49→            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n    50→                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n    51→                else => return err,\n    52→            };\n    53→        },\n    54→        .q => |quick_args| {\n    55→            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n    56→                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n    57→                else => return err,\n    58→            };\n    59→        },\n    60→        .list => |list_args| {\n    61→            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n    62→                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n    63→                else => return err,\n    64→            };\n    65→        },\n    66→        .show => |show_args| {\n    67→            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n    68→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n    69→                else => return err,\n    70→            };\n    71→        },\n    72→        .update => |update_args| {\n    73→            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n    74→                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n    75→                else => return err,\n    76→            };\n    77→        },\n    78→        .close => |close_args| {\n    79→            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n    80→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n    81→                else => return err,\n    82→            };\n    83→        },\n    84→        .reopen => |reopen_args| {\n    85→            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n    86→                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n    87→                else => return err,\n    88→            };\n    89→        },\n    90→        .delete => |delete_args| {\n    91→            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n    92→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n    93→                else => return err,\n    94→            };\n    95→        },\n    96→        .add_batch => |batch_args| {\n    97→            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n    98→                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n    99→                else => return err,\n   100→            };\n   101→        },\n   102→        .import_cmd => |import_args| {\n   103→            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n   104→                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n   105→                else => return err,\n   106→            };\n   107→        },\n   108→        .ready => |ready_args| {\n   109→            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n   110→                error.WorkspaceNotInitialized => std.process.exit(1),\n   111→                else => return err,\n   112→            };\n   113→        },\n   114→        .blocked => |blocked_args| {\n   115→            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n   116→                error.WorkspaceNotInitialized => std.process.exit(1),\n   117→                else => return err,\n   118→            };\n   119→        },\n   120→        .dep => |dep_args| {\n   121→            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n   122→                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n   123→                else => return err,\n   124→            };\n   125→        },\n   126→        .graph => |graph_args| {\n   127→            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n   128→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n   129→                else => return err,\n   130→            };\n   131→        },\n   132→        .epic => |epic_args| {\n   133→            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n   134→                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n   135→                else => return err,\n   136→            };\n   137→        },\n   138→        .sync => |sync_args| {\n   139→            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n   140→                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n   141→                else => return err,\n   142→            };\n   143→        },\n   144→        .backup => |backup_args| {\n   145→            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n   146→                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n   147→                else => return err,\n   148→            };\n   149→        },\n   150→        .search => |search_args| {\n   151→            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n   152→                error.WorkspaceNotInitialized => std.process.exit(1),\n   153→                else => return err,\n   154→            };\n   155→        },\n   156→        .stale => |stale_args| {\n   157→            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n   158→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   159→                else => return err,\n   160→            };\n   161→        },\n   162→        .count => |count_args| {\n   163→            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n   164→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   165→                else => return err,\n   166→            };\n   167→        },\n   168→        .defer_cmd => |defer_args| {\n   169→            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n   170→                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n   171→                else => return err,\n   172→            };\n   173→        },\n   174→        .undefer => |undefer_args| {\n   175→            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n   176→                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n   177→                else => return err,\n   178→            };\n   179→        },\n   180→        .help => |help_args| {\n   181→            cli.runHelp(help_args.topic, allocator) catch {\n   182→                std.process.exit(1);\n   183→            };\n   184→        },\n   185→        .version => {\n   186→            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n   187→                error.WriteError => std.process.exit(1),\n   188→            };\n   189→        },\n   190→        .schema => {\n   191→            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n   192→                error.WriteError, error.OutOfMemory => std.process.exit(1),\n   193→            };\n   194→        },\n   195→        .completions => |comp_args| {\n   196→            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n   197→                error.WriteError => std.process.exit(1),\n   198→            };\n   199→        },\n   200→        .metrics => |metrics_args| {\n   201→            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n   202→                error.WriteError, error.OutOfMemory => std.process.exit(1),\n   203→            };\n   204→        },\n   205→        .info => {\n   206→            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n   207→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   208→                else => return err,\n   209→            };\n   210→        },\n   211→        .stats => {\n   212→            cli.runStats(result.global, allocator) catch |err| switch (err) {\n   213→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   214→                else => return err,\n   215→            };\n   216→        },\n   217→        .doctor => {\n   218→            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n   219→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   220→                else => return err,\n   221→            };\n   222→        },\n   223→        .config => |config_args| {\n   224→            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n   225→                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n   226→                else => return err,\n   227→            };\n   228→        },\n   229→        .orphans => |orphans_args| {\n   230→            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n   231→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   232→                else => return err,\n   233→            };\n   234→        },\n   235→        .lint => |lint_args| {\n   236→            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n   237→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   238→                else => return err,\n   239→            };\n   240→        },\n   241→        .label => |label_args| {\n   242→            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n   243→                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n   244→                else => return err,\n   245→            };\n   246→        },\n   247→        .comments => |comments_args| {\n   248→            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n   249→                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n   250→                else => return err,\n   251→            };\n   252→        },\n   253→        .history => |history_args| {\n   254→            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n   255→                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n   256→                else => return err,\n   257→            };\n   258→        },\n   259→        .audit => |audit_args| {\n   260→            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n   261→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   262→                else => return err,\n   263→            };\n   264→        },\n   265→        .changelog => |changelog_args| {\n   266→            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n   267→                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n   268→                else => return err,\n   269→            };\n   270→        },\n   271→        .query => |query_args| {\n   272→            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n   273→                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n   274→                else => return err,\n   275→            };\n   276→        },\n   277→        .upgrade => |upgrade_args| {\n   278→            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n   279→                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n   280→                else => return err,\n   281→            };\n   282→        },\n   283→        .where => {\n   284→            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n   285→                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n   286→            };\n   287→        },\n   288→    }\n   289→}\n   290→\n   291→fn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n   292→    var out = output.Output.init(allocator, .{});\n   293→    switch (err) {\n   294→        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n   295→        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n   296→        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n   297→        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n   298→        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n   299→        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n   300→        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n   301→        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n   302→    }\n   303→    std.process.exit(1);\n   304→}\n   305→\n   306→test \"library imports compile\" {\n   307→    // Verify all modules are accessible\n   308→    _ = beads_zig.cli;\n   309→    _ = beads_zig.storage;\n   310→    _ = beads_zig.models;\n   311→    _ = beads_zig.sync;\n   312→    _ = beads_zig.id;\n   313→    _ = beads_zig.config;\n   314→    _ = beads_zig.output;\n   315→}\n   316→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"79928bbe-25f0-4d16-963a-63f94710c764","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","content":"//! beads_zig CLI entry point.\n//!\n//! Binary name: bz (beads-zig)\n\nconst std = @import(\"std\");\nconst beads_zig = @import(\"beads_zig\");\nconst cli = beads_zig.cli;\nconst output = beads_zig.output;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    run(allocator) catch |err| {\n        const stderr = std.fs.File.stderr();\n        stderr.writeAll(\"error: \") catch {};\n        stderr.writeAll(@errorName(err)) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        std.process.exit(1);\n    };\n}\n\nfn run(allocator: std.mem.Allocator) !void {\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    // Skip program name\n    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n\n    var parser = cli.ArgParser.init(allocator, cmd_args);\n    var result = parser.parse() catch |err| {\n        return handleParseError(err, allocator);\n    };\n    defer result.deinit(allocator);\n\n    try dispatch(result, allocator);\n}\n\nfn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    switch (result.command) {\n        .init => |init_args| {\n            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n                error.AlreadyInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .create => |create_args| {\n            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .q => |quick_args| {\n            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .list => |list_args| {\n            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .show => |show_args| {\n            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .update => |update_args| {\n            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .close => |close_args| {\n            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .reopen => |reopen_args| {\n            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .delete => |delete_args| {\n            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .add_batch => |batch_args| {\n            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .import_cmd => |import_args| {\n            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .ready => |ready_args| {\n            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .blocked => |blocked_args| {\n            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .dep => |dep_args| {\n            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .graph => |graph_args| {\n            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .epic => |epic_args| {\n            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .backup => |backup_args| {\n            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .orphans => |orphans_args| {\n            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .lint => |lint_args| {\n            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .label => |label_args| {\n            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .comments => |comments_args| {\n            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .history => |history_args| {\n            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .where => {\n            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n    }\n    std.process.exit(1);\n}\n\ntest \"library imports compile\" {\n    // Verify all modules are accessible\n    _ = beads_zig.cli;\n    _ = beads_zig.storage;\n    _ = beads_zig.models;\n    _ = beads_zig.sync;\n    _ = beads_zig.id;\n    _ = beads_zig.config;\n    _ = beads_zig.output;\n}\n","numLines":316,"startLine":1,"totalLines":316}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AaM1oQAN5cEaVugGdfQRMG","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the cli/mod.zig file to see how commands are exported."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13058,"cache_read_input_tokens":58447,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13058},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e880b827-8289-4556-81ea-d3817a7a345e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AaM1oQAN5cEaVugGdfQRMG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C5DCerPzcJaiRDqfGdtV5Y","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13058,"cache_read_input_tokens":58447,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13058},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6d9e682e-8460-4fff-9a80-c2fc313abc4f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C5DCerPzcJaiRDqfGdtV5Y","type":"tool_result","content":"     1→//! CLI command implementations for beads_zig.\n     2→//!\n     3→//! This module handles argument parsing and dispatches to the appropriate\n     4→//! command handlers (create, list, show, update, close, sync, etc.).\n     5→//!\n     6→//! All commands support --json output for machine-readable responses.\n     7→\n     8→const std = @import(\"std\");\n     9→\n    10→pub const args = @import(\"args.zig\");\n    11→pub const common = @import(\"common.zig\");\n    12→pub const init = @import(\"init.zig\");\n    13→pub const create = @import(\"create.zig\");\n    14→pub const list = @import(\"list.zig\");\n    15→pub const show = @import(\"show.zig\");\n    16→pub const update = @import(\"update.zig\");\n    17→pub const close = @import(\"close.zig\");\n    18→pub const delete = @import(\"delete.zig\");\n    19→pub const ready = @import(\"ready.zig\");\n    20→pub const dep = @import(\"dep.zig\");\n    21→pub const graph = @import(\"graph.zig\");\n    22→pub const epic = @import(\"epic.zig\");\n    23→pub const sync = @import(\"sync.zig\");\n    24→pub const batch = @import(\"batch.zig\");\n    25→pub const search = @import(\"search.zig\");\n    26→pub const stale = @import(\"stale.zig\");\n    27→pub const count = @import(\"count.zig\");\n    28→pub const defer_cmd = @import(\"defer.zig\");\n    29→pub const label = @import(\"label.zig\");\n    30→pub const comments = @import(\"comments.zig\");\n    31→pub const history = @import(\"history.zig\");\n    32→pub const audit = @import(\"audit.zig\");\n    33→pub const changelog = @import(\"changelog.zig\");\n    34→pub const info = @import(\"info.zig\");\n    35→pub const stats = @import(\"stats.zig\");\n    36→pub const doctor = @import(\"doctor.zig\");\n    37→pub const config = @import(\"config.zig\");\n    38→pub const orphans = @import(\"orphans.zig\");\n    39→pub const lint = @import(\"lint.zig\");\n    40→pub const version = @import(\"version.zig\");\n    41→pub const schema = @import(\"schema.zig\");\n    42→pub const completions = @import(\"completions.zig\");\n    43→pub const metrics_cmd = @import(\"metrics.zig\");\n    44→pub const help = @import(\"help.zig\");\n    45→pub const query = @import(\"query.zig\");\n    46→pub const upgrade = @import(\"upgrade.zig\");\n    47→pub const where = @import(\"where.zig\");\n    48→\n    49→pub const ArgParser = args.ArgParser;\n    50→pub const ParseResult = args.ParseResult;\n    51→pub const ParseError = args.ParseError;\n    52→pub const GlobalOptions = args.GlobalOptions;\n    53→pub const Command = args.Command;\n    54→pub const InitArgs = args.InitArgs;\n    55→pub const CreateArgs = args.CreateArgs;\n    56→pub const QuickArgs = args.QuickArgs;\n    57→\n    58→pub const InitError = init.InitError;\n    59→pub const InitResult = init.InitResult;\n    60→pub const runInit = init.run;\n    61→\n    62→pub const CreateError = create.CreateError;\n    63→pub const CreateResult = create.CreateResult;\n    64→pub const runCreate = create.run;\n    65→pub const runQuick = create.runQuick;\n    66→\n    67→pub const ListError = list.ListError;\n    68→pub const ListResult = list.ListResult;\n    69→pub const runList = list.run;\n    70→\n    71→pub const ShowError = show.ShowError;\n    72→pub const ShowResult = show.ShowResult;\n    73→pub const runShow = show.run;\n    74→\n    75→pub const UpdateError = update.UpdateError;\n    76→pub const UpdateResult = update.UpdateResult;\n    77→pub const runUpdate = update.run;\n    78→\n    79→pub const CloseError = close.CloseError;\n    80→pub const CloseResult = close.CloseResult;\n    81→pub const runClose = close.run;\n    82→pub const runReopen = close.runReopen;\n    83→\n    84→pub const DeleteError = delete.DeleteError;\n    85→pub const DeleteResult = delete.DeleteResult;\n    86→pub const runDelete = delete.run;\n    87→\n    88→pub const ReadyError = ready.ReadyError;\n    89→pub const ReadyResult = ready.ReadyResult;\n    90→pub const runReady = ready.run;\n    91→pub const runBlocked = ready.runBlocked;\n    92→\n    93→pub const DepError = dep.DepError;\n    94→pub const DepResult = dep.DepResult;\n    95→pub const runDep = dep.run;\n    96→\n    97→pub const GraphError = graph.GraphError;\n    98→pub const GraphResult = graph.GraphResult;\n    99→pub const runGraph = graph.run;\n   100→\n   101→pub const EpicError = epic.EpicError;\n   102→pub const EpicResult = epic.EpicResult;\n   103→pub const runEpic = epic.run;\n   104→\n   105→pub const SyncError = sync.SyncError;\n   106→pub const SyncResult = sync.SyncResult;\n   107→pub const runSync = sync.run;\n   108→\n   109→pub const backup = @import(\"backup.zig\");\n   110→pub const BackupError = backup.BackupError;\n   111→pub const BackupResult = backup.BackupResult;\n   112→pub const runBackup = backup.run;\n   113→pub const BackupArgs = args.BackupArgs;\n   114→\n   115→pub const BatchError = batch.BatchError;\n   116→pub const BatchResult = batch.BatchResult;\n   117→pub const ImportResult = batch.ImportResult;\n   118→pub const runAddBatch = batch.runAddBatch;\n   119→pub const runImportCmd = batch.runImport;\n   120→\n   121→pub const AddBatchArgs = args.AddBatchArgs;\n   122→pub const BatchFormat = args.BatchFormat;\n   123→pub const ImportArgs = args.ImportArgs;\n   124→pub const EpicArgs = args.EpicArgs;\n   125→pub const SortField = args.SortField;\n   126→\n   127→pub const SearchError = search.SearchError;\n   128→pub const SearchResult = search.SearchResult;\n   129→pub const runSearch = search.run;\n   130→\n   131→pub const runStale = stale.run;\n   132→\n   133→pub const runCount = count.run;\n   134→\n   135→pub const runDefer = defer_cmd.run;\n   136→pub const runUndefer = defer_cmd.runUndefer;\n   137→\n   138→pub const LabelError = label.LabelError;\n   139→pub const LabelResult = label.LabelResult;\n   140→pub const runLabel = label.run;\n   141→\n   142→pub const CommentsError = comments.CommentsError;\n   143→pub const CommentsResult = comments.CommentsResult;\n   144→pub const runComments = comments.run;\n   145→\n   146→pub const HistoryError = history.HistoryError;\n   147→pub const HistoryResult = history.HistoryResult;\n   148→pub const runHistory = history.run;\n   149→\n   150→pub const AuditError = audit.AuditError;\n   151→pub const AuditResult = audit.AuditResult;\n   152→pub const runAudit = audit.run;\n   153→\n   154→pub const ChangelogError = changelog.ChangelogError;\n   155→pub const ChangelogResult = changelog.ChangelogResult;\n   156→pub const runChangelog = changelog.run;\n   157→pub const ChangelogArgs = args.ChangelogArgs;\n   158→\n   159→pub const InfoError = info.InfoError;\n   160→pub const InfoResult = info.InfoResult;\n   161→pub const runInfo = info.run;\n   162→\n   163→pub const StatsError = stats.StatsError;\n   164→pub const StatsResult = stats.StatsResult;\n   165→pub const runStats = stats.run;\n   166→\n   167→pub const DoctorError = doctor.DoctorError;\n   168→pub const DoctorResult = doctor.DoctorResult;\n   169→pub const runDoctor = doctor.run;\n   170→\n   171→pub const ConfigError = config.ConfigError;\n   172→pub const ConfigResult = config.ConfigResult;\n   173→pub const runConfig = config.run;\n   174→\n   175→pub const OrphansError = orphans.OrphansError;\n   176→pub const OrphansResult = orphans.OrphansResult;\n   177→pub const runOrphans = orphans.run;\n   178→\n   179→pub const LintError = lint.LintError;\n   180→pub const LintResult = lint.LintResult;\n   181→pub const runLint = lint.run;\n   182→\n   183→pub const OrphansArgs = args.OrphansArgs;\n   184→pub const LintArgs = args.LintArgs;\n   185→\n   186→pub const VersionError = version.VersionError;\n   187→pub const VersionResult = version.VersionResult;\n   188→pub const runVersion = version.run;\n   189→pub const VERSION = version.VERSION;\n   190→\n   191→pub const SchemaError = schema.SchemaError;\n   192→pub const SchemaResult = schema.SchemaResult;\n   193→pub const runSchema = schema.run;\n   194→\n   195→pub const CompletionsError = completions.CompletionsError;\n   196→pub const CompletionsResult = completions.CompletionsResult;\n   197→pub const runCompletions = completions.run;\n   198→pub const Shell = completions.Shell;\n   199→\n   200→pub const MetricsError = metrics_cmd.MetricsError;\n   201→pub const MetricsResult = metrics_cmd.MetricsResult;\n   202→pub const runMetrics = metrics_cmd.run;\n   203→pub const MetricsArgs = args.MetricsArgs;\n   204→\n   205→pub const HelpError = help.HelpError;\n   206→pub const HelpResult = help.HelpResult;\n   207→pub const runHelp = help.run;\n   208→\n   209→pub const QueryError = query.QueryError;\n   210→pub const QueryResult = query.QueryResult;\n   211→pub const runQuery = query.run;\n   212→pub const QueryArgs = args.QueryArgs;\n   213→\n   214→pub const UpgradeError = upgrade.UpgradeError;\n   215→pub const UpgradeResult = upgrade.UpgradeResult;\n   216→pub const runUpgrade = upgrade.run;\n   217→pub const UpgradeArgs = args.UpgradeArgs;\n   218→\n   219→pub const WhereError = where.WhereError;\n   220→pub const WhereResult = where.WhereResult;\n   221→pub const runWhere = where.run;\n   222→\n   223→test {\n   224→    std.testing.refAllDecls(@This());\n   225→}\n   226→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4ecec8b6-dca1-413e-8bdd-c54b7e9a8656","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","content":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const backup = @import(\"backup.zig\");\npub const BackupError = backup.BackupError;\npub const BackupResult = backup.BackupResult;\npub const runBackup = backup.run;\npub const BackupArgs = args.BackupArgs;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\npub const WhereError = where.WhereError;\npub const WhereResult = where.WhereResult;\npub const runWhere = where.run;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","numLines":226,"startLine":1,"totalLines":226}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PcPCSTQeAmwXQk2YJqEHQi","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase. Let me implement Task 1: the audit command subcommands. The current audit command is simple and needs to be extended to support subcommands: `record`, `label`, `log`, and `summary`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3158,"cache_read_input_tokens":71505,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3158},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"37c1217f-cc10-4d77-9ad8-21ce76b11089"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PcPCSTQeAmwXQk2YJqEHQi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JiV8U12kAp7JFtcdStZ67P","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/events.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3158,"cache_read_input_tokens":71505,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3158},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f5436872-f3cd-4239-99a6-b4eeaf53c1aa"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JiV8U12kAp7JFtcdStZ67P","type":"tool_result","content":"     1→//! Event storage for beads_zig audit trail.\n     2→//!\n     3→//! Provides persistent storage for audit events, recording all changes\n     4→//! to issues, dependencies, labels, and comments. Events are stored in\n     5→//! a JSONL file (events.jsonl) in chronological order.\n     6→//!\n     7→//! Design:\n     8→//! - Events are append-only (never modified once written)\n     9→//! - Events use auto-incrementing IDs\n    10→//! - Events are stored with the issue ID for efficient filtering\n    11→//! - Events can be replayed to reconstruct issue history\n    12→\n    13→const std = @import(\"std\");\n    14→const fs = std.fs;\n    15→const Event = @import(\"../models/event.zig\").Event;\n    16→const EventType = @import(\"../models/event.zig\").EventType;\n    17→\n    18→pub const EventStoreError = error{\n    19→    WriteError,\n    20→    ParseError,\n    21→    FileNotFound,\n    22→    OutOfMemory,\n    23→};\n    24→\n    25→/// Persistent store for audit events.\n    26→pub const EventStore = struct {\n    27→    allocator: std.mem.Allocator,\n    28→    events_path: []const u8,\n    29→    next_id: i64,\n    30→\n    31→    const Self = @This();\n    32→\n    33→    pub fn init(allocator: std.mem.Allocator, events_path: []const u8) Self {\n    34→        return .{\n    35→            .allocator = allocator,\n    36→            .events_path = events_path,\n    37→            .next_id = 1,\n    38→        };\n    39→    }\n    40→\n    41→    /// Load existing events to determine next ID.\n    42→    /// Call this after init to ensure IDs are unique.\n    43→    pub fn loadNextId(self: *Self) !void {\n    44→        const file = fs.cwd().openFile(self.events_path, .{}) catch |err| switch (err) {\n    45→            error.FileNotFound => return, // Start from 1\n    46→            else => return err,\n    47→        };\n    48→        defer file.close();\n    49→\n    50→        const content = file.readToEndAlloc(self.allocator, 100 * 1024 * 1024) catch return EventStoreError.ParseError;\n    51→        defer self.allocator.free(content);\n    52→\n    53→        var max_id: i64 = 0;\n    54→        var line_start: usize = 0;\n    55→        for (content, 0..) |c, i| {\n    56→            if (c == '\\n') {\n    57→                const line = content[line_start..i];\n    58→                line_start = i + 1;\n    59→\n    60→                if (line.len == 0) continue;\n    61→\n    62→                if (self.parseEventId(line)) |id| {\n    63→                    if (id > max_id) max_id = id;\n    64→                }\n    65→            }\n    66→        }\n    67→\n    68→        // Handle last line\n    69→        if (line_start < content.len) {\n    70→            const line = content[line_start..];\n    71→            if (line.len > 0) {\n    72→                if (self.parseEventId(line)) |id| {\n    73→                    if (id > max_id) max_id = id;\n    74→                }\n    75→            }\n    76→        }\n    77→\n    78→        self.next_id = max_id + 1;\n    79→    }\n    80→\n    81→    /// Parse just the ID from a JSON event line.\n    82→    fn parseEventId(self: *Self, line: []const u8) ?i64 {\n    83→        const parsed = std.json.parseFromSlice(\n    84→            struct { id: i64 },\n    85→            self.allocator,\n    86→            line,\n    87→            .{ .ignore_unknown_fields = true },\n    88→        ) catch return null;\n    89→        defer parsed.deinit();\n    90→        return parsed.value.id;\n    91→    }\n    92→\n    93→    /// Append an event to the store.\n    94→    /// Returns the assigned event ID.\n    95→    pub fn append(self: *Self, event: Event) !i64 {\n    96→        const dir = fs.cwd();\n    97→\n    98→        // Ensure parent directory exists\n    99→        if (std.fs.path.dirname(self.events_path)) |parent| {\n   100→            dir.makePath(parent) catch |err| switch (err) {\n   101→                error.PathAlreadyExists => {},\n   102→                else => return err,\n   103→            };\n   104→        }\n   105→\n   106→        // Open or create file in append mode\n   107→        const file = dir.createFile(self.events_path, .{\n   108→            .truncate = false,\n   109→        }) catch return EventStoreError.WriteError;\n   110→        defer file.close();\n   111→\n   112→        // Seek to end\n   113→        file.seekFromEnd(0) catch return EventStoreError.WriteError;\n   114→\n   115→        // Assign ID\n   116→        const event_id = self.next_id;\n   117→        self.next_id += 1;\n   118→\n   119→        // Create event with assigned ID\n   120→        const stored_event = Event{\n   121→            .id = event_id,\n   122→            .issue_id = event.issue_id,\n   123→            .event_type = event.event_type,\n   124→            .actor = event.actor,\n   125→            .old_value = event.old_value,\n   126→            .new_value = event.new_value,\n   127→            .created_at = event.created_at,\n   128→        };\n   129→\n   130→        // Serialize\n   131→        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, stored_event, .{}) catch return EventStoreError.WriteError;\n   132→        defer self.allocator.free(json_bytes);\n   133→\n   134→        // Write\n   135→        file.writeAll(json_bytes) catch return EventStoreError.WriteError;\n   136→        file.writeAll(\"\\n\") catch return EventStoreError.WriteError;\n   137→\n   138→        // fsync for durability\n   139→        file.sync() catch return EventStoreError.WriteError;\n   140→\n   141→        return event_id;\n   142→    }\n   143→\n   144→    /// Get all events for a specific issue.\n   145→    pub fn getEventsForIssue(self: *Self, issue_id: []const u8) ![]Event {\n   146→        return self.queryEvents(.{ .issue_id = issue_id });\n   147→    }\n   148→\n   149→    /// Get all events (project-wide audit log).\n   150→    pub fn getAllEvents(self: *Self) ![]Event {\n   151→        return self.queryEvents(.{});\n   152→    }\n   153→\n   154→    /// Query parameters for filtering events.\n   155→    pub const QueryParams = struct {\n   156→        issue_id: ?[]const u8 = null,\n   157→        event_type: ?EventType = null,\n   158→        actor: ?[]const u8 = null,\n   159→        since: ?i64 = null, // Events after this timestamp\n   160→        until: ?i64 = null, // Events before this timestamp\n   161→        limit: ?usize = null,\n   162→    };\n   163→\n   164→    /// Query events with optional filters.\n   165→    pub fn queryEvents(self: *Self, params: QueryParams) ![]Event {\n   166→        const file = fs.cwd().openFile(self.events_path, .{}) catch |err| switch (err) {\n   167→            error.FileNotFound => return &[_]Event{},\n   168→            else => return err,\n   169→        };\n   170→        defer file.close();\n   171→\n   172→        const content = file.readToEndAlloc(self.allocator, 100 * 1024 * 1024) catch return EventStoreError.ParseError;\n   173→        defer self.allocator.free(content);\n   174→\n   175→        var events: std.ArrayListUnmanaged(Event) = .{};\n   176→        errdefer {\n   177→            for (events.items) |*e| {\n   178→                self.freeEvent(e);\n   179→            }\n   180→            events.deinit(self.allocator);\n   181→        }\n   182→\n   183→        var line_start: usize = 0;\n   184→        for (content, 0..) |c, i| {\n   185→            if (c == '\\n') {\n   186→                const line = content[line_start..i];\n   187→                line_start = i + 1;\n   188→\n   189→                if (line.len == 0) continue;\n   190→\n   191→                if (self.parseAndFilterEvent(line, params)) |event| {\n   192→                    try events.append(self.allocator, event);\n   193→\n   194→                    // Check limit\n   195→                    if (params.limit) |lim| {\n   196→                        if (events.items.len >= lim) break;\n   197→                    }\n   198→                }\n   199→            }\n   200→        }\n   201→\n   202→        // Handle last line\n   203→        if (line_start < content.len) {\n   204→            const line = content[line_start..];\n   205→            if (line.len > 0) {\n   206→                if (self.parseAndFilterEvent(line, params)) |event| {\n   207→                    const should_add = if (params.limit) |lim| events.items.len < lim else true;\n   208→                    if (should_add) {\n   209→                        try events.append(self.allocator, event);\n   210→                    } else {\n   211→                        var e = event;\n   212→                        self.freeEvent(&e);\n   213→                    }\n   214→                }\n   215→            }\n   216→        }\n   217→\n   218→        return events.toOwnedSlice(self.allocator);\n   219→    }\n   220→\n   221→    /// Parse an event line and check if it matches filters.\n   222→    fn parseAndFilterEvent(self: *Self, line: []const u8, params: QueryParams) ?Event {\n   223→        const parsed = std.json.parseFromSlice(Event, self.allocator, line, .{\n   224→            .ignore_unknown_fields = true,\n   225→            .allocate = .alloc_always,\n   226→        }) catch return null;\n   227→\n   228→        const event = parsed.value;\n   229→\n   230→        // Apply filters\n   231→        if (params.issue_id) |id| {\n   232→            if (!std.mem.eql(u8, event.issue_id, id)) {\n   233→                parsed.deinit();\n   234→                return null;\n   235→            }\n   236→        }\n   237→        if (params.event_type) |et| {\n   238→            if (event.event_type != et) {\n   239→                parsed.deinit();\n   240→                return null;\n   241→            }\n   242→        }\n   243→        if (params.actor) |a| {\n   244→            if (!std.mem.eql(u8, event.actor, a)) {\n   245→                parsed.deinit();\n   246→                return null;\n   247→            }\n   248→        }\n   249→        if (params.since) |s| {\n   250→            if (event.created_at < s) {\n   251→                parsed.deinit();\n   252→                return null;\n   253→            }\n   254→        }\n   255→        if (params.until) |u| {\n   256→            if (event.created_at > u) {\n   257→                parsed.deinit();\n   258→                return null;\n   259→            }\n   260→        }\n   261→\n   262→        // Clone strings since parsed will be freed\n   263→        const issue_id = self.allocator.dupe(u8, event.issue_id) catch {\n   264→            parsed.deinit();\n   265→            return null;\n   266→        };\n   267→        errdefer self.allocator.free(issue_id);\n   268→\n   269→        const actor = self.allocator.dupe(u8, event.actor) catch {\n   270→            parsed.deinit();\n   271→            return null;\n   272→        };\n   273→        errdefer self.allocator.free(actor);\n   274→\n   275→        const old_value = if (event.old_value) |v| self.allocator.dupe(u8, v) catch {\n   276→            parsed.deinit();\n   277→            return null;\n   278→        } else null;\n   279→        errdefer if (old_value) |v| self.allocator.free(v);\n   280→\n   281→        const new_value = if (event.new_value) |v| self.allocator.dupe(u8, v) catch {\n   282→            parsed.deinit();\n   283→            return null;\n   284→        } else null;\n   285→\n   286→        parsed.deinit();\n   287→        return Event{\n   288→            .id = event.id,\n   289→            .issue_id = issue_id,\n   290→            .event_type = event.event_type,\n   291→            .actor = actor,\n   292→            .old_value = old_value,\n   293→            .new_value = new_value,\n   294→            .created_at = event.created_at,\n   295→        };\n   296→    }\n   297→\n   298→    /// Free an event's allocated strings.\n   299→    pub fn freeEvent(self: *Self, event: *Event) void {\n   300→        self.allocator.free(event.issue_id);\n   301→        self.allocator.free(event.actor);\n   302→        if (event.old_value) |v| self.allocator.free(v);\n   303→        if (event.new_value) |v| self.allocator.free(v);\n   304→    }\n   305→\n   306→    /// Free a slice of events.\n   307→    pub fn freeEvents(self: *Self, events: []Event) void {\n   308→        for (events) |*e| {\n   309→            self.freeEvent(e);\n   310→        }\n   311→        self.allocator.free(events);\n   312→    }\n   313→\n   314→    /// Get the total count of events.\n   315→    pub fn count(self: *Self) !usize {\n   316→        const events = try self.getAllEvents();\n   317→        defer self.freeEvents(events);\n   318→        return events.len;\n   319→    }\n   320→\n   321→    /// Check if the events file exists.\n   322→    pub fn exists(self: *Self) bool {\n   323→        fs.cwd().access(self.events_path, .{}) catch return false;\n   324→        return true;\n   325→    }\n   326→};\n   327→\n   328→// --- Tests ---\n   329→\n   330→const test_util = @import(\"../test_util.zig\");\n   331→\n   332→test \"EventStore.init\" {\n   333→    const allocator = std.testing.allocator;\n   334→    const store = EventStore.init(allocator, \"test/events.jsonl\");\n   335→    try std.testing.expectEqual(@as(i64, 1), store.next_id);\n   336→}\n   337→\n   338→test \"EventStore.append and query\" {\n   339→    const allocator = std.testing.allocator;\n   340→    const test_dir = try test_util.createTestDir(allocator, \"events_append\");\n   341→    defer allocator.free(test_dir);\n   342→    defer test_util.cleanupTestDir(test_dir);\n   343→\n   344→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   345→    defer allocator.free(events_path);\n   346→\n   347→    var store = EventStore.init(allocator, events_path);\n   348→\n   349→    // Append an event\n   350→    const event = Event.issueCreated(\"bd-test1\", \"alice@example.com\", 1706540000);\n   351→    const id = try store.append(event);\n   352→\n   353→    try std.testing.expectEqual(@as(i64, 1), id);\n   354→\n   355→    // Query events\n   356→    const events = try store.getEventsForIssue(\"bd-test1\");\n   357→    defer store.freeEvents(events);\n   358→\n   359→    try std.testing.expectEqual(@as(usize, 1), events.len);\n   360→    try std.testing.expectEqualStrings(\"bd-test1\", events[0].issue_id);\n   361→    try std.testing.expectEqual(EventType.created, events[0].event_type);\n   362→}\n   363→\n   364→test \"EventStore.append assigns sequential IDs\" {\n   365→    const allocator = std.testing.allocator;\n   366→    const test_dir = try test_util.createTestDir(allocator, \"events_seq_ids\");\n   367→    defer allocator.free(test_dir);\n   368→    defer test_util.cleanupTestDir(test_dir);\n   369→\n   370→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   371→    defer allocator.free(events_path);\n   372→\n   373→    var store = EventStore.init(allocator, events_path);\n   374→\n   375→    const id1 = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   376→    const id2 = try store.append(Event.issueCreated(\"bd-2\", \"alice\", 1706540001));\n   377→    const id3 = try store.append(Event.issueCreated(\"bd-3\", \"alice\", 1706540002));\n   378→\n   379→    try std.testing.expectEqual(@as(i64, 1), id1);\n   380→    try std.testing.expectEqual(@as(i64, 2), id2);\n   381→    try std.testing.expectEqual(@as(i64, 3), id3);\n   382→}\n   383→\n   384→test \"EventStore.loadNextId resumes from existing events\" {\n   385→    const allocator = std.testing.allocator;\n   386→    const test_dir = try test_util.createTestDir(allocator, \"events_load_id\");\n   387→    defer allocator.free(test_dir);\n   388→    defer test_util.cleanupTestDir(test_dir);\n   389→\n   390→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   391→    defer allocator.free(events_path);\n   392→\n   393→    // Create some events\n   394→    {\n   395→        var store = EventStore.init(allocator, events_path);\n   396→        _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   397→        _ = try store.append(Event.issueCreated(\"bd-2\", \"alice\", 1706540001));\n   398→        _ = try store.append(Event.issueCreated(\"bd-3\", \"alice\", 1706540002));\n   399→    }\n   400→\n   401→    // Reopen store and load next ID\n   402→    {\n   403→        var store = EventStore.init(allocator, events_path);\n   404→        try store.loadNextId();\n   405→\n   406→        try std.testing.expectEqual(@as(i64, 4), store.next_id);\n   407→\n   408→        // Append should use next ID\n   409→        const id = try store.append(Event.issueCreated(\"bd-4\", \"alice\", 1706540003));\n   410→        try std.testing.expectEqual(@as(i64, 4), id);\n   411→    }\n   412→}\n   413→\n   414→test \"EventStore.queryEvents filters by issue_id\" {\n   415→    const allocator = std.testing.allocator;\n   416→    const test_dir = try test_util.createTestDir(allocator, \"events_filter_issue\");\n   417→    defer allocator.free(test_dir);\n   418→    defer test_util.cleanupTestDir(test_dir);\n   419→\n   420→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   421→    defer allocator.free(events_path);\n   422→\n   423→    var store = EventStore.init(allocator, events_path);\n   424→\n   425→    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   426→    _ = try store.append(Event.issueCreated(\"bd-2\", \"bob\", 1706540001));\n   427→    _ = try store.append(Event.issueReopened(\"bd-1\", \"charlie\", 1706540002));\n   428→\n   429→    const events = try store.getEventsForIssue(\"bd-1\");\n   430→    defer store.freeEvents(events);\n   431→\n   432→    try std.testing.expectEqual(@as(usize, 2), events.len);\n   433→    for (events) |e| {\n   434→        try std.testing.expectEqualStrings(\"bd-1\", e.issue_id);\n   435→    }\n   436→}\n   437→\n   438→test \"EventStore.queryEvents filters by event_type\" {\n   439→    const allocator = std.testing.allocator;\n   440→    const test_dir = try test_util.createTestDir(allocator, \"events_filter_type\");\n   441→    defer allocator.free(test_dir);\n   442→    defer test_util.cleanupTestDir(test_dir);\n   443→\n   444→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   445→    defer allocator.free(events_path);\n   446→\n   447→    var store = EventStore.init(allocator, events_path);\n   448→\n   449→    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   450→    _ = try store.append(Event.issueReopened(\"bd-1\", \"bob\", 1706540001));\n   451→    _ = try store.append(Event.issueCreated(\"bd-2\", \"charlie\", 1706540002));\n   452→\n   453→    const events = try store.queryEvents(.{ .event_type = .created });\n   454→    defer store.freeEvents(events);\n   455→\n   456→    try std.testing.expectEqual(@as(usize, 2), events.len);\n   457→    for (events) |e| {\n   458→        try std.testing.expectEqual(EventType.created, e.event_type);\n   459→    }\n   460→}\n   461→\n   462→test \"EventStore.queryEvents returns empty for missing file\" {\n   463→    const allocator = std.testing.allocator;\n   464→\n   465→    var store = EventStore.init(allocator, \"/nonexistent/events.jsonl\");\n   466→    const events = try store.getAllEvents();\n   467→    defer store.freeEvents(events);\n   468→\n   469→    try std.testing.expectEqual(@as(usize, 0), events.len);\n   470→}\n   471→\n   472→test \"EventStore.count\" {\n   473→    const allocator = std.testing.allocator;\n   474→    const test_dir = try test_util.createTestDir(allocator, \"events_count\");\n   475→    defer allocator.free(test_dir);\n   476→    defer test_util.cleanupTestDir(test_dir);\n   477→\n   478→    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n   479→    defer allocator.free(events_path);\n   480→\n   481→    var store = EventStore.init(allocator, events_path);\n   482→\n   483→    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n   484→    _ = try store.append(Event.issueCreated(\"bd-2\", \"bob\", 1706540001));\n   485→    _ = try store.append(Event.issueCreated(\"bd-3\", \"charlie\", 1706540002));\n   486→\n   487→    const total = try store.count();\n   488→    try std.testing.expectEqual(@as(usize, 3), total);\n   489→}\n   490→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"82eeee77-3fcc-4a84-bb08-1993104078ca","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/events.zig","content":"//! Event storage for beads_zig audit trail.\n//!\n//! Provides persistent storage for audit events, recording all changes\n//! to issues, dependencies, labels, and comments. Events are stored in\n//! a JSONL file (events.jsonl) in chronological order.\n//!\n//! Design:\n//! - Events are append-only (never modified once written)\n//! - Events use auto-incrementing IDs\n//! - Events are stored with the issue ID for efficient filtering\n//! - Events can be replayed to reconstruct issue history\n\nconst std = @import(\"std\");\nconst fs = std.fs;\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\npub const EventStoreError = error{\n    WriteError,\n    ParseError,\n    FileNotFound,\n    OutOfMemory,\n};\n\n/// Persistent store for audit events.\npub const EventStore = struct {\n    allocator: std.mem.Allocator,\n    events_path: []const u8,\n    next_id: i64,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, events_path: []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .events_path = events_path,\n            .next_id = 1,\n        };\n    }\n\n    /// Load existing events to determine next ID.\n    /// Call this after init to ensure IDs are unique.\n    pub fn loadNextId(self: *Self) !void {\n        const file = fs.cwd().openFile(self.events_path, .{}) catch |err| switch (err) {\n            error.FileNotFound => return, // Start from 1\n            else => return err,\n        };\n        defer file.close();\n\n        const content = file.readToEndAlloc(self.allocator, 100 * 1024 * 1024) catch return EventStoreError.ParseError;\n        defer self.allocator.free(content);\n\n        var max_id: i64 = 0;\n        var line_start: usize = 0;\n        for (content, 0..) |c, i| {\n            if (c == '\\n') {\n                const line = content[line_start..i];\n                line_start = i + 1;\n\n                if (line.len == 0) continue;\n\n                if (self.parseEventId(line)) |id| {\n                    if (id > max_id) max_id = id;\n                }\n            }\n        }\n\n        // Handle last line\n        if (line_start < content.len) {\n            const line = content[line_start..];\n            if (line.len > 0) {\n                if (self.parseEventId(line)) |id| {\n                    if (id > max_id) max_id = id;\n                }\n            }\n        }\n\n        self.next_id = max_id + 1;\n    }\n\n    /// Parse just the ID from a JSON event line.\n    fn parseEventId(self: *Self, line: []const u8) ?i64 {\n        const parsed = std.json.parseFromSlice(\n            struct { id: i64 },\n            self.allocator,\n            line,\n            .{ .ignore_unknown_fields = true },\n        ) catch return null;\n        defer parsed.deinit();\n        return parsed.value.id;\n    }\n\n    /// Append an event to the store.\n    /// Returns the assigned event ID.\n    pub fn append(self: *Self, event: Event) !i64 {\n        const dir = fs.cwd();\n\n        // Ensure parent directory exists\n        if (std.fs.path.dirname(self.events_path)) |parent| {\n            dir.makePath(parent) catch |err| switch (err) {\n                error.PathAlreadyExists => {},\n                else => return err,\n            };\n        }\n\n        // Open or create file in append mode\n        const file = dir.createFile(self.events_path, .{\n            .truncate = false,\n        }) catch return EventStoreError.WriteError;\n        defer file.close();\n\n        // Seek to end\n        file.seekFromEnd(0) catch return EventStoreError.WriteError;\n\n        // Assign ID\n        const event_id = self.next_id;\n        self.next_id += 1;\n\n        // Create event with assigned ID\n        const stored_event = Event{\n            .id = event_id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type,\n            .actor = event.actor,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n            .created_at = event.created_at,\n        };\n\n        // Serialize\n        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, stored_event, .{}) catch return EventStoreError.WriteError;\n        defer self.allocator.free(json_bytes);\n\n        // Write\n        file.writeAll(json_bytes) catch return EventStoreError.WriteError;\n        file.writeAll(\"\\n\") catch return EventStoreError.WriteError;\n\n        // fsync for durability\n        file.sync() catch return EventStoreError.WriteError;\n\n        return event_id;\n    }\n\n    /// Get all events for a specific issue.\n    pub fn getEventsForIssue(self: *Self, issue_id: []const u8) ![]Event {\n        return self.queryEvents(.{ .issue_id = issue_id });\n    }\n\n    /// Get all events (project-wide audit log).\n    pub fn getAllEvents(self: *Self) ![]Event {\n        return self.queryEvents(.{});\n    }\n\n    /// Query parameters for filtering events.\n    pub const QueryParams = struct {\n        issue_id: ?[]const u8 = null,\n        event_type: ?EventType = null,\n        actor: ?[]const u8 = null,\n        since: ?i64 = null, // Events after this timestamp\n        until: ?i64 = null, // Events before this timestamp\n        limit: ?usize = null,\n    };\n\n    /// Query events with optional filters.\n    pub fn queryEvents(self: *Self, params: QueryParams) ![]Event {\n        const file = fs.cwd().openFile(self.events_path, .{}) catch |err| switch (err) {\n            error.FileNotFound => return &[_]Event{},\n            else => return err,\n        };\n        defer file.close();\n\n        const content = file.readToEndAlloc(self.allocator, 100 * 1024 * 1024) catch return EventStoreError.ParseError;\n        defer self.allocator.free(content);\n\n        var events: std.ArrayListUnmanaged(Event) = .{};\n        errdefer {\n            for (events.items) |*e| {\n                self.freeEvent(e);\n            }\n            events.deinit(self.allocator);\n        }\n\n        var line_start: usize = 0;\n        for (content, 0..) |c, i| {\n            if (c == '\\n') {\n                const line = content[line_start..i];\n                line_start = i + 1;\n\n                if (line.len == 0) continue;\n\n                if (self.parseAndFilterEvent(line, params)) |event| {\n                    try events.append(self.allocator, event);\n\n                    // Check limit\n                    if (params.limit) |lim| {\n                        if (events.items.len >= lim) break;\n                    }\n                }\n            }\n        }\n\n        // Handle last line\n        if (line_start < content.len) {\n            const line = content[line_start..];\n            if (line.len > 0) {\n                if (self.parseAndFilterEvent(line, params)) |event| {\n                    const should_add = if (params.limit) |lim| events.items.len < lim else true;\n                    if (should_add) {\n                        try events.append(self.allocator, event);\n                    } else {\n                        var e = event;\n                        self.freeEvent(&e);\n                    }\n                }\n            }\n        }\n\n        return events.toOwnedSlice(self.allocator);\n    }\n\n    /// Parse an event line and check if it matches filters.\n    fn parseAndFilterEvent(self: *Self, line: []const u8, params: QueryParams) ?Event {\n        const parsed = std.json.parseFromSlice(Event, self.allocator, line, .{\n            .ignore_unknown_fields = true,\n            .allocate = .alloc_always,\n        }) catch return null;\n\n        const event = parsed.value;\n\n        // Apply filters\n        if (params.issue_id) |id| {\n            if (!std.mem.eql(u8, event.issue_id, id)) {\n                parsed.deinit();\n                return null;\n            }\n        }\n        if (params.event_type) |et| {\n            if (event.event_type != et) {\n                parsed.deinit();\n                return null;\n            }\n        }\n        if (params.actor) |a| {\n            if (!std.mem.eql(u8, event.actor, a)) {\n                parsed.deinit();\n                return null;\n            }\n        }\n        if (params.since) |s| {\n            if (event.created_at < s) {\n                parsed.deinit();\n                return null;\n            }\n        }\n        if (params.until) |u| {\n            if (event.created_at > u) {\n                parsed.deinit();\n                return null;\n            }\n        }\n\n        // Clone strings since parsed will be freed\n        const issue_id = self.allocator.dupe(u8, event.issue_id) catch {\n            parsed.deinit();\n            return null;\n        };\n        errdefer self.allocator.free(issue_id);\n\n        const actor = self.allocator.dupe(u8, event.actor) catch {\n            parsed.deinit();\n            return null;\n        };\n        errdefer self.allocator.free(actor);\n\n        const old_value = if (event.old_value) |v| self.allocator.dupe(u8, v) catch {\n            parsed.deinit();\n            return null;\n        } else null;\n        errdefer if (old_value) |v| self.allocator.free(v);\n\n        const new_value = if (event.new_value) |v| self.allocator.dupe(u8, v) catch {\n            parsed.deinit();\n            return null;\n        } else null;\n\n        parsed.deinit();\n        return Event{\n            .id = event.id,\n            .issue_id = issue_id,\n            .event_type = event.event_type,\n            .actor = actor,\n            .old_value = old_value,\n            .new_value = new_value,\n            .created_at = event.created_at,\n        };\n    }\n\n    /// Free an event's allocated strings.\n    pub fn freeEvent(self: *Self, event: *Event) void {\n        self.allocator.free(event.issue_id);\n        self.allocator.free(event.actor);\n        if (event.old_value) |v| self.allocator.free(v);\n        if (event.new_value) |v| self.allocator.free(v);\n    }\n\n    /// Free a slice of events.\n    pub fn freeEvents(self: *Self, events: []Event) void {\n        for (events) |*e| {\n            self.freeEvent(e);\n        }\n        self.allocator.free(events);\n    }\n\n    /// Get the total count of events.\n    pub fn count(self: *Self) !usize {\n        const events = try self.getAllEvents();\n        defer self.freeEvents(events);\n        return events.len;\n    }\n\n    /// Check if the events file exists.\n    pub fn exists(self: *Self) bool {\n        fs.cwd().access(self.events_path, .{}) catch return false;\n        return true;\n    }\n};\n\n// --- Tests ---\n\nconst test_util = @import(\"../test_util.zig\");\n\ntest \"EventStore.init\" {\n    const allocator = std.testing.allocator;\n    const store = EventStore.init(allocator, \"test/events.jsonl\");\n    try std.testing.expectEqual(@as(i64, 1), store.next_id);\n}\n\ntest \"EventStore.append and query\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"events_append\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n    defer allocator.free(events_path);\n\n    var store = EventStore.init(allocator, events_path);\n\n    // Append an event\n    const event = Event.issueCreated(\"bd-test1\", \"alice@example.com\", 1706540000);\n    const id = try store.append(event);\n\n    try std.testing.expectEqual(@as(i64, 1), id);\n\n    // Query events\n    const events = try store.getEventsForIssue(\"bd-test1\");\n    defer store.freeEvents(events);\n\n    try std.testing.expectEqual(@as(usize, 1), events.len);\n    try std.testing.expectEqualStrings(\"bd-test1\", events[0].issue_id);\n    try std.testing.expectEqual(EventType.created, events[0].event_type);\n}\n\ntest \"EventStore.append assigns sequential IDs\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"events_seq_ids\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n    defer allocator.free(events_path);\n\n    var store = EventStore.init(allocator, events_path);\n\n    const id1 = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n    const id2 = try store.append(Event.issueCreated(\"bd-2\", \"alice\", 1706540001));\n    const id3 = try store.append(Event.issueCreated(\"bd-3\", \"alice\", 1706540002));\n\n    try std.testing.expectEqual(@as(i64, 1), id1);\n    try std.testing.expectEqual(@as(i64, 2), id2);\n    try std.testing.expectEqual(@as(i64, 3), id3);\n}\n\ntest \"EventStore.loadNextId resumes from existing events\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"events_load_id\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n    defer allocator.free(events_path);\n\n    // Create some events\n    {\n        var store = EventStore.init(allocator, events_path);\n        _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n        _ = try store.append(Event.issueCreated(\"bd-2\", \"alice\", 1706540001));\n        _ = try store.append(Event.issueCreated(\"bd-3\", \"alice\", 1706540002));\n    }\n\n    // Reopen store and load next ID\n    {\n        var store = EventStore.init(allocator, events_path);\n        try store.loadNextId();\n\n        try std.testing.expectEqual(@as(i64, 4), store.next_id);\n\n        // Append should use next ID\n        const id = try store.append(Event.issueCreated(\"bd-4\", \"alice\", 1706540003));\n        try std.testing.expectEqual(@as(i64, 4), id);\n    }\n}\n\ntest \"EventStore.queryEvents filters by issue_id\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"events_filter_issue\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n    defer allocator.free(events_path);\n\n    var store = EventStore.init(allocator, events_path);\n\n    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n    _ = try store.append(Event.issueCreated(\"bd-2\", \"bob\", 1706540001));\n    _ = try store.append(Event.issueReopened(\"bd-1\", \"charlie\", 1706540002));\n\n    const events = try store.getEventsForIssue(\"bd-1\");\n    defer store.freeEvents(events);\n\n    try std.testing.expectEqual(@as(usize, 2), events.len);\n    for (events) |e| {\n        try std.testing.expectEqualStrings(\"bd-1\", e.issue_id);\n    }\n}\n\ntest \"EventStore.queryEvents filters by event_type\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"events_filter_type\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n    defer allocator.free(events_path);\n\n    var store = EventStore.init(allocator, events_path);\n\n    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n    _ = try store.append(Event.issueReopened(\"bd-1\", \"bob\", 1706540001));\n    _ = try store.append(Event.issueCreated(\"bd-2\", \"charlie\", 1706540002));\n\n    const events = try store.queryEvents(.{ .event_type = .created });\n    defer store.freeEvents(events);\n\n    try std.testing.expectEqual(@as(usize, 2), events.len);\n    for (events) |e| {\n        try std.testing.expectEqual(EventType.created, e.event_type);\n    }\n}\n\ntest \"EventStore.queryEvents returns empty for missing file\" {\n    const allocator = std.testing.allocator;\n\n    var store = EventStore.init(allocator, \"/nonexistent/events.jsonl\");\n    const events = try store.getAllEvents();\n    defer store.freeEvents(events);\n\n    try std.testing.expectEqual(@as(usize, 0), events.len);\n}\n\ntest \"EventStore.count\" {\n    const allocator = std.testing.allocator;\n    const test_dir = try test_util.createTestDir(allocator, \"events_count\");\n    defer allocator.free(test_dir);\n    defer test_util.cleanupTestDir(test_dir);\n\n    const events_path = try std.fs.path.join(allocator, &.{ test_dir, \"events.jsonl\" });\n    defer allocator.free(events_path);\n\n    var store = EventStore.init(allocator, events_path);\n\n    _ = try store.append(Event.issueCreated(\"bd-1\", \"alice\", 1706540000));\n    _ = try store.append(Event.issueCreated(\"bd-2\", \"bob\", 1706540001));\n    _ = try store.append(Event.issueCreated(\"bd-3\", \"charlie\", 1706540002));\n\n    const total = try store.count();\n    try std.testing.expectEqual(@as(usize, 3), total);\n}\n","numLines":490,"startLine":1,"totalLines":490}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015nfxDYDJqHAo9GbraA6MbR","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the models/event.zig to understand the Event struct and EventType enum:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6917,"cache_read_input_tokens":74663,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6917},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"513ccc38-3945-4fde-a52c-b88f4ed6c479"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015nfxDYDJqHAo9GbraA6MbR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PKKQP7Bf8a2UASSv2J5hBU","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/event.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6917,"cache_read_input_tokens":74663,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6917},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"de053595-5296-44c9-84d4-0c2e2099daea"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PKKQP7Bf8a2UASSv2J5hBU","type":"tool_result","content":"     1→//! Event struct and EventType enum for the audit log system.\n     2→//!\n     3→//! Events track changes to issues for audit and history purposes.\n     4→//! Each event records who made a change, what changed, and when.\n     5→\n     6→const std = @import(\"std\");\n     7→const Status = @import(\"status.zig\").Status;\n     8→const Priority = @import(\"priority.zig\").Priority;\n     9→\n    10→/// Types of events that can occur on an issue.\n    11→pub const EventType = enum {\n    12→    created,\n    13→    updated,\n    14→    status_changed,\n    15→    priority_changed,\n    16→    assignee_changed,\n    17→    commented,\n    18→    closed,\n    19→    reopened,\n    20→    dependency_added,\n    21→    dependency_removed,\n    22→    label_added,\n    23→    label_removed,\n    24→    compacted,\n    25→    deleted,\n    26→    restored,\n    27→\n    28→    const Self = @This();\n    29→\n    30→    /// Convert EventType to its string representation.\n    31→    pub fn toString(self: Self) []const u8 {\n    32→        return @tagName(self);\n    33→    }\n    34→\n    35→    /// Parse a string into an EventType.\n    36→    /// Returns null for unknown values.\n    37→    pub fn fromString(s: []const u8) ?Self {\n    38→        return std.meta.stringToEnum(Self, s);\n    39→    }\n    40→\n    41→    /// JSON serialization for std.json.\n    42→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    43→        try jws.write(self.toString());\n    44→    }\n    45→\n    46→    /// JSON deserialization for std.json.\n    47→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    48→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    49→        const str = switch (token) {\n    50→            .string, .allocated_string => |s| s,\n    51→            else => return error.UnexpectedToken,\n    52→        };\n    53→        return fromString(str) orelse error.UnexpectedToken;\n    54→    }\n    55→\n    56→    /// JSON deserialization from already-parsed value.\n    57→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    58→        _ = allocator;\n    59→        _ = options;\n    60→        return switch (source) {\n    61→            .string => |s| fromString(s) orelse error.UnexpectedToken,\n    62→            else => error.UnexpectedToken,\n    63→        };\n    64→    }\n    65→};\n    66→\n    67→/// Validation errors for Event.\n    68→pub const EventError = error{\n    69→    EmptyActor,\n    70→    EmptyIssueId,\n    71→};\n    72→\n    73→/// An audit log entry for an issue change.\n    74→pub const Event = struct {\n    75→    id: i64, // Unique identifier, 0 for new events before insert\n    76→    issue_id: []const u8, // The issue this event relates to\n    77→    event_type: EventType, // What kind of change occurred\n    78→    actor: []const u8, // Who performed the action\n    79→    old_value: ?[]const u8, // JSON of previous state (null for creation)\n    80→    new_value: ?[]const u8, // JSON of new state (null for deletion)\n    81→    created_at: i64, // Unix timestamp\n    82→\n    83→    const Self = @This();\n    84→\n    85→    /// Validate that the event has all required fields populated.\n    86→    pub fn validate(self: Self) EventError!void {\n    87→        if (self.actor.len == 0) return EventError.EmptyActor;\n    88→        if (self.issue_id.len == 0) return EventError.EmptyIssueId;\n    89→    }\n    90→\n    91→    /// Check deep equality between two Events.\n    92→    pub fn eql(a: Self, b: Self) bool {\n    93→        return a.id == b.id and\n    94→            a.created_at == b.created_at and\n    95→            a.event_type == b.event_type and\n    96→            std.mem.eql(u8, a.issue_id, b.issue_id) and\n    97→            std.mem.eql(u8, a.actor, b.actor) and\n    98→            optionalStrEql(a.old_value, b.old_value) and\n    99→            optionalStrEql(a.new_value, b.new_value);\n   100→    }\n   101→\n   102→    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n   103→        const av = a orelse return b == null;\n   104→        const bv = b orelse return false;\n   105→        return std.mem.eql(u8, av, bv);\n   106→    }\n   107→\n   108→    /// Create an event for issue creation.\n   109→    pub fn issueCreated(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   110→        return Self{\n   111→            .id = 0,\n   112→            .issue_id = issue_id,\n   113→            .event_type = .created,\n   114→            .actor = actor,\n   115→            .old_value = null,\n   116→            .new_value = null,\n   117→            .created_at = timestamp,\n   118→        };\n   119→    }\n   120→\n   121→    /// Create an event for status change.\n   122→    pub fn statusChange(\n   123→        allocator: std.mem.Allocator,\n   124→        issue_id: []const u8,\n   125→        actor: []const u8,\n   126→        old_status: Status,\n   127→        new_status: Status,\n   128→        timestamp: i64,\n   129→    ) !Self {\n   130→        const old_json = try allocator.dupe(u8, old_status.toString());\n   131→        const new_json = try allocator.dupe(u8, new_status.toString());\n   132→\n   133→        return Self{\n   134→            .id = 0,\n   135→            .issue_id = issue_id,\n   136→            .event_type = .status_changed,\n   137→            .actor = actor,\n   138→            .old_value = old_json,\n   139→            .new_value = new_json,\n   140→            .created_at = timestamp,\n   141→        };\n   142→    }\n   143→\n   144→    /// Create an event for priority change.\n   145→    pub fn priorityChange(\n   146→        allocator: std.mem.Allocator,\n   147→        issue_id: []const u8,\n   148→        actor: []const u8,\n   149→        old_priority: Priority,\n   150→        new_priority: Priority,\n   151→        timestamp: i64,\n   152→    ) !Self {\n   153→        var old_buf: [8]u8 = undefined;\n   154→        var new_buf: [8]u8 = undefined;\n   155→\n   156→        const old_str = std.fmt.bufPrint(&old_buf, \"{d}\", .{old_priority.value}) catch unreachable;\n   157→        const new_str = std.fmt.bufPrint(&new_buf, \"{d}\", .{new_priority.value}) catch unreachable;\n   158→\n   159→        const old_json = try allocator.dupe(u8, old_str);\n   160→        const new_json = try allocator.dupe(u8, new_str);\n   161→\n   162→        return Self{\n   163→            .id = 0,\n   164→            .issue_id = issue_id,\n   165→            .event_type = .priority_changed,\n   166→            .actor = actor,\n   167→            .old_value = old_json,\n   168→            .new_value = new_json,\n   169→            .created_at = timestamp,\n   170→        };\n   171→    }\n   172→\n   173→    /// Create an event for assignee change.\n   174→    pub fn assigneeChange(\n   175→        allocator: std.mem.Allocator,\n   176→        issue_id: []const u8,\n   177→        actor: []const u8,\n   178→        old_assignee: ?[]const u8,\n   179→        new_assignee: ?[]const u8,\n   180→        timestamp: i64,\n   181→    ) !Self {\n   182→        const old_json = if (old_assignee) |a| try allocator.dupe(u8, a) else null;\n   183→        const new_json = if (new_assignee) |a| try allocator.dupe(u8, a) else null;\n   184→\n   185→        return Self{\n   186→            .id = 0,\n   187→            .issue_id = issue_id,\n   188→            .event_type = .assignee_changed,\n   189→            .actor = actor,\n   190→            .old_value = old_json,\n   191→            .new_value = new_json,\n   192→            .created_at = timestamp,\n   193→        };\n   194→    }\n   195→\n   196→    /// Create an event for adding a label.\n   197→    pub fn labelAdded(\n   198→        allocator: std.mem.Allocator,\n   199→        issue_id: []const u8,\n   200→        actor: []const u8,\n   201→        label: []const u8,\n   202→        timestamp: i64,\n   203→    ) !Self {\n   204→        const new_json = try allocator.dupe(u8, label);\n   205→\n   206→        return Self{\n   207→            .id = 0,\n   208→            .issue_id = issue_id,\n   209→            .event_type = .label_added,\n   210→            .actor = actor,\n   211→            .old_value = null,\n   212→            .new_value = new_json,\n   213→            .created_at = timestamp,\n   214→        };\n   215→    }\n   216→\n   217→    /// Create an event for removing a label.\n   218→    pub fn labelRemoved(\n   219→        allocator: std.mem.Allocator,\n   220→        issue_id: []const u8,\n   221→        actor: []const u8,\n   222→        label: []const u8,\n   223→        timestamp: i64,\n   224→    ) !Self {\n   225→        const old_json = try allocator.dupe(u8, label);\n   226→\n   227→        return Self{\n   228→            .id = 0,\n   229→            .issue_id = issue_id,\n   230→            .event_type = .label_removed,\n   231→            .actor = actor,\n   232→            .old_value = old_json,\n   233→            .new_value = null,\n   234→            .created_at = timestamp,\n   235→        };\n   236→    }\n   237→\n   238→    /// Create an event for adding a dependency.\n   239→    pub fn dependencyAdded(\n   240→        allocator: std.mem.Allocator,\n   241→        issue_id: []const u8,\n   242→        actor: []const u8,\n   243→        depends_on_id: []const u8,\n   244→        timestamp: i64,\n   245→    ) !Self {\n   246→        const new_json = try allocator.dupe(u8, depends_on_id);\n   247→\n   248→        return Self{\n   249→            .id = 0,\n   250→            .issue_id = issue_id,\n   251→            .event_type = .dependency_added,\n   252→            .actor = actor,\n   253→            .old_value = null,\n   254→            .new_value = new_json,\n   255→            .created_at = timestamp,\n   256→        };\n   257→    }\n   258→\n   259→    /// Create an event for removing a dependency.\n   260→    pub fn dependencyRemoved(\n   261→        allocator: std.mem.Allocator,\n   262→        issue_id: []const u8,\n   263→        actor: []const u8,\n   264→        depends_on_id: []const u8,\n   265→        timestamp: i64,\n   266→    ) !Self {\n   267→        const old_json = try allocator.dupe(u8, depends_on_id);\n   268→\n   269→        return Self{\n   270→            .id = 0,\n   271→            .issue_id = issue_id,\n   272→            .event_type = .dependency_removed,\n   273→            .actor = actor,\n   274→            .old_value = old_json,\n   275→            .new_value = null,\n   276→            .created_at = timestamp,\n   277→        };\n   278→    }\n   279→\n   280→    /// Create an event for issue closure.\n   281→    pub fn issueClosed(\n   282→        allocator: std.mem.Allocator,\n   283→        issue_id: []const u8,\n   284→        actor: []const u8,\n   285→        close_reason: ?[]const u8,\n   286→        timestamp: i64,\n   287→    ) !Self {\n   288→        const new_json = if (close_reason) |r| try allocator.dupe(u8, r) else null;\n   289→\n   290→        return Self{\n   291→            .id = 0,\n   292→            .issue_id = issue_id,\n   293→            .event_type = .closed,\n   294→            .actor = actor,\n   295→            .old_value = null,\n   296→            .new_value = new_json,\n   297→            .created_at = timestamp,\n   298→        };\n   299→    }\n   300→\n   301→    /// Create an event for issue reopening.\n   302→    pub fn issueReopened(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   303→        return Self{\n   304→            .id = 0,\n   305→            .issue_id = issue_id,\n   306→            .event_type = .reopened,\n   307→            .actor = actor,\n   308→            .old_value = null,\n   309→            .new_value = null,\n   310→            .created_at = timestamp,\n   311→        };\n   312→    }\n   313→\n   314→    /// Create an event for issue deletion (tombstone).\n   315→    pub fn issueDeleted(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   316→        return Self{\n   317→            .id = 0,\n   318→            .issue_id = issue_id,\n   319→            .event_type = .deleted,\n   320→            .actor = actor,\n   321→            .old_value = null,\n   322→            .new_value = null,\n   323→            .created_at = timestamp,\n   324→        };\n   325→    }\n   326→\n   327→    /// Create an event for issue restoration.\n   328→    pub fn issueRestored(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n   329→        return Self{\n   330→            .id = 0,\n   331→            .issue_id = issue_id,\n   332→            .event_type = .restored,\n   333→            .actor = actor,\n   334→            .old_value = null,\n   335→            .new_value = null,\n   336→            .created_at = timestamp,\n   337→        };\n   338→    }\n   339→};\n   340→\n   341→// --- EventType Tests ---\n   342→\n   343→test \"EventType.toString returns correct strings\" {\n   344→    try std.testing.expectEqualStrings(\"created\", EventType.created.toString());\n   345→    try std.testing.expectEqualStrings(\"updated\", EventType.updated.toString());\n   346→    try std.testing.expectEqualStrings(\"status_changed\", EventType.status_changed.toString());\n   347→    try std.testing.expectEqualStrings(\"priority_changed\", EventType.priority_changed.toString());\n   348→    try std.testing.expectEqualStrings(\"assignee_changed\", EventType.assignee_changed.toString());\n   349→    try std.testing.expectEqualStrings(\"commented\", EventType.commented.toString());\n   350→    try std.testing.expectEqualStrings(\"closed\", EventType.closed.toString());\n   351→    try std.testing.expectEqualStrings(\"reopened\", EventType.reopened.toString());\n   352→    try std.testing.expectEqualStrings(\"dependency_added\", EventType.dependency_added.toString());\n   353→    try std.testing.expectEqualStrings(\"dependency_removed\", EventType.dependency_removed.toString());\n   354→    try std.testing.expectEqualStrings(\"label_added\", EventType.label_added.toString());\n   355→    try std.testing.expectEqualStrings(\"label_removed\", EventType.label_removed.toString());\n   356→    try std.testing.expectEqualStrings(\"compacted\", EventType.compacted.toString());\n   357→    try std.testing.expectEqualStrings(\"deleted\", EventType.deleted.toString());\n   358→    try std.testing.expectEqualStrings(\"restored\", EventType.restored.toString());\n   359→}\n   360→\n   361→test \"EventType.fromString parses known event types\" {\n   362→    try std.testing.expectEqual(EventType.created, EventType.fromString(\"created\").?);\n   363→    try std.testing.expectEqual(EventType.updated, EventType.fromString(\"updated\").?);\n   364→    try std.testing.expectEqual(EventType.status_changed, EventType.fromString(\"status_changed\").?);\n   365→    try std.testing.expectEqual(EventType.priority_changed, EventType.fromString(\"priority_changed\").?);\n   366→    try std.testing.expectEqual(EventType.assignee_changed, EventType.fromString(\"assignee_changed\").?);\n   367→    try std.testing.expectEqual(EventType.commented, EventType.fromString(\"commented\").?);\n   368→    try std.testing.expectEqual(EventType.closed, EventType.fromString(\"closed\").?);\n   369→    try std.testing.expectEqual(EventType.reopened, EventType.fromString(\"reopened\").?);\n   370→    try std.testing.expectEqual(EventType.dependency_added, EventType.fromString(\"dependency_added\").?);\n   371→    try std.testing.expectEqual(EventType.dependency_removed, EventType.fromString(\"dependency_removed\").?);\n   372→    try std.testing.expectEqual(EventType.label_added, EventType.fromString(\"label_added\").?);\n   373→    try std.testing.expectEqual(EventType.label_removed, EventType.fromString(\"label_removed\").?);\n   374→    try std.testing.expectEqual(EventType.compacted, EventType.fromString(\"compacted\").?);\n   375→    try std.testing.expectEqual(EventType.deleted, EventType.fromString(\"deleted\").?);\n   376→    try std.testing.expectEqual(EventType.restored, EventType.fromString(\"restored\").?);\n   377→}\n   378→\n   379→test \"EventType.fromString returns null for unknown values\" {\n   380→    try std.testing.expect(EventType.fromString(\"unknown\") == null);\n   381→    try std.testing.expect(EventType.fromString(\"\") == null);\n   382→    try std.testing.expect(EventType.fromString(\"CREATED\") == null);\n   383→    try std.testing.expect(EventType.fromString(\"Created\") == null);\n   384→}\n   385→\n   386→test \"EventType toString/fromString roundtrip\" {\n   387→    const event_types = [_]EventType{\n   388→        .created,\n   389→        .updated,\n   390→        .status_changed,\n   391→        .priority_changed,\n   392→        .assignee_changed,\n   393→        .commented,\n   394→        .closed,\n   395→        .reopened,\n   396→        .dependency_added,\n   397→        .dependency_removed,\n   398→        .label_added,\n   399→        .label_removed,\n   400→        .compacted,\n   401→        .deleted,\n   402→        .restored,\n   403→    };\n   404→\n   405→    for (event_types) |et| {\n   406→        const str = et.toString();\n   407→        const parsed = EventType.fromString(str);\n   408→        try std.testing.expect(parsed != null);\n   409→        try std.testing.expectEqual(et, parsed.?);\n   410→    }\n   411→}\n   412→\n   413→test \"EventType JSON serialization roundtrip\" {\n   414→    const allocator = std.testing.allocator;\n   415→\n   416→    const event_types = [_]EventType{\n   417→        .created,\n   418→        .updated,\n   419→        .status_changed,\n   420→        .priority_changed,\n   421→        .assignee_changed,\n   422→        .commented,\n   423→        .closed,\n   424→        .reopened,\n   425→        .dependency_added,\n   426→        .dependency_removed,\n   427→        .label_added,\n   428→        .label_removed,\n   429→        .compacted,\n   430→        .deleted,\n   431→        .restored,\n   432→    };\n   433→\n   434→    for (event_types) |et| {\n   435→        var aw: std.io.Writer.Allocating = .init(allocator);\n   436→        defer aw.deinit();\n   437→\n   438→        try std.json.Stringify.value(et, .{}, &aw.writer);\n   439→        const json_str = aw.written();\n   440→\n   441→        const parsed = try std.json.parseFromSlice(EventType, allocator, json_str, .{});\n   442→        defer parsed.deinit();\n   443→\n   444→        try std.testing.expectEqual(et, parsed.value);\n   445→    }\n   446→}\n   447→\n   448→// --- Event Tests ---\n   449→\n   450→test \"Event.validate accepts valid event\" {\n   451→    const event = Event{\n   452→        .id = 1,\n   453→        .issue_id = \"bd-abc123\",\n   454→        .event_type = .created,\n   455→        .actor = \"alice@example.com\",\n   456→        .old_value = null,\n   457→        .new_value = null,\n   458→        .created_at = 1706540000,\n   459→    };\n   460→\n   461→    try event.validate();\n   462→}\n   463→\n   464→test \"Event.validate rejects empty actor\" {\n   465→    const event = Event{\n   466→        .id = 1,\n   467→        .issue_id = \"bd-abc123\",\n   468→        .event_type = .created,\n   469→        .actor = \"\",\n   470→        .old_value = null,\n   471→        .new_value = null,\n   472→        .created_at = 1706540000,\n   473→    };\n   474→\n   475→    try std.testing.expectError(EventError.EmptyActor, event.validate());\n   476→}\n   477→\n   478→test \"Event.validate rejects empty issue_id\" {\n   479→    const event = Event{\n   480→        .id = 1,\n   481→        .issue_id = \"\",\n   482→        .event_type = .created,\n   483→        .actor = \"alice@example.com\",\n   484→        .old_value = null,\n   485→        .new_value = null,\n   486→        .created_at = 1706540000,\n   487→    };\n   488→\n   489→    try std.testing.expectError(EventError.EmptyIssueId, event.validate());\n   490→}\n   491→\n   492→test \"Event.eql compares all fields\" {\n   493→    const event1 = Event{\n   494→        .id = 1,\n   495→        .issue_id = \"bd-abc123\",\n   496→        .event_type = .status_changed,\n   497→        .actor = \"alice@example.com\",\n   498→        .old_value = \"open\",\n   499→        .new_value = \"closed\",\n   500→        .created_at = 1706540000,\n   501→    };\n   502→\n   503→    const event2 = Event{\n   504→        .id = 1,\n   505→        .issue_id = \"bd-abc123\",\n   506→        .event_type = .status_changed,\n   507→        .actor = \"alice@example.com\",\n   508→        .old_value = \"open\",\n   509→        .new_value = \"closed\",\n   510→        .created_at = 1706540000,\n   511→    };\n   512→\n   513→    try std.testing.expect(Event.eql(event1, event2));\n   514→}\n   515→\n   516→test \"Event.eql detects differences\" {\n   517→    const base = Event{\n   518→        .id = 1,\n   519→        .issue_id = \"bd-abc123\",\n   520→        .event_type = .status_changed,\n   521→        .actor = \"alice@example.com\",\n   522→        .old_value = \"open\",\n   523→        .new_value = \"closed\",\n   524→        .created_at = 1706540000,\n   525→    };\n   526→\n   527→    const diff_id = Event{\n   528→        .id = 2,\n   529→        .issue_id = \"bd-abc123\",\n   530→        .event_type = .status_changed,\n   531→        .actor = \"alice@example.com\",\n   532→        .old_value = \"open\",\n   533→        .new_value = \"closed\",\n   534→        .created_at = 1706540000,\n   535→    };\n   536→    try std.testing.expect(!Event.eql(base, diff_id));\n   537→\n   538→    const diff_event_type = Event{\n   539→        .id = 1,\n   540→        .issue_id = \"bd-abc123\",\n   541→        .event_type = .priority_changed,\n   542→        .actor = \"alice@example.com\",\n   543→        .old_value = \"open\",\n   544→        .new_value = \"closed\",\n   545→        .created_at = 1706540000,\n   546→    };\n   547→    try std.testing.expect(!Event.eql(base, diff_event_type));\n   548→\n   549→    const diff_old_value = Event{\n   550→        .id = 1,\n   551→        .issue_id = \"bd-abc123\",\n   552→        .event_type = .status_changed,\n   553→        .actor = \"alice@example.com\",\n   554→        .old_value = \"in_progress\",\n   555→        .new_value = \"closed\",\n   556→        .created_at = 1706540000,\n   557→    };\n   558→    try std.testing.expect(!Event.eql(base, diff_old_value));\n   559→\n   560→    const null_old_value = Event{\n   561→        .id = 1,\n   562→        .issue_id = \"bd-abc123\",\n   563→        .event_type = .status_changed,\n   564→        .actor = \"alice@example.com\",\n   565→        .old_value = null,\n   566→        .new_value = \"closed\",\n   567→        .created_at = 1706540000,\n   568→    };\n   569→    try std.testing.expect(!Event.eql(base, null_old_value));\n   570→}\n   571→\n   572→test \"Event JSON serialization roundtrip\" {\n   573→    const allocator = std.testing.allocator;\n   574→\n   575→    const event = Event{\n   576→        .id = 42,\n   577→        .issue_id = \"bd-abc123\",\n   578→        .event_type = .status_changed,\n   579→        .actor = \"alice@example.com\",\n   580→        .old_value = \"open\",\n   581→        .new_value = \"closed\",\n   582→        .created_at = 1706540000,\n   583→    };\n   584→\n   585→    var aw: std.io.Writer.Allocating = .init(allocator);\n   586→    defer aw.deinit();\n   587→\n   588→    try std.json.Stringify.value(event, .{}, &aw.writer);\n   589→    const json_str = aw.written();\n   590→\n   591→    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n   592→    defer parsed.deinit();\n   593→\n   594→    try std.testing.expect(Event.eql(event, parsed.value));\n   595→}\n   596→\n   597→test \"Event JSON serialization with null old_value\" {\n   598→    const allocator = std.testing.allocator;\n   599→\n   600→    const event = Event{\n   601→        .id = 1,\n   602→        .issue_id = \"bd-abc123\",\n   603→        .event_type = .created,\n   604→        .actor = \"alice@example.com\",\n   605→        .old_value = null,\n   606→        .new_value = \"initial state\",\n   607→        .created_at = 1706540000,\n   608→    };\n   609→\n   610→    var aw: std.io.Writer.Allocating = .init(allocator);\n   611→    defer aw.deinit();\n   612→\n   613→    try std.json.Stringify.value(event, .{}, &aw.writer);\n   614→    const json_str = aw.written();\n   615→\n   616→    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n   617→    defer parsed.deinit();\n   618→\n   619→    try std.testing.expect(Event.eql(event, parsed.value));\n   620→    try std.testing.expect(parsed.value.old_value == null);\n   621→}\n   622→\n   623→test \"Event JSON serialization with both values null\" {\n   624→    const allocator = std.testing.allocator;\n   625→\n   626→    const event = Event{\n   627→        .id = 1,\n   628→        .issue_id = \"bd-abc123\",\n   629→        .event_type = .deleted,\n   630→        .actor = \"alice@example.com\",\n   631→        .old_value = null,\n   632→        .new_value = null,\n   633→        .created_at = 1706540000,\n   634→    };\n   635→\n   636→    var aw: std.io.Writer.Allocating = .init(allocator);\n   637→    defer aw.deinit();\n   638→\n   639→    try std.json.Stringify.value(event, .{}, &aw.writer);\n   640→    const json_str = aw.written();\n   641→\n   642→    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n   643→    defer parsed.deinit();\n   644→\n   645→    try std.testing.expect(Event.eql(event, parsed.value));\n   646→}\n   647→\n   648→// --- Factory Function Tests ---\n   649→\n   650→test \"Event.issueCreated produces valid event\" {\n   651→    const event = Event.issueCreated(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   652→\n   653→    try std.testing.expectEqualStrings(\"bd-abc123\", event.issue_id);\n   654→    try std.testing.expectEqual(EventType.created, event.event_type);\n   655→    try std.testing.expectEqualStrings(\"alice@example.com\", event.actor);\n   656→    try std.testing.expect(event.old_value == null);\n   657→    try std.testing.expect(event.new_value == null);\n   658→    try std.testing.expectEqual(@as(i64, 1706540000), event.created_at);\n   659→    try std.testing.expectEqual(@as(i64, 0), event.id);\n   660→\n   661→    try event.validate();\n   662→}\n   663→\n   664→test \"Event.statusChange produces valid event\" {\n   665→    const allocator = std.testing.allocator;\n   666→\n   667→    const event = try Event.statusChange(\n   668→        allocator,\n   669→        \"bd-abc123\",\n   670→        \"alice@example.com\",\n   671→        Status.open,\n   672→        Status.closed,\n   673→        1706540000,\n   674→    );\n   675→    defer {\n   676→        if (event.old_value) |v| allocator.free(v);\n   677→        if (event.new_value) |v| allocator.free(v);\n   678→    }\n   679→\n   680→    try std.testing.expectEqual(EventType.status_changed, event.event_type);\n   681→    try std.testing.expectEqualStrings(\"open\", event.old_value.?);\n   682→    try std.testing.expectEqualStrings(\"closed\", event.new_value.?);\n   683→\n   684→    try event.validate();\n   685→}\n   686→\n   687→test \"Event.priorityChange produces valid event\" {\n   688→    const allocator = std.testing.allocator;\n   689→\n   690→    const event = try Event.priorityChange(\n   691→        allocator,\n   692→        \"bd-abc123\",\n   693→        \"alice@example.com\",\n   694→        Priority.LOW,\n   695→        Priority.HIGH,\n   696→        1706540000,\n   697→    );\n   698→    defer {\n   699→        if (event.old_value) |v| allocator.free(v);\n   700→        if (event.new_value) |v| allocator.free(v);\n   701→    }\n   702→\n   703→    try std.testing.expectEqual(EventType.priority_changed, event.event_type);\n   704→    try std.testing.expectEqualStrings(\"3\", event.old_value.?);\n   705→    try std.testing.expectEqualStrings(\"1\", event.new_value.?);\n   706→\n   707→    try event.validate();\n   708→}\n   709→\n   710→test \"Event.assigneeChange produces valid event\" {\n   711→    const allocator = std.testing.allocator;\n   712→\n   713→    const event = try Event.assigneeChange(\n   714→        allocator,\n   715→        \"bd-abc123\",\n   716→        \"admin@example.com\",\n   717→        \"alice@example.com\",\n   718→        \"bob@example.com\",\n   719→        1706540000,\n   720→    );\n   721→    defer {\n   722→        if (event.old_value) |v| allocator.free(v);\n   723→        if (event.new_value) |v| allocator.free(v);\n   724→    }\n   725→\n   726→    try std.testing.expectEqual(EventType.assignee_changed, event.event_type);\n   727→    try std.testing.expectEqualStrings(\"alice@example.com\", event.old_value.?);\n   728→    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n   729→\n   730→    try event.validate();\n   731→}\n   732→\n   733→test \"Event.assigneeChange handles null assignees\" {\n   734→    const allocator = std.testing.allocator;\n   735→\n   736→    const event = try Event.assigneeChange(\n   737→        allocator,\n   738→        \"bd-abc123\",\n   739→        \"admin@example.com\",\n   740→        null,\n   741→        \"bob@example.com\",\n   742→        1706540000,\n   743→    );\n   744→    defer {\n   745→        if (event.old_value) |v| allocator.free(v);\n   746→        if (event.new_value) |v| allocator.free(v);\n   747→    }\n   748→\n   749→    try std.testing.expect(event.old_value == null);\n   750→    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n   751→\n   752→    try event.validate();\n   753→}\n   754→\n   755→test \"Event.labelAdded produces valid event\" {\n   756→    const allocator = std.testing.allocator;\n   757→\n   758→    const event = try Event.labelAdded(\n   759→        allocator,\n   760→        \"bd-abc123\",\n   761→        \"alice@example.com\",\n   762→        \"urgent\",\n   763→        1706540000,\n   764→    );\n   765→    defer {\n   766→        if (event.new_value) |v| allocator.free(v);\n   767→    }\n   768→\n   769→    try std.testing.expectEqual(EventType.label_added, event.event_type);\n   770→    try std.testing.expect(event.old_value == null);\n   771→    try std.testing.expectEqualStrings(\"urgent\", event.new_value.?);\n   772→\n   773→    try event.validate();\n   774→}\n   775→\n   776→test \"Event.labelRemoved produces valid event\" {\n   777→    const allocator = std.testing.allocator;\n   778→\n   779→    const event = try Event.labelRemoved(\n   780→        allocator,\n   781→        \"bd-abc123\",\n   782→        \"alice@example.com\",\n   783→        \"wontfix\",\n   784→        1706540000,\n   785→    );\n   786→    defer {\n   787→        if (event.old_value) |v| allocator.free(v);\n   788→    }\n   789→\n   790→    try std.testing.expectEqual(EventType.label_removed, event.event_type);\n   791→    try std.testing.expectEqualStrings(\"wontfix\", event.old_value.?);\n   792→    try std.testing.expect(event.new_value == null);\n   793→\n   794→    try event.validate();\n   795→}\n   796→\n   797→test \"Event.dependencyAdded produces valid event\" {\n   798→    const allocator = std.testing.allocator;\n   799→\n   800→    const event = try Event.dependencyAdded(\n   801→        allocator,\n   802→        \"bd-abc123\",\n   803→        \"alice@example.com\",\n   804→        \"bd-def456\",\n   805→        1706540000,\n   806→    );\n   807→    defer {\n   808→        if (event.new_value) |v| allocator.free(v);\n   809→    }\n   810→\n   811→    try std.testing.expectEqual(EventType.dependency_added, event.event_type);\n   812→    try std.testing.expect(event.old_value == null);\n   813→    try std.testing.expectEqualStrings(\"bd-def456\", event.new_value.?);\n   814→\n   815→    try event.validate();\n   816→}\n   817→\n   818→test \"Event.dependencyRemoved produces valid event\" {\n   819→    const allocator = std.testing.allocator;\n   820→\n   821→    const event = try Event.dependencyRemoved(\n   822→        allocator,\n   823→        \"bd-abc123\",\n   824→        \"alice@example.com\",\n   825→        \"bd-def456\",\n   826→        1706540000,\n   827→    );\n   828→    defer {\n   829→        if (event.old_value) |v| allocator.free(v);\n   830→    }\n   831→\n   832→    try std.testing.expectEqual(EventType.dependency_removed, event.event_type);\n   833→    try std.testing.expectEqualStrings(\"bd-def456\", event.old_value.?);\n   834→    try std.testing.expect(event.new_value == null);\n   835→\n   836→    try event.validate();\n   837→}\n   838→\n   839→test \"Event.issueClosed produces valid event\" {\n   840→    const allocator = std.testing.allocator;\n   841→\n   842→    const event = try Event.issueClosed(\n   843→        allocator,\n   844→        \"bd-abc123\",\n   845→        \"alice@example.com\",\n   846→        \"completed\",\n   847→        1706540000,\n   848→    );\n   849→    defer {\n   850→        if (event.new_value) |v| allocator.free(v);\n   851→    }\n   852→\n   853→    try std.testing.expectEqual(EventType.closed, event.event_type);\n   854→    try std.testing.expect(event.old_value == null);\n   855→    try std.testing.expectEqualStrings(\"completed\", event.new_value.?);\n   856→\n   857→    try event.validate();\n   858→}\n   859→\n   860→test \"Event.issueClosed handles null close_reason\" {\n   861→    const allocator = std.testing.allocator;\n   862→\n   863→    const event = try Event.issueClosed(\n   864→        allocator,\n   865→        \"bd-abc123\",\n   866→        \"alice@example.com\",\n   867→        null,\n   868→        1706540000,\n   869→    );\n   870→\n   871→    try std.testing.expectEqual(EventType.closed, event.event_type);\n   872→    try std.testing.expect(event.old_value == null);\n   873→    try std.testing.expect(event.new_value == null);\n   874→\n   875→    try event.validate();\n   876→}\n   877→\n   878→test \"Event.issueReopened produces valid event\" {\n   879→    const event = Event.issueReopened(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   880→\n   881→    try std.testing.expectEqual(EventType.reopened, event.event_type);\n   882→    try std.testing.expect(event.old_value == null);\n   883→    try std.testing.expect(event.new_value == null);\n   884→\n   885→    try event.validate();\n   886→}\n   887→\n   888→test \"Event.issueDeleted produces valid event\" {\n   889→    const event = Event.issueDeleted(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   890→\n   891→    try std.testing.expectEqual(EventType.deleted, event.event_type);\n   892→    try std.testing.expect(event.old_value == null);\n   893→    try std.testing.expect(event.new_value == null);\n   894→\n   895→    try event.validate();\n   896→}\n   897→\n   898→test \"Event.issueRestored produces valid event\" {\n   899→    const event = Event.issueRestored(\"bd-abc123\", \"alice@example.com\", 1706540000);\n   900→\n   901→    try std.testing.expectEqual(EventType.restored, event.event_type);\n   902→    try std.testing.expect(event.old_value == null);\n   903→    try std.testing.expect(event.new_value == null);\n   904→\n   905→    try event.validate();\n   906→}\n   907→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4f4d7038-8e98-4a96-924a-e8dcecc20fc8","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/models/event.zig","content":"//! Event struct and EventType enum for the audit log system.\n//!\n//! Events track changes to issues for audit and history purposes.\n//! Each event records who made a change, what changed, and when.\n\nconst std = @import(\"std\");\nconst Status = @import(\"status.zig\").Status;\nconst Priority = @import(\"priority.zig\").Priority;\n\n/// Types of events that can occur on an issue.\npub const EventType = enum {\n    created,\n    updated,\n    status_changed,\n    priority_changed,\n    assignee_changed,\n    commented,\n    closed,\n    reopened,\n    dependency_added,\n    dependency_removed,\n    label_added,\n    label_removed,\n    compacted,\n    deleted,\n    restored,\n\n    const Self = @This();\n\n    /// Convert EventType to its string representation.\n    pub fn toString(self: Self) []const u8 {\n        return @tagName(self);\n    }\n\n    /// Parse a string into an EventType.\n    /// Returns null for unknown values.\n    pub fn fromString(s: []const u8) ?Self {\n        return std.meta.stringToEnum(Self, s);\n    }\n\n    /// JSON serialization for std.json.\n    pub fn jsonStringify(self: Self, jws: anytype) !void {\n        try jws.write(self.toString());\n    }\n\n    /// JSON deserialization for std.json.\n    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n        const str = switch (token) {\n            .string, .allocated_string => |s| s,\n            else => return error.UnexpectedToken,\n        };\n        return fromString(str) orelse error.UnexpectedToken;\n    }\n\n    /// JSON deserialization from already-parsed value.\n    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n        _ = allocator;\n        _ = options;\n        return switch (source) {\n            .string => |s| fromString(s) orelse error.UnexpectedToken,\n            else => error.UnexpectedToken,\n        };\n    }\n};\n\n/// Validation errors for Event.\npub const EventError = error{\n    EmptyActor,\n    EmptyIssueId,\n};\n\n/// An audit log entry for an issue change.\npub const Event = struct {\n    id: i64, // Unique identifier, 0 for new events before insert\n    issue_id: []const u8, // The issue this event relates to\n    event_type: EventType, // What kind of change occurred\n    actor: []const u8, // Who performed the action\n    old_value: ?[]const u8, // JSON of previous state (null for creation)\n    new_value: ?[]const u8, // JSON of new state (null for deletion)\n    created_at: i64, // Unix timestamp\n\n    const Self = @This();\n\n    /// Validate that the event has all required fields populated.\n    pub fn validate(self: Self) EventError!void {\n        if (self.actor.len == 0) return EventError.EmptyActor;\n        if (self.issue_id.len == 0) return EventError.EmptyIssueId;\n    }\n\n    /// Check deep equality between two Events.\n    pub fn eql(a: Self, b: Self) bool {\n        return a.id == b.id and\n            a.created_at == b.created_at and\n            a.event_type == b.event_type and\n            std.mem.eql(u8, a.issue_id, b.issue_id) and\n            std.mem.eql(u8, a.actor, b.actor) and\n            optionalStrEql(a.old_value, b.old_value) and\n            optionalStrEql(a.new_value, b.new_value);\n    }\n\n    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n        const av = a orelse return b == null;\n        const bv = b orelse return false;\n        return std.mem.eql(u8, av, bv);\n    }\n\n    /// Create an event for issue creation.\n    pub fn issueCreated(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .created,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for status change.\n    pub fn statusChange(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        old_status: Status,\n        new_status: Status,\n        timestamp: i64,\n    ) !Self {\n        const old_json = try allocator.dupe(u8, old_status.toString());\n        const new_json = try allocator.dupe(u8, new_status.toString());\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .status_changed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for priority change.\n    pub fn priorityChange(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        old_priority: Priority,\n        new_priority: Priority,\n        timestamp: i64,\n    ) !Self {\n        var old_buf: [8]u8 = undefined;\n        var new_buf: [8]u8 = undefined;\n\n        const old_str = std.fmt.bufPrint(&old_buf, \"{d}\", .{old_priority.value}) catch unreachable;\n        const new_str = std.fmt.bufPrint(&new_buf, \"{d}\", .{new_priority.value}) catch unreachable;\n\n        const old_json = try allocator.dupe(u8, old_str);\n        const new_json = try allocator.dupe(u8, new_str);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .priority_changed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for assignee change.\n    pub fn assigneeChange(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        old_assignee: ?[]const u8,\n        new_assignee: ?[]const u8,\n        timestamp: i64,\n    ) !Self {\n        const old_json = if (old_assignee) |a| try allocator.dupe(u8, a) else null;\n        const new_json = if (new_assignee) |a| try allocator.dupe(u8, a) else null;\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .assignee_changed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for adding a label.\n    pub fn labelAdded(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        label: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const new_json = try allocator.dupe(u8, label);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .label_added,\n            .actor = actor,\n            .old_value = null,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for removing a label.\n    pub fn labelRemoved(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        label: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const old_json = try allocator.dupe(u8, label);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .label_removed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for adding a dependency.\n    pub fn dependencyAdded(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        depends_on_id: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const new_json = try allocator.dupe(u8, depends_on_id);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .dependency_added,\n            .actor = actor,\n            .old_value = null,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for removing a dependency.\n    pub fn dependencyRemoved(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        depends_on_id: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const old_json = try allocator.dupe(u8, depends_on_id);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .dependency_removed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue closure.\n    pub fn issueClosed(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        close_reason: ?[]const u8,\n        timestamp: i64,\n    ) !Self {\n        const new_json = if (close_reason) |r| try allocator.dupe(u8, r) else null;\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .closed,\n            .actor = actor,\n            .old_value = null,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue reopening.\n    pub fn issueReopened(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .reopened,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue deletion (tombstone).\n    pub fn issueDeleted(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .deleted,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue restoration.\n    pub fn issueRestored(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .restored,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n};\n\n// --- EventType Tests ---\n\ntest \"EventType.toString returns correct strings\" {\n    try std.testing.expectEqualStrings(\"created\", EventType.created.toString());\n    try std.testing.expectEqualStrings(\"updated\", EventType.updated.toString());\n    try std.testing.expectEqualStrings(\"status_changed\", EventType.status_changed.toString());\n    try std.testing.expectEqualStrings(\"priority_changed\", EventType.priority_changed.toString());\n    try std.testing.expectEqualStrings(\"assignee_changed\", EventType.assignee_changed.toString());\n    try std.testing.expectEqualStrings(\"commented\", EventType.commented.toString());\n    try std.testing.expectEqualStrings(\"closed\", EventType.closed.toString());\n    try std.testing.expectEqualStrings(\"reopened\", EventType.reopened.toString());\n    try std.testing.expectEqualStrings(\"dependency_added\", EventType.dependency_added.toString());\n    try std.testing.expectEqualStrings(\"dependency_removed\", EventType.dependency_removed.toString());\n    try std.testing.expectEqualStrings(\"label_added\", EventType.label_added.toString());\n    try std.testing.expectEqualStrings(\"label_removed\", EventType.label_removed.toString());\n    try std.testing.expectEqualStrings(\"compacted\", EventType.compacted.toString());\n    try std.testing.expectEqualStrings(\"deleted\", EventType.deleted.toString());\n    try std.testing.expectEqualStrings(\"restored\", EventType.restored.toString());\n}\n\ntest \"EventType.fromString parses known event types\" {\n    try std.testing.expectEqual(EventType.created, EventType.fromString(\"created\").?);\n    try std.testing.expectEqual(EventType.updated, EventType.fromString(\"updated\").?);\n    try std.testing.expectEqual(EventType.status_changed, EventType.fromString(\"status_changed\").?);\n    try std.testing.expectEqual(EventType.priority_changed, EventType.fromString(\"priority_changed\").?);\n    try std.testing.expectEqual(EventType.assignee_changed, EventType.fromString(\"assignee_changed\").?);\n    try std.testing.expectEqual(EventType.commented, EventType.fromString(\"commented\").?);\n    try std.testing.expectEqual(EventType.closed, EventType.fromString(\"closed\").?);\n    try std.testing.expectEqual(EventType.reopened, EventType.fromString(\"reopened\").?);\n    try std.testing.expectEqual(EventType.dependency_added, EventType.fromString(\"dependency_added\").?);\n    try std.testing.expectEqual(EventType.dependency_removed, EventType.fromString(\"dependency_removed\").?);\n    try std.testing.expectEqual(EventType.label_added, EventType.fromString(\"label_added\").?);\n    try std.testing.expectEqual(EventType.label_removed, EventType.fromString(\"label_removed\").?);\n    try std.testing.expectEqual(EventType.compacted, EventType.fromString(\"compacted\").?);\n    try std.testing.expectEqual(EventType.deleted, EventType.fromString(\"deleted\").?);\n    try std.testing.expectEqual(EventType.restored, EventType.fromString(\"restored\").?);\n}\n\ntest \"EventType.fromString returns null for unknown values\" {\n    try std.testing.expect(EventType.fromString(\"unknown\") == null);\n    try std.testing.expect(EventType.fromString(\"\") == null);\n    try std.testing.expect(EventType.fromString(\"CREATED\") == null);\n    try std.testing.expect(EventType.fromString(\"Created\") == null);\n}\n\ntest \"EventType toString/fromString roundtrip\" {\n    const event_types = [_]EventType{\n        .created,\n        .updated,\n        .status_changed,\n        .priority_changed,\n        .assignee_changed,\n        .commented,\n        .closed,\n        .reopened,\n        .dependency_added,\n        .dependency_removed,\n        .label_added,\n        .label_removed,\n        .compacted,\n        .deleted,\n        .restored,\n    };\n\n    for (event_types) |et| {\n        const str = et.toString();\n        const parsed = EventType.fromString(str);\n        try std.testing.expect(parsed != null);\n        try std.testing.expectEqual(et, parsed.?);\n    }\n}\n\ntest \"EventType JSON serialization roundtrip\" {\n    const allocator = std.testing.allocator;\n\n    const event_types = [_]EventType{\n        .created,\n        .updated,\n        .status_changed,\n        .priority_changed,\n        .assignee_changed,\n        .commented,\n        .closed,\n        .reopened,\n        .dependency_added,\n        .dependency_removed,\n        .label_added,\n        .label_removed,\n        .compacted,\n        .deleted,\n        .restored,\n    };\n\n    for (event_types) |et| {\n        var aw: std.io.Writer.Allocating = .init(allocator);\n        defer aw.deinit();\n\n        try std.json.Stringify.value(et, .{}, &aw.writer);\n        const json_str = aw.written();\n\n        const parsed = try std.json.parseFromSlice(EventType, allocator, json_str, .{});\n        defer parsed.deinit();\n\n        try std.testing.expectEqual(et, parsed.value);\n    }\n}\n\n// --- Event Tests ---\n\ntest \"Event.validate accepts valid event\" {\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .created,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    try event.validate();\n}\n\ntest \"Event.validate rejects empty actor\" {\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .created,\n        .actor = \"\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    try std.testing.expectError(EventError.EmptyActor, event.validate());\n}\n\ntest \"Event.validate rejects empty issue_id\" {\n    const event = Event{\n        .id = 1,\n        .issue_id = \"\",\n        .event_type = .created,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    try std.testing.expectError(EventError.EmptyIssueId, event.validate());\n}\n\ntest \"Event.eql compares all fields\" {\n    const event1 = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    const event2 = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    try std.testing.expect(Event.eql(event1, event2));\n}\n\ntest \"Event.eql detects differences\" {\n    const base = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    const diff_id = Event{\n        .id = 2,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, diff_id));\n\n    const diff_event_type = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .priority_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, diff_event_type));\n\n    const diff_old_value = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"in_progress\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, diff_old_value));\n\n    const null_old_value = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, null_old_value));\n}\n\ntest \"Event JSON serialization roundtrip\" {\n    const allocator = std.testing.allocator;\n\n    const event = Event{\n        .id = 42,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(event, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Event.eql(event, parsed.value));\n}\n\ntest \"Event JSON serialization with null old_value\" {\n    const allocator = std.testing.allocator;\n\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .created,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = \"initial state\",\n        .created_at = 1706540000,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(event, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Event.eql(event, parsed.value));\n    try std.testing.expect(parsed.value.old_value == null);\n}\n\ntest \"Event JSON serialization with both values null\" {\n    const allocator = std.testing.allocator;\n\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .deleted,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(event, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Event.eql(event, parsed.value));\n}\n\n// --- Factory Function Tests ---\n\ntest \"Event.issueCreated produces valid event\" {\n    const event = Event.issueCreated(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", event.issue_id);\n    try std.testing.expectEqual(EventType.created, event.event_type);\n    try std.testing.expectEqualStrings(\"alice@example.com\", event.actor);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n    try std.testing.expectEqual(@as(i64, 1706540000), event.created_at);\n    try std.testing.expectEqual(@as(i64, 0), event.id);\n\n    try event.validate();\n}\n\ntest \"Event.statusChange produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.statusChange(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        Status.open,\n        Status.closed,\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.status_changed, event.event_type);\n    try std.testing.expectEqualStrings(\"open\", event.old_value.?);\n    try std.testing.expectEqualStrings(\"closed\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.priorityChange produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.priorityChange(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        Priority.LOW,\n        Priority.HIGH,\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.priority_changed, event.event_type);\n    try std.testing.expectEqualStrings(\"3\", event.old_value.?);\n    try std.testing.expectEqualStrings(\"1\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.assigneeChange produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.assigneeChange(\n        allocator,\n        \"bd-abc123\",\n        \"admin@example.com\",\n        \"alice@example.com\",\n        \"bob@example.com\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.assignee_changed, event.event_type);\n    try std.testing.expectEqualStrings(\"alice@example.com\", event.old_value.?);\n    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.assigneeChange handles null assignees\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.assigneeChange(\n        allocator,\n        \"bd-abc123\",\n        \"admin@example.com\",\n        null,\n        \"bob@example.com\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.labelAdded produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.labelAdded(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"urgent\",\n        1706540000,\n    );\n    defer {\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.label_added, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"urgent\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.labelRemoved produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.labelRemoved(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"wontfix\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.label_removed, event.event_type);\n    try std.testing.expectEqualStrings(\"wontfix\", event.old_value.?);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.dependencyAdded produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.dependencyAdded(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"bd-def456\",\n        1706540000,\n    );\n    defer {\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.dependency_added, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"bd-def456\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.dependencyRemoved produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.dependencyRemoved(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"bd-def456\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.dependency_removed, event.event_type);\n    try std.testing.expectEqualStrings(\"bd-def456\", event.old_value.?);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueClosed produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.issueClosed(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"completed\",\n        1706540000,\n    );\n    defer {\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.closed, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"completed\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.issueClosed handles null close_reason\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.issueClosed(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        null,\n        1706540000,\n    );\n\n    try std.testing.expectEqual(EventType.closed, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueReopened produces valid event\" {\n    const event = Event.issueReopened(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqual(EventType.reopened, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueDeleted produces valid event\" {\n    const event = Event.issueDeleted(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqual(EventType.deleted, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueRestored produces valid event\" {\n    const event = Event.issueRestored(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqual(EventType.restored, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n","numLines":907,"startLine":1,"totalLines":907}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Gzyu4AEcPxMo3oEkb7nazh","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase. Let me implement Task 1. The audit command needs to be extended with subcommands. I'll:\n\n1. Add new event types for LLM/tool interactions to the EventType enum\n2. Update AuditArgs to support subcommands\n3. Rewrite audit.zig to handle the subcommands\n\nLet me first update the EventType enum to include the new LLM/tool interaction types:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":11828,"cache_read_input_tokens":81580,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":11828},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d0066106-d273-4214-9a7c-8456d4c34aa2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Gzyu4AEcPxMo3oEkb7nazh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KgQKsDa9Kz9Qkjf86MJR8M","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/models/event.zig","old_string":"/// Types of events that can occur on an issue.\npub const EventType = enum {\n    created,\n    updated,\n    status_changed,\n    priority_changed,\n    assignee_changed,\n    commented,\n    closed,\n    reopened,\n    dependency_added,\n    dependency_removed,\n    label_added,\n    label_removed,\n    compacted,\n    deleted,\n    restored,","new_string":"/// Types of events that can occur on an issue.\npub const EventType = enum {\n    created,\n    updated,\n    status_changed,\n    priority_changed,\n    assignee_changed,\n    commented,\n    closed,\n    reopened,\n    dependency_added,\n    dependency_removed,\n    label_added,\n    label_removed,\n    compacted,\n    deleted,\n    restored,\n    // LLM/tool interaction tracking\n    llm_call,\n    tool_call,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":11828,"cache_read_input_tokens":81580,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":11828},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0c3d9398-d10b-40c8-b122-f91f8896fe8c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KgQKsDa9Kz9Qkjf86MJR8M","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/models/event.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6a798ab8-51a6-487c-bf5b-9f78a967d238","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/models/event.zig","oldString":"/// Types of events that can occur on an issue.\npub const EventType = enum {\n    created,\n    updated,\n    status_changed,\n    priority_changed,\n    assignee_changed,\n    commented,\n    closed,\n    reopened,\n    dependency_added,\n    dependency_removed,\n    label_added,\n    label_removed,\n    compacted,\n    deleted,\n    restored,","newString":"/// Types of events that can occur on an issue.\npub const EventType = enum {\n    created,\n    updated,\n    status_changed,\n    priority_changed,\n    assignee_changed,\n    commented,\n    closed,\n    reopened,\n    dependency_added,\n    dependency_removed,\n    label_added,\n    label_removed,\n    compacted,\n    deleted,\n    restored,\n    // LLM/tool interaction tracking\n    llm_call,\n    tool_call,","originalFile":"//! Event struct and EventType enum for the audit log system.\n//!\n//! Events track changes to issues for audit and history purposes.\n//! Each event records who made a change, what changed, and when.\n\nconst std = @import(\"std\");\nconst Status = @import(\"status.zig\").Status;\nconst Priority = @import(\"priority.zig\").Priority;\n\n/// Types of events that can occur on an issue.\npub const EventType = enum {\n    created,\n    updated,\n    status_changed,\n    priority_changed,\n    assignee_changed,\n    commented,\n    closed,\n    reopened,\n    dependency_added,\n    dependency_removed,\n    label_added,\n    label_removed,\n    compacted,\n    deleted,\n    restored,\n\n    const Self = @This();\n\n    /// Convert EventType to its string representation.\n    pub fn toString(self: Self) []const u8 {\n        return @tagName(self);\n    }\n\n    /// Parse a string into an EventType.\n    /// Returns null for unknown values.\n    pub fn fromString(s: []const u8) ?Self {\n        return std.meta.stringToEnum(Self, s);\n    }\n\n    /// JSON serialization for std.json.\n    pub fn jsonStringify(self: Self, jws: anytype) !void {\n        try jws.write(self.toString());\n    }\n\n    /// JSON deserialization for std.json.\n    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n        const str = switch (token) {\n            .string, .allocated_string => |s| s,\n            else => return error.UnexpectedToken,\n        };\n        return fromString(str) orelse error.UnexpectedToken;\n    }\n\n    /// JSON deserialization from already-parsed value.\n    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n        _ = allocator;\n        _ = options;\n        return switch (source) {\n            .string => |s| fromString(s) orelse error.UnexpectedToken,\n            else => error.UnexpectedToken,\n        };\n    }\n};\n\n/// Validation errors for Event.\npub const EventError = error{\n    EmptyActor,\n    EmptyIssueId,\n};\n\n/// An audit log entry for an issue change.\npub const Event = struct {\n    id: i64, // Unique identifier, 0 for new events before insert\n    issue_id: []const u8, // The issue this event relates to\n    event_type: EventType, // What kind of change occurred\n    actor: []const u8, // Who performed the action\n    old_value: ?[]const u8, // JSON of previous state (null for creation)\n    new_value: ?[]const u8, // JSON of new state (null for deletion)\n    created_at: i64, // Unix timestamp\n\n    const Self = @This();\n\n    /// Validate that the event has all required fields populated.\n    pub fn validate(self: Self) EventError!void {\n        if (self.actor.len == 0) return EventError.EmptyActor;\n        if (self.issue_id.len == 0) return EventError.EmptyIssueId;\n    }\n\n    /// Check deep equality between two Events.\n    pub fn eql(a: Self, b: Self) bool {\n        return a.id == b.id and\n            a.created_at == b.created_at and\n            a.event_type == b.event_type and\n            std.mem.eql(u8, a.issue_id, b.issue_id) and\n            std.mem.eql(u8, a.actor, b.actor) and\n            optionalStrEql(a.old_value, b.old_value) and\n            optionalStrEql(a.new_value, b.new_value);\n    }\n\n    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n        const av = a orelse return b == null;\n        const bv = b orelse return false;\n        return std.mem.eql(u8, av, bv);\n    }\n\n    /// Create an event for issue creation.\n    pub fn issueCreated(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .created,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for status change.\n    pub fn statusChange(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        old_status: Status,\n        new_status: Status,\n        timestamp: i64,\n    ) !Self {\n        const old_json = try allocator.dupe(u8, old_status.toString());\n        const new_json = try allocator.dupe(u8, new_status.toString());\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .status_changed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for priority change.\n    pub fn priorityChange(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        old_priority: Priority,\n        new_priority: Priority,\n        timestamp: i64,\n    ) !Self {\n        var old_buf: [8]u8 = undefined;\n        var new_buf: [8]u8 = undefined;\n\n        const old_str = std.fmt.bufPrint(&old_buf, \"{d}\", .{old_priority.value}) catch unreachable;\n        const new_str = std.fmt.bufPrint(&new_buf, \"{d}\", .{new_priority.value}) catch unreachable;\n\n        const old_json = try allocator.dupe(u8, old_str);\n        const new_json = try allocator.dupe(u8, new_str);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .priority_changed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for assignee change.\n    pub fn assigneeChange(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        old_assignee: ?[]const u8,\n        new_assignee: ?[]const u8,\n        timestamp: i64,\n    ) !Self {\n        const old_json = if (old_assignee) |a| try allocator.dupe(u8, a) else null;\n        const new_json = if (new_assignee) |a| try allocator.dupe(u8, a) else null;\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .assignee_changed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for adding a label.\n    pub fn labelAdded(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        label: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const new_json = try allocator.dupe(u8, label);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .label_added,\n            .actor = actor,\n            .old_value = null,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for removing a label.\n    pub fn labelRemoved(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        label: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const old_json = try allocator.dupe(u8, label);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .label_removed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for adding a dependency.\n    pub fn dependencyAdded(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        depends_on_id: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const new_json = try allocator.dupe(u8, depends_on_id);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .dependency_added,\n            .actor = actor,\n            .old_value = null,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for removing a dependency.\n    pub fn dependencyRemoved(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        depends_on_id: []const u8,\n        timestamp: i64,\n    ) !Self {\n        const old_json = try allocator.dupe(u8, depends_on_id);\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .dependency_removed,\n            .actor = actor,\n            .old_value = old_json,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue closure.\n    pub fn issueClosed(\n        allocator: std.mem.Allocator,\n        issue_id: []const u8,\n        actor: []const u8,\n        close_reason: ?[]const u8,\n        timestamp: i64,\n    ) !Self {\n        const new_json = if (close_reason) |r| try allocator.dupe(u8, r) else null;\n\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .closed,\n            .actor = actor,\n            .old_value = null,\n            .new_value = new_json,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue reopening.\n    pub fn issueReopened(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .reopened,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue deletion (tombstone).\n    pub fn issueDeleted(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .deleted,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n\n    /// Create an event for issue restoration.\n    pub fn issueRestored(issue_id: []const u8, actor: []const u8, timestamp: i64) Self {\n        return Self{\n            .id = 0,\n            .issue_id = issue_id,\n            .event_type = .restored,\n            .actor = actor,\n            .old_value = null,\n            .new_value = null,\n            .created_at = timestamp,\n        };\n    }\n};\n\n// --- EventType Tests ---\n\ntest \"EventType.toString returns correct strings\" {\n    try std.testing.expectEqualStrings(\"created\", EventType.created.toString());\n    try std.testing.expectEqualStrings(\"updated\", EventType.updated.toString());\n    try std.testing.expectEqualStrings(\"status_changed\", EventType.status_changed.toString());\n    try std.testing.expectEqualStrings(\"priority_changed\", EventType.priority_changed.toString());\n    try std.testing.expectEqualStrings(\"assignee_changed\", EventType.assignee_changed.toString());\n    try std.testing.expectEqualStrings(\"commented\", EventType.commented.toString());\n    try std.testing.expectEqualStrings(\"closed\", EventType.closed.toString());\n    try std.testing.expectEqualStrings(\"reopened\", EventType.reopened.toString());\n    try std.testing.expectEqualStrings(\"dependency_added\", EventType.dependency_added.toString());\n    try std.testing.expectEqualStrings(\"dependency_removed\", EventType.dependency_removed.toString());\n    try std.testing.expectEqualStrings(\"label_added\", EventType.label_added.toString());\n    try std.testing.expectEqualStrings(\"label_removed\", EventType.label_removed.toString());\n    try std.testing.expectEqualStrings(\"compacted\", EventType.compacted.toString());\n    try std.testing.expectEqualStrings(\"deleted\", EventType.deleted.toString());\n    try std.testing.expectEqualStrings(\"restored\", EventType.restored.toString());\n}\n\ntest \"EventType.fromString parses known event types\" {\n    try std.testing.expectEqual(EventType.created, EventType.fromString(\"created\").?);\n    try std.testing.expectEqual(EventType.updated, EventType.fromString(\"updated\").?);\n    try std.testing.expectEqual(EventType.status_changed, EventType.fromString(\"status_changed\").?);\n    try std.testing.expectEqual(EventType.priority_changed, EventType.fromString(\"priority_changed\").?);\n    try std.testing.expectEqual(EventType.assignee_changed, EventType.fromString(\"assignee_changed\").?);\n    try std.testing.expectEqual(EventType.commented, EventType.fromString(\"commented\").?);\n    try std.testing.expectEqual(EventType.closed, EventType.fromString(\"closed\").?);\n    try std.testing.expectEqual(EventType.reopened, EventType.fromString(\"reopened\").?);\n    try std.testing.expectEqual(EventType.dependency_added, EventType.fromString(\"dependency_added\").?);\n    try std.testing.expectEqual(EventType.dependency_removed, EventType.fromString(\"dependency_removed\").?);\n    try std.testing.expectEqual(EventType.label_added, EventType.fromString(\"label_added\").?);\n    try std.testing.expectEqual(EventType.label_removed, EventType.fromString(\"label_removed\").?);\n    try std.testing.expectEqual(EventType.compacted, EventType.fromString(\"compacted\").?);\n    try std.testing.expectEqual(EventType.deleted, EventType.fromString(\"deleted\").?);\n    try std.testing.expectEqual(EventType.restored, EventType.fromString(\"restored\").?);\n}\n\ntest \"EventType.fromString returns null for unknown values\" {\n    try std.testing.expect(EventType.fromString(\"unknown\") == null);\n    try std.testing.expect(EventType.fromString(\"\") == null);\n    try std.testing.expect(EventType.fromString(\"CREATED\") == null);\n    try std.testing.expect(EventType.fromString(\"Created\") == null);\n}\n\ntest \"EventType toString/fromString roundtrip\" {\n    const event_types = [_]EventType{\n        .created,\n        .updated,\n        .status_changed,\n        .priority_changed,\n        .assignee_changed,\n        .commented,\n        .closed,\n        .reopened,\n        .dependency_added,\n        .dependency_removed,\n        .label_added,\n        .label_removed,\n        .compacted,\n        .deleted,\n        .restored,\n    };\n\n    for (event_types) |et| {\n        const str = et.toString();\n        const parsed = EventType.fromString(str);\n        try std.testing.expect(parsed != null);\n        try std.testing.expectEqual(et, parsed.?);\n    }\n}\n\ntest \"EventType JSON serialization roundtrip\" {\n    const allocator = std.testing.allocator;\n\n    const event_types = [_]EventType{\n        .created,\n        .updated,\n        .status_changed,\n        .priority_changed,\n        .assignee_changed,\n        .commented,\n        .closed,\n        .reopened,\n        .dependency_added,\n        .dependency_removed,\n        .label_added,\n        .label_removed,\n        .compacted,\n        .deleted,\n        .restored,\n    };\n\n    for (event_types) |et| {\n        var aw: std.io.Writer.Allocating = .init(allocator);\n        defer aw.deinit();\n\n        try std.json.Stringify.value(et, .{}, &aw.writer);\n        const json_str = aw.written();\n\n        const parsed = try std.json.parseFromSlice(EventType, allocator, json_str, .{});\n        defer parsed.deinit();\n\n        try std.testing.expectEqual(et, parsed.value);\n    }\n}\n\n// --- Event Tests ---\n\ntest \"Event.validate accepts valid event\" {\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .created,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    try event.validate();\n}\n\ntest \"Event.validate rejects empty actor\" {\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .created,\n        .actor = \"\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    try std.testing.expectError(EventError.EmptyActor, event.validate());\n}\n\ntest \"Event.validate rejects empty issue_id\" {\n    const event = Event{\n        .id = 1,\n        .issue_id = \"\",\n        .event_type = .created,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    try std.testing.expectError(EventError.EmptyIssueId, event.validate());\n}\n\ntest \"Event.eql compares all fields\" {\n    const event1 = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    const event2 = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    try std.testing.expect(Event.eql(event1, event2));\n}\n\ntest \"Event.eql detects differences\" {\n    const base = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    const diff_id = Event{\n        .id = 2,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, diff_id));\n\n    const diff_event_type = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .priority_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, diff_event_type));\n\n    const diff_old_value = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"in_progress\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, diff_old_value));\n\n    const null_old_value = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n    try std.testing.expect(!Event.eql(base, null_old_value));\n}\n\ntest \"Event JSON serialization roundtrip\" {\n    const allocator = std.testing.allocator;\n\n    const event = Event{\n        .id = 42,\n        .issue_id = \"bd-abc123\",\n        .event_type = .status_changed,\n        .actor = \"alice@example.com\",\n        .old_value = \"open\",\n        .new_value = \"closed\",\n        .created_at = 1706540000,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(event, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Event.eql(event, parsed.value));\n}\n\ntest \"Event JSON serialization with null old_value\" {\n    const allocator = std.testing.allocator;\n\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .created,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = \"initial state\",\n        .created_at = 1706540000,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(event, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Event.eql(event, parsed.value));\n    try std.testing.expect(parsed.value.old_value == null);\n}\n\ntest \"Event JSON serialization with both values null\" {\n    const allocator = std.testing.allocator;\n\n    const event = Event{\n        .id = 1,\n        .issue_id = \"bd-abc123\",\n        .event_type = .deleted,\n        .actor = \"alice@example.com\",\n        .old_value = null,\n        .new_value = null,\n        .created_at = 1706540000,\n    };\n\n    var aw: std.io.Writer.Allocating = .init(allocator);\n    defer aw.deinit();\n\n    try std.json.Stringify.value(event, .{}, &aw.writer);\n    const json_str = aw.written();\n\n    const parsed = try std.json.parseFromSlice(Event, allocator, json_str, .{});\n    defer parsed.deinit();\n\n    try std.testing.expect(Event.eql(event, parsed.value));\n}\n\n// --- Factory Function Tests ---\n\ntest \"Event.issueCreated produces valid event\" {\n    const event = Event.issueCreated(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", event.issue_id);\n    try std.testing.expectEqual(EventType.created, event.event_type);\n    try std.testing.expectEqualStrings(\"alice@example.com\", event.actor);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n    try std.testing.expectEqual(@as(i64, 1706540000), event.created_at);\n    try std.testing.expectEqual(@as(i64, 0), event.id);\n\n    try event.validate();\n}\n\ntest \"Event.statusChange produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.statusChange(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        Status.open,\n        Status.closed,\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.status_changed, event.event_type);\n    try std.testing.expectEqualStrings(\"open\", event.old_value.?);\n    try std.testing.expectEqualStrings(\"closed\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.priorityChange produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.priorityChange(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        Priority.LOW,\n        Priority.HIGH,\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.priority_changed, event.event_type);\n    try std.testing.expectEqualStrings(\"3\", event.old_value.?);\n    try std.testing.expectEqualStrings(\"1\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.assigneeChange produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.assigneeChange(\n        allocator,\n        \"bd-abc123\",\n        \"admin@example.com\",\n        \"alice@example.com\",\n        \"bob@example.com\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.assignee_changed, event.event_type);\n    try std.testing.expectEqualStrings(\"alice@example.com\", event.old_value.?);\n    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.assigneeChange handles null assignees\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.assigneeChange(\n        allocator,\n        \"bd-abc123\",\n        \"admin@example.com\",\n        null,\n        \"bob@example.com\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"bob@example.com\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.labelAdded produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.labelAdded(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"urgent\",\n        1706540000,\n    );\n    defer {\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.label_added, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"urgent\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.labelRemoved produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.labelRemoved(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"wontfix\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.label_removed, event.event_type);\n    try std.testing.expectEqualStrings(\"wontfix\", event.old_value.?);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.dependencyAdded produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.dependencyAdded(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"bd-def456\",\n        1706540000,\n    );\n    defer {\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.dependency_added, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"bd-def456\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.dependencyRemoved produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.dependencyRemoved(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"bd-def456\",\n        1706540000,\n    );\n    defer {\n        if (event.old_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.dependency_removed, event.event_type);\n    try std.testing.expectEqualStrings(\"bd-def456\", event.old_value.?);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueClosed produces valid event\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.issueClosed(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        \"completed\",\n        1706540000,\n    );\n    defer {\n        if (event.new_value) |v| allocator.free(v);\n    }\n\n    try std.testing.expectEqual(EventType.closed, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expectEqualStrings(\"completed\", event.new_value.?);\n\n    try event.validate();\n}\n\ntest \"Event.issueClosed handles null close_reason\" {\n    const allocator = std.testing.allocator;\n\n    const event = try Event.issueClosed(\n        allocator,\n        \"bd-abc123\",\n        \"alice@example.com\",\n        null,\n        1706540000,\n    );\n\n    try std.testing.expectEqual(EventType.closed, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueReopened produces valid event\" {\n    const event = Event.issueReopened(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqual(EventType.reopened, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueDeleted produces valid event\" {\n    const event = Event.issueDeleted(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqual(EventType.deleted, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n\ntest \"Event.issueRestored produces valid event\" {\n    const event = Event.issueRestored(\"bd-abc123\", \"alice@example.com\", 1706540000);\n\n    try std.testing.expectEqual(EventType.restored, event.event_type);\n    try std.testing.expect(event.old_value == null);\n    try std.testing.expect(event.new_value == null);\n\n    try event.validate();\n}\n","structuredPatch":[{"oldStart":24,"oldLines":6,"newStart":24,"newLines":9,"lines":["     compacted,","     deleted,","     restored,","+    // LLM/tool interaction tracking","+    llm_call,","+    tool_call,"," ","     const Self = @This();"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NLtNpn6Nji36TvnUL4fJVD","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the args.zig to add the audit subcommand structure. First, let me find where AuditArgs is defined:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":645,"cache_read_input_tokens":93408,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":645},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2eda3f9c-747a-47c3-b964-6df299dce654"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NLtNpn6Nji36TvnUL4fJVD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015EkVwCfXnxfGBvhypEi6mP","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":475,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":645,"cache_read_input_tokens":93408,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":645},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"bab25cb7-3ce8-4353-aa9e-e210acc430a8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015EkVwCfXnxfGBvhypEi6mP","type":"tool_result","content":"   475→};\n   476→\n   477→/// Audit command arguments.\n   478→pub const AuditArgs = struct {\n   479→    limit: ?u32 = null,\n   480→};\n   481→\n   482→/// Changelog command arguments.\n   483→pub const ChangelogArgs = struct {\n   484→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   485→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   486→    limit: ?u32 = null,\n   487→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   488→};\n   489→\n   490→/// Error policy for export operations.\n   491→pub const ErrorPolicy = enum {\n   492→    strict, // Fail on any error\n   493→    best_effort, // Continue on errors, report at end\n   494→    partial, // Export what we can, skip errors silently\n   495→\n   496→    pub fn fromString(s: []const u8) ?ErrorPolicy {\n   497→        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n   498→        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n   499→        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n   500→        return null;\n   501→    }\n   502→};\n   503→\n   504→/// Orphan handling policy for import operations.\n   505→pub const OrphanPolicy = enum {\n   506→    strict, // Fail if orphans detected\n   507→    resurrect, // Create placeholder parents for orphans\n   508→    skip, // Skip orphaned issues silently\n   509→\n   510→    pub fn fromString(s: []const u8) ?OrphanPolicy {\n   511→        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n   512→        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n   513→        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n   514→        return null;\n   515→    }\n   516→};\n   517→\n   518→/// Sync command arguments.\n   519→pub const SyncArgs = struct {\n   520→    flush_only: bool = false,\n   521→    import_only: bool = false,\n   522→    merge: bool = false,\n   523→    status: bool = false,\n   524→    manifest: bool = false,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"bc26e3b7-51e3-4e63-a524-20228fd3bc0e","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,","numLines":50,"startLine":475,"totalLines":2746}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01V9ba4uuXk9GwYZdoaUDt1Q","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll update the AuditArgs to use subcommands like the other commands that have subcommands (dep, label, comments, etc.):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":916,"cache_read_input_tokens":94053,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":916},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7601ece8-f041-4772-8457-c654ed400fa3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01V9ba4uuXk9GwYZdoaUDt1Q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015ymhNVeAnq65pDb2C5NXdE","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};","new_string":"/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":916,"cache_read_input_tokens":94053,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":916},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d4825028-5430-4825-bfeb-9e17e8c49e5c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015ymhNVeAnq65pDb2C5NXdE","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"818b4d59-f8ca-40db-a360-2f6c729042d4","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};","newString":"/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":474,"oldLines":9,"newStart":474,"newLines":43,"lines":["     id: []const u8,"," };"," ","+/// Audit subcommand variants.","+pub const AuditSubcommand = union(enum) {","+    /// Record an LLM/tool interaction for training data.","+    record: struct {","+        kind: []const u8, // \"llm_call\" or \"tool_call\"","+        issue_id: ?[]const u8 = null, // Optional issue context","+        model: ?[]const u8 = null, // Model name (for llm_call)","+        prompt: ?[]const u8 = null, // Input prompt (for llm_call)","+        response: ?[]const u8 = null, // Output response (for llm_call)","+        tool_name: ?[]const u8 = null, // Tool name (for tool_call)","+        exit_code: ?i32 = null, // Exit code (for tool_call)","+        metadata: ?[]const u8 = null, // Additional JSON metadata","+    },","+    /// Label an audit entry for quality tracking.","+    label: struct {","+        entry_id: i64, // Event ID to label","+        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"","+        reason: ?[]const u8 = null, // Explanation for the label","+    },","+    /// View audit log for a specific issue.","+    log: struct {","+        issue_id: []const u8,","+        limit: ?u32 = null,","+    },","+    /// Summary of audit data over time period.","+    summary: struct {","+        days: u32 = 7, // Number of days to summarize","+    },","+    /// Legacy: show project-wide audit log (default behavior).","+    list: struct {","+        limit: ?u32 = null,","+    },","+};","+"," /// Audit command arguments."," pub const AuditArgs = struct {","-    limit: ?u32 = null,","+    subcommand: AuditSubcommand,"," };"," "," /// Changelog command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VZrzdKfwCq7QWooEnJsAXX","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the parseAuditArgs function in args.zig. Let me find and update it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":679,"cache_read_input_tokens":94969,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":679},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1cdfac6c-3591-4520-afe4-1c6074d78d05"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VZrzdKfwCq7QWooEnJsAXX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018AAD6FmFkuSqM1QPR73pME","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1575,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":679,"cache_read_input_tokens":94969,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":679},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"653a7604-4882-4872-9181-2d6f0e564ae0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018AAD6FmFkuSqM1QPR73pME","type":"tool_result","content":"  1575→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1576→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1577→        }\n  1578→        return error.UnknownSubcommand;\n  1579→    }\n  1580→\n  1581→    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n  1582→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1583→        return .{ .id = id };\n  1584→    }\n  1585→\n  1586→    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n  1587→        var result = AuditArgs{};\n  1588→        while (self.hasNext()) {\n  1589→            if (try self.parseLimitFlag()) |limit| {\n  1590→                result.limit = limit;\n  1591→            } else break;\n  1592→        }\n  1593→        return result;\n  1594→    }\n  1595→\n  1596→    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n  1597→        var result = ChangelogArgs{};\n  1598→        while (self.hasNext()) {\n  1599→            if (self.consumeFlag(null, \"--since\")) {\n  1600→                result.since = self.next() orelse return error.MissingFlagValue;\n  1601→            } else if (self.consumeFlag(null, \"--until\")) {\n  1602→                result.until = self.next() orelse return error.MissingFlagValue;\n  1603→            } else if (try self.parseLimitFlag()) |limit| {\n  1604→                result.limit = limit;\n  1605→            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1606→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1607→            } else break;\n  1608→        }\n  1609→        return result;\n  1610→    }\n  1611→\n  1612→    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n  1613→        var result = SyncArgs{};\n  1614→        while (self.hasNext()) {\n  1615→            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n  1616→                result.flush_only = true;\n  1617→            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n  1618→                result.import_only = true;\n  1619→            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n  1620→                result.merge = true;\n  1621→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n  1622→                result.status = true;\n  1623→            } else if (self.consumeFlag(null, \"--manifest\")) {\n  1624→                result.manifest = true;\n  1625→            } else if (self.consumeFlag(null, \"--error-policy\")) {\n  1626→                const policy_str = self.next() orelse return error.MissingFlagValue;\n  1627→                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n  1628→            } else if (self.consumeFlag(null, \"--orphans\")) {\n  1629→                const policy_str = self.next() orelse return error.MissingFlagValue;\n  1630→                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n  1631→            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n  1632→                result.rename_prefix = true;\n  1633→            } else break;\n  1634→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c7df9516-4156-4fbf-a6e6-9967445c295f","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }","numLines":60,"startLine":1575,"totalLines":2780}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018mdaTRLMYcg4hHV4gsWJp7","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll update the parseAuditArgs function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1271,"cache_read_input_tokens":95648,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1271},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f190436e-a115-44a9-bf76-328d326f2e3e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018mdaTRLMYcg4hHV4gsWJp7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NuEkVP92kVK94WubGSbsc9","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }","new_string":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.position -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1271,"cache_read_input_tokens":95648,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1271},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"663b64e9-664f-4c98-afd6-421d98152b0c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NuEkVP92kVK94WubGSbsc9","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d4af8b34-5cba-4899-859b-f7dbb35a3cb0","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }","newString":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.position -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1584,"oldLines":13,"newStart":1584,"newLines":108,"lines":["     }"," ","     fn parseAuditArgs(self: *Self) ParseError!AuditArgs {","-        var result = AuditArgs{};","-        while (self.hasNext()) {","-            if (try self.parseLimitFlag()) |limit| {","-                result.limit = limit;","-            } else break;","+        // Check for subcommand","+        const subcmd = self.next() orelse {","+            // Default: list with no limit","+            return .{ .subcommand = .{ .list = .{ .limit = null } } };","+        };","+","+        // Handle --limit flag at top level (legacy support)","+        if (std.mem.startsWith(u8, subcmd, \"-\")) {","+            // Put it back and parse as list subcommand with limit","+            self.position -= 1;","+            var limit: ?u32 = null;","+            while (self.hasNext()) {","+                if (try self.parseLimitFlag()) |l| {","+                    limit = l;","+                } else break;","+            }","+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };","         }","-        return result;","+","+        if (std.mem.eql(u8, subcmd, \"record\")) {","+            const kind = self.next() orelse return error.MissingRequiredArgument;","+            var result = AuditSubcommand{ .record = .{ .kind = kind } };","+","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-i\", \"--issue\")) {","+                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-m\", \"--model\")) {","+                    result.record.model = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {","+                    result.record.prompt = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-r\", \"--response\")) {","+                    result.record.response = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {","+                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {","+                    const exit_str = self.next() orelse return error.MissingFlagValue;","+                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;","+                } else if (self.consumeFlag(null, \"--metadata\")) {","+                    result.record.metadata = self.next() orelse return error.MissingFlagValue;","+                } else break;","+            }","+            return .{ .subcommand = result };","+        }","+","+        if (std.mem.eql(u8, subcmd, \"label\")) {","+            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;","+            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;","+            var label_value: ?[]const u8 = null;","+            var reason: ?[]const u8 = null;","+","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-l\", \"--label\")) {","+                    label_value = self.next() orelse return error.MissingFlagValue;","+                } else if (self.consumeFlag(\"-r\", \"--reason\")) {","+                    reason = self.next() orelse return error.MissingFlagValue;","+                } else if (self.peekPositional()) |_| {","+                    if (label_value == null) {","+                        label_value = self.next().?;","+                    } else break;","+                } else break;","+            }","+","+            if (label_value == null) return error.MissingRequiredArgument;","+            return .{ .subcommand = .{ .label = .{","+                .entry_id = entry_id,","+                .label_value = label_value.?,","+                .reason = reason,","+            } } };","+        }","+","+        if (std.mem.eql(u8, subcmd, \"log\")) {","+            const issue_id = self.next() orelse return error.MissingRequiredArgument;","+            var limit: ?u32 = null;","+            while (self.hasNext()) {","+                if (try self.parseLimitFlag()) |l| {","+                    limit = l;","+                } else break;","+            }","+            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };","+        }","+","+        if (std.mem.eql(u8, subcmd, \"summary\")) {","+            var days: u32 = 7;","+            while (self.hasNext()) {","+                if (self.consumeFlag(\"-d\", \"--days\")) {","+                    days = try self.consumeU32() orelse return error.MissingFlagValue;","+                } else break;","+            }","+            return .{ .subcommand = .{ .summary = .{ .days = days } } };","+        }","+","+        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {","+            var limit: ?u32 = null;","+            while (self.hasNext()) {","+                if (try self.parseLimitFlag()) |l| {","+                    limit = l;","+                } else break;","+            }","+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };","+        }","+","+        return error.UnknownSubcommand;","     }"," ","     fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018h9XabUuwVWunFA4iboiAa","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to rewrite the audit.zig file to handle all the subcommands:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1645,"cache_read_input_tokens":96919,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1645},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"21b36ef4-a98b-4bb4-a308-f2632b976f1a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018h9XabUuwVWunFA4iboiAa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ah9nJD4mL4Ddf27HuDJLvL","name":"Write","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","content":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: args.AuditSubcommand.record,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: args.AuditSubcommand.label,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1645,"cache_read_input_tokens":96919,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1645},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"26d6f0e0-cec9-4c39-8169-a70edb6ba0d9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ah9nJD4mL4Ddf27HuDJLvL","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→//! Audit command for beads_zig.\n     2→//!\n     3→//! `bz audit` - Show project-wide audit log (default)\n     4→//! `bz audit record <kind>` - Record LLM/tool interaction\n     5→//! `bz audit label <entry-id> <label>` - Label audit entry\n     6→//! `bz audit log <issue-id>` - View audit log for specific issue\n     7→//! `bz audit summary` - Summary of audit data over time period\n     8→\n     9→const std = @import(\"std\");\n    10→const common = @import(\"common.zig\");\n    11→const args = @import(\"args.zig\");\n    12→const Event = @import(\"../models/event.zig\").Event;\n    13→const EventType = @import(\"../models/event.zig\").EventType;\n    14→\n    15→const CommandContext = common.CommandContext;\n    16→\n    17→pub const AuditError = error{\n    18→    WorkspaceNotInitialized,\n    19→    StorageError,\n    20→    OutOfMemory,\n    21→    InvalidKind,\n    22→    EntryNotFound,\n    23→};\n    24→\n    25→pub const AuditResult = struct {\n    26→    success: bool,\n    27→    events: ?[]const AuditEvent = null,\n    28→    total: ?usize = null,\n    29→    event_id: ?i64 = null,\n    30→    summary: ?AuditSummary = null,\n    31→    message: ?[]const u8 = null,\n    32→\n    33→    pub const AuditEvent = struct {\n    34→        id: i64,\n    35→        issue_id: []const u8,\n    36→        event_type: []const u8,\n    37→        actor: []const u8,\n    38→        created_at: i64,\n    39→        old_value: ?[]const u8 = null,\n    40→        new_value: ?[]const u8 = null,\n    41→    };\n    42→\n    43→    pub const AuditSummary = struct {\n    44→        period_days: u32,\n    45→        total_events: usize,\n    46→        llm_calls: usize,\n    47→        tool_calls: usize,\n    48→        issue_creates: usize,\n    49→        issue_closes: usize,\n    50→        other_events: usize,\n    51→        by_actor: ?[]const ActorCount = null,\n    52→\n    53→        pub const ActorCount = struct {\n    54→            actor: []const u8,\n    55→            count: usize,\n    56→        };\n    57→    };\n    58→};\n    59→\n    60→pub fn run(\n    61→    audit_args: args.AuditArgs,\n    62→    global: args.GlobalOptions,\n    63→    allocator: std.mem.Allocator,\n    64→) !void {\n    65→    switch (audit_args.subcommand) {\n    66→        .record => |record_args| try runRecord(record_args, global, allocator),\n    67→        .label => |label_args| try runLabel(label_args, global, allocator),\n    68→        .log => |log_args| try runLog(log_args, global, allocator),\n    69→        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n    70→        .list => |list_args| try runList(list_args, global, allocator),\n    71→    }\n    72→}\n    73→\n    74→fn runRecord(\n    75→    record_args: args.AuditSubcommand.record,\n    76→    global: args.GlobalOptions,\n    77→    allocator: std.mem.Allocator,\n    78→) !void {\n    79→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    80→        return AuditError.WorkspaceNotInitialized;\n    81→    };\n    82→    defer ctx.deinit();\n    83→\n    84→    // Validate kind\n    85→    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n    86→        .llm_call\n    87→    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n    88→        .tool_call\n    89→    else {\n    90→        if (!global.silent) {\n    91→            if (global.isStructuredOutput()) {\n    92→                try ctx.output.printJson(AuditResult{\n    93→                    .success = false,\n    94→                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n    95→                });\n    96→            } else {\n    97→                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n    98→            }\n    99→        }\n   100→        return AuditError.InvalidKind;\n   101→    };\n   102→\n   103→    const actor = global.actor orelse \"unknown\";\n   104→    const now = std.time.timestamp();\n   105→\n   106→    // Build metadata JSON with all provided fields\n   107→    var metadata_buf: [4096]u8 = undefined;\n   108→    var fbs = std.io.fixedBufferStream(&metadata_buf);\n   109→    const writer = fbs.writer();\n   110→\n   111→    try writer.writeAll(\"{\");\n   112→    var first = true;\n   113→\n   114→    if (record_args.model) |model| {\n   115→        if (!first) try writer.writeAll(\",\");\n   116→        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n   117→        first = false;\n   118→    }\n   119→    if (record_args.prompt) |prompt| {\n   120→        if (!first) try writer.writeAll(\",\");\n   121→        try writer.writeAll(\"\\\"prompt\\\":\");\n   122→        try std.json.stringify(prompt, .{}, writer);\n   123→        first = false;\n   124→    }\n   125→    if (record_args.response) |response| {\n   126→        if (!first) try writer.writeAll(\",\");\n   127→        try writer.writeAll(\"\\\"response\\\":\");\n   128→        try std.json.stringify(response, .{}, writer);\n   129→        first = false;\n   130→    }\n   131→    if (record_args.tool_name) |tool_name| {\n   132→        if (!first) try writer.writeAll(\",\");\n   133→        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n   134→        first = false;\n   135→    }\n   136→    if (record_args.exit_code) |exit_code| {\n   137→        if (!first) try writer.writeAll(\",\");\n   138→        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n   139→        first = false;\n   140→    }\n   141→    if (record_args.metadata) |metadata| {\n   142→        if (!first) try writer.writeAll(\",\");\n   143→        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n   144→        first = false;\n   145→    }\n   146→    try writer.writeAll(\"}\");\n   147→\n   148→    const metadata_json = fbs.getWritten();\n   149→    const new_value = try allocator.dupe(u8, metadata_json);\n   150→    defer allocator.free(new_value);\n   151→\n   152→    const event = Event{\n   153→        .id = 0,\n   154→        .issue_id = record_args.issue_id orelse \"\",\n   155→        .event_type = event_type,\n   156→        .actor = actor,\n   157→        .old_value = null,\n   158→        .new_value = new_value,\n   159→        .created_at = now,\n   160→    };\n   161→\n   162→    const event_id = try ctx.event_store.append(event);\n   163→\n   164→    if (global.isStructuredOutput()) {\n   165→        try ctx.output.printJson(AuditResult{\n   166→            .success = true,\n   167→            .event_id = event_id,\n   168→            .message = \"Audit entry recorded\",\n   169→        });\n   170→    } else if (!global.quiet) {\n   171→        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n   172→    }\n   173→}\n   174→\n   175→fn runLabel(\n   176→    label_args: args.AuditSubcommand.label,\n   177→    global: args.GlobalOptions,\n   178→    allocator: std.mem.Allocator,\n   179→) !void {\n   180→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   181→        return AuditError.WorkspaceNotInitialized;\n   182→    };\n   183→    defer ctx.deinit();\n   184→\n   185→    // Record a label event referencing the original entry\n   186→    const actor = global.actor orelse \"unknown\";\n   187→    const now = std.time.timestamp();\n   188→\n   189→    // Build the label metadata\n   190→    var metadata_buf: [1024]u8 = undefined;\n   191→    var fbs = std.io.fixedBufferStream(&metadata_buf);\n   192→    const writer = fbs.writer();\n   193→\n   194→    try writer.writeAll(\"{\");\n   195→    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n   196→    if (label_args.reason) |reason| {\n   197→        try writer.writeAll(\",\\\"reason\\\":\");\n   198→        try std.json.stringify(reason, .{}, writer);\n   199→    }\n   200→    try writer.writeAll(\"}\");\n   201→\n   202→    const metadata_json = fbs.getWritten();\n   203→    const new_value = try allocator.dupe(u8, metadata_json);\n   204→    defer allocator.free(new_value);\n   205→\n   206→    // Use 'updated' event type to represent a label action on an existing entry\n   207→    const event = Event{\n   208→        .id = 0,\n   209→        .issue_id = \"\", // Labels are not issue-specific\n   210→        .event_type = .updated,\n   211→        .actor = actor,\n   212→        .old_value = null,\n   213→        .new_value = new_value,\n   214→        .created_at = now,\n   215→    };\n   216→\n   217→    const event_id = try ctx.event_store.append(event);\n   218→\n   219→    if (global.isStructuredOutput()) {\n   220→        try ctx.output.printJson(AuditResult{\n   221→            .success = true,\n   222→            .event_id = event_id,\n   223→            .message = \"Label applied to audit entry\",\n   224→        });\n   225→    } else if (!global.quiet) {\n   226→        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n   227→    }\n   228→}\n   229→\n   230→fn runLog(\n   231→    log_args: args.AuditSubcommand.log,\n   232→    global: args.GlobalOptions,\n   233→    allocator: std.mem.Allocator,\n   234→) !void {\n   235→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   236→        return AuditError.WorkspaceNotInitialized;\n   237→    };\n   238→    defer ctx.deinit();\n   239→\n   240→    const limit = log_args.limit orelse 100;\n   241→\n   242→    // Query events for the specific issue from the event store\n   243→    const events = try ctx.event_store.queryEvents(.{\n   244→        .issue_id = log_args.issue_id,\n   245→        .limit = limit,\n   246→    });\n   247→    defer ctx.event_store.freeEvents(events);\n   248→\n   249→    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n   250→    defer audit_events.deinit(allocator);\n   251→\n   252→    for (events) |event| {\n   253→        try audit_events.append(allocator, .{\n   254→            .id = event.id,\n   255→            .issue_id = event.issue_id,\n   256→            .event_type = event.event_type.toString(),\n   257→            .actor = event.actor,\n   258→            .created_at = event.created_at,\n   259→            .old_value = event.old_value,\n   260→            .new_value = event.new_value,\n   261→        });\n   262→    }\n   263→\n   264→    // Sort by timestamp descending\n   265→    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n   266→        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n   267→            return a.created_at > b.created_at;\n   268→        }\n   269→    }.lessThan);\n   270→\n   271→    if (global.isStructuredOutput()) {\n   272→        try ctx.output.printJson(AuditResult{\n   273→            .success = true,\n   274→            .events = audit_events.items,\n   275→            .total = audit_events.items.len,\n   276→        });\n   277→    } else if (global.quiet) {\n   278→        for (audit_events.items) |event| {\n   279→            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n   280→        }\n   281→    } else {\n   282→        if (audit_events.items.len == 0) {\n   283→            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n   284→        } else {\n   285→            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n   286→            try ctx.output.print(\"\\n\", .{});\n   287→\n   288→            for (audit_events.items) |event| {\n   289→                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n   290→                    event.id,\n   291→                    event.created_at,\n   292→                    event.actor,\n   293→                    event.event_type,\n   294→                });\n   295→                if (event.new_value) |v| {\n   296→                    if (v.len > 0 and v.len < 200) {\n   297→                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n   298→                    }\n   299→                }\n   300→            }\n   301→        }\n   302→    }\n   303→}\n   304→\n   305→fn runSummary(\n   306→    summary_args: args.AuditSubcommand.summary,\n   307→    global: args.GlobalOptions,\n   308→    allocator: std.mem.Allocator,\n   309→) !void {\n   310→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   311→        return AuditError.WorkspaceNotInitialized;\n   312→    };\n   313→    defer ctx.deinit();\n   314→\n   315→    const now = std.time.timestamp();\n   316→    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n   317→\n   318→    // Query all events in the time period\n   319→    const events = try ctx.event_store.queryEvents(.{ .since = since });\n   320→    defer ctx.event_store.freeEvents(events);\n   321→\n   322→    // Count by type\n   323→    var llm_calls: usize = 0;\n   324→    var tool_calls: usize = 0;\n   325→    var issue_creates: usize = 0;\n   326→    var issue_closes: usize = 0;\n   327→    var other_events: usize = 0;\n   328→\n   329→    // Count by actor\n   330→    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n   331→    defer actor_counts.deinit(allocator);\n   332→\n   333→    for (events) |event| {\n   334→        switch (event.event_type) {\n   335→            .llm_call => llm_calls += 1,\n   336→            .tool_call => tool_calls += 1,\n   337→            .created => issue_creates += 1,\n   338→            .closed => issue_closes += 1,\n   339→            else => other_events += 1,\n   340→        }\n   341→\n   342→        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n   343→        entry.value_ptr.* += 1;\n   344→    }\n   345→\n   346→    // Convert actor counts to array\n   347→    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n   348→    defer actor_list.deinit(allocator);\n   349→\n   350→    var it = actor_counts.iterator();\n   351→    while (it.next()) |entry| {\n   352→        try actor_list.append(allocator, .{\n   353→            .actor = entry.key_ptr.*,\n   354→            .count = entry.value_ptr.*,\n   355→        });\n   356→    }\n   357→\n   358→    // Sort by count descending\n   359→    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n   360→        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n   361→            return a.count > b.count;\n   362→        }\n   363→    }.lessThan);\n   364→\n   365→    const summary = AuditResult.AuditSummary{\n   366→        .period_days = summary_args.days,\n   367→        .total_events = events.len,\n   368→        .llm_calls = llm_calls,\n   369→        .tool_calls = tool_calls,\n   370→        .issue_creates = issue_creates,\n   371→        .issue_closes = issue_closes,\n   372→        .other_events = other_events,\n   373→        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n   374→    };\n   375→\n   376→    if (global.isStructuredOutput()) {\n   377→        try ctx.output.printJson(AuditResult{\n   378→            .success = true,\n   379→            .summary = summary,\n   380→        });\n   381→    } else if (!global.quiet) {\n   382→        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n   383→        try ctx.output.print(\"\\n\", .{});\n   384→        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n   385→        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n   386→        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n   387→        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n   388→        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n   389→        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n   390→\n   391→        if (actor_list.items.len > 0) {\n   392→            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n   393→            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n   394→                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n   395→            }\n   396→        }\n   397→    }\n   398→}\n   399→\n   400→fn runList(\n   401→    list_args: args.AuditSubcommand.list,\n   402→    global: args.GlobalOptions,\n   403→    allocator: std.mem.Allocator,\n   404→) !void {\n   405→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   406→        return AuditError.WorkspaceNotInitialized;\n   407→    };\n   408→    defer ctx.deinit();\n   409→\n   410→    const limit = list_args.limit orelse 100;\n   411→\n   412→    // Build synthetic audit log from all issues\n   413→    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n   414→    defer events.deinit(allocator);\n   415→\n   416→    for (ctx.store.issues.items) |issue| {\n   417→        // Created event\n   418→        try events.append(allocator, .{\n   419→            .id = 0,\n   420→            .issue_id = issue.id,\n   421→            .event_type = \"created\",\n   422→            .actor = issue.created_by orelse \"unknown\",\n   423→            .created_at = issue.created_at.value,\n   424→        });\n   425→\n   426→        // Closed event\n   427→        if (issue.closed_at.value) |closed_ts| {\n   428→            try events.append(allocator, .{\n   429→                .id = 0,\n   430→                .issue_id = issue.id,\n   431→                .event_type = \"closed\",\n   432→                .actor = \"unknown\",\n   433→                .created_at = closed_ts,\n   434→            });\n   435→        }\n   436→\n   437→        // If tombstoned\n   438→        if (issue.status.eql(.tombstone)) {\n   439→            try events.append(allocator, .{\n   440→                .id = 0,\n   441→                .issue_id = issue.id,\n   442→                .event_type = \"deleted\",\n   443→                .actor = \"unknown\",\n   444→                .created_at = issue.updated_at.value,\n   445→            });\n   446→        }\n   447→    }\n   448→\n   449→    // Sort by timestamp descending (most recent first)\n   450→    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n   451→        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n   452→            return a.created_at > b.created_at;\n   453→        }\n   454→    }.lessThan);\n   455→\n   456→    // Apply limit\n   457→    const display_count = @min(events.items.len, limit);\n   458→    const display_events = events.items[0..display_count];\n   459→\n   460→    if (global.isStructuredOutput()) {\n   461→        try ctx.output.printJson(AuditResult{\n   462→            .success = true,\n   463→            .events = display_events,\n   464→            .total = events.items.len,\n   465→        });\n   466→    } else if (global.quiet) {\n   467→        for (display_events) |event| {\n   468→            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n   469→        }\n   470→    } else {\n   471→        if (display_events.len == 0) {\n   472→            try ctx.output.info(\"No events found\", .{});\n   473→        } else {\n   474→            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n   475→            try ctx.output.print(\"\\n\", .{});\n   476→\n   477→            for (display_events) |event| {\n   478→                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n   479→                    event.created_at,\n   480→                    event.issue_id,\n   481→                    event.actor,\n   482→                    event.event_type,\n   483→                });\n   484→            }\n   485→\n   486→            if (events.items.len > display_count) {\n   487→                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n   488→                    events.items.len - display_count,\n   489→                });\n   490→            }\n   491→        }\n   492→    }\n   493→}\n   494→\n   495→// --- Tests ---\n   496→\n   497→test \"AuditError enum exists\" {\n   498→    const err: AuditError = AuditError.WorkspaceNotInitialized;\n   499→    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n   500→}\n   501→\n   502→test \"AuditResult struct works\" {\n   503→    const result = AuditResult{\n   504→        .success = true,\n   505→        .total = 10,\n   506→    };\n   507→    try std.testing.expect(result.success);\n   508→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   509→}\n   510→\n   511→test \"run detects uninitialized workspace\" {\n   512→    const allocator = std.testing.allocator;\n   513→\n   514→    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n   515→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   516→\n   517→    const result = run(audit_args, global, allocator);\n   518→    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n   519→}\n   520→\n   521→test \"AuditSubcommand record parses correctly\" {\n   522→    const allocator = std.testing.allocator;\n   523→    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n   524→    var parser = args.ArgParser.init(allocator, &cmd_args);\n   525→    const result = parser.parse() catch unreachable;\n   526→    defer result.deinit(allocator);\n   527→\n   528→    switch (result.command) {\n   529→        .audit => |a| {\n   530→            switch (a.subcommand) {\n   531→                .record => |r| {\n   532→                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n   533→                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n   534→                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n   535→                },\n   536→                else => try std.testing.expect(false),\n   537→            }\n   538→        },\n   539→        else => try std.testing.expect(false),\n   540→    }\n   541→}\n   542→\n   543→test \"AuditSubcommand summary parses days\" {\n   544→    const allocator = std.testing.allocator;\n   545→    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n   546→    var parser = args.ArgParser.init(allocator, &cmd_args);\n   547→    const result = parser.parse() catch unreachable;\n   548→    defer result.deinit(allocator);\n   549→\n   550→    switch (result.command) {\n   551→        .audit => |a| {\n   552→            switch (a.subcommand) {\n   553→                .summary => |s| {\n   554→                    try std.testing.expectEqual(@as(u32, 30), s.days);\n   555→                },\n   556→                else => try std.testing.expect(false),\n   557→            }\n   558→        },\n   559→        else => try std.testing.expect(false),\n   560→    }\n   561→}\n   562→\n   563→test \"AuditSubcommand list is default\" {\n   564→    const allocator = std.testing.allocator;\n   565→    const cmd_args = [_][]const u8{\"audit\"};\n   566→    var parser = args.ArgParser.init(allocator, &cmd_args);\n   567→    const result = parser.parse() catch unreachable;\n   568→    defer result.deinit(allocator);\n   569→\n   570→    switch (result.command) {\n   571→        .audit => |a| {\n   572→            switch (a.subcommand) {\n   573→                .list => {},\n   574→                else => try std.testing.expect(false),\n   575→            }\n   576→        },\n   577→        else => try std.testing.expect(false),\n   578→    }\n   579→}\n   580→"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"79a969c9-ff46-4dbc-b695-88c5924b3607","tool_use_result":{"type":"update","filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","content":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: args.AuditSubcommand.record,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: args.AuditSubcommand.label,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":1,"oldLines":10,"newStart":1,"newLines":16,"lines":[" //! Audit command for beads_zig."," //!","-//! `bz audit [--limit N]` - Show project-wide audit log","+//! `bz audit` - Show project-wide audit log (default)","+//! `bz audit record <kind>` - Record LLM/tool interaction","+//! `bz audit label <entry-id> <label>` - Label audit entry","+//! `bz audit log <issue-id>` - View audit log for specific issue","+//! `bz audit summary` - Summary of audit data over time period"," "," const std = @import(\"std\");"," const common = @import(\"common.zig\");"," const args = @import(\"args.zig\");","+const Event = @import(\"../models/event.zig\").Event;","+const EventType = @import(\"../models/event.zig\").EventType;"," "," const CommandContext = common.CommandContext;"," "]},{"oldStart":12,"oldLines":20,"newStart":18,"newLines":43,"lines":["     WorkspaceNotInitialized,","     StorageError,","     OutOfMemory,","+    InvalidKind,","+    EntryNotFound,"," };"," "," pub const AuditResult = struct {","     success: bool,","     events: ?[]const AuditEvent = null,","     total: ?usize = null,","+    event_id: ?i64 = null,","+    summary: ?AuditSummary = null,","     message: ?[]const u8 = null,"," ","     pub const AuditEvent = struct {","+        id: i64,","         issue_id: []const u8,","         event_type: []const u8,","         actor: []const u8,","         created_at: i64,","+        old_value: ?[]const u8 = null,","+        new_value: ?[]const u8 = null,","     };","+","+    pub const AuditSummary = struct {","+        period_days: u32,","+        total_events: usize,","+        llm_calls: usize,","+        tool_calls: usize,","+        issue_creates: usize,","+        issue_closes: usize,","+        other_events: usize,","+        by_actor: ?[]const ActorCount = null,","+","+        pub const ActorCount = struct {","+            actor: []const u8,","+            count: usize,","+        };","+    };"," };"," "," pub fn run("]},{"oldStart":33,"oldLines":13,"newStart":62,"newLines":353,"lines":["     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {","+    switch (audit_args.subcommand) {","+        .record => |record_args| try runRecord(record_args, global, allocator),","+        .label => |label_args| try runLabel(label_args, global, allocator),","+        .log => |log_args| try runLog(log_args, global, allocator),","+        .summary => |summary_args| try runSummary(summary_args, global, allocator),","+        .list => |list_args| try runList(list_args, global, allocator),","+    }","+}","+","+fn runRecord(","+    record_args: args.AuditSubcommand.record,","+    global: args.GlobalOptions,","+    allocator: std.mem.Allocator,","+) !void {","     var ctx = (try CommandContext.init(allocator, global)) orelse {","         return AuditError.WorkspaceNotInitialized;","     };","     defer ctx.deinit();"," ","-    const limit = audit_args.limit orelse 100;","+    // Validate kind","+    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))","+        .llm_call","+    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))","+        .tool_call","+    else {","+        if (!global.silent) {","+            if (global.isStructuredOutput()) {","+                try ctx.output.printJson(AuditResult{","+                    .success = false,","+                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",","+                });","+            } else {","+                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});","+            }","+        }","+        return AuditError.InvalidKind;","+    };"," ","+    const actor = global.actor orelse \"unknown\";","+    const now = std.time.timestamp();","+","+    // Build metadata JSON with all provided fields","+    var metadata_buf: [4096]u8 = undefined;","+    var fbs = std.io.fixedBufferStream(&metadata_buf);","+    const writer = fbs.writer();","+","+    try writer.writeAll(\"{\");","+    var first = true;","+","+    if (record_args.model) |model| {","+        if (!first) try writer.writeAll(\",\");","+        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});","+        first = false;","+    }","+    if (record_args.prompt) |prompt| {","+        if (!first) try writer.writeAll(\",\");","+        try writer.writeAll(\"\\\"prompt\\\":\");","+        try std.json.stringify(prompt, .{}, writer);","+        first = false;","+    }","+    if (record_args.response) |response| {","+        if (!first) try writer.writeAll(\",\");","+        try writer.writeAll(\"\\\"response\\\":\");","+        try std.json.stringify(response, .{}, writer);","+        first = false;","+    }","+    if (record_args.tool_name) |tool_name| {","+        if (!first) try writer.writeAll(\",\");","+        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});","+        first = false;","+    }","+    if (record_args.exit_code) |exit_code| {","+        if (!first) try writer.writeAll(\",\");","+        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});","+        first = false;","+    }","+    if (record_args.metadata) |metadata| {","+        if (!first) try writer.writeAll(\",\");","+        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});","+        first = false;","+    }","+    try writer.writeAll(\"}\");","+","+    const metadata_json = fbs.getWritten();","+    const new_value = try allocator.dupe(u8, metadata_json);","+    defer allocator.free(new_value);","+","+    const event = Event{","+        .id = 0,","+        .issue_id = record_args.issue_id orelse \"\",","+        .event_type = event_type,","+        .actor = actor,","+        .old_value = null,","+        .new_value = new_value,","+        .created_at = now,","+    };","+","+    const event_id = try ctx.event_store.append(event);","+","+    if (global.isStructuredOutput()) {","+        try ctx.output.printJson(AuditResult{","+            .success = true,","+            .event_id = event_id,","+            .message = \"Audit entry recorded\",","+        });","+    } else if (!global.quiet) {","+        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});","+    }","+}","+","+fn runLabel(","+    label_args: args.AuditSubcommand.label,","+    global: args.GlobalOptions,","+    allocator: std.mem.Allocator,","+) !void {","+    var ctx = (try CommandContext.init(allocator, global)) orelse {","+        return AuditError.WorkspaceNotInitialized;","+    };","+    defer ctx.deinit();","+","+    // Record a label event referencing the original entry","+    const actor = global.actor orelse \"unknown\";","+    const now = std.time.timestamp();","+","+    // Build the label metadata","+    var metadata_buf: [1024]u8 = undefined;","+    var fbs = std.io.fixedBufferStream(&metadata_buf);","+    const writer = fbs.writer();","+","+    try writer.writeAll(\"{\");","+    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });","+    if (label_args.reason) |reason| {","+        try writer.writeAll(\",\\\"reason\\\":\");","+        try std.json.stringify(reason, .{}, writer);","+    }","+    try writer.writeAll(\"}\");","+","+    const metadata_json = fbs.getWritten();","+    const new_value = try allocator.dupe(u8, metadata_json);","+    defer allocator.free(new_value);","+","+    // Use 'updated' event type to represent a label action on an existing entry","+    const event = Event{","+        .id = 0,","+        .issue_id = \"\", // Labels are not issue-specific","+        .event_type = .updated,","+        .actor = actor,","+        .old_value = null,","+        .new_value = new_value,","+        .created_at = now,","+    };","+","+    const event_id = try ctx.event_store.append(event);","+","+    if (global.isStructuredOutput()) {","+        try ctx.output.printJson(AuditResult{","+            .success = true,","+            .event_id = event_id,","+            .message = \"Label applied to audit entry\",","+        });","+    } else if (!global.quiet) {","+        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });","+    }","+}","+","+fn runLog(","+    log_args: args.AuditSubcommand.log,","+    global: args.GlobalOptions,","+    allocator: std.mem.Allocator,","+) !void {","+    var ctx = (try CommandContext.init(allocator, global)) orelse {","+        return AuditError.WorkspaceNotInitialized;","+    };","+    defer ctx.deinit();","+","+    const limit = log_args.limit orelse 100;","+","+    // Query events for the specific issue from the event store","+    const events = try ctx.event_store.queryEvents(.{","+        .issue_id = log_args.issue_id,","+        .limit = limit,","+    });","+    defer ctx.event_store.freeEvents(events);","+","+    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};","+    defer audit_events.deinit(allocator);","+","+    for (events) |event| {","+        try audit_events.append(allocator, .{","+            .id = event.id,","+            .issue_id = event.issue_id,","+            .event_type = event.event_type.toString(),","+            .actor = event.actor,","+            .created_at = event.created_at,","+            .old_value = event.old_value,","+            .new_value = event.new_value,","+        });","+    }","+","+    // Sort by timestamp descending","+    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {","+        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {","+            return a.created_at > b.created_at;","+        }","+    }.lessThan);","+","+    if (global.isStructuredOutput()) {","+        try ctx.output.printJson(AuditResult{","+            .success = true,","+            .events = audit_events.items,","+            .total = audit_events.items.len,","+        });","+    } else if (global.quiet) {","+        for (audit_events.items) |event| {","+            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });","+        }","+    } else {","+        if (audit_events.items.len == 0) {","+            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});","+        } else {","+            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });","+            try ctx.output.print(\"\\n\", .{});","+","+            for (audit_events.items) |event| {","+                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{","+                    event.id,","+                    event.created_at,","+                    event.actor,","+                    event.event_type,","+                });","+                if (event.new_value) |v| {","+                    if (v.len > 0 and v.len < 200) {","+                        try ctx.output.print(\"      -> {s}\\n\", .{v});","+                    }","+                }","+            }","+        }","+    }","+}","+","+fn runSummary(","+    summary_args: args.AuditSubcommand.summary,","+    global: args.GlobalOptions,","+    allocator: std.mem.Allocator,","+) !void {","+    var ctx = (try CommandContext.init(allocator, global)) orelse {","+        return AuditError.WorkspaceNotInitialized;","+    };","+    defer ctx.deinit();","+","+    const now = std.time.timestamp();","+    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;","+","+    // Query all events in the time period","+    const events = try ctx.event_store.queryEvents(.{ .since = since });","+    defer ctx.event_store.freeEvents(events);","+","+    // Count by type","+    var llm_calls: usize = 0;","+    var tool_calls: usize = 0;","+    var issue_creates: usize = 0;","+    var issue_closes: usize = 0;","+    var other_events: usize = 0;","+","+    // Count by actor","+    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};","+    defer actor_counts.deinit(allocator);","+","+    for (events) |event| {","+        switch (event.event_type) {","+            .llm_call => llm_calls += 1,","+            .tool_call => tool_calls += 1,","+            .created => issue_creates += 1,","+            .closed => issue_closes += 1,","+            else => other_events += 1,","+        }","+","+        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);","+        entry.value_ptr.* += 1;","+    }","+","+    // Convert actor counts to array","+    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};","+    defer actor_list.deinit(allocator);","+","+    var it = actor_counts.iterator();","+    while (it.next()) |entry| {","+        try actor_list.append(allocator, .{","+            .actor = entry.key_ptr.*,","+            .count = entry.value_ptr.*,","+        });","+    }","+","+    // Sort by count descending","+    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {","+        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {","+            return a.count > b.count;","+        }","+    }.lessThan);","+","+    const summary = AuditResult.AuditSummary{","+        .period_days = summary_args.days,","+        .total_events = events.len,","+        .llm_calls = llm_calls,","+        .tool_calls = tool_calls,","+        .issue_creates = issue_creates,","+        .issue_closes = issue_closes,","+        .other_events = other_events,","+        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,","+    };","+","+    if (global.isStructuredOutput()) {","+        try ctx.output.printJson(AuditResult{","+            .success = true,","+            .summary = summary,","+        });","+    } else if (!global.quiet) {","+        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});","+        try ctx.output.print(\"\\n\", .{});","+        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});","+        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});","+        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});","+        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});","+        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});","+        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});","+","+        if (actor_list.items.len > 0) {","+            try ctx.output.print(\"\\nBy Actor:\\n\", .{});","+            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {","+                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });","+            }","+        }","+    }","+}","+","+fn runList(","+    list_args: args.AuditSubcommand.list,","+    global: args.GlobalOptions,","+    allocator: std.mem.Allocator,","+) !void {","+    var ctx = (try CommandContext.init(allocator, global)) orelse {","+        return AuditError.WorkspaceNotInitialized;","+    };","+    defer ctx.deinit();","+","+    const limit = list_args.limit orelse 100;","+","     // Build synthetic audit log from all issues","     var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};","     defer events.deinit(allocator);"]},{"oldStart":47,"oldLines":6,"newStart":416,"newLines":7,"lines":["     for (ctx.store.issues.items) |issue| {","         // Created event","         try events.append(allocator, .{","+            .id = 0,","             .issue_id = issue.id,","             .event_type = \"created\",","             .actor = issue.created_by orelse \"unknown\","]},{"oldStart":56,"oldLines":6,"newStart":426,"newLines":7,"lines":["         // Closed event","         if (issue.closed_at.value) |closed_ts| {","             try events.append(allocator, .{","+                .id = 0,","                 .issue_id = issue.id,","                 .event_type = \"closed\",","                 .actor = \"unknown\","]},{"oldStart":66,"oldLines":6,"newStart":437,"newLines":7,"lines":["         // If tombstoned","         if (issue.status.eql(.tombstone)) {","             try events.append(allocator, .{","+                .id = 0,","                 .issue_id = issue.id,","                 .event_type = \"deleted\",","                 .actor = \"unknown\","]},{"oldStart":139,"oldLines":9,"newStart":511,"newLines":69,"lines":[" test \"run detects uninitialized workspace\" {","     const allocator = std.testing.allocator;"," ","-    const audit_args = args.AuditArgs{};","+    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };","     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };"," ","     const result = run(audit_args, global, allocator);","     try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);"," }","+","+test \"AuditSubcommand record parses correctly\" {","+    const allocator = std.testing.allocator;","+    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };","+    var parser = args.ArgParser.init(allocator, &cmd_args);","+    const result = parser.parse() catch unreachable;","+    defer result.deinit(allocator);","+","+    switch (result.command) {","+        .audit => |a| {","+            switch (a.subcommand) {","+                .record => |r| {","+                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);","+                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);","+                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);","+                },","+                else => try std.testing.expect(false),","+            }","+        },","+        else => try std.testing.expect(false),","+    }","+}","+","+test \"AuditSubcommand summary parses days\" {","+    const allocator = std.testing.allocator;","+    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };","+    var parser = args.ArgParser.init(allocator, &cmd_args);","+    const result = parser.parse() catch unreachable;","+    defer result.deinit(allocator);","+","+    switch (result.command) {","+        .audit => |a| {","+            switch (a.subcommand) {","+                .summary => |s| {","+                    try std.testing.expectEqual(@as(u32, 30), s.days);","+                },","+                else => try std.testing.expect(false),","+            }","+        },","+        else => try std.testing.expect(false),","+    }","+}","+","+test \"AuditSubcommand list is default\" {","+    const allocator = std.testing.allocator;","+    const cmd_args = [_][]const u8{\"audit\"};","+    var parser = args.ArgParser.init(allocator, &cmd_args);","+    const result = parser.parse() catch unreachable;","+    defer result.deinit(allocator);","+","+    switch (result.command) {","+        .audit => |a| {","+            switch (a.subcommand) {","+                .list => {},","+                else => try std.testing.expect(false),","+            }","+        },","+        else => try std.testing.expect(false),","+    }","+}"]}],"originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit [--limit N]` - Show project-wide audit log\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = audit_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n"}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UiDx8kYXHB2SXnMdbUNRPv","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to export the AuditSubcommand from mod.zig. Let me update mod.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14503,"cache_read_input_tokens":98564,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14503},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0a1a9893-18da-48db-822e-4be2b3cd06f1"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UiDx8kYXHB2SXnMdbUNRPv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NVuFX36iPx7AoBEMPQUbQ1","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","offset":148,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14503,"cache_read_input_tokens":98564,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14503},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"efa90a38-08d3-46b2-80d2-f210ac328fd5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NVuFX36iPx7AoBEMPQUbQ1","type":"tool_result","content":"   148→pub const runHistory = history.run;\n   149→\n   150→pub const AuditError = audit.AuditError;\n   151→pub const AuditResult = audit.AuditResult;\n   152→pub const runAudit = audit.run;\n   153→\n   154→pub const ChangelogError = changelog.ChangelogError;\n   155→pub const ChangelogResult = changelog.ChangelogResult;\n   156→pub const runChangelog = changelog.run;\n   157→pub const ChangelogArgs = args.ChangelogArgs;\n   158→\n   159→pub const InfoError = info.InfoError;\n   160→pub const InfoResult = info.InfoResult;\n   161→pub const runInfo = info.run;\n   162→\n   163→pub const StatsError = stats.StatsError;\n   164→pub const StatsResult = stats.StatsResult;\n   165→pub const runStats = stats.run;\n   166→\n   167→pub const DoctorError = doctor.DoctorError;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a03b1a6c-0aa2-4816-a2a8-f2434ca805f3","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","content":"pub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;","numLines":20,"startLine":148,"totalLines":226}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BUYpRjeRZoYopYWpPdf1Lw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BKpGRKkDcSrqYcwfeRQLXs","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","old_string":"pub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;","new_string":"pub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\npub const AuditArgs = args.AuditArgs;\npub const AuditSubcommand = args.AuditSubcommand;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":482,"cache_read_input_tokens":113067,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":482},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5c06cded-d179-4614-9ef3-acf059fa1c63"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BKpGRKkDcSrqYcwfeRQLXs","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"651019f7-120f-44d5-a5e6-cfdb3966f360","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","oldString":"pub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;","newString":"pub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\npub const AuditArgs = args.AuditArgs;\npub const AuditSubcommand = args.AuditSubcommand;","originalFile":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const backup = @import(\"backup.zig\");\npub const BackupError = backup.BackupError;\npub const BackupResult = backup.BackupResult;\npub const runBackup = backup.run;\npub const BackupArgs = args.BackupArgs;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\npub const WhereError = where.WhereError;\npub const WhereResult = where.WhereResult;\npub const runWhere = where.run;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","structuredPatch":[{"oldStart":150,"oldLines":6,"newStart":150,"newLines":8,"lines":[" pub const AuditError = audit.AuditError;"," pub const AuditResult = audit.AuditResult;"," pub const runAudit = audit.run;","+pub const AuditArgs = args.AuditArgs;","+pub const AuditSubcommand = args.AuditSubcommand;"," "," pub const ChangelogError = changelog.ChangelogError;"," pub const ChangelogResult = changelog.ChangelogResult;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012WFHBwWzWyoxPQmEDhjDQN","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the main.zig dispatch to handle the new audit errors. Let me check it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":283,"cache_read_input_tokens":113549,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":283},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c7264154-6dd4-4f51-8c95-15b6b987ffa6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012WFHBwWzWyoxPQmEDhjDQN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NMAnHpXuATbehzShuvVpUp","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig","offset":255,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":283,"cache_read_input_tokens":113549,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":283},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4f40ad7f-14d0-49e3-a0c2-031e47f66440"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NMAnHpXuATbehzShuvVpUp","type":"tool_result","content":"   255→                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n   256→                else => return err,\n   257→            };\n   258→        },\n   259→        .audit => |audit_args| {\n   260→            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n   261→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   262→                else => return err,\n   263→            };\n   264→        },\n   265→        .changelog => |changelog_args| {\n   266→            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n   267→                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n   268→                else => return err,\n   269→            };\n   270→        },\n   271→        .query => |query_args| {\n   272→            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n   273→                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n   274→                else => return err,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6b833d02-d9ee-4cb6-a704-ab813a250e93","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","content":"                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,","numLines":20,"startLine":255,"totalLines":316}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HSsJEdF84MrXas9xSCp2pX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TfW7w3HwpNedLg7uxredRE","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/main.zig","old_string":"        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },","new_string":"        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":582,"cache_read_input_tokens":113832,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":582},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3bc7068f-943a-4c29-9b1f-8f2c7cdc77d7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TfW7w3HwpNedLg7uxredRE","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/main.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"781866e5-0dba-468d-80d2-a36f625d39d1","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","oldString":"        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },","newString":"        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },","originalFile":"//! beads_zig CLI entry point.\n//!\n//! Binary name: bz (beads-zig)\n\nconst std = @import(\"std\");\nconst beads_zig = @import(\"beads_zig\");\nconst cli = beads_zig.cli;\nconst output = beads_zig.output;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    run(allocator) catch |err| {\n        const stderr = std.fs.File.stderr();\n        stderr.writeAll(\"error: \") catch {};\n        stderr.writeAll(@errorName(err)) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        std.process.exit(1);\n    };\n}\n\nfn run(allocator: std.mem.Allocator) !void {\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    // Skip program name\n    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n\n    var parser = cli.ArgParser.init(allocator, cmd_args);\n    var result = parser.parse() catch |err| {\n        return handleParseError(err, allocator);\n    };\n    defer result.deinit(allocator);\n\n    try dispatch(result, allocator);\n}\n\nfn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    switch (result.command) {\n        .init => |init_args| {\n            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n                error.AlreadyInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .create => |create_args| {\n            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .q => |quick_args| {\n            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .list => |list_args| {\n            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .show => |show_args| {\n            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .update => |update_args| {\n            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .close => |close_args| {\n            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .reopen => |reopen_args| {\n            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .delete => |delete_args| {\n            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .add_batch => |batch_args| {\n            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .import_cmd => |import_args| {\n            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .ready => |ready_args| {\n            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .blocked => |blocked_args| {\n            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .dep => |dep_args| {\n            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .graph => |graph_args| {\n            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .epic => |epic_args| {\n            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .backup => |backup_args| {\n            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .orphans => |orphans_args| {\n            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .lint => |lint_args| {\n            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .label => |label_args| {\n            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .comments => |comments_args| {\n            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .history => |history_args| {\n            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .where => {\n            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n    }\n    std.process.exit(1);\n}\n\ntest \"library imports compile\" {\n    // Verify all modules are accessible\n    _ = beads_zig.cli;\n    _ = beads_zig.storage;\n    _ = beads_zig.models;\n    _ = beads_zig.sync;\n    _ = beads_zig.id;\n    _ = beads_zig.config;\n    _ = beads_zig.output;\n}\n","structuredPatch":[{"oldStart":258,"oldLines":7,"newStart":258,"newLines":7,"lines":["         },","         .audit => |audit_args| {","             cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {","-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),","+                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),","                 else => return err,","             };","         },"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016zbwMsirCGdLDP79SZvh3h","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me test that the code compiles by running the build:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":334,"cache_read_input_tokens":114414,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":334},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"14e22860-0fdb-4c04-a554-f8d32cdabc07"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016zbwMsirCGdLDP79SZvh3h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GVQTj5Qjo3TfcFHBkz1EKe","name":"Bash","input":{"command":"zig build 2>&1 | head -100","description":"Build beads_zig to verify changes compile","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":334,"cache_read_input_tokens":114414,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":334},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6d4b18f4-825c-49bb-82ce-c84917b321d6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GVQTj5Qjo3TfcFHBkz1EKe","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 2 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/args.zig:1596:18: \u001b[31merror: \u001b[0m\u001b[1mno field named 'position' in struct 'cli.args.ArgParser'\n\u001b[0m            self.position -= 1;\n                 \u001b[32m^~~~~~~~\n\u001b[0m\u001b[1msrc/cli/args.zig:718:23: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0mpub const ArgParser = struct {\n                      \u001b[32m^~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    parseCommand: src/cli/args.zig:944:55\n    parse: src/cli/args.zig:758:46\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[1msrc/cli/audit.zig:75:5: \u001b[31merror: \u001b[0m\u001b[1mexpected type 'type', found '@typeInfo(cli.args.AuditSubcommand).@\"union\".tag_type.?'\n\u001b[0m    record_args: args.AuditSubcommand.record,\n    \u001b[32m^~~~~~~~~~~\n\u001b[0m\u001b[1msrc/cli/args.zig:478:29: \u001b[36mnote: \u001b[0m\u001b[1menum declared here\n\u001b[0mpub const AuditSubcommand = union(enum) {\n                            \u001b[32m^~~~~\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 2 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 2 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xfb1a767b -Z3103d397497edac8","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1fa3f13c-7b9e-409d-9d43-d006c7e23167","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 2 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/args.zig:1596:18: \u001b[31merror: \u001b[0m\u001b[1mno field named 'position' in struct 'cli.args.ArgParser'\n\u001b[0m            self.position -= 1;\n                 \u001b[32m^~~~~~~~\n\u001b[0m\u001b[1msrc/cli/args.zig:718:23: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0mpub const ArgParser = struct {\n                      \u001b[32m^~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    parseCommand: src/cli/args.zig:944:55\n    parse: src/cli/args.zig:758:46\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[1msrc/cli/audit.zig:75:5: \u001b[31merror: \u001b[0m\u001b[1mexpected type 'type', found '@typeInfo(cli.args.AuditSubcommand).@\"union\".tag_type.?'\n\u001b[0m    record_args: args.AuditSubcommand.record,\n    \u001b[32m^~~~~~~~~~~\n\u001b[0m\u001b[1msrc/cli/args.zig:478:29: \u001b[36mnote: \u001b[0m\u001b[1menum declared here\n\u001b[0mpub const AuditSubcommand = union(enum) {\n                            \u001b[32m^~~~~\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 2 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 2 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xfb1a767b -Z3103d397497edac8","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QDt1g9ZN9erQjFfM6uwurR","type":"message","role":"assistant","content":[{"type":"text","text":"I have two errors to fix:\n\n1. The `position` field doesn't exist in ArgParser - need to find the correct way to go back in the parser\n2. The type access for `args.AuditSubcommand.record` is wrong - it should be accessed differently\n\nLet me look at how other subcommand parsers handle similar cases and understand the ArgParser structure:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":938,"cache_read_input_tokens":114748,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":938},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"10a776e8-6846-425d-bf4a-ee88993756a9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QDt1g9ZN9erQjFfM6uwurR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019jfoWeh56abFBTE1WJNK1T","name":"Grep","input":{"pattern":"struct.*ArgParser","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":938,"cache_read_input_tokens":114748,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":938},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4e28623f-9bb4-499c-97ae-b083ef312144"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019jfoWeh56abFBTE1WJNK1T","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"cd8a9204-f634-4566-bb16-9bd5e707f288","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AgYQFCF2Lt9hApwgBvMXYg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Cbin9rFY8LhhgkpAVdVNJz","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":715,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":385,"cache_read_input_tokens":115686,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":385},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"436aacad-3872-4346-8fe8-1b9e02eda967"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Cbin9rFY8LhhgkpAVdVNJz","type":"tool_result","content":"   715→};\n   716→\n   717→/// Command-line argument parser.\n   718→pub const ArgParser = struct {\n   719→    allocator: std.mem.Allocator,\n   720→    args: []const []const u8,\n   721→    index: usize = 0,\n   722→\n   723→    const Self = @This();\n   724→\n   725→    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n   726→        return .{\n   727→            .allocator = allocator,\n   728→            .args = args,\n   729→        };\n   730→    }\n   731→\n   732→    /// Parse all arguments into a ParseResult.\n   733→    pub fn parse(self: *Self) ParseError!ParseResult {\n   734→        var global = GlobalOptions{};\n   735→\n   736→        // Parse global flags first\n   737→        while (self.hasNext()) {\n   738→            const arg = self.peek().?;\n   739→            if (std.mem.startsWith(u8, arg, \"-\")) {\n   740→                if (self.parseGlobalFlag(&global)) |consumed| {\n   741→                    if (!consumed) break;\n   742→                } else |_| {\n   743→                    break;\n   744→                }\n   745→            } else {\n   746→                break;\n   747→            }\n   748→        }\n   749→\n   750→        // Parse subcommand\n   751→        const cmd_str = self.next() orelse {\n   752→            return .{\n   753→                .global = global,\n   754→                .command = .{ .help = .{ .topic = null } },\n   755→            };\n   756→        };\n   757→\n   758→        const command = try self.parseCommand(cmd_str);\n   759→\n   760→        return .{\n   761→            .global = global,\n   762→            .command = command,\n   763→        };\n   764→    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3977da54-59ae-4d59-ac00-166473a587eb","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }","numLines":50,"startLine":715,"totalLines":2875}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015J1vcYqHezkdRo1NVa9Bzt","type":"message","role":"assistant","content":[{"type":"text","text":"I see - the field is `index`, not `position`. Let me also understand how to properly access the union fields. Let me look at how other commands handle this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":710,"cache_read_input_tokens":116071,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":710},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"35b43113-a8e6-4d10-8e30-d513d02fba54"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015J1vcYqHezkdRo1NVa9Bzt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XEgeEhhUYT7HASaGmr96AH","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":760,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":710,"cache_read_input_tokens":116071,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":710},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"ddeac528-5876-4359-a672-4bf019607e8c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XEgeEhhUYT7HASaGmr96AH","type":"tool_result","content":"   760→        return .{\n   761→            .global = global,\n   762→            .command = command,\n   763→        };\n   764→    }\n   765→\n   766→    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n   767→        const arg = self.next().?;\n   768→\n   769→        if (std.mem.eql(u8, arg, \"--json\")) {\n   770→            global.json = true;\n   771→            return true;\n   772→        }\n   773→        if (std.mem.eql(u8, arg, \"--toon\")) {\n   774→            global.toon = true;\n   775→            return true;\n   776→        }\n   777→        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   778→            global.quiet = true;\n   779→            return true;\n   780→        }\n   781→        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   782→            global.verbose +|= 1;\n   783→            return true;\n   784→        }\n   785→        if (std.mem.eql(u8, arg, \"-vv\")) {\n   786→            global.verbose +|= 2;\n   787→            return true;\n   788→        }\n   789→        if (std.mem.eql(u8, arg, \"--no-color\")) {\n   790→            global.no_color = true;\n   791→            return true;\n   792→        }\n   793→        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n   794→            global.no_auto_flush = true;\n   795→            return true;\n   796→        }\n   797→        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n   798→            global.no_auto_import = true;\n   799→            return true;\n   800→        }\n   801→        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n   802→            global.data_path = self.next() orelse return error.MissingFlagValue;\n   803→            return true;\n   804→        }\n   805→        if (std.mem.eql(u8, arg, \"--actor\")) {\n   806→            global.actor = self.next() orelse return error.MissingFlagValue;\n   807→            return true;\n   808→        }\n   809→        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"78ace964-17e6-4bd8-b1f9-94478cfa8c64","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {","numLines":50,"startLine":760,"totalLines":2875}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01G8ncKdVAgcVGKErT6B85So","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me fix the two issues:\n\n1. Change `self.position` to `self.index`\n2. Fix the type access in audit.zig"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":936,"cache_read_input_tokens":116781,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":936},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"194d9bff-3df0-49e2-bf56-9883c3f9577c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01G8ncKdVAgcVGKErT6B85So","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013UcxmyuQSFjpMQVBmEY3gm","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.position -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }","new_string":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":936,"cache_read_input_tokens":116781,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":936},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a340406d-3894-41a7-b1a6-aa9bbc961fe7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013UcxmyuQSFjpMQVBmEY3gm","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"fe9ee772-8c3c-4f12-b067-f36258b823ef","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.position -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }","newString":"    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.position -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1593,"oldLines":7,"newStart":1593,"newLines":7,"lines":["         // Handle --limit flag at top level (legacy support)","         if (std.mem.startsWith(u8, subcmd, \"-\")) {","             // Put it back and parse as list subcommand with limit","-            self.position -= 1;","+            self.index -= 1;","             var limit: ?u32 = null;","             while (self.hasNext()) {","                 if (try self.parseLimitFlag()) |l| {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KoHmk4yLQTLPzQERHUVzUS","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me fix the type issue in audit.zig. The issue is that I'm trying to use `args.AuditSubcommand.record` as a type, but that's accessing the union field, not the struct type inside. Let me look at how other commands handle this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":639,"cache_read_input_tokens":117717,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":639},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"bffbe09d-c6d0-4350-8983-a457f56c1eec"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KoHmk4yLQTLPzQERHUVzUS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MjxUMNc1QgBjwherhqXto5","name":"Grep","input":{"pattern":"fn run.*Subcommand","path":"/home/hotschmoe/beads_zig/src/cli","output_mode":"content","-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":639,"cache_read_input_tokens":117717,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":639},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"fcdca1b7-d7c2-4609-8cdd-f4eee0bf0a33"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MjxUMNc1QgBjwherhqXto5","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f158ca9f-eede-4d71-903a-1b3941599652","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ERyRwmz4DVbbJsjJoVs6eB","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at how dep.zig handles its subcommands:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":206,"cache_read_input_tokens":118356,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":206},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"41191922-aec9-4fb4-b808-33cc92599e5a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ERyRwmz4DVbbJsjJoVs6eB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WMuGL7M951CCpanR16fYyY","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":206,"cache_read_input_tokens":118356,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":206},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"75e5274a-72d5-4689-8047-4e913f064fa2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WMuGL7M951CCpanR16fYyY","type":"tool_result","content":"     1→//! Dependency management commands for beads_zig.\n     2→//!\n     3→//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n     4→//! `bz dep remove <child> <parent>` - Remove dependency\n     5→//! `bz dep list <id>` - List dependencies for an issue\n     6→//!\n     7→//! Manages relationships between issues.\n     8→\n     9→const std = @import(\"std\");\n    10→const models = @import(\"../models/mod.zig\");\n    11→const storage = @import(\"../storage/mod.zig\");\n    12→const common = @import(\"common.zig\");\n    13→const args = @import(\"args.zig\");\n    14→const test_util = @import(\"../test_util.zig\");\n    15→\n    16→const Dependency = models.Dependency;\n    17→const DependencyType = models.DependencyType;\n    18→const CommandContext = common.CommandContext;\n    19→const DependencyGraph = common.DependencyGraph;\n    20→const DependencyGraphError = storage.DependencyGraphError;\n    21→\n    22→pub const DepError = error{\n    23→    WorkspaceNotInitialized,\n    24→    IssueNotFound,\n    25→    CycleDetected,\n    26→    SelfDependency,\n    27→    StorageError,\n    28→    OutOfMemory,\n    29→};\n    30→\n    31→pub const DepResult = struct {\n    32→    success: bool,\n    33→    action: ?[]const u8 = null,\n    34→    child: ?[]const u8 = null,\n    35→    parent: ?[]const u8 = null,\n    36→    depends_on: ?[]const []const u8 = null,\n    37→    blocks: ?[]const []const u8 = null,\n    38→    message: ?[]const u8 = null,\n    39→};\n    40→\n    41→pub fn run(\n    42→    dep_args: args.DepArgs,\n    43→    global: args.GlobalOptions,\n    44→    allocator: std.mem.Allocator,\n    45→) !void {\n    46→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    47→        return DepError.WorkspaceNotInitialized;\n    48→    };\n    49→    defer ctx.deinit();\n    50→\n    51→    var graph = ctx.createGraph();\n    52→\n    53→    switch (dep_args.subcommand) {\n    54→        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n    55→        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n    56→        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n    57→        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n    58→        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    59→    }\n    60→}\n    61→\n    62→fn runAdd(\n    63→    graph: *DependencyGraph,\n    64→    ctx: *CommandContext,\n    65→    add_args: anytype,\n    66→    global: args.GlobalOptions,\n    67→    allocator: std.mem.Allocator,\n    68→) !void {\n    69→    const structured_output = global.isStructuredOutput();\n    70→    if (!try ctx.store.exists(add_args.child)) {\n    71→        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n    72→        return DepError.IssueNotFound;\n    73→    }\n    74→\n    75→    if (!try ctx.store.exists(add_args.parent)) {\n    76→        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n    77→        return DepError.IssueNotFound;\n    78→    }\n    79→\n    80→    const now = std.time.timestamp();\n    81→    const dep = Dependency{\n    82→        .issue_id = add_args.child,\n    83→        .depends_on_id = add_args.parent,\n    84→        .dep_type = DependencyType.fromString(add_args.dep_type),\n    85→        .created_at = now,\n    86→        .created_by = global.actor,\n    87→        .metadata = add_args.metadata,\n    88→        .thread_id = null,\n    89→    };\n    90→\n    91→    graph.addDependency(dep) catch |err| {\n    92→        const msg = switch (err) {\n    93→            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n    94→            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n    95→            DependencyGraphError.IssueNotFound => \"issue not found\",\n    96→            else => \"failed to add dependency\",\n    97→        };\n    98→        try outputError(&ctx.output, structured_output, msg);\n    99→\n   100→        return switch (err) {\n   101→            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n   102→            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n   103→            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n   104→            else => DepError.StorageError,\n   105→        };\n   106→    };\n   107→\n   108→    try ctx.saveIfAutoFlush();\n   109→\n   110→    if (structured_output) {\n   111→        try ctx.output.printJson(DepResult{\n   112→            .success = true,\n   113→            .action = \"added\",\n   114→            .child = add_args.child,\n   115→            .parent = add_args.parent,\n   116→        });\n   117→    } else if (!global.quiet) {\n   118→        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n   119→    }\n   120→}\n   121→\n   122→fn runRemove(\n   123→    graph: *DependencyGraph,\n   124→    ctx: *CommandContext,\n   125→    remove_args: anytype,\n   126→    global: args.GlobalOptions,\n   127→) !void {\n   128→    const structured_output = global.isStructuredOutput();\n   129→    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n   130→        const msg = if (err == DependencyGraphError.IssueNotFound)\n   131→            \"issue not found\"\n   132→        else\n   133→            \"failed to remove dependency\";\n   134→        try outputError(&ctx.output, structured_output, msg);\n   135→\n   136→        return if (err == DependencyGraphError.IssueNotFound)\n   137→            DepError.IssueNotFound\n   138→        else\n   139→            DepError.StorageError;\n   140→    };\n   141→\n   142→    try ctx.saveIfAutoFlush();\n   143→\n   144→    if (structured_output) {\n   145→        try ctx.output.printJson(DepResult{\n   146→            .success = true,\n   147→            .action = \"removed\",\n   148→            .child = remove_args.child,\n   149→            .parent = remove_args.parent,\n   150→        });\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c7e51824-a7bc-400f-9c21-fd04ad99d393","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","content":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });","numLines":150,"startLine":1,"totalLines":702}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TQDyLvFLzzz1SAiG73uSPY","type":"message","role":"assistant","content":[{"type":"text","text":"I see the pattern - they use `anytype` for the sub-args. Let me fix the audit.zig to use the same pattern:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2218,"cache_read_input_tokens":118562,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2218},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"085358a6-eabe-4fba-8559-9fb018015d84"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TQDyLvFLzzz1SAiG73uSPY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DDScHxrTEq9vuhkdRvjXQX","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"pub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: args.AuditSubcommand.record,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","new_string":"pub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2218,"cache_read_input_tokens":118562,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2218},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1cae4788-0bb8-4647-a946-3b68d47d26f7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DDScHxrTEq9vuhkdRvjXQX","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e6489dfc-a10c-41a6-aa0b-f51e476cc976","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"pub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: args.AuditSubcommand.record,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","newString":"pub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: args.AuditSubcommand.record,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: args.AuditSubcommand.label,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":72,"oldLines":7,"newStart":72,"newLines":7,"lines":[" }"," "," fn runRecord(","-    record_args: args.AuditSubcommand.record,","+    record_args: anytype,","     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BYYxQZftnD4PCWe28iiMTX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fu8USuyyPFXGF338CpFoWg","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"fn runLabel(\n    label_args: args.AuditSubcommand.label,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","new_string":"fn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":806,"cache_read_input_tokens":120780,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":806},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3447bde1-e46f-4175-aefe-65b016e37738"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fu8USuyyPFXGF338CpFoWg","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b3ba237c-7458-48d5-b1dc-d4b3c37ed55c","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"fn runLabel(\n    label_args: args.AuditSubcommand.label,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","newString":"fn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: args.AuditSubcommand.label,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":173,"oldLines":7,"newStart":173,"newLines":7,"lines":[" }"," "," fn runLabel(","-    label_args: args.AuditSubcommand.label,","+    label_args: anytype,","     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013m6DGCbypaXNjNk5vjcaed","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013tQn7GHQM74p3RvZ8UCW5P","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"fn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","new_string":"fn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":257,"cache_read_input_tokens":121586,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":257},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"655856f5-1735-4ca7-9934-c1c63e0e935c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013tQn7GHQM74p3RvZ8UCW5P","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"13d0944e-3a06-4219-8bd4-5cace6e50404","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"fn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","newString":"fn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: args.AuditSubcommand.log,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":228,"oldLines":7,"newStart":228,"newLines":7,"lines":[" }"," "," fn runLog(","-    log_args: args.AuditSubcommand.log,","+    log_args: anytype,","     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UebhUVBHQm62op7fSHNsFa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NZvpSgYS2o3Rf6qknvGWyR","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"fn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","new_string":"fn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":257,"cache_read_input_tokens":121843,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":257},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8bd360d0-95fe-4862-81f3-3dc953a24aea"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NZvpSgYS2o3Rf6qknvGWyR","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"793b4bcc-22f5-41e3-88a3-b724125aa846","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"fn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","newString":"fn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: args.AuditSubcommand.summary,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":303,"oldLines":7,"newStart":303,"newLines":7,"lines":[" }"," "," fn runSummary(","-    summary_args: args.AuditSubcommand.summary,","+    summary_args: anytype,","     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0164f62MxMbM6bb8BuciPBYx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QzjDZRWW8WHUjWXEHf9WAY","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"fn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","new_string":"fn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":261,"cache_read_input_tokens":122100,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":261},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4d17d4db-647f-4807-8826-a02e992e6333"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QzjDZRWW8WHUjWXEHf9WAY","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5aa094a1-f185-420f-ae10-8b8c6b207577","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"fn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","newString":"fn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: args.AuditSubcommand.list,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":398,"oldLines":7,"newStart":398,"newLines":7,"lines":[" }"," "," fn runList(","-    list_args: args.AuditSubcommand.list,","+    list_args: anytype,","     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018J128DZ87xwHtFegXJy9HR","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me try building again:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":257,"cache_read_input_tokens":122361,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":257},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a314cc79-73b5-4e0d-842c-f81b0172bcc8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018J128DZ87xwHtFegXJy9HR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01D19NtM1YfnQTQ1g3vQkP56","name":"Bash","input":{"command":"zig build 2>&1 | head -100","description":"Build beads_zig to verify changes compile","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":257,"cache_read_input_tokens":122361,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":257},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2877c094-4c82-41b5-a173-e7bb09599533"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01D19NtM1YfnQTQ1g3vQkP56","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/audit.zig:122:21: \u001b[31merror: \u001b[0m\u001b[1mroot source file struct 'json' has no member named 'stringify'\n\u001b[0m        try std.json.stringify(prompt, .{}, writer);\n            \u001b[32m~~~~~~~~^~~~~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/json.zig:1:1: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0m//! JSON parsing and stringification conforming to RFC 8259. https://datatracker.ietf.org/doc/html/rfc8259\n\u001b[32m^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/audit.zig:66:47\n    dispatch: src/main.zig:260:25\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x5727aa50 -Z3ab2536b14b0d3db","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b3176b4f-0d48-4421-bec6-bef390715e6f","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/audit.zig:122:21: \u001b[31merror: \u001b[0m\u001b[1mroot source file struct 'json' has no member named 'stringify'\n\u001b[0m        try std.json.stringify(prompt, .{}, writer);\n            \u001b[32m~~~~~~~~^~~~~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/json.zig:1:1: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0m//! JSON parsing and stringification conforming to RFC 8259. https://datatracker.ietf.org/doc/html/rfc8259\n\u001b[32m^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/audit.zig:66:47\n    dispatch: src/main.zig:260:25\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x5727aa50 -Z3ab2536b14b0d3db","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CwEugPjMoRfRo4CHkZ3TA4","type":"message","role":"assistant","content":[{"type":"text","text":"There's a Zig version issue - the JSON API changed. Let me look at how other files use JSON stringify:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":820,"cache_read_input_tokens":122618,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":820},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"899c5dd1-d1c0-4060-9595-b7d5221d8221"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CwEugPjMoRfRo4CHkZ3TA4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TMmB5xafrTnyXPB25vKuDB","name":"Grep","input":{"pattern":"std.json.Stringify","path":"/home/hotschmoe/beads_zig/src","output_mode":"content","-C":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":820,"cache_read_input_tokens":122618,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":820},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"29cf9c08-549b-4dc3-8392-66e4da56d3e6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TMmB5xafrTnyXPB25vKuDB","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/storage/compact.zig-358-        // Serialize and write each issue\n/home/hotschmoe/beads_zig/src/storage/compact.zig-359-        for (issues) |issue| {\nsrc/storage/compact.zig:360:            const json_bytes = std.json.Stringify.valueAlloc(self.allocator, issue, .{}) catch return CompactError.WriteError;\n/home/hotschmoe/beads_zig/src/storage/compact.zig-361-            defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/compact.zig-362-\n--\n/home/hotschmoe/beads_zig/src/storage/wal.zig-336-\n/home/hotschmoe/beads_zig/src/storage/wal.zig-337-        // Serialize entry to JSON\nsrc/storage/wal.zig:338:        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, entry, .{}) catch return WalError.WriteError;\n/home/hotschmoe/beads_zig/src/storage/wal.zig-339-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/wal.zig-340-\n--\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1065-    };\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1066-\nsrc/storage/wal.zig:1067:    const json_bytes = try std.json.Stringify.valueAlloc(allocator, entry, .{});\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1068-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1069-\n--\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1084-    };\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1085-\nsrc/storage/wal.zig:1086:    const json_bytes = try std.json.Stringify.valueAlloc(allocator, entry, .{});\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1087-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1088-\n--\n/home/hotschmoe/beads_zig/src/cli/query.zig-424-\n/home/hotschmoe/beads_zig/src/cli/query.zig-425-    // Serialize to JSON\nsrc/cli/query.zig:426:    const json_bytes = std.json.Stringify.valueAlloc(allocator, query_data, .{}) catch return error.StorageError;\n/home/hotschmoe/beads_zig/src/cli/query.zig-427-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/cli/query.zig-428-\n--\n/home/hotschmoe/beads_zig/src/cli/query.zig-443-\n/home/hotschmoe/beads_zig/src/cli/query.zig-444-    for (queries) |q| {\nsrc/cli/query.zig:445:        const json_bytes = std.json.Stringify.valueAlloc(allocator, q, .{}) catch return error.StorageError;\n/home/hotschmoe/beads_zig/src/cli/query.zig-446-        defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/cli/query.zig-447-        try file.writeAll(json_bytes);\n--\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-203-            if (issue.ephemeral) continue;\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-204-\nsrc/storage/jsonl.zig:205:            const json_bytes = std.json.Stringify.valueAlloc(self.allocator, issue, .{}) catch return error.WriteError;\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-206-            defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-207-            content.appendSlice(self.allocator, json_bytes) catch return error.WriteError;\n--\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-245-\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-246-        // Build content in memory and write all at once\nsrc/storage/jsonl.zig:247:        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, issue, .{}) catch return error.WriteError;\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-248-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-249-\n--\n/home/hotschmoe/beads_zig/src/storage/events.zig-129-\n/home/hotschmoe/beads_zig/src/storage/events.zig-130-        // Serialize\nsrc/storage/events.zig:131:        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, stored_event, .{}) catch return EventStoreError.WriteError;\n/home/hotschmoe/beads_zig/src/storage/events.zig-132-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/events.zig-133-\n--\n/home/hotschmoe/beads_zig/src/models/status.zig-170-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/status.zig-171-\nsrc/models/status.zig:172:        try std.json.Stringify.value(status, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/status.zig-173-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/status.zig-174-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-439-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-440-\nsrc/models/event.zig:441:        try std.json.Stringify.value(et, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-442-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-443-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-589-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-590-\nsrc/models/event.zig:591:    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-592-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-593-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-614-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-615-\nsrc/models/event.zig:616:    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-617-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-618-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-640-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-641-\nsrc/models/event.zig:642:    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-643-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-644-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-196-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-197-\nsrc/models/comment.zig:198:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-199-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-200-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-219-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-220-\nsrc/models/comment.zig:221:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-222-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-223-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-243-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-244-\nsrc/models/comment.zig:245:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-246-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-247-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-267-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-268-\nsrc/models/comment.zig:269:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-270-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-271-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-291-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-292-\nsrc/models/comment.zig:293:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-294-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-295-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-315-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-316-\nsrc/models/comment.zig:317:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-318-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-319-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-700-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-701-\nsrc/models/issue.zig:702:    try std.json.Stringify.value(ts, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-703-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-704-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-724-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-725-\nsrc/models/issue.zig:726:    try std.json.Stringify.value(original, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-727-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-728-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-741-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-742-\nsrc/models/issue.zig:743:    try std.json.Stringify.value(ts, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-744-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-745-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-755-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-756-\nsrc/models/issue.zig:757:    try std.json.Stringify.value(ts, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-758-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-759-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-791-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-792-\nsrc/models/issue.zig:793:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-794-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-795-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-831-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-832-\nsrc/models/issue.zig:833:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-834-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-835-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-855-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-856-\nsrc/models/issue.zig:857:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-858-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-859-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-869-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-870-\nsrc/models/issue.zig:871:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-872-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-873-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-247-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-248-\nsrc/models/dependency.zig:249:        try std.json.Stringify.value(dep_type, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-250-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-251-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-276-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-277-\nsrc/models/dependency.zig:278:    try std.json.Stringify.value(DependencyType.blocks, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-279-\n/home/hotschmoe/beads_zig/src/models/dependency.zig-280-    try std.testing.expectEqualStrings(\"\\\"blocks\\\"\", aw.written());\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-430-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-431-\nsrc/models/dependency.zig:432:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-433-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-434-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-455-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-456-\nsrc/models/dependency.zig:457:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-458-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-459-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-480-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-481-\nsrc/models/dependency.zig:482:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-483-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-484-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-511-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-512-\nsrc/models/dependency.zig:513:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-514-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-515-\n--\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-165-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-166-\nsrc/models/issue_type.zig:167:        try std.json.Stringify.value(issue_type, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-168-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-169-\n--\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-194-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-195-\nsrc/models/issue_type.zig:196:    try std.json.Stringify.value(IssueType.task, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-197-\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-198-    try std.testing.expectEqualStrings(\"\\\"task\\\"\", aw.written());\n--\n/home/hotschmoe/beads_zig/src/errors.zig-388-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/errors.zig-389-\nsrc/errors.zig:390:    try std.json.Stringify.value(err, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/errors.zig-391-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/errors.zig-392-\n--\n/home/hotschmoe/beads_zig/src/output/mod.zig-259-    /// If stats mode is also enabled, displays token savings information.\nsrc/output/mod.zig-260-    pub fn printJson(self: *Self, value: anytype) !void {\nsrc/output/mod.zig:261:        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n/home/hotschmoe/beads_zig/src/output/mod.zig-262-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/output/mod.zig-263-\n--\n/home/hotschmoe/beads_zig/src/output/mod.zig-968-\n/home/hotschmoe/beads_zig/src/output/mod.zig-969-    // Serialize to JSON\nsrc/output/mod.zig:970:    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n/home/hotschmoe/beads_zig/src/output/mod.zig-971-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/output/mod.zig-972-\n--\n/home/hotschmoe/beads_zig/src/models/priority.zig-223-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/priority.zig-224-\nsrc/models/priority.zig:225:        try std.json.Stringify.value(priority, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/priority.zig-226-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/priority.zig-227-\n--\n/home/hotschmoe/beads_zig/src/models/priority.zig-239-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/priority.zig-240-\nsrc/models/priority.zig:241:    try std.json.Stringify.value(Priority.MEDIUM, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/priority.zig-242-\n/home/hotschmoe/beads_zig/src/models/priority.zig-243-    try std.testing.expectEqualStrings(\"2\", aw.written());"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"297d0117-de16-45ec-8996-77dd5f3fbcc4","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"/home/hotschmoe/beads_zig/src/storage/compact.zig-358-        // Serialize and write each issue\n/home/hotschmoe/beads_zig/src/storage/compact.zig-359-        for (issues) |issue| {\nsrc/storage/compact.zig:360:            const json_bytes = std.json.Stringify.valueAlloc(self.allocator, issue, .{}) catch return CompactError.WriteError;\n/home/hotschmoe/beads_zig/src/storage/compact.zig-361-            defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/compact.zig-362-\n--\n/home/hotschmoe/beads_zig/src/storage/wal.zig-336-\n/home/hotschmoe/beads_zig/src/storage/wal.zig-337-        // Serialize entry to JSON\nsrc/storage/wal.zig:338:        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, entry, .{}) catch return WalError.WriteError;\n/home/hotschmoe/beads_zig/src/storage/wal.zig-339-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/wal.zig-340-\n--\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1065-    };\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1066-\nsrc/storage/wal.zig:1067:    const json_bytes = try std.json.Stringify.valueAlloc(allocator, entry, .{});\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1068-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1069-\n--\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1084-    };\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1085-\nsrc/storage/wal.zig:1086:    const json_bytes = try std.json.Stringify.valueAlloc(allocator, entry, .{});\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1087-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/wal.zig-1088-\n--\n/home/hotschmoe/beads_zig/src/cli/query.zig-424-\n/home/hotschmoe/beads_zig/src/cli/query.zig-425-    // Serialize to JSON\nsrc/cli/query.zig:426:    const json_bytes = std.json.Stringify.valueAlloc(allocator, query_data, .{}) catch return error.StorageError;\n/home/hotschmoe/beads_zig/src/cli/query.zig-427-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/cli/query.zig-428-\n--\n/home/hotschmoe/beads_zig/src/cli/query.zig-443-\n/home/hotschmoe/beads_zig/src/cli/query.zig-444-    for (queries) |q| {\nsrc/cli/query.zig:445:        const json_bytes = std.json.Stringify.valueAlloc(allocator, q, .{}) catch return error.StorageError;\n/home/hotschmoe/beads_zig/src/cli/query.zig-446-        defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/cli/query.zig-447-        try file.writeAll(json_bytes);\n--\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-203-            if (issue.ephemeral) continue;\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-204-\nsrc/storage/jsonl.zig:205:            const json_bytes = std.json.Stringify.valueAlloc(self.allocator, issue, .{}) catch return error.WriteError;\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-206-            defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-207-            content.appendSlice(self.allocator, json_bytes) catch return error.WriteError;\n--\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-245-\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-246-        // Build content in memory and write all at once\nsrc/storage/jsonl.zig:247:        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, issue, .{}) catch return error.WriteError;\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-248-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/jsonl.zig-249-\n--\n/home/hotschmoe/beads_zig/src/storage/events.zig-129-\n/home/hotschmoe/beads_zig/src/storage/events.zig-130-        // Serialize\nsrc/storage/events.zig:131:        const json_bytes = std.json.Stringify.valueAlloc(self.allocator, stored_event, .{}) catch return EventStoreError.WriteError;\n/home/hotschmoe/beads_zig/src/storage/events.zig-132-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/storage/events.zig-133-\n--\n/home/hotschmoe/beads_zig/src/models/status.zig-170-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/status.zig-171-\nsrc/models/status.zig:172:        try std.json.Stringify.value(status, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/status.zig-173-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/status.zig-174-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-439-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-440-\nsrc/models/event.zig:441:        try std.json.Stringify.value(et, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-442-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-443-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-589-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-590-\nsrc/models/event.zig:591:    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-592-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-593-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-614-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-615-\nsrc/models/event.zig:616:    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-617-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-618-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-640-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-641-\nsrc/models/event.zig:642:    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-643-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-644-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-196-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-197-\nsrc/models/comment.zig:198:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-199-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-200-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-219-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-220-\nsrc/models/comment.zig:221:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-222-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-223-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-243-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-244-\nsrc/models/comment.zig:245:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-246-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-247-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-267-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-268-\nsrc/models/comment.zig:269:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-270-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-271-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-291-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-292-\nsrc/models/comment.zig:293:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-294-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-295-\n--\n/home/hotschmoe/beads_zig/src/models/comment.zig-315-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/comment.zig-316-\nsrc/models/comment.zig:317:    try std.json.Stringify.value(comment, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/comment.zig-318-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/comment.zig-319-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-700-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-701-\nsrc/models/issue.zig:702:    try std.json.Stringify.value(ts, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-703-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-704-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-724-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-725-\nsrc/models/issue.zig:726:    try std.json.Stringify.value(original, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-727-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-728-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-741-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-742-\nsrc/models/issue.zig:743:    try std.json.Stringify.value(ts, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-744-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-745-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-755-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-756-\nsrc/models/issue.zig:757:    try std.json.Stringify.value(ts, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-758-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-759-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-791-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-792-\nsrc/models/issue.zig:793:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-794-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-795-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-831-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-832-\nsrc/models/issue.zig:833:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-834-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-835-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-855-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-856-\nsrc/models/issue.zig:857:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-858-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-859-\n--\n/home/hotschmoe/beads_zig/src/models/issue.zig-869-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue.zig-870-\nsrc/models/issue.zig:871:    try std.json.Stringify.value(issue, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue.zig-872-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue.zig-873-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-247-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-248-\nsrc/models/dependency.zig:249:        try std.json.Stringify.value(dep_type, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-250-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-251-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-276-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-277-\nsrc/models/dependency.zig:278:    try std.json.Stringify.value(DependencyType.blocks, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-279-\n/home/hotschmoe/beads_zig/src/models/dependency.zig-280-    try std.testing.expectEqualStrings(\"\\\"blocks\\\"\", aw.written());\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-430-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-431-\nsrc/models/dependency.zig:432:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-433-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-434-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-455-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-456-\nsrc/models/dependency.zig:457:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-458-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-459-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-480-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-481-\nsrc/models/dependency.zig:482:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-483-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-484-\n--\n/home/hotschmoe/beads_zig/src/models/dependency.zig-511-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-512-\nsrc/models/dependency.zig:513:    try std.json.Stringify.value(dep, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/dependency.zig-514-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/dependency.zig-515-\n--\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-165-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-166-\nsrc/models/issue_type.zig:167:        try std.json.Stringify.value(issue_type, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-168-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-169-\n--\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-194-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-195-\nsrc/models/issue_type.zig:196:    try std.json.Stringify.value(IssueType.task, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-197-\n/home/hotschmoe/beads_zig/src/models/issue_type.zig-198-    try std.testing.expectEqualStrings(\"\\\"task\\\"\", aw.written());\n--\n/home/hotschmoe/beads_zig/src/errors.zig-388-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/errors.zig-389-\nsrc/errors.zig:390:    try std.json.Stringify.value(err, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/errors.zig-391-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/errors.zig-392-\n--\n/home/hotschmoe/beads_zig/src/output/mod.zig-259-    /// If stats mode is also enabled, displays token savings information.\nsrc/output/mod.zig-260-    pub fn printJson(self: *Self, value: anytype) !void {\nsrc/output/mod.zig:261:        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n/home/hotschmoe/beads_zig/src/output/mod.zig-262-        defer self.allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/output/mod.zig-263-\n--\n/home/hotschmoe/beads_zig/src/output/mod.zig-968-\n/home/hotschmoe/beads_zig/src/output/mod.zig-969-    // Serialize to JSON\nsrc/output/mod.zig:970:    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n/home/hotschmoe/beads_zig/src/output/mod.zig-971-    defer allocator.free(json_bytes);\n/home/hotschmoe/beads_zig/src/output/mod.zig-972-\n--\n/home/hotschmoe/beads_zig/src/models/priority.zig-223-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/priority.zig-224-\nsrc/models/priority.zig:225:        try std.json.Stringify.value(priority, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/priority.zig-226-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/priority.zig-227-\n--\n/home/hotschmoe/beads_zig/src/models/priority.zig-239-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/priority.zig-240-\nsrc/models/priority.zig:241:    try std.json.Stringify.value(Priority.MEDIUM, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/priority.zig-242-\n/home/hotschmoe/beads_zig/src/models/priority.zig-243-    try std.testing.expectEqualStrings(\"2\", aw.written());","numLines":245}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0118gErLStJpXB8k5Cfjtpis","type":"message","role":"assistant","content":[{"type":"text","text":"I see - the API is `std.json.Stringify.value()` for a writer, or `std.json.Stringify.valueAlloc()` for allocating. Let me fix the audit.zig file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6961,"cache_read_input_tokens":123438,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6961},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f54077f5-fac3-41d6-be38-ec2f758819ed"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0118gErLStJpXB8k5Cfjtpis","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Wc4Pz8KKkVgJCKVZjLmcdN","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }","new_string":"    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.Stringify.value(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.Stringify.value(response, .{}, writer);\n        first = false;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6961,"cache_read_input_tokens":123438,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6961},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"357f478e-b988-496e-ade6-f5f771ca3b78"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Wc4Pz8KKkVgJCKVZjLmcdN","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"fc91ad09-7505-477b-ae03-cebd87660d98","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }","newString":"    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.Stringify.value(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.Stringify.value(response, .{}, writer);\n        first = false;\n    }","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.stringify(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.stringify(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":119,"oldLines":13,"newStart":119,"newLines":13,"lines":["     if (record_args.prompt) |prompt| {","         if (!first) try writer.writeAll(\",\");","         try writer.writeAll(\"\\\"prompt\\\":\");","-        try std.json.stringify(prompt, .{}, writer);","+        try std.json.Stringify.value(prompt, .{}, writer);","         first = false;","     }","     if (record_args.response) |response| {","         if (!first) try writer.writeAll(\",\");","         try writer.writeAll(\"\\\"response\\\":\");","-        try std.json.stringify(response, .{}, writer);","+        try std.json.Stringify.value(response, .{}, writer);","         first = false;","     }","     if (record_args.tool_name) |tool_name| {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013ge4GRaB2XcWSGJyVFfBf9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MedNaCKsQujRRgGZjVjiQ2","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }","new_string":"    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.Stringify.value(reason, .{}, writer);\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":636,"cache_read_input_tokens":130399,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":636},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c3a61f45-c49f-4fd2-88bc-56a545493e1d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MedNaCKsQujRRgGZjVjiQ2","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c14bfc11-6017-4465-98cc-f41159b85184","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }","newString":"    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.Stringify.value(reason, .{}, writer);\n    }","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.Stringify.value(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.Stringify.value(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.stringify(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":195,"oldLines":7,"newStart":195,"newLines":7,"lines":["     try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });","     if (label_args.reason) |reason| {","         try writer.writeAll(\",\\\"reason\\\":\");","-        try std.json.stringify(reason, .{}, writer);","+        try std.json.Stringify.value(reason, .{}, writer);","     }","     try writer.writeAll(\"}\");"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015nQ7e7LqCDqe4iGZZTCU7P","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's build again:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":260,"cache_read_input_tokens":131035,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":260},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e75a4514-1c34-4de0-b212-992dbb8bb78f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015nQ7e7LqCDqe4iGZZTCU7P","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019eVS1LV5KAvkyJBfmkhP8C","name":"Bash","input":{"command":"zig build 2>&1 | head -100","description":"Build beads_zig to verify changes compile","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":260,"cache_read_input_tokens":131035,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":260},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"26340029-98ef-4e89-b1dc-877b8310751f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019eVS1LV5KAvkyJBfmkhP8C","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/audit.zig:122:51: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*Io.Writer', found 'Io.GenericWriter(*Io.fixed_buffer_stream.FixedBufferStream([]u8),error{NoSpaceLeft},(function 'write'))'\n\u001b[0m        try std.json.Stringify.value(prompt, .{}, writer);\n                                                  \u001b[32m^~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/Io.zig:335:12: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0m    return struct {\n           \u001b[32m^~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/json/Stringify.zig:573:52: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0mpub fn value(v: anytype, options: Options, writer: *Writer) Error!void {\n                                                   \u001b[32m^~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/audit.zig:66:47\n    dispatch: src/main.zig:260:25\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x1b8fd9df -Zf312670123ebd33d","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"fbd2a80b-0a56-45c1-af7c-ace9fe53550a","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/audit.zig:122:51: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*Io.Writer', found 'Io.GenericWriter(*Io.fixed_buffer_stream.FixedBufferStream([]u8),error{NoSpaceLeft},(function 'write'))'\n\u001b[0m        try std.json.Stringify.value(prompt, .{}, writer);\n                                                  \u001b[32m^~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/Io.zig:335:12: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0m    return struct {\n           \u001b[32m^~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/json/Stringify.zig:573:52: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0mpub fn value(v: anytype, options: Options, writer: *Writer) Error!void {\n                                                   \u001b[32m^~~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/audit.zig:66:47\n    dispatch: src/main.zig:260:25\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x1b8fd9df -Zf312670123ebd33d","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014sABvQFsFxCiid37BVhNaG","type":"message","role":"assistant","content":[{"type":"text","text":"I see - the writer parameter needs to be a pointer. Let me look at how other code uses it to write to a fixed buffer:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":906,"cache_read_input_tokens":131295,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":906},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f9a4f424-f7f3-4773-add2-d1e644deba48"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014sABvQFsFxCiid37BVhNaG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FegGJ3TGgYira6ar2mUZWL","name":"Grep","input":{"pattern":"fixedBufferStream.*json.Stringify","path":"/home/hotschmoe/beads_zig/src","output_mode":"content","-B":5,"-A":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":906,"cache_read_input_tokens":131295,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":906},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d490aa93-d147-4772-92eb-52081d1b1c7f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FegGJ3TGgYira6ar2mUZWL","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d2db551c-c7c4-4b1e-917e-7550faaf5eb8","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013dMKs7YDYBtkXLWLgJeQmz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011XpWn2FoH9XqN9TjrnDJ33","name":"Grep","input":{"pattern":"fixedBufferStream","path":"/home/hotschmoe/beads_zig/src","output_mode":"content","-B":3,"-A":5,"head_limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":191,"cache_read_input_tokens":132201,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":191},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6c49778c-933b-4278-bb7e-a4c5906fecdc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011XpWn2FoH9XqN9TjrnDJ33","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/audit.zig-105-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-106-    // Build metadata JSON with all provided fields\nsrc/cli/audit.zig-107-    var metadata_buf: [4096]u8 = undefined;\nsrc/cli/audit.zig:108:    var fbs = std.io.fixedBufferStream(&metadata_buf);\n/home/hotschmoe/beads_zig/src/cli/audit.zig-109-    const writer = fbs.writer();\n/home/hotschmoe/beads_zig/src/cli/audit.zig-110-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-111-    try writer.writeAll(\"{\");\n/home/hotschmoe/beads_zig/src/cli/audit.zig-112-    var first = true;\n/home/hotschmoe/beads_zig/src/cli/audit.zig-113-\n--\n/home/hotschmoe/beads_zig/src/cli/audit.zig-188-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-189-    // Build the label metadata\nsrc/cli/audit.zig-190-    var metadata_buf: [1024]u8 = undefined;\nsrc/cli/audit.zig:191:    var fbs = std.io.fixedBufferStream(&metadata_buf);\n/home/hotschmoe/beads_zig/src/cli/audit.zig-192-    const writer = fbs.writer();\n/home/hotschmoe/beads_zig/src/cli/audit.zig-193-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-194-    try writer.writeAll(\"{\");\nsrc/cli/audit.zig-195-    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n/home/hotschmoe/beads_zig/src/cli/audit.zig-196-    if (label_args.reason) |reason| {\n\n[Showing results with pagination = limit: 50, offset: 0]"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7791a702-7a22-4a21-adff-d6fa8e632005","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"/home/hotschmoe/beads_zig/src/cli/audit.zig-105-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-106-    // Build metadata JSON with all provided fields\nsrc/cli/audit.zig-107-    var metadata_buf: [4096]u8 = undefined;\nsrc/cli/audit.zig:108:    var fbs = std.io.fixedBufferStream(&metadata_buf);\n/home/hotschmoe/beads_zig/src/cli/audit.zig-109-    const writer = fbs.writer();\n/home/hotschmoe/beads_zig/src/cli/audit.zig-110-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-111-    try writer.writeAll(\"{\");\n/home/hotschmoe/beads_zig/src/cli/audit.zig-112-    var first = true;\n/home/hotschmoe/beads_zig/src/cli/audit.zig-113-\n--\n/home/hotschmoe/beads_zig/src/cli/audit.zig-188-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-189-    // Build the label metadata\nsrc/cli/audit.zig-190-    var metadata_buf: [1024]u8 = undefined;\nsrc/cli/audit.zig:191:    var fbs = std.io.fixedBufferStream(&metadata_buf);\n/home/hotschmoe/beads_zig/src/cli/audit.zig-192-    const writer = fbs.writer();\n/home/hotschmoe/beads_zig/src/cli/audit.zig-193-\n/home/hotschmoe/beads_zig/src/cli/audit.zig-194-    try writer.writeAll(\"{\");\nsrc/cli/audit.zig-195-    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n/home/hotschmoe/beads_zig/src/cli/audit.zig-196-    if (label_args.reason) |reason| {","numLines":19,"appliedLimit":50}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Dpy74AmH9kFsXs2DSxinr2","type":"message","role":"assistant","content":[{"type":"text","text":"Looking at the `std.json.Stringify.value` signature, it requires `*Writer`, not the generic writer. Let me look at how other code uses Stringify with a writer:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":773,"cache_read_input_tokens":132392,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":773},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e93db914-a375-467b-8b9c-c739a26860a3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Dpy74AmH9kFsXs2DSxinr2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XoLKbchQQ3A6wyCWw4DFdU","name":"Grep","input":{"pattern":"Allocating.*init","path":"/home/hotschmoe/beads_zig/src","output_mode":"content","-B":3,"-A":5,"head_limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":773,"cache_read_input_tokens":132392,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":773},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"36aa5bbb-555e-4f14-a522-d1bbd7d1dfc7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XoLKbchQQ3A6wyCWw4DFdU","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/models/status.zig-166-    };\n/home/hotschmoe/beads_zig/src/models/status.zig-167-\n/home/hotschmoe/beads_zig/src/models/status.zig-168-    for (statuses) |status| {\nsrc/models/status.zig:169:        var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/status.zig-170-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/status.zig-171-\n/home/hotschmoe/beads_zig/src/models/status.zig-172-        try std.json.Stringify.value(status, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/status.zig-173-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/status.zig-174-\n--\n/home/hotschmoe/beads_zig/src/errors.zig-384-\n/home/hotschmoe/beads_zig/src/errors.zig-385-    const err = BeadsError.issueNotFound(\"bd-123\");\n/home/hotschmoe/beads_zig/src/errors.zig-386-\nsrc/errors.zig:387:    var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/errors.zig-388-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/errors.zig-389-\n/home/hotschmoe/beads_zig/src/errors.zig-390-    try std.json.Stringify.value(err, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/errors.zig-391-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/errors.zig-392-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-435-    };\n/home/hotschmoe/beads_zig/src/models/event.zig-436-\n/home/hotschmoe/beads_zig/src/models/event.zig-437-    for (event_types) |et| {\nsrc/models/event.zig:438:        var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/event.zig-439-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-440-\n/home/hotschmoe/beads_zig/src/models/event.zig-441-        try std.json.Stringify.value(et, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-442-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-443-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-585-        .created_at = 1706540000,\n/home/hotschmoe/beads_zig/src/models/event.zig-586-    };\n/home/hotschmoe/beads_zig/src/models/event.zig-587-\nsrc/models/event.zig:588:    var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/event.zig-589-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-590-\n/home/hotschmoe/beads_zig/src/models/event.zig-591-    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-592-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-593-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-610-        .created_at = 1706540000,\n/home/hotschmoe/beads_zig/src/models/event.zig-611-    };\n/home/hotschmoe/beads_zig/src/models/event.zig-612-\nsrc/models/event.zig:613:    var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/event.zig-614-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-615-\n/home/hotschmoe/beads_zig/src/models/event.zig-616-    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-617-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-618-\n--\n\n[Showing results with pagination = limit: 50, offset: 0]"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"cb9bba56-2842-443c-9880-59430c851fbf","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"/home/hotschmoe/beads_zig/src/models/status.zig-166-    };\n/home/hotschmoe/beads_zig/src/models/status.zig-167-\n/home/hotschmoe/beads_zig/src/models/status.zig-168-    for (statuses) |status| {\nsrc/models/status.zig:169:        var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/status.zig-170-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/status.zig-171-\n/home/hotschmoe/beads_zig/src/models/status.zig-172-        try std.json.Stringify.value(status, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/status.zig-173-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/status.zig-174-\n--\n/home/hotschmoe/beads_zig/src/errors.zig-384-\n/home/hotschmoe/beads_zig/src/errors.zig-385-    const err = BeadsError.issueNotFound(\"bd-123\");\n/home/hotschmoe/beads_zig/src/errors.zig-386-\nsrc/errors.zig:387:    var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/errors.zig-388-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/errors.zig-389-\n/home/hotschmoe/beads_zig/src/errors.zig-390-    try std.json.Stringify.value(err, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/errors.zig-391-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/errors.zig-392-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-435-    };\n/home/hotschmoe/beads_zig/src/models/event.zig-436-\n/home/hotschmoe/beads_zig/src/models/event.zig-437-    for (event_types) |et| {\nsrc/models/event.zig:438:        var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/event.zig-439-        defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-440-\n/home/hotschmoe/beads_zig/src/models/event.zig-441-        try std.json.Stringify.value(et, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-442-        const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-443-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-585-        .created_at = 1706540000,\n/home/hotschmoe/beads_zig/src/models/event.zig-586-    };\n/home/hotschmoe/beads_zig/src/models/event.zig-587-\nsrc/models/event.zig:588:    var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/event.zig-589-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-590-\n/home/hotschmoe/beads_zig/src/models/event.zig-591-    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-592-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-593-\n--\n/home/hotschmoe/beads_zig/src/models/event.zig-610-        .created_at = 1706540000,\n/home/hotschmoe/beads_zig/src/models/event.zig-611-    };\n/home/hotschmoe/beads_zig/src/models/event.zig-612-\nsrc/models/event.zig:613:    var aw: std.io.Writer.Allocating = .init(allocator);\n/home/hotschmoe/beads_zig/src/models/event.zig-614-    defer aw.deinit();\n/home/hotschmoe/beads_zig/src/models/event.zig-615-\n/home/hotschmoe/beads_zig/src/models/event.zig-616-    try std.json.Stringify.value(event, .{}, &aw.writer);\n/home/hotschmoe/beads_zig/src/models/event.zig-617-    const json_str = aw.written();\n/home/hotschmoe/beads_zig/src/models/event.zig-618-\n--","numLines":50,"appliedLimit":50}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0168iDAhMSCxJ1KDemmiSdMM","type":"message","role":"assistant","content":[{"type":"text","text":"I see - the code uses `std.io.Writer.Allocating` which has a `.writer` field that is the appropriate type. For a simple approach, since I'm just writing simple strings to a fixed buffer, let me use a simpler method - just escape the strings manually or use valueAlloc. For simplicity, let me avoid using json.Stringify for just escaping strings and instead write the JSON manually with simple escaping:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1707,"cache_read_input_tokens":133165,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1707},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"cbf2e12b-8921-4a45-b54f-8e1ccdbbfd79"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0168iDAhMSCxJ1KDemmiSdMM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EnsEEWp6GEo4kEDe9GRsqA","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.Stringify.value(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.Stringify.value(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);","new_string":"    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    try metadata_parts.appendSlice(allocator, \"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, model);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, tool_name);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        var buf: [32]u8 = undefined;\n        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n        try metadata_parts.appendSlice(allocator, s);\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n        try metadata_parts.appendSlice(allocator, metadata);\n        first = false;\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1707,"cache_read_input_tokens":133165,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1707},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0af5db0e-3081-45b9-85af-96931fb84765"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EnsEEWp6GEo4kEDe9GRsqA","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5817df6c-dc3b-46e1-8bd2-1ba556c6c878","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.Stringify.value(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.Stringify.value(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);","newString":"    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    try metadata_parts.appendSlice(allocator, \"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, model);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, tool_name);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        var buf: [32]u8 = undefined;\n        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n        try metadata_parts.appendSlice(allocator, s);\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n        try metadata_parts.appendSlice(allocator, metadata);\n        first = false;\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_buf: [4096]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"prompt\\\":\");\n        try std.json.Stringify.value(prompt, .{}, writer);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try writer.writeAll(\",\");\n        try writer.writeAll(\"\\\"response\\\":\");\n        try std.json.Stringify.value(response, .{}, writer);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try writer.writeAll(\",\");\n        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});\n        first = false;\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.Stringify.value(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":104,"oldLines":49,"newStart":104,"newLines":58,"lines":["     const now = std.time.timestamp();"," ","     // Build metadata JSON with all provided fields","-    var metadata_buf: [4096]u8 = undefined;","-    var fbs = std.io.fixedBufferStream(&metadata_buf);","-    const writer = fbs.writer();","+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};","+    defer metadata_parts.deinit(allocator);"," ","-    try writer.writeAll(\"{\");","+    try metadata_parts.appendSlice(allocator, \"{\");","     var first = true;"," ","     if (record_args.model) |model| {","-        if (!first) try writer.writeAll(\",\");","-        try std.fmt.format(writer, \"\\\"model\\\":\\\"{s}\\\"\", .{model});","+        if (!first) try metadata_parts.appendSlice(allocator, \",\");","+        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");","+        try metadata_parts.appendSlice(allocator, model);","+        try metadata_parts.appendSlice(allocator, \"\\\"\");","         first = false;","     }","     if (record_args.prompt) |prompt| {","-        if (!first) try writer.writeAll(\",\");","-        try writer.writeAll(\"\\\"prompt\\\":\");","-        try std.json.Stringify.value(prompt, .{}, writer);","+        if (!first) try metadata_parts.appendSlice(allocator, \",\");","+        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");","+        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});","+        defer allocator.free(escaped);","+        try metadata_parts.appendSlice(allocator, escaped);","         first = false;","     }","     if (record_args.response) |response| {","-        if (!first) try writer.writeAll(\",\");","-        try writer.writeAll(\"\\\"response\\\":\");","-        try std.json.Stringify.value(response, .{}, writer);","+        if (!first) try metadata_parts.appendSlice(allocator, \",\");","+        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");","+        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});","+        defer allocator.free(escaped);","+        try metadata_parts.appendSlice(allocator, escaped);","         first = false;","     }","     if (record_args.tool_name) |tool_name| {","-        if (!first) try writer.writeAll(\",\");","-        try std.fmt.format(writer, \"\\\"tool_name\\\":\\\"{s}\\\"\", .{tool_name});","+        if (!first) try metadata_parts.appendSlice(allocator, \",\");","+        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");","+        try metadata_parts.appendSlice(allocator, tool_name);","+        try metadata_parts.appendSlice(allocator, \"\\\"\");","         first = false;","     }","     if (record_args.exit_code) |exit_code| {","-        if (!first) try writer.writeAll(\",\");","-        try std.fmt.format(writer, \"\\\"exit_code\\\":{d}\", .{exit_code});","+        if (!first) try metadata_parts.appendSlice(allocator, \",\");","+        var buf: [32]u8 = undefined;","+        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;","+        try metadata_parts.appendSlice(allocator, s);","         first = false;","     }","     if (record_args.metadata) |metadata| {","-        if (!first) try writer.writeAll(\",\");","-        try std.fmt.format(writer, \"\\\"extra\\\":{s}\", .{metadata});","+        if (!first) try metadata_parts.appendSlice(allocator, \",\");","+        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");","+        try metadata_parts.appendSlice(allocator, metadata);","         first = false;","     }","-    try writer.writeAll(\"}\");","+    try metadata_parts.appendSlice(allocator, \"}\");"," ","-    const metadata_json = fbs.getWritten();","-    const new_value = try allocator.dupe(u8, metadata_json);","+    const new_value = try allocator.dupe(u8, metadata_parts.items);","     defer allocator.free(new_value);"," ","     const event = Event{"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015bhSdriKwLc87ZsnHY3m8J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M3JmctnaisggviZmJezhEd","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.Stringify.value(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);","new_string":"    // Build the label metadata\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    var buf: [64]u8 = undefined;\n    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n    try metadata_parts.appendSlice(allocator, header);\n\n    if (label_args.reason) |reason| {\n        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1722,"cache_read_input_tokens":134872,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1722},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"904f4d99-6a9f-4b72-9afd-411c0c4d465e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M3JmctnaisggviZmJezhEd","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"9fadceb0-29ac-429f-b20b-16da8be2ac22","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.Stringify.value(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);","newString":"    // Build the label metadata\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    var buf: [64]u8 = undefined;\n    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n    try metadata_parts.appendSlice(allocator, header);\n\n    if (label_args.reason) |reason| {\n        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    try metadata_parts.appendSlice(allocator, \"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, model);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, tool_name);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        var buf: [32]u8 = undefined;\n        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n        try metadata_parts.appendSlice(allocator, s);\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n        try metadata_parts.appendSlice(allocator, metadata);\n        first = false;\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_buf: [1024]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&metadata_buf);\n    const writer = fbs.writer();\n\n    try writer.writeAll(\"{\");\n    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });\n    if (label_args.reason) |reason| {\n        try writer.writeAll(\",\\\"reason\\\":\");\n        try std.json.Stringify.value(reason, .{}, writer);\n    }\n    try writer.writeAll(\"}\");\n\n    const metadata_json = fbs.getWritten();\n    const new_value = try allocator.dupe(u8, metadata_json);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":196,"oldLines":20,"newStart":196,"newLines":22,"lines":["     const now = std.time.timestamp();"," ","     // Build the label metadata","-    var metadata_buf: [1024]u8 = undefined;","-    var fbs = std.io.fixedBufferStream(&metadata_buf);","-    const writer = fbs.writer();","+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};","+    defer metadata_parts.deinit(allocator);"," ","-    try writer.writeAll(\"{\");","-    try std.fmt.format(writer, \"\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value });","+    var buf: [64]u8 = undefined;","+    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;","+    try metadata_parts.appendSlice(allocator, header);","+","     if (label_args.reason) |reason| {","-        try writer.writeAll(\",\\\"reason\\\":\");","-        try std.json.Stringify.value(reason, .{}, writer);","+        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");","+        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});","+        defer allocator.free(escaped);","+        try metadata_parts.appendSlice(allocator, escaped);","     }","-    try writer.writeAll(\"}\");","+    try metadata_parts.appendSlice(allocator, \"}\");"," ","-    const metadata_json = fbs.getWritten();","-    const new_value = try allocator.dupe(u8, metadata_json);","+    const new_value = try allocator.dupe(u8, metadata_parts.items);","     defer allocator.free(new_value);"," ","     // Use 'updated' event type to represent a label action on an existing entry"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D5irsEaW262Uv5nY85zPPW","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's build again:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":651,"cache_read_input_tokens":136594,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":651},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"df2677d4-212d-4c30-9e00-42a8f6172bfb"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D5irsEaW262Uv5nY85zPPW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B6ofG56y7QN4mBbyuvodGW","name":"Bash","input":{"command":"zig build 2>&1 | head -100","description":"Build beads_zig to verify changes compile","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":651,"cache_read_input_tokens":136594,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":651},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4b167c19-d4a5-4982-8a3a-4c1064dd9118"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B6ofG56y7QN4mBbyuvodGW","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"95da9612-48ab-46b5-9310-fee38e8b15cc","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BDRQKTaZAtnm99Hue8uQnJ","type":"message","role":"assistant","content":[{"type":"text","text":"The code compiles now. Let me run the tests to make sure everything works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":140,"cache_read_input_tokens":137245,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":140},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4612a913-ebdd-4746-87db-3367ad1b20e0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BDRQKTaZAtnm99Hue8uQnJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HKzr259e2JD3s8f51EHVqk","name":"Bash","input":{"command":"zig build test 2>&1 | tail -50","description":"Run tests to verify the changes work","timeout":180000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":140,"cache_read_input_tokens":137245,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":140},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f34857c7-7e97-4f9f-bb2f-411634846a7f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HKzr259e2JD3s8f51EHVqk","type":"tool_result","content":"\u001b[2mtest\n\u001b(0mq\u001b(B run test\n   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/args.zig:2616:68: \u001b[31merror: \u001b[0m\u001b[1mno field named 'limit' in struct 'cli.args.AuditArgs'\n\u001b[0m    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n                                                                   \u001b[32m^~~~~\n\u001b[0m\u001b[1msrc/cli/args.zig:512:23: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0mpub const AuditArgs = struct {\n                      \u001b[32m^~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    args: src/cli/mod.zig:10:26\n    refAllDecls__anon_29705: /opt/zig/lib/std/testing.zig:1179:14\n    4 reference(s) hidden; use '-freference-trace=6' to see all references\n\u001b[0m\u001b[1msrc/cli/audit.zig:537:17: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*cli.args.ParseResult', found '*const cli.args.ParseResult'\n\u001b[0m    defer result.deinit(allocator);\n          \u001b[32m~~~~~~^~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:537:17: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/cli/args.zig:684:25: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n                        \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:559:17: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*cli.args.ParseResult', found '*const cli.args.ParseResult'\n\u001b[0m    defer result.deinit(allocator);\n          \u001b[32m~~~~~~^~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:559:17: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/cli/args.zig:684:25: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n                        \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:579:17: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*cli.args.ParseResult', found '*const cli.args.ParseResult'\n\u001b[0m    defer result.deinit(allocator);\n          \u001b[32m~~~~~~^~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:579:17: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/cli/args.zig:684:25: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n                        \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 4 compilation errors:\n/opt/zig/zig test -ODebug --dep toon_zig -Mroot=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name test --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 0/3 steps succeeded; 1 failed\ntest\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B run test\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x346dc242 -Zb5eccba6ed15e2e7 test","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7e0038e4-3313-4b08-979a-31f4358c4bf3","tool_use_result":{"stdout":"\u001b[2mtest\n\u001b(0mq\u001b(B run test\n   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/args.zig:2616:68: \u001b[31merror: \u001b[0m\u001b[1mno field named 'limit' in struct 'cli.args.AuditArgs'\n\u001b[0m    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n                                                                   \u001b[32m^~~~~\n\u001b[0m\u001b[1msrc/cli/args.zig:512:23: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0mpub const AuditArgs = struct {\n                      \u001b[32m^~~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    args: src/cli/mod.zig:10:26\n    refAllDecls__anon_29705: /opt/zig/lib/std/testing.zig:1179:14\n    4 reference(s) hidden; use '-freference-trace=6' to see all references\n\u001b[0m\u001b[1msrc/cli/audit.zig:537:17: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*cli.args.ParseResult', found '*const cli.args.ParseResult'\n\u001b[0m    defer result.deinit(allocator);\n          \u001b[32m~~~~~~^~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:537:17: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/cli/args.zig:684:25: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n                        \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:559:17: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*cli.args.ParseResult', found '*const cli.args.ParseResult'\n\u001b[0m    defer result.deinit(allocator);\n          \u001b[32m~~~~~~^~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:559:17: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/cli/args.zig:684:25: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n                        \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:579:17: \u001b[31merror: \u001b[0m\u001b[1mexpected type '*cli.args.ParseResult', found '*const cli.args.ParseResult'\n\u001b[0m    defer result.deinit(allocator);\n          \u001b[32m~~~~~~^~~~~~~\n\u001b[0m\u001b[1msrc/cli/audit.zig:579:17: \u001b[36mnote: \u001b[0m\u001b[1mcast discards const qualifier\n\u001b[0m\u001b[1msrc/cli/args.zig:684:25: \u001b[36mnote: \u001b[0m\u001b[1mparameter type declared here\n\u001b[0m    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n                        \u001b[32m^~~~~~~~~~~~\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 4 compilation errors:\n/opt/zig/zig test -ODebug --dep toon_zig -Mroot=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name test --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 0/3 steps succeeded; 1 failed\ntest\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B run test\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile test Debug native\u001b[31m 4 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x346dc242 -Zb5eccba6ed15e2e7 test","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BW8NmqU9GsS3tWDdgNjVaU","type":"message","role":"assistant","content":[{"type":"text","text":"There are some test issues. Let me fix them:\n\n1. There's a test in args.zig that references the old AuditArgs.limit field\n2. My new tests have `const result` but need `var result`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1344,"cache_read_input_tokens":137385,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1344},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"20e1aa10-71cc-4553-b828-a9132a3e4ed6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BW8NmqU9GsS3tWDdgNjVaU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NCMMFU1xjYj6GWNgg8yJNC","name":"Grep","input":{"pattern":"result.command.audit.limit","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1344,"cache_read_input_tokens":137385,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1344},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d6f8704f-cd58-4484-ad33-7009a745fc35"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NCMMFU1xjYj6GWNgg8yJNC","type":"tool_result","content":"2606-    const result = try parser.parse();\n2607-\n2608-    try std.testing.expect(result.command == .audit);\n2609-}\n2610-\n2611-test \"parse audit command with limit\" {\n2612-    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n2613-    var parser = ArgParser.init(std.testing.allocator, &args);\n2614-    const result = try parser.parse();\n2615-\n2616:    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n2617-}\n2618-\n2619-test \"parse sync command\" {\n2620-    const args = [_][]const u8{\"sync\"};\n2621-    var parser = ArgParser.init(std.testing.allocator, &args);\n2622-    const result = try parser.parse();\n2623-\n2624-    try std.testing.expect(result.command == .sync);\n2625-    try std.testing.expect(!result.command.sync.flush_only);\n2626-    try std.testing.expect(!result.command.sync.import_only);"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"88b4d399-abe0-4f38-bf67-834ef310128f","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"2606-    const result = try parser.parse();\n2607-\n2608-    try std.testing.expect(result.command == .audit);\n2609-}\n2610-\n2611-test \"parse audit command with limit\" {\n2612-    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n2613-    var parser = ArgParser.init(std.testing.allocator, &args);\n2614-    const result = try parser.parse();\n2615-\n2616:    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n2617-}\n2618-\n2619-test \"parse sync command\" {\n2620-    const args = [_][]const u8{\"sync\"};\n2621-    var parser = ArgParser.init(std.testing.allocator, &args);\n2622-    const result = try parser.parse();\n2623-\n2624-    try std.testing.expect(result.command == .sync);\n2625-    try std.testing.expect(!result.command.sync.flush_only);\n2626-    try std.testing.expect(!result.command.sync.import_only);","numLines":21}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MFAayJJj3KHK85b5G1qxZB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nhs9PRZ47w8WnBUpbswycA","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"test \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}","new_string":"test \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":493,"cache_read_input_tokens":138729,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":493},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b86ce8f2-b153-405b-85a8-1fc6eb54e169"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nhs9PRZ47w8WnBUpbswycA","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"da54fbec-57d0-402e-a21e-82be8d7d7adc","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"test \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}","newString":"test \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":2611,"oldLines":9,"newStart":2611,"newLines":13,"lines":[" test \"parse audit command with limit\" {","     const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };","     var parser = ArgParser.init(std.testing.allocator, &args);","-    const result = try parser.parse();","+    var result = try parser.parse();","+    defer result.deinit(std.testing.allocator);"," ","-    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);","+    switch (result.command.audit.subcommand) {","+        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),","+        else => try std.testing.expect(false),","+    }"," }"," "," test \"parse sync command\" {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KepAHJxMtWq51sK8HWswXz","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me fix the audit.zig tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":404,"cache_read_input_tokens":139222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":404},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2f9fc497-86b3-4692-a14b-83c1e0f83c6a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KepAHJxMtWq51sK8HWswXz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MYpgesACj9CiYn5yiuDKdw","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig","old_string":"test \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}","new_string":"test \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":404,"cache_read_input_tokens":139222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":404},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0a4a066f-bb0d-44d3-b23d-759a7909ca01"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MYpgesACj9CiYn5yiuDKdw","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/audit.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8642004e-55c8-4b4b-a2e9-5f7cad961d4c","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","oldString":"test \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}","newString":"test \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}","originalFile":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    try metadata_parts.appendSlice(allocator, \"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, model);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, tool_name);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        var buf: [32]u8 = undefined;\n        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n        try metadata_parts.appendSlice(allocator, s);\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n        try metadata_parts.appendSlice(allocator, metadata);\n        first = false;\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    var buf: [64]u8 = undefined;\n    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n    try metadata_parts.appendSlice(allocator, header);\n\n    if (label_args.reason) |reason| {\n        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    const result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":533,"oldLines":7,"newStart":533,"newLines":7,"lines":["     const allocator = std.testing.allocator;","     const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };","     var parser = args.ArgParser.init(allocator, &cmd_args);","-    const result = parser.parse() catch unreachable;","+    var result = parser.parse() catch unreachable;","     defer result.deinit(allocator);"," ","     switch (result.command) {"]},{"oldStart":555,"oldLines":7,"newStart":555,"newLines":7,"lines":["     const allocator = std.testing.allocator;","     const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };","     var parser = args.ArgParser.init(allocator, &cmd_args);","-    const result = parser.parse() catch unreachable;","+    var result = parser.parse() catch unreachable;","     defer result.deinit(allocator);"," ","     switch (result.command) {"]},{"oldStart":575,"oldLines":7,"newStart":575,"newLines":7,"lines":["     const allocator = std.testing.allocator;","     const cmd_args = [_][]const u8{\"audit\"};","     var parser = args.ArgParser.init(allocator, &cmd_args);","-    const result = parser.parse() catch unreachable;","+    var result = parser.parse() catch unreachable;","     defer result.deinit(allocator);"," ","     switch (result.command) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019cJiGFrj3ibrKeQkcn3wYV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PHP8LTeMtCgRoW9nakvJaf","name":"Bash","input":{"command":"zig build test 2>&1 | tail -50","description":"Run tests to verify changes","timeout":180000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1596,"cache_read_input_tokens":139626,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1596},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8a8c30b5-d515-4de4-b451-de703b654cfa"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PHP8LTeMtCgRoW9nakvJaf","type":"tool_result","content":"640/681 id.hash.test.contentHash different for different flags...OK\n641/681 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n642/681 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n643/681 id.hash.test.contentHash ignores id field...OK\n644/681 id.hash.test.contentHash ignores timestamps...OK\n645/681 id.hash.test.contentHash with custom status...OK\n646/681 id.hash.test.contentHash with custom issue_type...OK\n647/681 config.yaml.test.parse simple key-value...OK\n648/681 config.yaml.test.parse with comments...OK\n649/681 config.yaml.test.parse nested structure...OK\n650/681 config.yaml.test.parse quoted values...OK\n651/681 config.yaml.test.parse empty value...OK\n652/681 config.yaml.test.get returns null for missing key...OK\n653/681 config.yaml.test.parse handles Windows line endings...OK\n654/681 config.yaml.test.parse ignores blank lines...OK\n655/681 tests.cli_test.test.bz version shows version info...OK\n656/681 tests.cli_test.test.bz help shows usage...OK\n657/681 tests.cli_test.test.bz --help shows usage...OK\n658/681 tests.cli_test.test.bz init creates workspace...OK\n659/681 tests.cli_test.test.bz init fails when already initialized...OK\n660/681 tests.cli_test.test.bz create returns ID...OK\n661/681 tests.cli_test.test.bz q returns ID...OK\n662/681 tests.cli_test.test.bz list returns issues...OK\n663/681 tests.cli_test.test.bz list --json returns output...OK\n664/681 tests.cli_test.test.bz show displays issue...OK\n665/681 tests.cli_test.test.bz show not-found returns error...OK\n666/681 tests.cli_test.test.bz close marks issue as closed...OK\n667/681 tests.cli_test.test.bz reopen reopens closed issue...OK\n668/681 tests.cli_test.test.bz delete soft deletes issue...OK\n669/681 tests.cli_test.test.bz search finds matching issues...OK\n670/681 tests.cli_test.test.bz dep add creates dependency...OK\n671/681 tests.cli_test.test.bz dep add rejects cycles...OK\n672/681 tests.cli_test.test.bz ready shows unblocked issues...OK\n673/681 tests.cli_test.test.bz blocked shows blocked issues...OK\n674/681 tests.cli_test.test.bz unknown command returns error...OK\n675/681 tests.cli_test.test.bz without workspace shows error...OK\n676/681 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n677/681 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n678/681 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n679/681 tests.stress_test.test.sequential writes: single thread baseline...OK\n680/681 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n681/681 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 681 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f88d0c8a-6fbd-4b1e-9508-700309dbbfbb","tool_use_result":{"stdout":"640/681 id.hash.test.contentHash different for different flags...OK\n641/681 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n642/681 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n643/681 id.hash.test.contentHash ignores id field...OK\n644/681 id.hash.test.contentHash ignores timestamps...OK\n645/681 id.hash.test.contentHash with custom status...OK\n646/681 id.hash.test.contentHash with custom issue_type...OK\n647/681 config.yaml.test.parse simple key-value...OK\n648/681 config.yaml.test.parse with comments...OK\n649/681 config.yaml.test.parse nested structure...OK\n650/681 config.yaml.test.parse quoted values...OK\n651/681 config.yaml.test.parse empty value...OK\n652/681 config.yaml.test.get returns null for missing key...OK\n653/681 config.yaml.test.parse handles Windows line endings...OK\n654/681 config.yaml.test.parse ignores blank lines...OK\n655/681 tests.cli_test.test.bz version shows version info...OK\n656/681 tests.cli_test.test.bz help shows usage...OK\n657/681 tests.cli_test.test.bz --help shows usage...OK\n658/681 tests.cli_test.test.bz init creates workspace...OK\n659/681 tests.cli_test.test.bz init fails when already initialized...OK\n660/681 tests.cli_test.test.bz create returns ID...OK\n661/681 tests.cli_test.test.bz q returns ID...OK\n662/681 tests.cli_test.test.bz list returns issues...OK\n663/681 tests.cli_test.test.bz list --json returns output...OK\n664/681 tests.cli_test.test.bz show displays issue...OK\n665/681 tests.cli_test.test.bz show not-found returns error...OK\n666/681 tests.cli_test.test.bz close marks issue as closed...OK\n667/681 tests.cli_test.test.bz reopen reopens closed issue...OK\n668/681 tests.cli_test.test.bz delete soft deletes issue...OK\n669/681 tests.cli_test.test.bz search finds matching issues...OK\n670/681 tests.cli_test.test.bz dep add creates dependency...OK\n671/681 tests.cli_test.test.bz dep add rejects cycles...OK\n672/681 tests.cli_test.test.bz ready shows unblocked issues...OK\n673/681 tests.cli_test.test.bz blocked shows blocked issues...OK\n674/681 tests.cli_test.test.bz unknown command returns error...OK\n675/681 tests.cli_test.test.bz without workspace shows error...OK\n676/681 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n677/681 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n678/681 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n679/681 tests.stress_test.test.sequential writes: single thread baseline...OK\n680/681 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n681/681 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 681 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BSrEHb6Y1HMvnH8JHgeqQB","type":"message","role":"assistant","content":[{"type":"text","text":"All 681 tests pass. Task 1 is complete. Let me update the todo list and move to Task 2:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1035,"cache_read_input_tokens":141222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1035},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"94867ba2-35c3-461e-a28e-01ab08d0f617"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BSrEHb6Y1HMvnH8JHgeqQB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QEvHrCqx7HonSzKLD5anyJ","name":"TodoWrite","input":{"todos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"completed","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"in_progress","activeForm":"Adding --activity git-based stats to stats command"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1035,"cache_read_input_tokens":141222,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1035},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6d2c6cfe-d6bc-4063-9117-490074e050db"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QEvHrCqx7HonSzKLD5anyJ","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c234e3e6-7834-4bfa-ba48-43ccc51696c6","tool_use_result":{"oldTodos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"in_progress","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"pending","activeForm":"Adding --activity git-based stats to stats command"}],"newTodos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"completed","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"in_progress","activeForm":"Adding --activity git-based stats to stats command"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MfTMwoTUVR6LjssEcYCBER","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me implement Task 2: Add `--activity` git-based stats to the stats command. I need to modify the stats command to show git-based activity statistics that correlate issue activity with git commits."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":202,"cache_read_input_tokens":142257,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":202},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"ceb580b4-bc5c-4c5d-b4bf-3e1799a4aa8f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MfTMwoTUVR6LjssEcYCBER","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UG8PXtCqoXhevW1nEjvRsq","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/stats.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":202,"cache_read_input_tokens":142257,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":202},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a467e319-4ffb-447a-8b00-b560bd92e334"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UG8PXtCqoXhevW1nEjvRsq","type":"tool_result","content":"     1→//! Stats command for beads_zig.\n     2→//!\n     3→//! `bz stats` - Show project statistics\n     4→\n     5→const std = @import(\"std\");\n     6→const common = @import(\"common.zig\");\n     7→const args = @import(\"args.zig\");\n     8→\n     9→const CommandContext = common.CommandContext;\n    10→\n    11→pub const StatsError = error{\n    12→    WorkspaceNotInitialized,\n    13→    StorageError,\n    14→    OutOfMemory,\n    15→};\n    16→\n    17→pub const StatsResult = struct {\n    18→    success: bool,\n    19→    total: ?usize = null,\n    20→    open: ?usize = null,\n    21→    closed: ?usize = null,\n    22→    by_status: ?[]const CountEntry = null,\n    23→    by_priority: ?[]const CountEntry = null,\n    24→    by_type: ?[]const CountEntry = null,\n    25→    message: ?[]const u8 = null,\n    26→\n    27→    pub const CountEntry = struct {\n    28→        key: []const u8,\n    29→        count: usize,\n    30→    };\n    31→};\n    32→\n    33→pub fn run(\n    34→    global: args.GlobalOptions,\n    35→    allocator: std.mem.Allocator,\n    36→) !void {\n    37→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    38→        return StatsError.WorkspaceNotInitialized;\n    39→    };\n    40→    defer ctx.deinit();\n    41→\n    42→    // Count totals\n    43→    var total: usize = 0;\n    44→    var open: usize = 0;\n    45→    var closed: usize = 0;\n    46→\n    47→    // Count by status\n    48→    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    49→    defer status_counts.deinit(allocator);\n    50→\n    51→    // Count by priority\n    52→    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n    53→\n    54→    // Count by type\n    55→    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    56→    defer type_counts.deinit(allocator);\n    57→\n    58→    for (ctx.store.issues.items) |issue| {\n    59→        if (issue.status.eql(.tombstone)) continue;\n    60→\n    61→        total += 1;\n    62→\n    63→        // Status\n    64→        const status_str = issue.status.toString();\n    65→        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n    66→        status_entry.value_ptr.* += 1;\n    67→\n    68→        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n    69→            open += 1;\n    70→        } else if (issue.status.eql(.closed)) {\n    71→            closed += 1;\n    72→        }\n    73→\n    74→        // Priority\n    75→        if (issue.priority.value <= 4) {\n    76→            priority_counts[issue.priority.value] += 1;\n    77→        }\n    78→\n    79→        // Type\n    80→        const type_str = issue.issue_type.toString();\n    81→        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n    82→        type_entry.value_ptr.* += 1;\n    83→    }\n    84→\n    85→    // Convert to arrays for output\n    86→    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    87→    defer status_list.deinit(allocator);\n    88→\n    89→    var status_it = status_counts.iterator();\n    90→    while (status_it.next()) |entry| {\n    91→        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    92→    }\n    93→\n    94→    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    95→    defer priority_list.deinit(allocator);\n    96→\n    97→    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    98→    for (0..5) |i| {\n    99→        if (priority_counts[i] > 0) {\n   100→            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n   101→        }\n   102→    }\n   103→\n   104→    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n   105→    defer type_list.deinit(allocator);\n   106→\n   107→    var type_it = type_counts.iterator();\n   108→    while (type_it.next()) |entry| {\n   109→        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n   110→    }\n   111→\n   112→    if (global.isStructuredOutput()) {\n   113→        try ctx.output.printJson(StatsResult{\n   114→            .success = true,\n   115→            .total = total,\n   116→            .open = open,\n   117→            .closed = closed,\n   118→            .by_status = status_list.items,\n   119→            .by_priority = priority_list.items,\n   120→            .by_type = type_list.items,\n   121→        });\n   122→    } else if (!global.quiet) {\n   123→        try ctx.output.println(\"Issue Statistics\", .{});\n   124→        try ctx.output.print(\"\\n\", .{});\n   125→        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n   126→        try ctx.output.print(\"\\n\", .{});\n   127→\n   128→        if (status_list.items.len > 0) {\n   129→            try ctx.output.print(\"By Status:\\n\", .{});\n   130→            for (status_list.items) |entry| {\n   131→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   132→            }\n   133→        }\n   134→\n   135→        if (priority_list.items.len > 0) {\n   136→            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n   137→            for (priority_list.items) |entry| {\n   138→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   139→            }\n   140→        }\n   141→\n   142→        if (type_list.items.len > 0) {\n   143→            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n   144→            for (type_list.items) |entry| {\n   145→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   146→            }\n   147→        }\n   148→    }\n   149→}\n   150→\n   151→// --- Tests ---\n   152→\n   153→test \"StatsError enum exists\" {\n   154→    const err: StatsError = StatsError.WorkspaceNotInitialized;\n   155→    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n   156→}\n   157→\n   158→test \"StatsResult struct works\" {\n   159→    const result = StatsResult{\n   160→        .success = true,\n   161→        .total = 10,\n   162→        .open = 5,\n   163→        .closed = 5,\n   164→    };\n   165→    try std.testing.expect(result.success);\n   166→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   167→}\n   168→\n   169→test \"run detects uninitialized workspace\" {\n   170→    const allocator = std.testing.allocator;\n   171→\n   172→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   173→\n   174→    const result = run(global, allocator);\n   175→    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n   176→}\n   177→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"9011f5d7-74b4-4187-ba4f-f8bcd7320ef1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/stats.zig","content":"//! Stats command for beads_zig.\n//!\n//! `bz stats` - Show project statistics\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const StatsError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const StatsResult = struct {\n    success: bool,\n    total: ?usize = null,\n    open: ?usize = null,\n    closed: ?usize = null,\n    by_status: ?[]const CountEntry = null,\n    by_priority: ?[]const CountEntry = null,\n    by_type: ?[]const CountEntry = null,\n    message: ?[]const u8 = null,\n\n    pub const CountEntry = struct {\n        key: []const u8,\n        count: usize,\n    };\n};\n\npub fn run(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return StatsError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count totals\n    var total: usize = 0;\n    var open: usize = 0;\n    var closed: usize = 0;\n\n    // Count by status\n    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer status_counts.deinit(allocator);\n\n    // Count by priority\n    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n\n    // Count by type\n    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer type_counts.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        total += 1;\n\n        // Status\n        const status_str = issue.status.toString();\n        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n        status_entry.value_ptr.* += 1;\n\n        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n            open += 1;\n        } else if (issue.status.eql(.closed)) {\n            closed += 1;\n        }\n\n        // Priority\n        if (issue.priority.value <= 4) {\n            priority_counts[issue.priority.value] += 1;\n        }\n\n        // Type\n        const type_str = issue.issue_type.toString();\n        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n        type_entry.value_ptr.* += 1;\n    }\n\n    // Convert to arrays for output\n    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer status_list.deinit(allocator);\n\n    var status_it = status_counts.iterator();\n    while (status_it.next()) |entry| {\n        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer priority_list.deinit(allocator);\n\n    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    for (0..5) |i| {\n        if (priority_counts[i] > 0) {\n            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n        }\n    }\n\n    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer type_list.deinit(allocator);\n\n    var type_it = type_counts.iterator();\n    while (type_it.next()) |entry| {\n        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(StatsResult{\n            .success = true,\n            .total = total,\n            .open = open,\n            .closed = closed,\n            .by_status = status_list.items,\n            .by_priority = priority_list.items,\n            .by_type = type_list.items,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Issue Statistics\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n        try ctx.output.print(\"\\n\", .{});\n\n        if (status_list.items.len > 0) {\n            try ctx.output.print(\"By Status:\\n\", .{});\n            for (status_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (priority_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n            for (priority_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (type_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n            for (type_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"StatsError enum exists\" {\n    const err: StatsError = StatsError.WorkspaceNotInitialized;\n    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n}\n\ntest \"StatsResult struct works\" {\n    const result = StatsResult{\n        .success = true,\n        .total = 10,\n        .open = 5,\n        .closed = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(global, allocator);\n    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n}\n","numLines":177,"startLine":1,"totalLines":177}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q5FwYkhSBg2a7j25n2JKQc","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to:\n1. Add `--activity` and `--activity-hours` flags to the stats command in args.zig\n2. Update the stats command to include git-based activity statistics\n\nLet me first find how stats is handled in args.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2565,"cache_read_input_tokens":142459,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2565},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"de385e48-88f3-4c75-a3cb-bcb7fed29f41"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q5FwYkhSBg2a7j25n2JKQc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PyNwWm1kay8tH3nJrp7AyG","name":"Grep","input":{"pattern":"stats:","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2565,"cache_read_input_tokens":142459,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2565},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"27c86ef5-75ae-41d1-abcd-e971deddbe82"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PyNwWm1kay8tH3nJrp7AyG","type":"tool_result","content":"13-    quiet: bool = false,\n14-    silent: bool = false, // Suppress ALL output including errors (for tests)\n15-    verbose: u8 = 0,\n16-    no_color: bool = false,\n17-    wrap: bool = false, // Wrap long lines in plain text output\n18:    stats: bool = false, // Show token savings stats for TOON output\n19-    data_path: ?[]const u8 = null,\n20-    actor: ?[]const u8 = null,\n21-    lock_timeout: u32 = 5000,\n22-    no_auto_flush: bool = false,\n23-    no_auto_import: bool = false,\n--\n36-/// All available subcommands.\n37-pub const Command = union(enum) {\n38-    // Workspace\n39-    init: InitArgs,\n40-    info: void,\n41:    stats: void,\n42-    doctor: void,\n43-    config: ConfigArgs,\n44-    orphans: OrphansArgs,\n45-    lint: LintArgs,\n46-    where: void,"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"13c2e5a1-2248-40ef-89cc-bbb860d774e2","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"13-    quiet: bool = false,\n14-    silent: bool = false, // Suppress ALL output including errors (for tests)\n15-    verbose: u8 = 0,\n16-    no_color: bool = false,\n17-    wrap: bool = false, // Wrap long lines in plain text output\n18:    stats: bool = false, // Show token savings stats for TOON output\n19-    data_path: ?[]const u8 = null,\n20-    actor: ?[]const u8 = null,\n21-    lock_timeout: u32 = 5000,\n22-    no_auto_flush: bool = false,\n23-    no_auto_import: bool = false,\n--\n36-/// All available subcommands.\n37-pub const Command = union(enum) {\n38-    // Workspace\n39-    init: InitArgs,\n40-    info: void,\n41:    stats: void,\n42-    doctor: void,\n43-    config: ConfigArgs,\n44-    orphans: OrphansArgs,\n45-    lint: LintArgs,\n46-    where: void,","numLines":23}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TCsNcB89V66Q4VzamLQwu9","type":"message","role":"assistant","content":[{"type":"text","text":"I see that `stats` is currently `void` (no args). I need to change it to use `StatsArgs` with the `--activity` and `--activity-hours` flags. Let me update args.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":472,"cache_read_input_tokens":145024,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":472},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6f2cb395-2944-49b8-8100-ffc8845f00a9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TCsNcB89V66Q4VzamLQwu9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015A6XrghaWDitGtLsL8F1HM","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,","new_string":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":472,"cache_read_input_tokens":145024,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":472},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4d3b7f0b-ecc8-42da-bfe6-9878b3779e4f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015A6XrghaWDitGtLsL8F1HM","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6fd1a526-139d-4051-907a-43923f4972a3","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,","newString":"    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":38,"oldLines":7,"newStart":38,"newLines":7,"lines":["     // Workspace","     init: InitArgs,","     info: void,","-    stats: void,","+    stats: StatsArgs,","     doctor: void,","     config: ConfigArgs,","     orphans: OrphansArgs,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Sx7YwC7a228QiGQ1CsUxCt","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the StatsArgs struct. Let me find where to put it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":280,"cache_read_input_tokens":145496,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":280},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d2bb2b76-7b81-4d78-926b-5909a9868cc5"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Sx7YwC7a228QiGQ1CsUxCt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K4bG4g3xLfKey3H9nSfsQN","name":"Grep","input":{"pattern":"pub const InfoError|pub const InitArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":280,"cache_read_input_tokens":145496,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":280},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"ac1f73fc-e760-40f8-9e8c-8a8a085d6dd8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K4bG4g3xLfKey3H9nSfsQN","type":"tool_result","content":"111-};\n112-\n113-/// Init command arguments.\n114:pub const InitArgs = struct {\n115-    prefix: []const u8 = \"bd\",\n116-};\n117-"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"192f3c80-df80-4347-ab4a-4a35839958a6","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"111-};\n112-\n113-/// Init command arguments.\n114:pub const InitArgs = struct {\n115-    prefix: []const u8 = \"bd\",\n116-};\n117-","numLines":7}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WHRDZqKFXtzwm4cSdojFf2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YKG9cwykRkMnJuAPHfHNwM","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};","new_string":"/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":213,"cache_read_input_tokens":145776,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":213},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a4c81284-67eb-4cd1-a5ad-f6a8948a713a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YKG9cwykRkMnJuAPHfHNwM","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2add0798-5fb0-4753-b332-1b076193fbf0","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};","newString":"/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":115,"oldLines":6,"newStart":115,"newLines":12,"lines":["     prefix: []const u8 = \"bd\","," };"," ","+/// Stats command arguments.","+pub const StatsArgs = struct {","+    activity: bool = false, // Show git-based activity statistics","+    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)","+};","+"," /// Create command arguments."," pub const CreateArgs = struct {","     title: []const u8,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0176Bgc966SftracZZCxRqkh","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to find where the stats command is parsed and update it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":283,"cache_read_input_tokens":145989,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":283},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5e88615a-2ab6-4ff6-bf25-fc82f7338252"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0176Bgc966SftracZZCxRqkh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016SxZdGwDaEauf7bKmBjnnk","name":"Grep","input":{"pattern":"stats","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":283,"cache_read_input_tokens":145989,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":283},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e70348ea-add5-4150-823c-81a1e923b49d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016SxZdGwDaEauf7bKmBjnnk","type":"tool_result","content":"13-    quiet: bool = false,\n14-    silent: bool = false, // Suppress ALL output including errors (for tests)\n15-    verbose: u8 = 0,\n16-    no_color: bool = false,\n17-    wrap: bool = false, // Wrap long lines in plain text output\n18:    stats: bool = false, // Show token savings stats for TOON output\n19-    data_path: ?[]const u8 = null,\n20-    actor: ?[]const u8 = null,\n21-    lock_timeout: u32 = 5000,\n22-    no_auto_flush: bool = false,\n23-    no_auto_import: bool = false,\n--\n36-/// All available subcommands.\n37-pub const Command = union(enum) {\n38-    // Workspace\n39-    init: InitArgs,\n40-    info: void,\n41:    stats: StatsArgs,\n42-    doctor: void,\n43-    config: ConfigArgs,\n44-    orphans: OrphansArgs,\n45-    lint: LintArgs,\n46-    where: void,\n--\n116-};\n117-\n118-/// Stats command arguments.\n119-pub const StatsArgs = struct {\n120-    activity: bool = false, // Show git-based activity statistics\n121:    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n122-};\n123-\n124-/// Create command arguments.\n125-pub const CreateArgs = struct {\n126-    title: []const u8,\n--\n819-        }\n820-        if (std.mem.eql(u8, arg, \"--wrap\")) {\n821-            global.wrap = true;\n822-            return true;\n823-        }\n824:        if (std.mem.eql(u8, arg, \"--stats\")) {\n825:            global.stats = true;\n826-            return true;\n827-        }\n828-        if (std.mem.eql(u8, arg, \"--robot\")) {\n829-            global.robot = true;\n830-            return true;\n--\n841-            return .{ .init = try self.parseInitArgs() };\n842-        }\n843-        if (std.mem.eql(u8, cmd, \"info\")) {\n844-            return .{ .info = {} };\n845-        }\n846:        if (std.mem.eql(u8, cmd, \"stats\")) {\n847:            return .{ .stats = {} };\n848-        }\n849-        if (std.mem.eql(u8, cmd, \"doctor\")) {\n850-            return .{ .doctor = {} };\n851-        }\n852-        if (std.mem.eql(u8, cmd, \"config\")) {"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"66dc4a5e-638f-42ee-a8d4-e3727a138e02","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"13-    quiet: bool = false,\n14-    silent: bool = false, // Suppress ALL output including errors (for tests)\n15-    verbose: u8 = 0,\n16-    no_color: bool = false,\n17-    wrap: bool = false, // Wrap long lines in plain text output\n18:    stats: bool = false, // Show token savings stats for TOON output\n19-    data_path: ?[]const u8 = null,\n20-    actor: ?[]const u8 = null,\n21-    lock_timeout: u32 = 5000,\n22-    no_auto_flush: bool = false,\n23-    no_auto_import: bool = false,\n--\n36-/// All available subcommands.\n37-pub const Command = union(enum) {\n38-    // Workspace\n39-    init: InitArgs,\n40-    info: void,\n41:    stats: StatsArgs,\n42-    doctor: void,\n43-    config: ConfigArgs,\n44-    orphans: OrphansArgs,\n45-    lint: LintArgs,\n46-    where: void,\n--\n116-};\n117-\n118-/// Stats command arguments.\n119-pub const StatsArgs = struct {\n120-    activity: bool = false, // Show git-based activity statistics\n121:    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n122-};\n123-\n124-/// Create command arguments.\n125-pub const CreateArgs = struct {\n126-    title: []const u8,\n--\n819-        }\n820-        if (std.mem.eql(u8, arg, \"--wrap\")) {\n821-            global.wrap = true;\n822-            return true;\n823-        }\n824:        if (std.mem.eql(u8, arg, \"--stats\")) {\n825:            global.stats = true;\n826-            return true;\n827-        }\n828-        if (std.mem.eql(u8, arg, \"--robot\")) {\n829-            global.robot = true;\n830-            return true;\n--\n841-            return .{ .init = try self.parseInitArgs() };\n842-        }\n843-        if (std.mem.eql(u8, cmd, \"info\")) {\n844-            return .{ .info = {} };\n845-        }\n846:        if (std.mem.eql(u8, cmd, \"stats\")) {\n847:            return .{ .stats = {} };\n848-        }\n849-        if (std.mem.eql(u8, cmd, \"doctor\")) {\n850-            return .{ .doctor = {} };\n851-        }\n852-        if (std.mem.eql(u8, cmd, \"config\")) {","numLines":61}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kie1UvXczctb5NSsJDKjFx","type":"message","role":"assistant","content":[{"type":"text","text":"I need to change the line where stats is parsed to use parseStatsArgs:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":993,"cache_read_input_tokens":146272,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":993},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3d9741b4-614c-447e-af17-b5018454267b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kie1UvXczctb5NSsJDKjFx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JVLPouhVLYnTz6U9F2dB7M","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }","new_string":"        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":993,"cache_read_input_tokens":146272,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":993},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"23e35901-4469-40cb-a7c3-24cd160b3fdd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JVLPouhVLYnTz6U9F2dB7M","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c73e5968-7526-47a8-933e-c36b4fadced5","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }","newString":"        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":844,"oldLines":7,"newStart":844,"newLines":7,"lines":["             return .{ .info = {} };","         }","         if (std.mem.eql(u8, cmd, \"stats\")) {","-            return .{ .stats = {} };","+            return .{ .stats = try self.parseStatsArgs() };","         }","         if (std.mem.eql(u8, cmd, \"doctor\")) {","             return .{ .doctor = {} };"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QvuJJ3YmJPiAcF61ZrNEfd","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the parseStatsArgs function. Let me find a good place to add it near other parse functions:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":258,"cache_read_input_tokens":147265,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":258},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5d484833-afe9-4442-852e-8e6237b83731"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QvuJJ3YmJPiAcF61ZrNEfd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Wfie9AenunMQt4FVL2fE2w","name":"Grep","input":{"pattern":"fn parseInitArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","-C":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":258,"cache_read_input_tokens":147265,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":258},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"17a65f95-c9d0-43ef-9383-1e912e932454"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Wfie9AenunMQt4FVL2fE2w","type":"tool_result","content":"985-        }\n986-\n987-        // Self-upgrade\n988-        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n989-            return .{ .upgrade = try self.parseUpgradeArgs() };\n990-        }\n991-\n992-        // Help\n993-        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n994-            return .{ .help = try self.parseHelpArgs() };\n995-        }\n996-\n997-        return error.UnknownCommand;\n998-    }\n999-\n1000:    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n1001-        var result = InitArgs{};\n1002-        while (self.hasNext()) {\n1003-            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n1004-                result.prefix = self.next() orelse return error.MissingFlagValue;\n1005-            } else if (self.peekPositional()) |_| {\n1006-                result.prefix = self.next().?;\n1007-            } else break;\n1008-        }\n1009-        return result;\n1010-    }\n1011-\n1012-    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n1013-        var result = CreateArgs{ .title = undefined };\n1014-        var title_set = false;\n1015-        var labels: std.ArrayListUnmanaged([]const u8) = .{};"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d0050660-a484-4331-87c6-5c686e06a06a","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"985-        }\n986-\n987-        // Self-upgrade\n988-        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n989-            return .{ .upgrade = try self.parseUpgradeArgs() };\n990-        }\n991-\n992-        // Help\n993-        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n994-            return .{ .help = try self.parseHelpArgs() };\n995-        }\n996-\n997-        return error.UnknownCommand;\n998-    }\n999-\n1000:    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n1001-        var result = InitArgs{};\n1002-        while (self.hasNext()) {\n1003-            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n1004-                result.prefix = self.next() orelse return error.MissingFlagValue;\n1005-            } else if (self.peekPositional()) |_| {\n1006-                result.prefix = self.next().?;\n1007-            } else break;\n1008-        }\n1009-        return result;\n1010-    }\n1011-\n1012-    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n1013-        var result = CreateArgs{ .title = undefined };\n1014-        var title_set = false;\n1015-        var labels: std.ArrayListUnmanaged([]const u8) = .{};","numLines":31}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FzP5YDn3ymxNi92tpdU7dx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UikJQhmgBTR8axD9jp44dp","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }","new_string":"    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n        var result = StatsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-a\", \"--activity\")) {\n                result.activity = true;\n            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":572,"cache_read_input_tokens":147523,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":572},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3f9c8c49-eee5-4c20-a44d-4518dbb8ad5c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UikJQhmgBTR8axD9jp44dp","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1daacacc-350a-4742-abad-b3fc6178815a","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }","newString":"    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n        var result = StatsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-a\", \"--activity\")) {\n                result.activity = true;\n            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1009,"oldLines":6,"newStart":1009,"newLines":18,"lines":["         return result;","     }"," ","+    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {","+        var result = StatsArgs{};","+        while (self.hasNext()) {","+            if (self.consumeFlag(\"-a\", \"--activity\")) {","+                result.activity = true;","+            } else if (self.consumeFlag(null, \"--activity-hours\")) {","+                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;","+            } else break;","+        }","+        return result;","+    }","+","     fn parseCreateArgs(self: *Self) ParseError!CreateArgs {","         var result = CreateArgs{ .title = undefined };","         var title_set = false;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UCf5MnQ5oegJry9EAs95Hn","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the stats.zig to handle the new arguments and show git-based activity. Let me update it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":538,"cache_read_input_tokens":148095,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":538},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c1d82a8a-5a8d-4b28-a712-08289b4e1b7b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UCf5MnQ5oegJry9EAs95Hn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0145rKWMQfiG3VXfSFkMxUme","name":"Write","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/stats.zig","content":"//! Stats command for beads_zig.\n//!\n//! `bz stats` - Show project statistics\n//! `bz stats --activity` - Show git-based activity statistics\n//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const StatsError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    GitError,\n};\n\npub const StatsResult = struct {\n    success: bool,\n    total: ?usize = null,\n    open: ?usize = null,\n    closed: ?usize = null,\n    by_status: ?[]const CountEntry = null,\n    by_priority: ?[]const CountEntry = null,\n    by_type: ?[]const CountEntry = null,\n    activity: ?ActivityStats = null,\n    message: ?[]const u8 = null,\n\n    pub const CountEntry = struct {\n        key: []const u8,\n        count: usize,\n    };\n\n    pub const ActivityStats = struct {\n        period_hours: u32,\n        git_commits: usize,\n        issues_created: usize,\n        issues_closed: usize,\n        issues_updated: usize,\n        commits_with_issue_refs: usize,\n        issue_refs: ?[]const IssueRef = null,\n\n        pub const IssueRef = struct {\n            issue_id: []const u8,\n            commit_count: usize,\n        };\n    };\n};\n\npub fn run(\n    stats_args: args.StatsArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return StatsError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count totals\n    var total: usize = 0;\n    var open: usize = 0;\n    var closed: usize = 0;\n\n    // Count by status\n    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer status_counts.deinit(allocator);\n\n    // Count by priority\n    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n\n    // Count by type\n    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer type_counts.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        total += 1;\n\n        // Status\n        const status_str = issue.status.toString();\n        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n        status_entry.value_ptr.* += 1;\n\n        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n            open += 1;\n        } else if (issue.status.eql(.closed)) {\n            closed += 1;\n        }\n\n        // Priority\n        if (issue.priority.value <= 4) {\n            priority_counts[issue.priority.value] += 1;\n        }\n\n        // Type\n        const type_str = issue.issue_type.toString();\n        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n        type_entry.value_ptr.* += 1;\n    }\n\n    // Convert to arrays for output\n    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer status_list.deinit(allocator);\n\n    var status_it = status_counts.iterator();\n    while (status_it.next()) |entry| {\n        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer priority_list.deinit(allocator);\n\n    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    for (0..5) |i| {\n        if (priority_counts[i] > 0) {\n            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n        }\n    }\n\n    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer type_list.deinit(allocator);\n\n    var type_it = type_counts.iterator();\n    while (type_it.next()) |entry| {\n        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    // Activity stats (if requested)\n    var activity_stats: ?StatsResult.ActivityStats = null;\n    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n    defer issue_refs_list.deinit(allocator);\n\n    if (stats_args.activity) {\n        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(StatsResult{\n            .success = true,\n            .total = total,\n            .open = open,\n            .closed = closed,\n            .by_status = status_list.items,\n            .by_priority = priority_list.items,\n            .by_type = type_list.items,\n            .activity = activity_stats,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Issue Statistics\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n        try ctx.output.print(\"\\n\", .{});\n\n        if (status_list.items.len > 0) {\n            try ctx.output.print(\"By Status:\\n\", .{});\n            for (status_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (priority_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n            for (priority_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (type_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n            for (type_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (activity_stats) |activity| {\n            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n\n            if (activity.issue_refs) |refs| {\n                if (refs.len > 0) {\n                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n                    for (refs[0..@min(10, refs.len)]) |ref| {\n                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n                    }\n                    if (refs.len > 10) {\n                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn getActivityStats(\n    allocator: std.mem.Allocator,\n    ctx: *CommandContext,\n    hours: u32,\n    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n) !StatsResult.ActivityStats {\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n\n    // Count issue activity in the time period\n    var issues_created: usize = 0;\n    var issues_closed: usize = 0;\n    var issues_updated: usize = 0;\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        if (issue.created_at.value >= since) {\n            issues_created += 1;\n        }\n        if (issue.closed_at.value) |closed_ts| {\n            if (closed_ts >= since) {\n                issues_closed += 1;\n            }\n        }\n        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n            issues_updated += 1;\n        }\n    }\n\n    // Get git commit stats\n    var git_commits: usize = 0;\n    var commits_with_refs: usize = 0;\n    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer issue_ref_counts.deinit(allocator);\n\n    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch |err| {\n        // Git not available or not a git repo - return partial stats\n        _ = err;\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };\n    defer allocator.free(git_result);\n\n    // Parse git log output\n    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n    while (lines.next()) |line| {\n        if (line.len == 0) continue;\n        git_commits += 1;\n\n        // Look for issue references (bd-xxx pattern)\n        var found_ref = false;\n        var i: usize = 0;\n        while (i < line.len) {\n            // Look for \"bd-\" or similar prefix\n            if (i + 3 < line.len and\n                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n            {\n                // Extract the issue ID\n                const start = i;\n                i += 3;\n                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n                    i += 1;\n                }\n                const issue_id = line[start..i];\n                if (issue_id.len > 3) {\n                    // Normalize to lowercase\n                    var normalized: [32]u8 = undefined;\n                    const len = @min(issue_id.len, 32);\n                    for (0..len) |j| {\n                        normalized[j] = std.ascii.toLower(issue_id[j]);\n                    }\n                    const key = normalized[0..len];\n\n                    // Check if this issue exists in our store\n                    if (ctx.store.exists(key) catch false) {\n                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n                        entry.value_ptr.* += 1;\n                        found_ref = true;\n                    }\n                }\n            } else {\n                i += 1;\n            }\n        }\n        if (found_ref) {\n            commits_with_refs += 1;\n        }\n    }\n\n    // Convert issue refs to array\n    var it = issue_ref_counts.iterator();\n    while (it.next()) |entry| {\n        try issue_refs_list.append(allocator, .{\n            .issue_id = entry.key_ptr.*,\n            .commit_count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by commit count descending\n    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n            return a.commit_count > b.commit_count;\n        }\n    }.lessThan);\n\n    return StatsResult.ActivityStats{\n        .period_hours = hours,\n        .git_commits = git_commits,\n        .issues_created = issues_created,\n        .issues_closed = issues_closed,\n        .issues_updated = issues_updated,\n        .commits_with_issue_refs = commits_with_refs,\n        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n    };\n}\n\nfn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n    var buf: [32]u8 = undefined;\n    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n        .cwd = null,\n    }) catch return StatsError.GitError;\n\n    defer allocator.free(result.stderr);\n\n    if (result.term.Exited != 0) {\n        allocator.free(result.stdout);\n        return StatsError.GitError;\n    }\n\n    return result.stdout;\n}\n\n// --- Tests ---\n\ntest \"StatsError enum exists\" {\n    const err: StatsError = StatsError.WorkspaceNotInitialized;\n    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n}\n\ntest \"StatsResult struct works\" {\n    const result = StatsResult{\n        .success = true,\n        .total = 10,\n        .open = 5,\n        .closed = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const stats_args = args.StatsArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(stats_args, global, allocator);\n    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n}\n\ntest \"StatsArgs default values\" {\n    const stats_args = args.StatsArgs{};\n    try std.testing.expect(!stats_args.activity);\n    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n}\n\ntest \"parse stats with activity flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .stats => |s| {\n            try std.testing.expect(s.activity);\n            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse stats with activity-hours flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .stats => |s| {\n            try std.testing.expect(s.activity);\n            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":538,"cache_read_input_tokens":148095,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":538},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3e98de54-3721-4d64-8055-180383f5b74b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0145rKWMQfiG3VXfSFkMxUme","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/stats.zig has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→//! Stats command for beads_zig.\n     2→//!\n     3→//! `bz stats` - Show project statistics\n     4→//! `bz stats --activity` - Show git-based activity statistics\n     5→//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n     6→\n     7→const std = @import(\"std\");\n     8→const common = @import(\"common.zig\");\n     9→const args = @import(\"args.zig\");\n    10→\n    11→const CommandContext = common.CommandContext;\n    12→\n    13→pub const StatsError = error{\n    14→    WorkspaceNotInitialized,\n    15→    StorageError,\n    16→    OutOfMemory,\n    17→    GitError,\n    18→};\n    19→\n    20→pub const StatsResult = struct {\n    21→    success: bool,\n    22→    total: ?usize = null,\n    23→    open: ?usize = null,\n    24→    closed: ?usize = null,\n    25→    by_status: ?[]const CountEntry = null,\n    26→    by_priority: ?[]const CountEntry = null,\n    27→    by_type: ?[]const CountEntry = null,\n    28→    activity: ?ActivityStats = null,\n    29→    message: ?[]const u8 = null,\n    30→\n    31→    pub const CountEntry = struct {\n    32→        key: []const u8,\n    33→        count: usize,\n    34→    };\n    35→\n    36→    pub const ActivityStats = struct {\n    37→        period_hours: u32,\n    38→        git_commits: usize,\n    39→        issues_created: usize,\n    40→        issues_closed: usize,\n    41→        issues_updated: usize,\n    42→        commits_with_issue_refs: usize,\n    43→        issue_refs: ?[]const IssueRef = null,\n    44→\n    45→        pub const IssueRef = struct {\n    46→            issue_id: []const u8,\n    47→            commit_count: usize,\n    48→        };\n    49→    };\n    50→};\n    51→\n    52→pub fn run(\n    53→    stats_args: args.StatsArgs,\n    54→    global: args.GlobalOptions,\n    55→    allocator: std.mem.Allocator,\n    56→) !void {\n    57→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    58→        return StatsError.WorkspaceNotInitialized;\n    59→    };\n    60→    defer ctx.deinit();\n    61→\n    62→    // Count totals\n    63→    var total: usize = 0;\n    64→    var open: usize = 0;\n    65→    var closed: usize = 0;\n    66→\n    67→    // Count by status\n    68→    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    69→    defer status_counts.deinit(allocator);\n    70→\n    71→    // Count by priority\n    72→    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n    73→\n    74→    // Count by type\n    75→    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    76→    defer type_counts.deinit(allocator);\n    77→\n    78→    for (ctx.store.issues.items) |issue| {\n    79→        if (issue.status.eql(.tombstone)) continue;\n    80→\n    81→        total += 1;\n    82→\n    83→        // Status\n    84→        const status_str = issue.status.toString();\n    85→        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n    86→        status_entry.value_ptr.* += 1;\n    87→\n    88→        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n    89→            open += 1;\n    90→        } else if (issue.status.eql(.closed)) {\n    91→            closed += 1;\n    92→        }\n    93→\n    94→        // Priority\n    95→        if (issue.priority.value <= 4) {\n    96→            priority_counts[issue.priority.value] += 1;\n    97→        }\n    98→\n    99→        // Type\n   100→        const type_str = issue.issue_type.toString();\n   101→        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n   102→        type_entry.value_ptr.* += 1;\n   103→    }\n   104→\n   105→    // Convert to arrays for output\n   106→    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n   107→    defer status_list.deinit(allocator);\n   108→\n   109→    var status_it = status_counts.iterator();\n   110→    while (status_it.next()) |entry| {\n   111→        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n   112→    }\n   113→\n   114→    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n   115→    defer priority_list.deinit(allocator);\n   116→\n   117→    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n   118→    for (0..5) |i| {\n   119→        if (priority_counts[i] > 0) {\n   120→            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n   121→        }\n   122→    }\n   123→\n   124→    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n   125→    defer type_list.deinit(allocator);\n   126→\n   127→    var type_it = type_counts.iterator();\n   128→    while (type_it.next()) |entry| {\n   129→        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n   130→    }\n   131→\n   132→    // Activity stats (if requested)\n   133→    var activity_stats: ?StatsResult.ActivityStats = null;\n   134→    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n   135→    defer issue_refs_list.deinit(allocator);\n   136→\n   137→    if (stats_args.activity) {\n   138→        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n   139→    }\n   140→\n   141→    if (global.isStructuredOutput()) {\n   142→        try ctx.output.printJson(StatsResult{\n   143→            .success = true,\n   144→            .total = total,\n   145→            .open = open,\n   146→            .closed = closed,\n   147→            .by_status = status_list.items,\n   148→            .by_priority = priority_list.items,\n   149→            .by_type = type_list.items,\n   150→            .activity = activity_stats,\n   151→        });\n   152→    } else if (!global.quiet) {\n   153→        try ctx.output.println(\"Issue Statistics\", .{});\n   154→        try ctx.output.print(\"\\n\", .{});\n   155→        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n   156→        try ctx.output.print(\"\\n\", .{});\n   157→\n   158→        if (status_list.items.len > 0) {\n   159→            try ctx.output.print(\"By Status:\\n\", .{});\n   160→            for (status_list.items) |entry| {\n   161→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   162→            }\n   163→        }\n   164→\n   165→        if (priority_list.items.len > 0) {\n   166→            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n   167→            for (priority_list.items) |entry| {\n   168→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   169→            }\n   170→        }\n   171→\n   172→        if (type_list.items.len > 0) {\n   173→            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n   174→            for (type_list.items) |entry| {\n   175→                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n   176→            }\n   177→        }\n   178→\n   179→        if (activity_stats) |activity| {\n   180→            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n   181→            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n   182→            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n   183→            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n   184→            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n   185→            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n   186→\n   187→            if (activity.issue_refs) |refs| {\n   188→                if (refs.len > 0) {\n   189→                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n   190→                    for (refs[0..@min(10, refs.len)]) |ref| {\n   191→                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n   192→                    }\n   193→                    if (refs.len > 10) {\n   194→                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n   195→                    }\n   196→                }\n   197→            }\n   198→        }\n   199→    }\n   200→}\n   201→\n   202→fn getActivityStats(\n   203→    allocator: std.mem.Allocator,\n   204→    ctx: *CommandContext,\n   205→    hours: u32,\n   206→    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n   207→) !StatsResult.ActivityStats {\n   208→    const now = std.time.timestamp();\n   209→    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n   210→\n   211→    // Count issue activity in the time period\n   212→    var issues_created: usize = 0;\n   213→    var issues_closed: usize = 0;\n   214→    var issues_updated: usize = 0;\n   215→\n   216→    for (ctx.store.issues.items) |issue| {\n   217→        if (issue.status.eql(.tombstone)) continue;\n   218→\n   219→        if (issue.created_at.value >= since) {\n   220→            issues_created += 1;\n   221→        }\n   222→        if (issue.closed_at.value) |closed_ts| {\n   223→            if (closed_ts >= since) {\n   224→                issues_closed += 1;\n   225→            }\n   226→        }\n   227→        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n   228→            issues_updated += 1;\n   229→        }\n   230→    }\n   231→\n   232→    // Get git commit stats\n   233→    var git_commits: usize = 0;\n   234→    var commits_with_refs: usize = 0;\n   235→    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n   236→    defer issue_ref_counts.deinit(allocator);\n   237→\n   238→    // Run git log to get recent commits\n   239→    const git_result = runGitLog(allocator, hours) catch |err| {\n   240→        // Git not available or not a git repo - return partial stats\n   241→        _ = err;\n   242→        return StatsResult.ActivityStats{\n   243→            .period_hours = hours,\n   244→            .git_commits = 0,\n   245→            .issues_created = issues_created,\n   246→            .issues_closed = issues_closed,\n   247→            .issues_updated = issues_updated,\n   248→            .commits_with_issue_refs = 0,\n   249→            .issue_refs = null,\n   250→        };\n   251→    };\n   252→    defer allocator.free(git_result);\n   253→\n   254→    // Parse git log output\n   255→    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n   256→    while (lines.next()) |line| {\n   257→        if (line.len == 0) continue;\n   258→        git_commits += 1;\n   259→\n   260→        // Look for issue references (bd-xxx pattern)\n   261→        var found_ref = false;\n   262→        var i: usize = 0;\n   263→        while (i < line.len) {\n   264→            // Look for \"bd-\" or similar prefix\n   265→            if (i + 3 < line.len and\n   266→                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n   267→            {\n   268→                // Extract the issue ID\n   269→                const start = i;\n   270→                i += 3;\n   271→                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n   272→                    i += 1;\n   273→                }\n   274→                const issue_id = line[start..i];\n   275→                if (issue_id.len > 3) {\n   276→                    // Normalize to lowercase\n   277→                    var normalized: [32]u8 = undefined;\n   278→                    const len = @min(issue_id.len, 32);\n   279→                    for (0..len) |j| {\n   280→                        normalized[j] = std.ascii.toLower(issue_id[j]);\n   281→                    }\n   282→                    const key = normalized[0..len];\n   283→\n   284→                    // Check if this issue exists in our store\n   285→                    if (ctx.store.exists(key) catch false) {\n   286→                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n   287→                        entry.value_ptr.* += 1;\n   288→                        found_ref = true;\n   289→                    }\n   290→                }\n   291→            } else {\n   292→                i += 1;\n   293→            }\n   294→        }\n   295→        if (found_ref) {\n   296→            commits_with_refs += 1;\n   297→        }\n   298→    }\n   299→\n   300→    // Convert issue refs to array\n   301→    var it = issue_ref_counts.iterator();\n   302→    while (it.next()) |entry| {\n   303→        try issue_refs_list.append(allocator, .{\n   304→            .issue_id = entry.key_ptr.*,\n   305→            .commit_count = entry.value_ptr.*,\n   306→        });\n   307→    }\n   308→\n   309→    // Sort by commit count descending\n   310→    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n   311→        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n   312→            return a.commit_count > b.commit_count;\n   313→        }\n   314→    }.lessThan);\n   315→\n   316→    return StatsResult.ActivityStats{\n   317→        .period_hours = hours,\n   318→        .git_commits = git_commits,\n   319→        .issues_created = issues_created,\n   320→        .issues_closed = issues_closed,\n   321→        .issues_updated = issues_updated,\n   322→        .commits_with_issue_refs = commits_with_refs,\n   323→        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n   324→    };\n   325→}\n   326→\n   327→fn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n   328→    var buf: [32]u8 = undefined;\n   329→    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n   330→\n   331→    const result = std.process.Child.run(.{\n   332→        .allocator = allocator,\n   333→        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n   334→        .cwd = null,\n   335→    }) catch return StatsError.GitError;\n   336→\n   337→    defer allocator.free(result.stderr);\n   338→\n   339→    if (result.term.Exited != 0) {\n   340→        allocator.free(result.stdout);\n   341→        return StatsError.GitError;\n   342→    }\n   343→\n   344→    return result.stdout;\n   345→}\n   346→\n   347→// --- Tests ---\n   348→\n   349→test \"StatsError enum exists\" {\n   350→    const err: StatsError = StatsError.WorkspaceNotInitialized;\n   351→    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n   352→}\n   353→\n   354→test \"StatsResult struct works\" {\n   355→    const result = StatsResult{\n   356→        .success = true,\n   357→        .total = 10,\n   358→        .open = 5,\n   359→        .closed = 5,\n   360→    };\n   361→    try std.testing.expect(result.success);\n   362→    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   363→}\n   364→\n   365→test \"run detects uninitialized workspace\" {\n   366→    const allocator = std.testing.allocator;\n   367→\n   368→    const stats_args = args.StatsArgs{};\n   369→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   370→\n   371→    const result = run(stats_args, global, allocator);\n   372→    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n   373→}\n   374→\n   375→test \"StatsArgs default values\" {\n   376→    const stats_args = args.StatsArgs{};\n   377→    try std.testing.expect(!stats_args.activity);\n   378→    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n   379→}\n   380→\n   381→test \"parse stats with activity flag\" {\n   382→    const allocator = std.testing.allocator;\n   383→    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n   384→    var parser = args.ArgParser.init(allocator, &cmd_args);\n   385→    var result = parser.parse() catch unreachable;\n   386→    defer result.deinit(allocator);\n   387→\n   388→    switch (result.command) {\n   389→        .stats => |s| {\n   390→            try std.testing.expect(s.activity);\n   391→            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n   392→        },\n   393→        else => try std.testing.expect(false),\n   394→    }\n   395→}\n   396→\n   397→test \"parse stats with activity-hours flag\" {\n   398→    const allocator = std.testing.allocator;\n   399→    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n   400→    var parser = args.ArgParser.init(allocator, &cmd_args);\n   401→    var result = parser.parse() catch unreachable;\n   402→    defer result.deinit(allocator);\n   403→\n   404→    switch (result.command) {\n   405→        .stats => |s| {\n   406→            try std.testing.expect(s.activity);\n   407→            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n   408→        },\n   409→        else => try std.testing.expect(false),\n   410→    }\n   411→}\n   412→"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7b131fc0-5c82-46ad-b74f-784481207198","tool_use_result":{"type":"update","filePath":"/home/hotschmoe/beads_zig/src/cli/stats.zig","content":"//! Stats command for beads_zig.\n//!\n//! `bz stats` - Show project statistics\n//! `bz stats --activity` - Show git-based activity statistics\n//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const StatsError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    GitError,\n};\n\npub const StatsResult = struct {\n    success: bool,\n    total: ?usize = null,\n    open: ?usize = null,\n    closed: ?usize = null,\n    by_status: ?[]const CountEntry = null,\n    by_priority: ?[]const CountEntry = null,\n    by_type: ?[]const CountEntry = null,\n    activity: ?ActivityStats = null,\n    message: ?[]const u8 = null,\n\n    pub const CountEntry = struct {\n        key: []const u8,\n        count: usize,\n    };\n\n    pub const ActivityStats = struct {\n        period_hours: u32,\n        git_commits: usize,\n        issues_created: usize,\n        issues_closed: usize,\n        issues_updated: usize,\n        commits_with_issue_refs: usize,\n        issue_refs: ?[]const IssueRef = null,\n\n        pub const IssueRef = struct {\n            issue_id: []const u8,\n            commit_count: usize,\n        };\n    };\n};\n\npub fn run(\n    stats_args: args.StatsArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return StatsError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count totals\n    var total: usize = 0;\n    var open: usize = 0;\n    var closed: usize = 0;\n\n    // Count by status\n    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer status_counts.deinit(allocator);\n\n    // Count by priority\n    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n\n    // Count by type\n    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer type_counts.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        total += 1;\n\n        // Status\n        const status_str = issue.status.toString();\n        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n        status_entry.value_ptr.* += 1;\n\n        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n            open += 1;\n        } else if (issue.status.eql(.closed)) {\n            closed += 1;\n        }\n\n        // Priority\n        if (issue.priority.value <= 4) {\n            priority_counts[issue.priority.value] += 1;\n        }\n\n        // Type\n        const type_str = issue.issue_type.toString();\n        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n        type_entry.value_ptr.* += 1;\n    }\n\n    // Convert to arrays for output\n    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer status_list.deinit(allocator);\n\n    var status_it = status_counts.iterator();\n    while (status_it.next()) |entry| {\n        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer priority_list.deinit(allocator);\n\n    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    for (0..5) |i| {\n        if (priority_counts[i] > 0) {\n            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n        }\n    }\n\n    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer type_list.deinit(allocator);\n\n    var type_it = type_counts.iterator();\n    while (type_it.next()) |entry| {\n        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    // Activity stats (if requested)\n    var activity_stats: ?StatsResult.ActivityStats = null;\n    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n    defer issue_refs_list.deinit(allocator);\n\n    if (stats_args.activity) {\n        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(StatsResult{\n            .success = true,\n            .total = total,\n            .open = open,\n            .closed = closed,\n            .by_status = status_list.items,\n            .by_priority = priority_list.items,\n            .by_type = type_list.items,\n            .activity = activity_stats,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Issue Statistics\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n        try ctx.output.print(\"\\n\", .{});\n\n        if (status_list.items.len > 0) {\n            try ctx.output.print(\"By Status:\\n\", .{});\n            for (status_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (priority_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n            for (priority_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (type_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n            for (type_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (activity_stats) |activity| {\n            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n\n            if (activity.issue_refs) |refs| {\n                if (refs.len > 0) {\n                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n                    for (refs[0..@min(10, refs.len)]) |ref| {\n                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n                    }\n                    if (refs.len > 10) {\n                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn getActivityStats(\n    allocator: std.mem.Allocator,\n    ctx: *CommandContext,\n    hours: u32,\n    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n) !StatsResult.ActivityStats {\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n\n    // Count issue activity in the time period\n    var issues_created: usize = 0;\n    var issues_closed: usize = 0;\n    var issues_updated: usize = 0;\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        if (issue.created_at.value >= since) {\n            issues_created += 1;\n        }\n        if (issue.closed_at.value) |closed_ts| {\n            if (closed_ts >= since) {\n                issues_closed += 1;\n            }\n        }\n        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n            issues_updated += 1;\n        }\n    }\n\n    // Get git commit stats\n    var git_commits: usize = 0;\n    var commits_with_refs: usize = 0;\n    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer issue_ref_counts.deinit(allocator);\n\n    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch |err| {\n        // Git not available or not a git repo - return partial stats\n        _ = err;\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };\n    defer allocator.free(git_result);\n\n    // Parse git log output\n    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n    while (lines.next()) |line| {\n        if (line.len == 0) continue;\n        git_commits += 1;\n\n        // Look for issue references (bd-xxx pattern)\n        var found_ref = false;\n        var i: usize = 0;\n        while (i < line.len) {\n            // Look for \"bd-\" or similar prefix\n            if (i + 3 < line.len and\n                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n            {\n                // Extract the issue ID\n                const start = i;\n                i += 3;\n                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n                    i += 1;\n                }\n                const issue_id = line[start..i];\n                if (issue_id.len > 3) {\n                    // Normalize to lowercase\n                    var normalized: [32]u8 = undefined;\n                    const len = @min(issue_id.len, 32);\n                    for (0..len) |j| {\n                        normalized[j] = std.ascii.toLower(issue_id[j]);\n                    }\n                    const key = normalized[0..len];\n\n                    // Check if this issue exists in our store\n                    if (ctx.store.exists(key) catch false) {\n                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n                        entry.value_ptr.* += 1;\n                        found_ref = true;\n                    }\n                }\n            } else {\n                i += 1;\n            }\n        }\n        if (found_ref) {\n            commits_with_refs += 1;\n        }\n    }\n\n    // Convert issue refs to array\n    var it = issue_ref_counts.iterator();\n    while (it.next()) |entry| {\n        try issue_refs_list.append(allocator, .{\n            .issue_id = entry.key_ptr.*,\n            .commit_count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by commit count descending\n    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n            return a.commit_count > b.commit_count;\n        }\n    }.lessThan);\n\n    return StatsResult.ActivityStats{\n        .period_hours = hours,\n        .git_commits = git_commits,\n        .issues_created = issues_created,\n        .issues_closed = issues_closed,\n        .issues_updated = issues_updated,\n        .commits_with_issue_refs = commits_with_refs,\n        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n    };\n}\n\nfn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n    var buf: [32]u8 = undefined;\n    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n        .cwd = null,\n    }) catch return StatsError.GitError;\n\n    defer allocator.free(result.stderr);\n\n    if (result.term.Exited != 0) {\n        allocator.free(result.stdout);\n        return StatsError.GitError;\n    }\n\n    return result.stdout;\n}\n\n// --- Tests ---\n\ntest \"StatsError enum exists\" {\n    const err: StatsError = StatsError.WorkspaceNotInitialized;\n    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n}\n\ntest \"StatsResult struct works\" {\n    const result = StatsResult{\n        .success = true,\n        .total = 10,\n        .open = 5,\n        .closed = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const stats_args = args.StatsArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(stats_args, global, allocator);\n    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n}\n\ntest \"StatsArgs default values\" {\n    const stats_args = args.StatsArgs{};\n    try std.testing.expect(!stats_args.activity);\n    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n}\n\ntest \"parse stats with activity flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .stats => |s| {\n            try std.testing.expect(s.activity);\n            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse stats with activity-hours flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .stats => |s| {\n            try std.testing.expect(s.activity);\n            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":1,"oldLines":6,"newStart":1,"newLines":8,"lines":[" //! Stats command for beads_zig."," //!"," //! `bz stats` - Show project statistics","+//! `bz stats --activity` - Show git-based activity statistics","+//! `bz stats --activity-hours 48` - Show activity for last 48 hours"," "," const std = @import(\"std\");"," const common = @import(\"common.zig\");"]},{"oldStart":12,"oldLines":6,"newStart":14,"newLines":7,"lines":["     WorkspaceNotInitialized,","     StorageError,","     OutOfMemory,","+    GitError,"," };"," "," pub const StatsResult = struct {"]},{"oldStart":22,"oldLines":15,"newStart":25,"newLines":32,"lines":["     by_status: ?[]const CountEntry = null,","     by_priority: ?[]const CountEntry = null,","     by_type: ?[]const CountEntry = null,","+    activity: ?ActivityStats = null,","     message: ?[]const u8 = null,"," ","     pub const CountEntry = struct {","         key: []const u8,","         count: usize,","     };","+","+    pub const ActivityStats = struct {","+        period_hours: u32,","+        git_commits: usize,","+        issues_created: usize,","+        issues_closed: usize,","+        issues_updated: usize,","+        commits_with_issue_refs: usize,","+        issue_refs: ?[]const IssueRef = null,","+","+        pub const IssueRef = struct {","+            issue_id: []const u8,","+            commit_count: usize,","+        };","+    };"," };"," "," pub fn run(","+    stats_args: args.StatsArgs,","     global: args.GlobalOptions,","     allocator: std.mem.Allocator,"," ) !void {"]},{"oldStart":109,"oldLines":6,"newStart":129,"newLines":15,"lines":["         try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });","     }"," ","+    // Activity stats (if requested)","+    var activity_stats: ?StatsResult.ActivityStats = null;","+    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};","+    defer issue_refs_list.deinit(allocator);","+","+    if (stats_args.activity) {","+        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);","+    }","+","     if (global.isStructuredOutput()) {","         try ctx.output.printJson(StatsResult{","             .success = true,"]},{"oldStart":118,"oldLines":6,"newStart":147,"newLines":7,"lines":["             .by_status = status_list.items,","             .by_priority = priority_list.items,","             .by_type = type_list.items,","+            .activity = activity_stats,","         });","     } else if (!global.quiet) {","         try ctx.output.println(\"Issue Statistics\", .{});"]},{"oldStart":145,"oldLines":9,"newStart":175,"newLines":175,"lines":["                 try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });","             }","         }","+","+        if (activity_stats) |activity| {","+            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});","+            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});","+            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});","+            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});","+            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});","+            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});","+","+            if (activity.issue_refs) |refs| {","+                if (refs.len > 0) {","+                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});","+                    for (refs[0..@min(10, refs.len)]) |ref| {","+                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });","+                    }","+                    if (refs.len > 10) {","+                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});","+                    }","+                }","+            }","+        }","     }"," }"," ","+fn getActivityStats(","+    allocator: std.mem.Allocator,","+    ctx: *CommandContext,","+    hours: u32,","+    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),","+) !StatsResult.ActivityStats {","+    const now = std.time.timestamp();","+    const since = now - @as(i64, @intCast(hours)) * 60 * 60;","+","+    // Count issue activity in the time period","+    var issues_created: usize = 0;","+    var issues_closed: usize = 0;","+    var issues_updated: usize = 0;","+","+    for (ctx.store.issues.items) |issue| {","+        if (issue.status.eql(.tombstone)) continue;","+","+        if (issue.created_at.value >= since) {","+            issues_created += 1;","+        }","+        if (issue.closed_at.value) |closed_ts| {","+            if (closed_ts >= since) {","+                issues_closed += 1;","+            }","+        }","+        if (issue.updated_at.value >= since and issue.created_at.value < since) {","+            issues_updated += 1;","+        }","+    }","+","+    // Get git commit stats","+    var git_commits: usize = 0;","+    var commits_with_refs: usize = 0;","+    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};","+    defer issue_ref_counts.deinit(allocator);","+","+    // Run git log to get recent commits","+    const git_result = runGitLog(allocator, hours) catch |err| {","+        // Git not available or not a git repo - return partial stats","+        _ = err;","+        return StatsResult.ActivityStats{","+            .period_hours = hours,","+            .git_commits = 0,","+            .issues_created = issues_created,","+            .issues_closed = issues_closed,","+            .issues_updated = issues_updated,","+            .commits_with_issue_refs = 0,","+            .issue_refs = null,","+        };","+    };","+    defer allocator.free(git_result);","+","+    // Parse git log output","+    var lines = std.mem.splitScalar(u8, git_result, '\\n');","+    while (lines.next()) |line| {","+        if (line.len == 0) continue;","+        git_commits += 1;","+","+        // Look for issue references (bd-xxx pattern)","+        var found_ref = false;","+        var i: usize = 0;","+        while (i < line.len) {","+            // Look for \"bd-\" or similar prefix","+            if (i + 3 < line.len and","+                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))","+            {","+                // Extract the issue ID","+                const start = i;","+                i += 3;","+                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {","+                    i += 1;","+                }","+                const issue_id = line[start..i];","+                if (issue_id.len > 3) {","+                    // Normalize to lowercase","+                    var normalized: [32]u8 = undefined;","+                    const len = @min(issue_id.len, 32);","+                    for (0..len) |j| {","+                        normalized[j] = std.ascii.toLower(issue_id[j]);","+                    }","+                    const key = normalized[0..len];","+","+                    // Check if this issue exists in our store","+                    if (ctx.store.exists(key) catch false) {","+                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);","+                        entry.value_ptr.* += 1;","+                        found_ref = true;","+                    }","+                }","+            } else {","+                i += 1;","+            }","+        }","+        if (found_ref) {","+            commits_with_refs += 1;","+        }","+    }","+","+    // Convert issue refs to array","+    var it = issue_ref_counts.iterator();","+    while (it.next()) |entry| {","+        try issue_refs_list.append(allocator, .{","+            .issue_id = entry.key_ptr.*,","+            .commit_count = entry.value_ptr.*,","+        });","+    }","+","+    // Sort by commit count descending","+    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {","+        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {","+            return a.commit_count > b.commit_count;","+        }","+    }.lessThan);","+","+    return StatsResult.ActivityStats{","+        .period_hours = hours,","+        .git_commits = git_commits,","+        .issues_created = issues_created,","+        .issues_closed = issues_closed,","+        .issues_updated = issues_updated,","+        .commits_with_issue_refs = commits_with_refs,","+        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,","+    };","+}","+","+fn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {","+    var buf: [32]u8 = undefined;","+    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;","+","+    const result = std.process.Child.run(.{","+        .allocator = allocator,","+        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },","+        .cwd = null,","+    }) catch return StatsError.GitError;","+","+    defer allocator.free(result.stderr);","+","+    if (result.term.Exited != 0) {","+        allocator.free(result.stdout);","+        return StatsError.GitError;","+    }","+","+    return result.stdout;","+}","+"," // --- Tests ---"," "," test \"StatsError enum exists\" {"]},{"oldStart":169,"oldLines":8,"newStart":365,"newLines":47,"lines":[" test \"run detects uninitialized workspace\" {","     const allocator = std.testing.allocator;"," ","+    const stats_args = args.StatsArgs{};","     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };"," ","-    const result = run(global, allocator);","+    const result = run(stats_args, global, allocator);","     try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);"," }","+","+test \"StatsArgs default values\" {","+    const stats_args = args.StatsArgs{};","+    try std.testing.expect(!stats_args.activity);","+    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);","+}","+","+test \"parse stats with activity flag\" {","+    const allocator = std.testing.allocator;","+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };","+    var parser = args.ArgParser.init(allocator, &cmd_args);","+    var result = parser.parse() catch unreachable;","+    defer result.deinit(allocator);","+","+    switch (result.command) {","+        .stats => |s| {","+            try std.testing.expect(s.activity);","+            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);","+        },","+        else => try std.testing.expect(false),","+    }","+}","+","+test \"parse stats with activity-hours flag\" {","+    const allocator = std.testing.allocator;","+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };","+    var parser = args.ArgParser.init(allocator, &cmd_args);","+    var result = parser.parse() catch unreachable;","+    defer result.deinit(allocator);","+","+    switch (result.command) {","+        .stats => |s| {","+            try std.testing.expect(s.activity);","+            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);","+        },","+        else => try std.testing.expect(false),","+    }","+}"]}],"originalFile":"//! Stats command for beads_zig.\n//!\n//! `bz stats` - Show project statistics\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const StatsError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\npub const StatsResult = struct {\n    success: bool,\n    total: ?usize = null,\n    open: ?usize = null,\n    closed: ?usize = null,\n    by_status: ?[]const CountEntry = null,\n    by_priority: ?[]const CountEntry = null,\n    by_type: ?[]const CountEntry = null,\n    message: ?[]const u8 = null,\n\n    pub const CountEntry = struct {\n        key: []const u8,\n        count: usize,\n    };\n};\n\npub fn run(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return StatsError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count totals\n    var total: usize = 0;\n    var open: usize = 0;\n    var closed: usize = 0;\n\n    // Count by status\n    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer status_counts.deinit(allocator);\n\n    // Count by priority\n    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n\n    // Count by type\n    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer type_counts.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        total += 1;\n\n        // Status\n        const status_str = issue.status.toString();\n        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n        status_entry.value_ptr.* += 1;\n\n        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n            open += 1;\n        } else if (issue.status.eql(.closed)) {\n            closed += 1;\n        }\n\n        // Priority\n        if (issue.priority.value <= 4) {\n            priority_counts[issue.priority.value] += 1;\n        }\n\n        // Type\n        const type_str = issue.issue_type.toString();\n        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n        type_entry.value_ptr.* += 1;\n    }\n\n    // Convert to arrays for output\n    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer status_list.deinit(allocator);\n\n    var status_it = status_counts.iterator();\n    while (status_it.next()) |entry| {\n        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer priority_list.deinit(allocator);\n\n    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    for (0..5) |i| {\n        if (priority_counts[i] > 0) {\n            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n        }\n    }\n\n    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer type_list.deinit(allocator);\n\n    var type_it = type_counts.iterator();\n    while (type_it.next()) |entry| {\n        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(StatsResult{\n            .success = true,\n            .total = total,\n            .open = open,\n            .closed = closed,\n            .by_status = status_list.items,\n            .by_priority = priority_list.items,\n            .by_type = type_list.items,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Issue Statistics\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n        try ctx.output.print(\"\\n\", .{});\n\n        if (status_list.items.len > 0) {\n            try ctx.output.print(\"By Status:\\n\", .{});\n            for (status_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (priority_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n            for (priority_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (type_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n            for (type_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"StatsError enum exists\" {\n    const err: StatsError = StatsError.WorkspaceNotInitialized;\n    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n}\n\ntest \"StatsResult struct works\" {\n    const result = StatsResult{\n        .success = true,\n        .total = 10,\n        .open = 5,\n        .closed = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(global, allocator);\n    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n}\n"}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011hzmgnsJ3XUFAyDANsjfDF","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update main.zig to pass the stats args, and also export StatsArgs from mod.zig:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10376,"cache_read_input_tokens":148633,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10376},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b331d13d-e377-462a-b723-02292ca43ae0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011hzmgnsJ3XUFAyDANsjfDF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QVJf7MtcMAoAxGBkMT3bxJ","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/main.zig","offset":208,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10376,"cache_read_input_tokens":148633,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10376},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3861a94e-aa41-4a15-a52f-d31a0cc1201f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QVJf7MtcMAoAxGBkMT3bxJ","type":"tool_result","content":"   208→                else => return err,\n   209→            };\n   210→        },\n   211→        .stats => {\n   212→            cli.runStats(result.global, allocator) catch |err| switch (err) {\n   213→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   214→                else => return err,\n   215→            };\n   216→        },\n   217→        .doctor => {\n   218→            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n   219→                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n   220→                else => return err,\n   221→            };\n   222→        },\n   223→        .config => |config_args| {\n   224→            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n   225→                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n   226→                else => return err,\n   227→            };\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"722642ae-6d99-415d-8466-61399c6acc49","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","content":"                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };","numLines":20,"startLine":208,"totalLines":316}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MGsskt6TefHjksfWLbLipy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KdniaxADe6mNT7dJ58mx8x","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/main.zig","old_string":"        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },","new_string":"        .stats => |stats_args| {\n            cli.runStats(stats_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.GitError => std.process.exit(1),\n                else => return err,\n            };\n        },"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":520,"cache_read_input_tokens":159009,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":520},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"545d8d9c-2cb4-4369-960b-ca9714b1a02d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KdniaxADe6mNT7dJ58mx8x","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/main.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"50c57cec-4ece-4726-a1b8-3ca29d34212b","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/main.zig","oldString":"        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },","newString":"        .stats => |stats_args| {\n            cli.runStats(stats_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.GitError => std.process.exit(1),\n                else => return err,\n            };\n        },","originalFile":"//! beads_zig CLI entry point.\n//!\n//! Binary name: bz (beads-zig)\n\nconst std = @import(\"std\");\nconst beads_zig = @import(\"beads_zig\");\nconst cli = beads_zig.cli;\nconst output = beads_zig.output;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    run(allocator) catch |err| {\n        const stderr = std.fs.File.stderr();\n        stderr.writeAll(\"error: \") catch {};\n        stderr.writeAll(@errorName(err)) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        std.process.exit(1);\n    };\n}\n\nfn run(allocator: std.mem.Allocator) !void {\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    // Skip program name\n    const cmd_args = if (args.len > 1) args[1..] else args[0..0];\n\n    var parser = cli.ArgParser.init(allocator, cmd_args);\n    var result = parser.parse() catch |err| {\n        return handleParseError(err, allocator);\n    };\n    defer result.deinit(allocator);\n\n    try dispatch(result, allocator);\n}\n\nfn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n    switch (result.command) {\n        .init => |init_args| {\n            cli.runInit(init_args, result.global, allocator) catch |err| switch (err) {\n                error.AlreadyInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .create => |create_args| {\n            cli.runCreate(create_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .q => |quick_args| {\n            cli.runQuick(quick_args, result.global, allocator) catch |err| switch (err) {\n                error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .list => |list_args| {\n            cli.runList(list_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidFilter => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .show => |show_args| {\n            cli.runShow(show_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .update => |update_args| {\n            cli.runUpdate(update_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.InvalidArgument => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .close => |close_args| {\n            cli.runClose(close_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .reopen => |reopen_args| {\n            cli.runReopen(reopen_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.NotClosed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .delete => |delete_args| {\n            cli.runDelete(delete_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeleted => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .add_batch => |batch_args| {\n            cli.runAddBatch(batch_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError, error.NoIssuesToAdd => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .import_cmd => |import_args| {\n            cli.runImportCmd(import_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidInput, error.FileReadError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .ready => |ready_args| {\n            cli.runReady(ready_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .blocked => |blocked_args| {\n            cli.runBlocked(blocked_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .dep => |dep_args| {\n            cli.runDep(dep_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.CycleDetected, error.SelfDependency => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .graph => |graph_args| {\n            cli.runGraph(graph_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .epic => |epic_args| {\n            cli.runEpic(epic_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.EpicNotFound, error.IssueNotFound, error.NotAnEpic, error.EmptyTitle, error.TitleTooLong, error.InvalidPriority, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .sync => |sync_args| {\n            cli.runSync(sync_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.MergeConflictDetected, error.ImportError, error.ExportError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .backup => |backup_args| {\n            cli.runBackup(backup_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.BackupNotFound, error.RestoreFailed, error.CreateFailed => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .search => |search_args| {\n            cli.runSearch(search_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stale => |stale_args| {\n            cli.runStale(stale_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .count => |count_args| {\n            cli.runCount(count_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .defer_cmd => |defer_args| {\n            cli.runDefer(defer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.AlreadyDeferred, error.InvalidDate => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .undefer => |undefer_args| {\n            cli.runUndefer(undefer_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .help => |help_args| {\n            cli.runHelp(help_args.topic, allocator) catch {\n                std.process.exit(1);\n            };\n        },\n        .version => {\n            _ = cli.runVersion(result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .schema => {\n            _ = cli.runSchema(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .completions => |comp_args| {\n            _ = cli.runCompletions(comp_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError => std.process.exit(1),\n            };\n        },\n        .metrics => |metrics_args| {\n            cli.runMetrics(metrics_args, result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.OutOfMemory => std.process.exit(1),\n            };\n        },\n        .info => {\n            cli.runInfo(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .stats => {\n            cli.runStats(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .doctor => {\n            cli.runDoctor(result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .config => |config_args| {\n            cli.runConfig(config_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.ConfigNotFound, error.InvalidKey, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .orphans => |orphans_args| {\n            cli.runOrphans(orphans_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .lint => |lint_args| {\n            cli.runLint(lint_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .label => |label_args| {\n            cli.runLabel(label_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .comments => |comments_args| {\n            cli.runComments(comments_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.EmptyCommentBody, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .history => |history_args| {\n            cli.runHistory(history_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.IssueNotFound, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .audit => |audit_args| {\n            cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .changelog => |changelog_args| {\n            cli.runChangelog(changelog_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.InvalidDateFormat, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .query => |query_args| {\n            cli.runQuery(query_args, result.global, allocator) catch |err| switch (err) {\n                error.WorkspaceNotInitialized, error.QueryNotFound, error.QueryAlreadyExists, error.InvalidQueryName, error.StorageError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .upgrade => |upgrade_args| {\n            cli.runUpgrade(upgrade_args, result.global, allocator) catch |err| switch (err) {\n                error.NetworkError, error.UnsupportedPlatform, error.WriteError => std.process.exit(1),\n                else => return err,\n            };\n        },\n        .where => {\n            _ = cli.runWhere(result.global, allocator) catch |err| switch (err) {\n                error.WriteError, error.WorkspaceNotFound => std.process.exit(1),\n            };\n        },\n    }\n}\n\nfn handleParseError(err: cli.ParseError, allocator: std.mem.Allocator) !void {\n    var out = output.Output.init(allocator, .{});\n    switch (err) {\n        cli.ParseError.UnknownCommand => try out.err(\"unknown command. Run 'bz help' for usage.\", .{}),\n        cli.ParseError.MissingRequiredArgument => try out.err(\"missing required argument\", .{}),\n        cli.ParseError.InvalidArgument => try out.err(\"invalid argument value\", .{}),\n        cli.ParseError.UnknownFlag => try out.err(\"unknown flag\", .{}),\n        cli.ParseError.MissingFlagValue => try out.err(\"flag requires a value\", .{}),\n        cli.ParseError.InvalidFlagValue => try out.err(\"invalid flag value\", .{}),\n        cli.ParseError.InvalidShell => try out.err(\"invalid shell type\", .{}),\n        cli.ParseError.UnknownSubcommand => try out.err(\"unknown subcommand\", .{}),\n    }\n    std.process.exit(1);\n}\n\ntest \"library imports compile\" {\n    // Verify all modules are accessible\n    _ = beads_zig.cli;\n    _ = beads_zig.storage;\n    _ = beads_zig.models;\n    _ = beads_zig.sync;\n    _ = beads_zig.id;\n    _ = beads_zig.config;\n    _ = beads_zig.output;\n}\n","structuredPatch":[{"oldStart":208,"oldLines":9,"newStart":208,"newLines":9,"lines":["                 else => return err,","             };","         },","-        .stats => {","-            cli.runStats(result.global, allocator) catch |err| switch (err) {","-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),","+        .stats => |stats_args| {","+            cli.runStats(stats_args, result.global, allocator) catch |err| switch (err) {","+                error.WorkspaceNotInitialized, error.StorageError, error.GitError => std.process.exit(1),","                 else => return err,","             };","         },"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MzFuJfk6AGAaVhdV2LX5qE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update mod.zig to export StatsArgs:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":470,"cache_read_input_tokens":159529,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":470},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"a9f3515e-244b-4340-ba20-748091b69460"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MzFuJfk6AGAaVhdV2LX5qE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014Jxn7yv2Q3V4KTZ8moV2vb","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","offset":160,"limit":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":470,"cache_read_input_tokens":159529,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":470},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1ef311a6-8901-409d-8a0c-3dc8b6d8964b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014Jxn7yv2Q3V4KTZ8moV2vb","type":"tool_result","content":"   160→\n   161→pub const InfoError = info.InfoError;\n   162→pub const InfoResult = info.InfoResult;\n   163→pub const runInfo = info.run;\n   164→\n   165→pub const StatsError = stats.StatsError;\n   166→pub const StatsResult = stats.StatsResult;\n   167→pub const runStats = stats.run;\n   168→\n   169→pub const DoctorError = doctor.DoctorError;\n   170→pub const DoctorResult = doctor.DoctorResult;\n   171→pub const runDoctor = doctor.run;\n   172→\n   173→pub const ConfigError = config.ConfigError;\n   174→pub const ConfigResult = config.ConfigResult;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f8ba598f-175e-431b-99a8-236a9940a0e5","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","content":"\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;","numLines":15,"startLine":160,"totalLines":228}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011zQyNYnayWd563RAvxxDBR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LN7bF9qujNKbuHLNwmueoA","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/mod.zig","old_string":"pub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;","new_string":"pub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\npub const StatsArgs = args.StatsArgs;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":394,"cache_read_input_tokens":159999,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":394},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"8612d03f-a86e-445e-bef7-bdedaa165db4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LN7bF9qujNKbuHLNwmueoA","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"7aa08386-4508-44de-a3a9-d98741f8b393","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/mod.zig","oldString":"pub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;","newString":"pub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\npub const StatsArgs = args.StatsArgs;","originalFile":"//! CLI command implementations for beads_zig.\n//!\n//! This module handles argument parsing and dispatches to the appropriate\n//! command handlers (create, list, show, update, close, sync, etc.).\n//!\n//! All commands support --json output for machine-readable responses.\n\nconst std = @import(\"std\");\n\npub const args = @import(\"args.zig\");\npub const common = @import(\"common.zig\");\npub const init = @import(\"init.zig\");\npub const create = @import(\"create.zig\");\npub const list = @import(\"list.zig\");\npub const show = @import(\"show.zig\");\npub const update = @import(\"update.zig\");\npub const close = @import(\"close.zig\");\npub const delete = @import(\"delete.zig\");\npub const ready = @import(\"ready.zig\");\npub const dep = @import(\"dep.zig\");\npub const graph = @import(\"graph.zig\");\npub const epic = @import(\"epic.zig\");\npub const sync = @import(\"sync.zig\");\npub const batch = @import(\"batch.zig\");\npub const search = @import(\"search.zig\");\npub const stale = @import(\"stale.zig\");\npub const count = @import(\"count.zig\");\npub const defer_cmd = @import(\"defer.zig\");\npub const label = @import(\"label.zig\");\npub const comments = @import(\"comments.zig\");\npub const history = @import(\"history.zig\");\npub const audit = @import(\"audit.zig\");\npub const changelog = @import(\"changelog.zig\");\npub const info = @import(\"info.zig\");\npub const stats = @import(\"stats.zig\");\npub const doctor = @import(\"doctor.zig\");\npub const config = @import(\"config.zig\");\npub const orphans = @import(\"orphans.zig\");\npub const lint = @import(\"lint.zig\");\npub const version = @import(\"version.zig\");\npub const schema = @import(\"schema.zig\");\npub const completions = @import(\"completions.zig\");\npub const metrics_cmd = @import(\"metrics.zig\");\npub const help = @import(\"help.zig\");\npub const query = @import(\"query.zig\");\npub const upgrade = @import(\"upgrade.zig\");\npub const where = @import(\"where.zig\");\n\npub const ArgParser = args.ArgParser;\npub const ParseResult = args.ParseResult;\npub const ParseError = args.ParseError;\npub const GlobalOptions = args.GlobalOptions;\npub const Command = args.Command;\npub const InitArgs = args.InitArgs;\npub const CreateArgs = args.CreateArgs;\npub const QuickArgs = args.QuickArgs;\n\npub const InitError = init.InitError;\npub const InitResult = init.InitResult;\npub const runInit = init.run;\n\npub const CreateError = create.CreateError;\npub const CreateResult = create.CreateResult;\npub const runCreate = create.run;\npub const runQuick = create.runQuick;\n\npub const ListError = list.ListError;\npub const ListResult = list.ListResult;\npub const runList = list.run;\n\npub const ShowError = show.ShowError;\npub const ShowResult = show.ShowResult;\npub const runShow = show.run;\n\npub const UpdateError = update.UpdateError;\npub const UpdateResult = update.UpdateResult;\npub const runUpdate = update.run;\n\npub const CloseError = close.CloseError;\npub const CloseResult = close.CloseResult;\npub const runClose = close.run;\npub const runReopen = close.runReopen;\n\npub const DeleteError = delete.DeleteError;\npub const DeleteResult = delete.DeleteResult;\npub const runDelete = delete.run;\n\npub const ReadyError = ready.ReadyError;\npub const ReadyResult = ready.ReadyResult;\npub const runReady = ready.run;\npub const runBlocked = ready.runBlocked;\n\npub const DepError = dep.DepError;\npub const DepResult = dep.DepResult;\npub const runDep = dep.run;\n\npub const GraphError = graph.GraphError;\npub const GraphResult = graph.GraphResult;\npub const runGraph = graph.run;\n\npub const EpicError = epic.EpicError;\npub const EpicResult = epic.EpicResult;\npub const runEpic = epic.run;\n\npub const SyncError = sync.SyncError;\npub const SyncResult = sync.SyncResult;\npub const runSync = sync.run;\n\npub const backup = @import(\"backup.zig\");\npub const BackupError = backup.BackupError;\npub const BackupResult = backup.BackupResult;\npub const runBackup = backup.run;\npub const BackupArgs = args.BackupArgs;\n\npub const BatchError = batch.BatchError;\npub const BatchResult = batch.BatchResult;\npub const ImportResult = batch.ImportResult;\npub const runAddBatch = batch.runAddBatch;\npub const runImportCmd = batch.runImport;\n\npub const AddBatchArgs = args.AddBatchArgs;\npub const BatchFormat = args.BatchFormat;\npub const ImportArgs = args.ImportArgs;\npub const EpicArgs = args.EpicArgs;\npub const SortField = args.SortField;\n\npub const SearchError = search.SearchError;\npub const SearchResult = search.SearchResult;\npub const runSearch = search.run;\n\npub const runStale = stale.run;\n\npub const runCount = count.run;\n\npub const runDefer = defer_cmd.run;\npub const runUndefer = defer_cmd.runUndefer;\n\npub const LabelError = label.LabelError;\npub const LabelResult = label.LabelResult;\npub const runLabel = label.run;\n\npub const CommentsError = comments.CommentsError;\npub const CommentsResult = comments.CommentsResult;\npub const runComments = comments.run;\n\npub const HistoryError = history.HistoryError;\npub const HistoryResult = history.HistoryResult;\npub const runHistory = history.run;\n\npub const AuditError = audit.AuditError;\npub const AuditResult = audit.AuditResult;\npub const runAudit = audit.run;\npub const AuditArgs = args.AuditArgs;\npub const AuditSubcommand = args.AuditSubcommand;\n\npub const ChangelogError = changelog.ChangelogError;\npub const ChangelogResult = changelog.ChangelogResult;\npub const runChangelog = changelog.run;\npub const ChangelogArgs = args.ChangelogArgs;\n\npub const InfoError = info.InfoError;\npub const InfoResult = info.InfoResult;\npub const runInfo = info.run;\n\npub const StatsError = stats.StatsError;\npub const StatsResult = stats.StatsResult;\npub const runStats = stats.run;\n\npub const DoctorError = doctor.DoctorError;\npub const DoctorResult = doctor.DoctorResult;\npub const runDoctor = doctor.run;\n\npub const ConfigError = config.ConfigError;\npub const ConfigResult = config.ConfigResult;\npub const runConfig = config.run;\n\npub const OrphansError = orphans.OrphansError;\npub const OrphansResult = orphans.OrphansResult;\npub const runOrphans = orphans.run;\n\npub const LintError = lint.LintError;\npub const LintResult = lint.LintResult;\npub const runLint = lint.run;\n\npub const OrphansArgs = args.OrphansArgs;\npub const LintArgs = args.LintArgs;\n\npub const VersionError = version.VersionError;\npub const VersionResult = version.VersionResult;\npub const runVersion = version.run;\npub const VERSION = version.VERSION;\n\npub const SchemaError = schema.SchemaError;\npub const SchemaResult = schema.SchemaResult;\npub const runSchema = schema.run;\n\npub const CompletionsError = completions.CompletionsError;\npub const CompletionsResult = completions.CompletionsResult;\npub const runCompletions = completions.run;\npub const Shell = completions.Shell;\n\npub const MetricsError = metrics_cmd.MetricsError;\npub const MetricsResult = metrics_cmd.MetricsResult;\npub const runMetrics = metrics_cmd.run;\npub const MetricsArgs = args.MetricsArgs;\n\npub const HelpError = help.HelpError;\npub const HelpResult = help.HelpResult;\npub const runHelp = help.run;\n\npub const QueryError = query.QueryError;\npub const QueryResult = query.QueryResult;\npub const runQuery = query.run;\npub const QueryArgs = args.QueryArgs;\n\npub const UpgradeError = upgrade.UpgradeError;\npub const UpgradeResult = upgrade.UpgradeResult;\npub const runUpgrade = upgrade.run;\npub const UpgradeArgs = args.UpgradeArgs;\n\npub const WhereError = where.WhereError;\npub const WhereResult = where.WhereResult;\npub const runWhere = where.run;\n\ntest {\n    std.testing.refAllDecls(@This());\n}\n","structuredPatch":[{"oldStart":165,"oldLines":6,"newStart":165,"newLines":7,"lines":[" pub const StatsError = stats.StatsError;"," pub const StatsResult = stats.StatsResult;"," pub const runStats = stats.run;","+pub const StatsArgs = args.StatsArgs;"," "," pub const DoctorError = doctor.DoctorError;"," pub const DoctorResult = doctor.DoctorResult;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018FR3GwrqxFK1XTP1EHdMig","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's build and test:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":250,"cache_read_input_tokens":160393,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":250},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"f3b65671-56f1-4b0a-be82-0d68c190593f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018FR3GwrqxFK1XTP1EHdMig","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017ju1acrGQJzJV4c8aNNDQK","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build beads_zig","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":250,"cache_read_input_tokens":160393,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":250},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1f82db8f-09ec-4de4-a2c0-ee73d2264931"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017ju1acrGQJzJV4c8aNNDQK","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/stats.zig:241:13: \u001b[31merror: \u001b[0m\u001b[1merror set is discarded\n\u001b[0m        _ = err;\n            \u001b[32m^~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/stats.zig:138:46\n    dispatch: src/main.zig:212:25\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xc5cdbd45 -Z224bd6e098918e34","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4cdfed93-19ae-4d03-b00a-74ea0d3ed92f","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/cli/stats.zig:241:13: \u001b[31merror: \u001b[0m\u001b[1merror set is discarded\n\u001b[0m        _ = err;\n            \u001b[32m^~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    run: src/cli/stats.zig:138:46\n    dispatch: src/main.zig:212:25\n    7 reference(s) hidden; use '-freference-trace=9' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0xc5cdbd45 -Z224bd6e098918e34","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LePKnnzdJdytHb7SbTeDtc","type":"message","role":"assistant","content":[{"type":"text","text":"I need to fix the error handling. In Zig, you can't just discard an error like that:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":698,"cache_read_input_tokens":160643,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":698},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"eb9ad14f-85df-4bdd-98bd-e0802ce51351"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LePKnnzdJdytHb7SbTeDtc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NQiFk5HHXQVabxhpiQc9KG","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/stats.zig","old_string":"    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch |err| {\n        // Git not available or not a git repo - return partial stats\n        _ = err;\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };","new_string":"    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch {\n        // Git not available or not a git repo - return partial stats\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":698,"cache_read_input_tokens":160643,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":698},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"6acc1f3c-545f-469c-ae46-4206c35a6986"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NQiFk5HHXQVabxhpiQc9KG","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/stats.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"4e0e40d0-e6e6-4da5-a66d-007ff120d636","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/stats.zig","oldString":"    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch |err| {\n        // Git not available or not a git repo - return partial stats\n        _ = err;\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };","newString":"    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch {\n        // Git not available or not a git repo - return partial stats\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };","originalFile":"//! Stats command for beads_zig.\n//!\n//! `bz stats` - Show project statistics\n//! `bz stats --activity` - Show git-based activity statistics\n//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const StatsError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    GitError,\n};\n\npub const StatsResult = struct {\n    success: bool,\n    total: ?usize = null,\n    open: ?usize = null,\n    closed: ?usize = null,\n    by_status: ?[]const CountEntry = null,\n    by_priority: ?[]const CountEntry = null,\n    by_type: ?[]const CountEntry = null,\n    activity: ?ActivityStats = null,\n    message: ?[]const u8 = null,\n\n    pub const CountEntry = struct {\n        key: []const u8,\n        count: usize,\n    };\n\n    pub const ActivityStats = struct {\n        period_hours: u32,\n        git_commits: usize,\n        issues_created: usize,\n        issues_closed: usize,\n        issues_updated: usize,\n        commits_with_issue_refs: usize,\n        issue_refs: ?[]const IssueRef = null,\n\n        pub const IssueRef = struct {\n            issue_id: []const u8,\n            commit_count: usize,\n        };\n    };\n};\n\npub fn run(\n    stats_args: args.StatsArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return StatsError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count totals\n    var total: usize = 0;\n    var open: usize = 0;\n    var closed: usize = 0;\n\n    // Count by status\n    var status_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer status_counts.deinit(allocator);\n\n    // Count by priority\n    var priority_counts: [5]usize = .{ 0, 0, 0, 0, 0 };\n\n    // Count by type\n    var type_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer type_counts.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        total += 1;\n\n        // Status\n        const status_str = issue.status.toString();\n        const status_entry = try status_counts.getOrPutValue(allocator, status_str, 0);\n        status_entry.value_ptr.* += 1;\n\n        if (issue.status.eql(.open) or issue.status.eql(.in_progress) or issue.status.eql(.blocked)) {\n            open += 1;\n        } else if (issue.status.eql(.closed)) {\n            closed += 1;\n        }\n\n        // Priority\n        if (issue.priority.value <= 4) {\n            priority_counts[issue.priority.value] += 1;\n        }\n\n        // Type\n        const type_str = issue.issue_type.toString();\n        const type_entry = try type_counts.getOrPutValue(allocator, type_str, 0);\n        type_entry.value_ptr.* += 1;\n    }\n\n    // Convert to arrays for output\n    var status_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer status_list.deinit(allocator);\n\n    var status_it = status_counts.iterator();\n    while (status_it.next()) |entry| {\n        try status_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    var priority_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer priority_list.deinit(allocator);\n\n    const priority_names = [_][]const u8{ \"critical\", \"high\", \"medium\", \"low\", \"backlog\" };\n    for (0..5) |i| {\n        if (priority_counts[i] > 0) {\n            try priority_list.append(allocator, .{ .key = priority_names[i], .count = priority_counts[i] });\n        }\n    }\n\n    var type_list: std.ArrayListUnmanaged(StatsResult.CountEntry) = .{};\n    defer type_list.deinit(allocator);\n\n    var type_it = type_counts.iterator();\n    while (type_it.next()) |entry| {\n        try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n    }\n\n    // Activity stats (if requested)\n    var activity_stats: ?StatsResult.ActivityStats = null;\n    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n    defer issue_refs_list.deinit(allocator);\n\n    if (stats_args.activity) {\n        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(StatsResult{\n            .success = true,\n            .total = total,\n            .open = open,\n            .closed = closed,\n            .by_status = status_list.items,\n            .by_priority = priority_list.items,\n            .by_type = type_list.items,\n            .activity = activity_stats,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Issue Statistics\", .{});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total: {d} issues ({d} open, {d} closed)\\n\", .{ total, open, closed });\n        try ctx.output.print(\"\\n\", .{});\n\n        if (status_list.items.len > 0) {\n            try ctx.output.print(\"By Status:\\n\", .{});\n            for (status_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (priority_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Priority:\\n\", .{});\n            for (priority_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (type_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Type:\\n\", .{});\n            for (type_list.items) |entry| {\n                try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n            }\n        }\n\n        if (activity_stats) |activity| {\n            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n\n            if (activity.issue_refs) |refs| {\n                if (refs.len > 0) {\n                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n                    for (refs[0..@min(10, refs.len)]) |ref| {\n                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n                    }\n                    if (refs.len > 10) {\n                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn getActivityStats(\n    allocator: std.mem.Allocator,\n    ctx: *CommandContext,\n    hours: u32,\n    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n) !StatsResult.ActivityStats {\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n\n    // Count issue activity in the time period\n    var issues_created: usize = 0;\n    var issues_closed: usize = 0;\n    var issues_updated: usize = 0;\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        if (issue.created_at.value >= since) {\n            issues_created += 1;\n        }\n        if (issue.closed_at.value) |closed_ts| {\n            if (closed_ts >= since) {\n                issues_closed += 1;\n            }\n        }\n        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n            issues_updated += 1;\n        }\n    }\n\n    // Get git commit stats\n    var git_commits: usize = 0;\n    var commits_with_refs: usize = 0;\n    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer issue_ref_counts.deinit(allocator);\n\n    // Run git log to get recent commits\n    const git_result = runGitLog(allocator, hours) catch |err| {\n        // Git not available or not a git repo - return partial stats\n        _ = err;\n        return StatsResult.ActivityStats{\n            .period_hours = hours,\n            .git_commits = 0,\n            .issues_created = issues_created,\n            .issues_closed = issues_closed,\n            .issues_updated = issues_updated,\n            .commits_with_issue_refs = 0,\n            .issue_refs = null,\n        };\n    };\n    defer allocator.free(git_result);\n\n    // Parse git log output\n    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n    while (lines.next()) |line| {\n        if (line.len == 0) continue;\n        git_commits += 1;\n\n        // Look for issue references (bd-xxx pattern)\n        var found_ref = false;\n        var i: usize = 0;\n        while (i < line.len) {\n            // Look for \"bd-\" or similar prefix\n            if (i + 3 < line.len and\n                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n            {\n                // Extract the issue ID\n                const start = i;\n                i += 3;\n                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n                    i += 1;\n                }\n                const issue_id = line[start..i];\n                if (issue_id.len > 3) {\n                    // Normalize to lowercase\n                    var normalized: [32]u8 = undefined;\n                    const len = @min(issue_id.len, 32);\n                    for (0..len) |j| {\n                        normalized[j] = std.ascii.toLower(issue_id[j]);\n                    }\n                    const key = normalized[0..len];\n\n                    // Check if this issue exists in our store\n                    if (ctx.store.exists(key) catch false) {\n                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n                        entry.value_ptr.* += 1;\n                        found_ref = true;\n                    }\n                }\n            } else {\n                i += 1;\n            }\n        }\n        if (found_ref) {\n            commits_with_refs += 1;\n        }\n    }\n\n    // Convert issue refs to array\n    var it = issue_ref_counts.iterator();\n    while (it.next()) |entry| {\n        try issue_refs_list.append(allocator, .{\n            .issue_id = entry.key_ptr.*,\n            .commit_count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by commit count descending\n    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n            return a.commit_count > b.commit_count;\n        }\n    }.lessThan);\n\n    return StatsResult.ActivityStats{\n        .period_hours = hours,\n        .git_commits = git_commits,\n        .issues_created = issues_created,\n        .issues_closed = issues_closed,\n        .issues_updated = issues_updated,\n        .commits_with_issue_refs = commits_with_refs,\n        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n    };\n}\n\nfn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n    var buf: [32]u8 = undefined;\n    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n        .cwd = null,\n    }) catch return StatsError.GitError;\n\n    defer allocator.free(result.stderr);\n\n    if (result.term.Exited != 0) {\n        allocator.free(result.stdout);\n        return StatsError.GitError;\n    }\n\n    return result.stdout;\n}\n\n// --- Tests ---\n\ntest \"StatsError enum exists\" {\n    const err: StatsError = StatsError.WorkspaceNotInitialized;\n    try std.testing.expect(err == StatsError.WorkspaceNotInitialized);\n}\n\ntest \"StatsResult struct works\" {\n    const result = StatsResult{\n        .success = true,\n        .total = 10,\n        .open = 5,\n        .closed = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const stats_args = args.StatsArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(stats_args, global, allocator);\n    try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n}\n\ntest \"StatsArgs default values\" {\n    const stats_args = args.StatsArgs{};\n    try std.testing.expect(!stats_args.activity);\n    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n}\n\ntest \"parse stats with activity flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .stats => |s| {\n            try std.testing.expect(s.activity);\n            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse stats with activity-hours flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .stats => |s| {\n            try std.testing.expect(s.activity);\n            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":236,"oldLines":9,"newStart":236,"newLines":8,"lines":["     defer issue_ref_counts.deinit(allocator);"," ","     // Run git log to get recent commits","-    const git_result = runGitLog(allocator, hours) catch |err| {","+    const git_result = runGitLog(allocator, hours) catch {","         // Git not available or not a git repo - return partial stats","-        _ = err;","         return StatsResult.ActivityStats{","             .period_hours = hours,","             .git_commits = 0,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014HzEwi6TLKyfsr7TjQAhGM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UpWiMKc77aKsZ1eiZkWty1","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build beads_zig","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":471,"cache_read_input_tokens":161341,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":471},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"e8278286-660b-4ea4-81cb-a29a6288c154"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UpWiMKc77aKsZ1eiZkWty1","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"fa5dae82-6657-45a0-a4c7-4cf39d4aa2cd","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011fr8QDKbu7uYZMfnpNrKhe","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's run the tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":129,"cache_read_input_tokens":161812,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":129},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"2f41d606-e709-4c2d-a44c-f0218a6c21ee"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011fr8QDKbu7uYZMfnpNrKhe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018iUeq4xoGZ63keE32szyAZ","name":"Bash","input":{"command":"zig build test 2>&1 | tail -50","description":"Run tests to verify the changes","timeout":180000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":129,"cache_read_input_tokens":161812,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":129},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"69ae0eec-eab4-474c-805c-e8c4a58e0d6f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018iUeq4xoGZ63keE32szyAZ","type":"tool_result","content":"643/684 id.hash.test.contentHash different for different flags...OK\n644/684 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n645/684 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n646/684 id.hash.test.contentHash ignores id field...OK\n647/684 id.hash.test.contentHash ignores timestamps...OK\n648/684 id.hash.test.contentHash with custom status...OK\n649/684 id.hash.test.contentHash with custom issue_type...OK\n650/684 config.yaml.test.parse simple key-value...OK\n651/684 config.yaml.test.parse with comments...OK\n652/684 config.yaml.test.parse nested structure...OK\n653/684 config.yaml.test.parse quoted values...OK\n654/684 config.yaml.test.parse empty value...OK\n655/684 config.yaml.test.get returns null for missing key...OK\n656/684 config.yaml.test.parse handles Windows line endings...OK\n657/684 config.yaml.test.parse ignores blank lines...OK\n658/684 tests.cli_test.test.bz version shows version info...OK\n659/684 tests.cli_test.test.bz help shows usage...OK\n660/684 tests.cli_test.test.bz --help shows usage...OK\n661/684 tests.cli_test.test.bz init creates workspace...OK\n662/684 tests.cli_test.test.bz init fails when already initialized...OK\n663/684 tests.cli_test.test.bz create returns ID...OK\n664/684 tests.cli_test.test.bz q returns ID...OK\n665/684 tests.cli_test.test.bz list returns issues...OK\n666/684 tests.cli_test.test.bz list --json returns output...OK\n667/684 tests.cli_test.test.bz show displays issue...OK\n668/684 tests.cli_test.test.bz show not-found returns error...OK\n669/684 tests.cli_test.test.bz close marks issue as closed...OK\n670/684 tests.cli_test.test.bz reopen reopens closed issue...OK\n671/684 tests.cli_test.test.bz delete soft deletes issue...OK\n672/684 tests.cli_test.test.bz search finds matching issues...OK\n673/684 tests.cli_test.test.bz dep add creates dependency...OK\n674/684 tests.cli_test.test.bz dep add rejects cycles...OK\n675/684 tests.cli_test.test.bz ready shows unblocked issues...OK\n676/684 tests.cli_test.test.bz blocked shows blocked issues...OK\n677/684 tests.cli_test.test.bz unknown command returns error...OK\n678/684 tests.cli_test.test.bz without workspace shows error...OK\n679/684 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n680/684 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n681/684 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 73 issues created\nOK\n682/684 tests.stress_test.test.sequential writes: single thread baseline...OK\n683/684 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n684/684 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 684 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d7e0e86f-b8bc-4179-8a7c-11ecd4d729e0","tool_use_result":{"stdout":"643/684 id.hash.test.contentHash different for different flags...OK\n644/684 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n645/684 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n646/684 id.hash.test.contentHash ignores id field...OK\n647/684 id.hash.test.contentHash ignores timestamps...OK\n648/684 id.hash.test.contentHash with custom status...OK\n649/684 id.hash.test.contentHash with custom issue_type...OK\n650/684 config.yaml.test.parse simple key-value...OK\n651/684 config.yaml.test.parse with comments...OK\n652/684 config.yaml.test.parse nested structure...OK\n653/684 config.yaml.test.parse quoted values...OK\n654/684 config.yaml.test.parse empty value...OK\n655/684 config.yaml.test.get returns null for missing key...OK\n656/684 config.yaml.test.parse handles Windows line endings...OK\n657/684 config.yaml.test.parse ignores blank lines...OK\n658/684 tests.cli_test.test.bz version shows version info...OK\n659/684 tests.cli_test.test.bz help shows usage...OK\n660/684 tests.cli_test.test.bz --help shows usage...OK\n661/684 tests.cli_test.test.bz init creates workspace...OK\n662/684 tests.cli_test.test.bz init fails when already initialized...OK\n663/684 tests.cli_test.test.bz create returns ID...OK\n664/684 tests.cli_test.test.bz q returns ID...OK\n665/684 tests.cli_test.test.bz list returns issues...OK\n666/684 tests.cli_test.test.bz list --json returns output...OK\n667/684 tests.cli_test.test.bz show displays issue...OK\n668/684 tests.cli_test.test.bz show not-found returns error...OK\n669/684 tests.cli_test.test.bz close marks issue as closed...OK\n670/684 tests.cli_test.test.bz reopen reopens closed issue...OK\n671/684 tests.cli_test.test.bz delete soft deletes issue...OK\n672/684 tests.cli_test.test.bz search finds matching issues...OK\n673/684 tests.cli_test.test.bz dep add creates dependency...OK\n674/684 tests.cli_test.test.bz dep add rejects cycles...OK\n675/684 tests.cli_test.test.bz ready shows unblocked issues...OK\n676/684 tests.cli_test.test.bz blocked shows blocked issues...OK\n677/684 tests.cli_test.test.bz unknown command returns error...OK\n678/684 tests.cli_test.test.bz without workspace shows error...OK\n679/684 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n680/684 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n681/684 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 73 issues created\nOK\n682/684 tests.stress_test.test.sequential writes: single thread baseline...OK\n683/684 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n684/684 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 684 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NfxHvTUXATMq49mZrjsZBo","type":"message","role":"assistant","content":[{"type":"text","text":"All 684 tests pass (3 new tests were added). Both tasks are complete. Let me update the todo list and then create the commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1201,"cache_read_input_tokens":161941,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1201},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"d0ad3b55-df17-43ab-9256-254da3f465a3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NfxHvTUXATMq49mZrjsZBo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014c8gJu62dyqz5rGTFVkYHP","name":"TodoWrite","input":{"todos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"completed","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"completed","activeForm":"Adding --activity git-based stats to stats command"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1201,"cache_read_input_tokens":161941,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1201},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"1169e961-85f8-4d6c-bd70-1dae33b6023b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014c8gJu62dyqz5rGTFVkYHP","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b47c2089-71d6-46b4-88be-2761df79f55c","tool_use_result":{"oldTodos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"completed","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"in_progress","activeForm":"Adding --activity git-based stats to stats command"}],"newTodos":[{"content":"Implement audit command subcommands (record, label, log, summary)","status":"completed","activeForm":"Implementing audit command subcommands"},{"content":"Add --activity git-based stats to stats command","status":"completed","activeForm":"Adding --activity git-based stats to stats command"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LnoHW7neAVZQw4qUSg9d1E","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify the changes and then create the commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":204,"cache_read_input_tokens":163142,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":204},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3bdfc2b4-ce3a-4003-af22-97e4046e29d0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LnoHW7neAVZQw4qUSg9d1E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AtN1we6giaf74fxEXLobS3","name":"Bash","input":{"command":"git status","description":"Show git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":204,"cache_read_input_tokens":163142,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":204},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"ff398613-59a9-4af1-beaf-b5ce431fd25b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AtN1we6giaf74fxEXLobS3","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 37 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/audit.zig\n\tmodified:   src/cli/mod.zig\n\tmodified:   src/cli/stats.zig\n\tmodified:   src/main.zig\n\tmodified:   src/models/event.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"ddf29b95-350e-4e68-8419-3544a6396e68","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 37 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/audit.zig\n\tmodified:   src/cli/mod.zig\n\tmodified:   src/cli/stats.zig\n\tmodified:   src/main.zig\n\tmodified:   src/models/event.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LnoHW7neAVZQw4qUSg9d1E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013f6osVVzZZT1d3eoPzZuA9","name":"Bash","input":{"command":"git diff --stat","description":"Show diff statistics"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":204,"cache_read_input_tokens":163142,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":204},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0a14a21b-de7b-4043-8ffa-a66fd8d8230a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013f6osVVzZZT1d3eoPzZuA9","type":"tool_result","content":" .beads/issues.jsonl   |   4 +-\n .hot_ralph/state.json |   6 +-\n src/cli/args.zig      | 173 +++++++++++++++++--\n src/cli/audit.zig     | 449 +++++++++++++++++++++++++++++++++++++++++++++++++-\n src/cli/mod.zig       |   3 +\n src/cli/stats.zig     | 236 +++++++++++++++++++++++++-\n src/main.zig          |   8 +-\n src/models/event.zig  |   3 +\n 8 files changed, 858 insertions(+), 24 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"3f41c4e3-6ed1-41c3-8c2a-afd7b49cfd6d","tool_use_result":{"stdout":" .beads/issues.jsonl   |   4 +-\n .hot_ralph/state.json |   6 +-\n src/cli/args.zig      | 173 +++++++++++++++++--\n src/cli/audit.zig     | 449 +++++++++++++++++++++++++++++++++++++++++++++++++-\n src/cli/mod.zig       |   3 +\n src/cli/stats.zig     | 236 +++++++++++++++++++++++++-\n src/main.zig          |   8 +-\n src/models/event.zig  |   3 +\n 8 files changed, 858 insertions(+), 24 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LwSky5Y1oJJXYy26ADf8T3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012KWKtrGfPQCejx9XryhRKX","name":"Bash","input":{"command":"git log --oneline -5","description":"Show recent commits for commit message style"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":594,"cache_read_input_tokens":163346,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":594},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"0cbff586-ab7c-48a6-b644-440d6f0fd9b6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012KWKtrGfPQCejx9XryhRKX","type":"tool_result","content":"2e7f4d0 Plan mode: complete 2 tasks\nd5c13be refactor(backup): extract collectBackups helper function\nbd756fc feat(sync,backup): add sync policy options and backup command\na97a7a7 Plan mode: complete 2 tasks\n87f5f40 refactor(epic): use existing storage import for IssueUpdate","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c56941b0-f56b-4c0b-98a4-4fe0707f3995","tool_use_result":{"stdout":"2e7f4d0 Plan mode: complete 2 tasks\nd5c13be refactor(backup): extract collectBackups helper function\nbd756fc feat(sync,backup): add sync policy options and backup command\na97a7a7 Plan mode: complete 2 tasks\n87f5f40 refactor(epic): use existing storage import for IssueUpdate","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RcWUhPhCC24LTS58qftPb1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012LjSEmNKdvKki36KmXXCsb","name":"Bash","input":{"command":"git add src/cli/args.zig src/cli/audit.zig src/cli/mod.zig src/cli/stats.zig src/main.zig src/models/event.zig","description":"Stage changed source files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":180,"cache_read_input_tokens":163940,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":180},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"5f4d1892-f5ff-4643-82d8-439e62ac2b0b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012LjSEmNKdvKki36KmXXCsb","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"9543a8da-faad-48f8-b4e9-95e8d708a97d","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MCyuRDkWbRjgUTHkpSkpmr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K42HKNuN95L1vsZYhJHXg6","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nfeat(audit,stats): add audit subcommands and git activity stats\n\nAdd audit command subcommands for LLM/tool interaction tracking:\n- `audit record <kind>` - Record LLM/tool calls for training data\n- `audit label <entry-id> <label>` - Label audit entries for quality tracking\n- `audit log <issue-id>` - View audit log for specific issue\n- `audit summary` - Summary of audit data over time period\n\nAdd git-based activity statistics to stats command:\n- `stats --activity` - Show git commits, issue activity in last 24h\n- `stats --activity-hours N` - Customize lookback period\n- Correlates issue references in commit messages\n\nNew event types added: llm_call, tool_call\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Create commit with changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":145,"cache_read_input_tokens":164120,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":145},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"b1f324e5-834f-4910-88eb-c46d6bc73f80"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K42HKNuN95L1vsZYhJHXg6","type":"tool_result","content":"[dev-hotschmoe 0acd12d] feat(audit,stats): add audit subcommands and git activity stats\n 6 files changed, 853 insertions(+), 19 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"31a111d4-9d85-4030-b8e7-7389ffd4d123","tool_use_result":{"stdout":"[dev-hotschmoe 0acd12d] feat(audit,stats): add audit subcommands and git activity stats\n 6 files changed, 853 insertions(+), 19 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CmdGNivxecJqEf8C2qkZ4k","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Eg7P3WXVR2stWL3M4v4bSU","name":"Bash","input":{"command":"git status","description":"Verify commit status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":348,"cache_read_input_tokens":164265,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":348},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"99cc197c-b6fd-46df-8178-bfe2c156356c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Eg7P3WXVR2stWL3M4v4bSU","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 38 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"c68200c9-bcc2-4813-b733-0f05fb768f18","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 38 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KE6LpUKieCstLFrTc934Da","type":"message","role":"assistant","content":[{"type":"text","text":"Both tasks have been completed successfully. Here's a summary:\n\n## Task Status\n\n### Task 1: Add audit command (record, label, log, summary) - **SUCCESS**\n**ID**: bd-nks\n\nImplemented the `audit` command with subcommands:\n- `bz audit record <kind>` - Records LLM/tool interactions with fields like `--model`, `--prompt`, `--response`, `--tool-name`, `--exit-code`\n- `bz audit label <entry-id> <label>` - Labels audit entries with optional `--reason`\n- `bz audit log <issue-id>` - Views audit log for a specific issue\n- `bz audit summary [--days N]` - Shows summary of audit data over time period\n- `bz audit [list]` - Default behavior shows project-wide audit log (backwards compatible)\n\nAdded new event types `llm_call` and `tool_call` to the EventType enum.\n\n### Task 2: Add --activity git-based stats to stats command - **SUCCESS**\n**ID**: bd-3el\n\nImplemented git-based activity statistics:\n- `bz stats --activity` - Shows git commits and issue activity correlation\n- `bz stats --activity-hours N` - Customize lookback period (default 24 hours)\n- Displays: git commits count, issues created/closed/updated in period, commits referencing issues\n- Gracefully handles non-git repositories\n\n## Files Changed\n\n| File | Changes |\n|------|---------|\n| `src/cli/args.zig` | Added `AuditSubcommand`, `AuditArgs`, `StatsArgs`, and parsing functions |\n| `src/cli/audit.zig` | Complete rewrite with subcommand handling for record, label, log, summary, list |\n| `src/cli/stats.zig` | Added activity stats with git integration |\n| `src/cli/mod.zig` | Exported new types |\n| `src/main.zig` | Updated dispatch for new signatures and errors |\n| `src/models/event.zig` | Added `llm_call` and `tool_call` event types |\n\nAll 684 tests pass."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":221,"cache_read_input_tokens":164613,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":221},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","uuid":"bf93270a-f602-45e0-9e93-dbcec31d3261"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":632305,"duration_api_ms":630714,"num_turns":77,"result":"Both tasks have been completed successfully. Here's a summary:\n\n## Task Status\n\n### Task 1: Add audit command (record, label, log, summary) - **SUCCESS**\n**ID**: bd-nks\n\nImplemented the `audit` command with subcommands:\n- `bz audit record <kind>` - Records LLM/tool interactions with fields like `--model`, `--prompt`, `--response`, `--tool-name`, `--exit-code`\n- `bz audit label <entry-id> <label>` - Labels audit entries with optional `--reason`\n- `bz audit log <issue-id>` - Views audit log for a specific issue\n- `bz audit summary [--days N]` - Shows summary of audit data over time period\n- `bz audit [list]` - Default behavior shows project-wide audit log (backwards compatible)\n\nAdded new event types `llm_call` and `tool_call` to the EventType enum.\n\n### Task 2: Add --activity git-based stats to stats command - **SUCCESS**\n**ID**: bd-3el\n\nImplemented git-based activity statistics:\n- `bz stats --activity` - Shows git commits and issue activity correlation\n- `bz stats --activity-hours N` - Customize lookback period (default 24 hours)\n- Displays: git commits count, issues created/closed/updated in period, commits referencing issues\n- Gracefully handles non-git repositories\n\n## Files Changed\n\n| File | Changes |\n|------|---------|\n| `src/cli/args.zig` | Added `AuditSubcommand`, `AuditArgs`, `StatsArgs`, and parsing functions |\n| `src/cli/audit.zig` | Complete rewrite with subcommand handling for record, label, log, summary, list |\n| `src/cli/stats.zig` | Added activity stats with git integration |\n| `src/cli/mod.zig` | Exported new types |\n| `src/main.zig` | Updated dispatch for new signatures and errors |\n| `src/models/event.zig` | Added `llm_call` and `tool_call` event types |\n\nAll 684 tests pass.","session_id":"ba1ae0ef-22e7-4606-9b29-3431d57c8b2e","total_cost_usd":6.3567838,"usage":{"input_tokens":2,"cache_creation_input_tokens":146858,"cache_read_input_tokens":8968010,"output_tokens":29935,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":146858,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":29935,"cacheReadInputTokens":8968010,"cacheCreationInputTokens":146858,"webSearchRequests":0,"costUSD":6.150252500000001,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":21328,"outputTokens":10242,"cacheReadInputTokens":536233,"cacheCreationInputTokens":64296,"webSearchRequests":0,"costUSD":0.20653129999999997,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"25da4ee6-1c46-45b8-aeae-217a9c3eb473"}
