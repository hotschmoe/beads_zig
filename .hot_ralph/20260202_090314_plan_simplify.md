{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"ca0d35f8-ceb2-48dc-9ddf-a06aa706251a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NjesXUrgjzcHh9E2ZWbZ4N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LpSQ3xSTGcnKVjEd6nHSSm","name":"Bash","input":{"command":"git status","description":"Check git status for modified files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3678,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3678},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"40a9b333-4681-453b-9c14-e96dd3791411"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LpSQ3xSTGcnKVjEd6nHSSm","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 26 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260202_090140_plan_mode.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"32567e7d-bb5e-4362-9814-34b1344561f4","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 26 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260202_090140_plan_mode.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NjesXUrgjzcHh9E2ZWbZ4N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DRb2HgMpZtnRPJQXC14wXT","name":"Bash","input":{"command":"git diff --stat HEAD~5","description":"See what files changed in recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3678,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3678},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"9dad2b55-a045-4862-9e77-6cd49987fee0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DRb2HgMpZtnRPJQXC14wXT","type":"tool_result","content":" .beads/issues.jsonl                         |  12 +-\n .hot_ralph/20260202_083900_plan_mode.md     | 195 +++++++++++++++++++\n .hot_ralph/20260202_084152_plan_simplify.md |  77 ++++++++\n .hot_ralph/20260202_085222_plan_mode.md     | 289 ++++++++++++++++++++++++++++\n .hot_ralph/20260202_085444_plan_simplify.md |  65 +++++++\n .hot_ralph/state.json                       |   4 +-\n src/cli/args.zig                            | 199 ++++++++++++++++++-\n src/cli/close.zig                           |   6 +\n src/cli/common.zig                          |   4 +\n src/cli/delete.zig                          | 262 ++++++++++++++++++++++---\n src/cli/dep.zig                             | 215 +++++++++++++++++++--\n src/cli/label.zig                           |  76 ++++++++\n src/output/mod.zig                          |  29 +++\n src/storage/store.zig                       |  33 ++++\n 14 files changed, 1403 insertions(+), 63 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"87451668-db96-49b1-84f6-7e8a89f17adb","tool_use_result":{"stdout":" .beads/issues.jsonl                         |  12 +-\n .hot_ralph/20260202_083900_plan_mode.md     | 195 +++++++++++++++++++\n .hot_ralph/20260202_084152_plan_simplify.md |  77 ++++++++\n .hot_ralph/20260202_085222_plan_mode.md     | 289 ++++++++++++++++++++++++++++\n .hot_ralph/20260202_085444_plan_simplify.md |  65 +++++++\n .hot_ralph/state.json                       |   4 +-\n src/cli/args.zig                            | 199 ++++++++++++++++++-\n src/cli/close.zig                           |   6 +\n src/cli/common.zig                          |   4 +\n src/cli/delete.zig                          | 262 ++++++++++++++++++++++---\n src/cli/dep.zig                             | 215 +++++++++++++++++++--\n src/cli/label.zig                           |  76 ++++++++\n src/output/mod.zig                          |  29 +++\n src/storage/store.zig                       |  33 ++++\n 14 files changed, 1403 insertions(+), 63 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GcLWRJMchEPTT71j4LkjwQ","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at the actual code changes in the main source files to understand what was modified."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":720,"cache_read_input_tokens":21654,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":720},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"80061718-1896-4105-ab26-fe9bb9693e0a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GcLWRJMchEPTT71j4LkjwQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CwaCkThUTTJ4wkfKrMqLET","name":"Bash","input":{"command":"git diff HEAD~5 -- src/cli/args.zig src/cli/delete.zig src/cli/dep.zig src/cli/label.zig src/cli/close.zig src/cli/common.zig src/output/mod.zig src/storage/store.zig","description":"View code changes in recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":720,"cache_read_input_tokens":21654,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":720},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"391de1d8-19dd-456f-8268-cb1f69f247f4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CwaCkThUTTJ4wkfKrMqLET","type":"tool_result","content":"<persisted-output>\nOutput too large (43.6KB). Full output saved to: /home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/d965594a-b540-4605-8ceb-7e84a6081b47/tool-results/toolu_01CwaCkThUTTJ4wkfKrMqLET.txt\n\nPreview (first 2KB):\ndiff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 54a8db2..2de3b21 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -9,6 +9,7 @@ const std = @import(\"std\");\n pub const GlobalOptions = struct {\n     json: bool = false,\n     toon: bool = false,\n+    robot: bool = false, // Line-oriented machine-readable output for scripting\n     quiet: bool = false,\n     silent: bool = false, // Suppress ALL output including errors (for tests)\n     verbose: u8 = 0,\n@@ -25,6 +26,11 @@ pub const GlobalOptions = struct {\n     pub fn isStructuredOutput(self: GlobalOptions) bool {\n         return self.json or self.toon;\n     }\n+\n+    /// Returns true if any machine-readable output is enabled.\n+    pub fn isMachineOutput(self: GlobalOptions) bool {\n+        return self.json or self.toon or self.robot;\n+    }\n };\n \n /// All available subcommands.\n@@ -170,7 +176,16 @@ pub const ReopenArgs = struct {\n \n /// Delete command arguments.\n pub const DeleteArgs = struct {\n-    id: []const u8,\n+    /// Single issue ID to delete (mutually exclusive with from_file).\n+    id: ?[]const u8 = null,\n+    /// Path to file containing issue IDs to delete (one per line).\n+    from_file: ?[]const u8 = null,\n+    /// Delete issue and all its dependents recursively.\n+    cascade: bool = false,\n+    /// Prune from database immediately instead of marking as tombstone.\n+    hard: bool = false,\n+    /// Preview what would be deleted without making changes.\n+    dry_run: bool = false,\n };\n \n /// Add-batch command arguments.\n@@ -332,12 +347,39 @@ pub const EpicArgs = struct {\n     subcommand: EpicSubcommand,\n };\n \n+/// Direction filter for dependency listing.\n+pub const DepDirection = enum {\n+    up, // What depends on this issue (dependents/blocked-by)\n+    down, // What this issue depends on\n+    both, // Both directions (default)\n+\n+    pub fn fromString(s: []const u8) ?DepDirection {\n+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n...\n</persisted-output>","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"19f4e958-4b2b-4d77-8178-659dc8f1bd05","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 54a8db2..2de3b21 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -9,6 +9,7 @@ const std = @import(\"std\");\n pub const GlobalOptions = struct {\n     json: bool = false,\n     toon: bool = false,\n+    robot: bool = false, // Line-oriented machine-readable output for scripting\n     quiet: bool = false,\n     silent: bool = false, // Suppress ALL output including errors (for tests)\n     verbose: u8 = 0,\n@@ -25,6 +26,11 @@ pub const GlobalOptions = struct {\n     pub fn isStructuredOutput(self: GlobalOptions) bool {\n         return self.json or self.toon;\n     }\n+\n+    /// Returns true if any machine-readable output is enabled.\n+    pub fn isMachineOutput(self: GlobalOptions) bool {\n+        return self.json or self.toon or self.robot;\n+    }\n };\n \n /// All available subcommands.\n@@ -170,7 +176,16 @@ pub const ReopenArgs = struct {\n \n /// Delete command arguments.\n pub const DeleteArgs = struct {\n-    id: []const u8,\n+    /// Single issue ID to delete (mutually exclusive with from_file).\n+    id: ?[]const u8 = null,\n+    /// Path to file containing issue IDs to delete (one per line).\n+    from_file: ?[]const u8 = null,\n+    /// Delete issue and all its dependents recursively.\n+    cascade: bool = false,\n+    /// Prune from database immediately instead of marking as tombstone.\n+    hard: bool = false,\n+    /// Preview what would be deleted without making changes.\n+    dry_run: bool = false,\n };\n \n /// Add-batch command arguments.\n@@ -332,12 +347,39 @@ pub const EpicArgs = struct {\n     subcommand: EpicSubcommand,\n };\n \n+/// Direction filter for dependency listing.\n+pub const DepDirection = enum {\n+    up, // What depends on this issue (dependents/blocked-by)\n+    down, // What this issue depends on\n+    both, // Both directions (default)\n+\n+    pub fn fromString(s: []const u8) ?DepDirection {\n+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n+        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n+        return null;\n+    }\n+};\n+\n+/// Tree output formats for dep tree.\n+pub const TreeFormat = enum {\n+    ascii,\n+    mermaid,\n+\n+    pub fn fromString(s: []const u8) ?TreeFormat {\n+        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n+        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n+        return null;\n+    }\n+};\n+\n /// Dependency subcommand variants.\n pub const DepSubcommand = union(enum) {\n     add: struct {\n         child: []const u8,\n         parent: []const u8,\n         dep_type: []const u8 = \"blocks\",\n+        metadata: ?[]const u8 = null,\n     },\n     remove: struct {\n         child: []const u8,\n@@ -345,9 +387,11 @@ pub const DepSubcommand = union(enum) {\n     },\n     list: struct {\n         id: []const u8,\n+        direction: DepDirection = .both,\n     },\n     tree: struct {\n         id: []const u8,\n+        format: TreeFormat = .ascii,\n     },\n     cycles: void,\n };\n@@ -391,6 +435,10 @@ pub const LabelSubcommand = union(enum) {\n         id: []const u8,\n     },\n     list_all: void,\n+    rename: struct {\n+        old_name: []const u8,\n+        new_name: []const u8,\n+    },\n };\n \n /// Label command arguments.\n@@ -674,6 +722,10 @@ pub const ArgParser = struct {\n             global.stats = true;\n             return true;\n         }\n+        if (std.mem.eql(u8, arg, \"--robot\")) {\n+            global.robot = true;\n+            return true;\n+        }\n \n         // Put back if not recognized\n         self.index -= 1;\n@@ -1012,8 +1064,30 @@ pub const ArgParser = struct {\n     }\n \n     fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n-        const id = self.next() orelse return error.MissingRequiredArgument;\n-        return .{ .id = id };\n+        var result = DeleteArgs{};\n+\n+        while (self.hasNext()) {\n+            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n+                result.from_file = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--cascade\")) {\n+                result.cascade = true;\n+            } else if (self.consumeFlag(null, \"--hard\")) {\n+                result.hard = true;\n+            } else if (self.consumeFlag(null, \"--dry-run\")) {\n+                result.dry_run = true;\n+            } else if (self.peekPositional()) |_| {\n+                if (result.id == null) {\n+                    result.id = self.next().?;\n+                } else break;\n+            } else break;\n+        }\n+\n+        // Require either id or from_file\n+        if (result.id == null and result.from_file == null) {\n+            return error.MissingRequiredArgument;\n+        }\n+\n+        return result;\n     }\n \n     fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n@@ -1235,12 +1309,15 @@ pub const ArgParser = struct {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n             const parent = self.next() orelse return error.MissingRequiredArgument;\n             var dep_type: []const u8 = \"blocks\";\n+            var metadata: ?[]const u8 = null;\n             while (self.hasNext()) {\n                 if (self.consumeFlag(\"-t\", \"--type\")) {\n                     dep_type = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n+                    metadata = self.next() orelse return error.MissingFlagValue;\n                 } else break;\n             }\n-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n+            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n@@ -1248,10 +1325,26 @@ pub const ArgParser = struct {\n             return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n+            const id = self.next() orelse return error.MissingRequiredArgument;\n+            var direction: DepDirection = .both;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-d\", \"--direction\")) {\n+                    const dir_str = self.next() orelse return error.MissingFlagValue;\n+                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"tree\")) {\n-            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n+            const id = self.next() orelse return error.MissingRequiredArgument;\n+            var format: TreeFormat = .ascii;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-f\", \"--format\")) {\n+                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n+                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"cycles\")) {\n             return .{ .subcommand = .{ .cycles = {} } };\n@@ -1348,6 +1441,11 @@ pub const ArgParser = struct {\n         if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n             return .{ .subcommand = .{ .list_all = {} } };\n         }\n+        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n+            const old_name = self.next() orelse return error.MissingRequiredArgument;\n+            const new_name = self.next() orelse return error.MissingRequiredArgument;\n+            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n+        }\n         return error.UnknownSubcommand;\n     }\n \n@@ -1897,12 +1995,34 @@ test \"parse reopen command\" {\n }\n \n test \"parse delete command\" {\n-    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n-    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n     const result = try parser.parse();\n \n     try std.testing.expect(result.command == .delete);\n-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n+    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n+}\n+\n+test \"parse delete command with flags\" {\n+    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.command == .delete);\n+    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n+    try std.testing.expect(result.command.delete.cascade);\n+    try std.testing.expect(result.command.delete.dry_run);\n+    try std.testing.expect(!result.command.delete.hard);\n+}\n+\n+test \"parse delete command with from-file\" {\n+    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.command == .delete);\n+    try std.testing.expect(result.command.delete.id == null);\n+    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n }\n \n test \"parse list command\" {\n@@ -2089,6 +2209,47 @@ test \"parse dep cycles command\" {\n     try std.testing.expect(result.command.dep.subcommand == .cycles);\n }\n \n+test \"parse dep add command with metadata\" {\n+    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const add = result.command.dep.subcommand.add;\n+    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n+    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n+    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n+    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n+}\n+\n+test \"parse dep list command with direction down\" {\n+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const list = result.command.dep.subcommand.list;\n+    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n+    try std.testing.expectEqual(DepDirection.down, list.direction);\n+}\n+\n+test \"parse dep list command with direction up\" {\n+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const list = result.command.dep.subcommand.list;\n+    try std.testing.expectEqual(DepDirection.up, list.direction);\n+}\n+\n+test \"parse dep tree command with format mermaid\" {\n+    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const tree = result.command.dep.subcommand.tree;\n+    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n+    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n+}\n+\n test \"parse label add command\" {\n     const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\n@@ -2130,6 +2291,26 @@ test \"parse label list-all command\" {\n     try std.testing.expect(result.command.label.subcommand == .list_all);\n }\n \n+test \"parse label rename command\" {\n+    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const rename = result.command.label.subcommand.rename;\n+    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n+    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n+}\n+\n+test \"parse label mv command (alias for rename)\" {\n+    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const rename = result.command.label.subcommand.rename;\n+    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n+    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n+}\n+\n test \"parse comments add command\" {\n     const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\ndiff --git a/src/cli/close.zig b/src/cli/close.zig\nindex e5f3e98..b2dc347 100644\n--- a/src/cli/close.zig\n+++ b/src/cli/close.zig\n@@ -142,6 +142,12 @@ fn outputSuccess(\n             .id = id,\n             .action = action,\n         });\n+    } else if (global.robot) {\n+        // Robot format: ACTION<TAB>ID\n+        try output.raw(action);\n+        try output.raw(\"\\t\");\n+        try output.raw(id);\n+        try output.raw(\"\\n\");\n     } else if (global.quiet) {\n         try output.raw(id);\n         try output.raw(\"\\n\");\ndiff --git a/src/cli/common.zig b/src/cli/common.zig\nindex 6034248..4d9634d 100644\n--- a/src/cli/common.zig\n+++ b/src/cli/common.zig\n@@ -51,6 +51,7 @@ pub const CommandContext = struct {\n         var output = Output.init(allocator, .{\n             .json = global.json,\n             .toon = global.toon,\n+            .robot = global.robot,\n             .quiet = global.quiet,\n             .silent = global.silent,\n             .no_color = global.no_color,\n@@ -268,9 +269,12 @@ pub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Outp\n     return Output.init(allocator, .{\n         .json = global.json,\n         .toon = global.toon,\n+        .robot = global.robot,\n         .quiet = global.quiet,\n         .silent = global.silent,\n         .no_color = global.no_color,\n+        .wrap = global.wrap,\n+        .stats = global.stats,\n     });\n }\n \ndiff --git a/src/cli/delete.zig b/src/cli/delete.zig\nindex a637a10..1d1bf79 100644\n--- a/src/cli/delete.zig\n+++ b/src/cli/delete.zig\n@@ -1,19 +1,54 @@\n //! Delete command for beads_zig.\n //!\n //! `bz delete <id>` - Soft delete an issue (set status to tombstone)\n+//! `bz delete --from-file <path>` - Delete multiple issues from a file\n+//! `bz delete <id> --cascade` - Delete issue and all its dependents\n+//! `bz delete <id> --hard` - Permanently remove from database\n+//! `bz delete <id> --dry-run` - Preview what would be deleted\n //!\n-//! This is a soft delete - the issue is marked as tombstone but remains\n+//! By default, this is a soft delete - the issue is marked as tombstone but remains\n //! in the database for audit purposes. Use `bz list --all` to see tombstoned issues.\n \n const std = @import(\"std\");\n const models = @import(\"../models/mod.zig\");\n+const storage = @import(\"../storage/mod.zig\");\n const common = @import(\"common.zig\");\n const args = @import(\"args.zig\");\n const test_util = @import(\"../test_util.zig\");\n \n const Status = models.Status;\n+const Issue = models.Issue;\n const IssueStore = common.IssueStore;\n const CommandContext = common.CommandContext;\n+const DependencyGraph = common.DependencyGraph;\n+const Wal = storage.Wal;\n+const Output = @import(\"../output/mod.zig\").Output;\n+\n+/// Output a list of IDs, one per line (used for quiet/robot output).\n+fn outputIdList(output: *Output, ids: []const []const u8) !void {\n+    for (ids) |id| {\n+        try output.raw(id);\n+        try output.raw(\"\\n\");\n+    }\n+}\n+\n+/// Create a slice of IDs from the ArrayList (for JSON output).\n+fn createIdSlice(allocator: std.mem.Allocator, ids: std.ArrayListUnmanaged([]const u8)) ![]const []const u8 {\n+    const id_slice = try allocator.alloc([]const u8, ids.items.len);\n+    for (ids.items, 0..) |id, i| {\n+        id_slice[i] = id;\n+    }\n+    return id_slice;\n+}\n+\n+/// Truncate the WAL after hard delete to prevent deleted issues from reappearing.\n+fn truncateWalIfNeeded(hard: bool, deleted_count: usize, beads_dir: []const u8, allocator: std.mem.Allocator) void {\n+    if (!hard or deleted_count == 0) return;\n+\n+    var wal_obj = Wal.init(beads_dir, allocator) catch return;\n+    defer wal_obj.deinit();\n+    wal_obj.truncate() catch {};\n+}\n \n pub const DeleteError = error{\n     WorkspaceNotInitialized,\n@@ -21,12 +56,16 @@ pub const DeleteError = error{\n     AlreadyDeleted,\n     StorageError,\n     OutOfMemory,\n+    FileReadError,\n+    InvalidInput,\n };\n \n pub const DeleteResult = struct {\n     success: bool,\n-    id: ?[]const u8 = null,\n+    ids: ?[]const []const u8 = null,\n+    deleted_count: ?usize = null,\n     message: ?[]const u8 = null,\n+    dry_run: bool = false,\n };\n \n pub fn run(\n@@ -40,40 +79,206 @@ pub fn run(\n     defer ctx.deinit();\n \n     const structured_output = global.isStructuredOutput();\n-    const issue_ref = ctx.store.getRef(delete_args.id) orelse {\n-        try common.outputNotFoundError(DeleteResult, &ctx.output, structured_output, delete_args.id, allocator);\n-        return DeleteError.IssueNotFound;\n-    };\n \n-    if (issue_ref.status.eql(.tombstone)) {\n-        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"issue is already deleted\");\n-        return DeleteError.AlreadyDeleted;\n+    // Collect all IDs to delete\n+    var ids_to_delete: std.ArrayListUnmanaged([]const u8) = .{};\n+    defer ids_to_delete.deinit(allocator);\n+\n+    if (delete_args.from_file) |file_path| {\n+        // Read IDs from file\n+        const file = std.fs.cwd().openFile(file_path, .{}) catch {\n+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot open file\");\n+            return DeleteError.FileReadError;\n+        };\n+        defer file.close();\n+\n+        const content = file.readToEndAlloc(allocator, 1024 * 1024) catch {\n+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot read file\");\n+            return DeleteError.FileReadError;\n+        };\n+        defer allocator.free(content);\n+\n+        var lines = std.mem.splitScalar(u8, content, '\\n');\n+        while (lines.next()) |line| {\n+            const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n+            if (trimmed.len == 0) continue;\n+            if (trimmed[0] == '#') continue; // Skip comments\n+            const id_copy = try allocator.dupe(u8, trimmed);\n+            try ids_to_delete.append(allocator, id_copy);\n+        }\n+\n+        if (ids_to_delete.items.len == 0) {\n+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no valid IDs in file\");\n+            return DeleteError.InvalidInput;\n+        }\n+    } else if (delete_args.id) |id| {\n+        const id_copy = try allocator.dupe(u8, id);\n+        try ids_to_delete.append(allocator, id_copy);\n+    } else {\n+        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no issue ID specified\");\n+        return DeleteError.InvalidInput;\n+    }\n+    defer {\n+        for (ids_to_delete.items) |id| {\n+            allocator.free(id);\n+        }\n     }\n \n+    // If cascade mode, expand to include all dependents\n+    if (delete_args.cascade) {\n+        var graph = ctx.createGraph();\n+        var expanded_ids: std.StringHashMapUnmanaged(void) = .{};\n+        defer {\n+            var key_it = expanded_ids.keyIterator();\n+            while (key_it.next()) |key| {\n+                allocator.free(key.*);\n+            }\n+            expanded_ids.deinit(allocator);\n+        }\n+\n+        // Add initial IDs\n+        for (ids_to_delete.items) |id| {\n+            if (!expanded_ids.contains(id)) {\n+                const id_copy = try allocator.dupe(u8, id);\n+                try expanded_ids.put(allocator, id_copy, {});\n+            }\n+        }\n+\n+        // Recursively add all dependents using BFS\n+        var work_queue: std.ArrayListUnmanaged([]const u8) = .{};\n+        defer work_queue.deinit(allocator);\n+\n+        for (ids_to_delete.items) |id| {\n+            try work_queue.append(allocator, id);\n+        }\n+\n+        while (work_queue.items.len > 0) {\n+            const current_id = work_queue.orderedRemove(0);\n+            const dependents = graph.getDependents(current_id) catch continue;\n+            defer graph.freeDependencies(dependents);\n+\n+            for (dependents) |dep| {\n+                if (!expanded_ids.contains(dep.issue_id)) {\n+                    const dep_id_copy = try allocator.dupe(u8, dep.issue_id);\n+                    try expanded_ids.put(allocator, dep_id_copy, {});\n+                    try work_queue.append(allocator, dep_id_copy);\n+                }\n+            }\n+        }\n+\n+        // Replace ids_to_delete with expanded set\n+        for (ids_to_delete.items) |id| {\n+            allocator.free(id);\n+        }\n+        ids_to_delete.clearRetainingCapacity();\n+\n+        var id_it = expanded_ids.keyIterator();\n+        while (id_it.next()) |key| {\n+            const id_copy = try allocator.dupe(u8, key.*);\n+            try ids_to_delete.append(allocator, id_copy);\n+        }\n+    }\n+\n+    // Dry run mode - just report what would be deleted\n+    if (delete_args.dry_run) {\n+        if (structured_output) {\n+            const id_slice = try createIdSlice(allocator, ids_to_delete);\n+            defer allocator.free(id_slice);\n+            try ctx.output.printJson(DeleteResult{\n+                .success = true,\n+                .ids = id_slice,\n+                .deleted_count = ids_to_delete.items.len,\n+                .dry_run = true,\n+                .message = \"dry run - no changes made\",\n+            });\n+        } else if (global.robot) {\n+            try ctx.output.raw(\"DRY_RUN\\t\");\n+            try ctx.output.print(\"{d}\\n\", .{ids_to_delete.items.len});\n+            try outputIdList(&ctx.output, ids_to_delete.items);\n+        } else if (global.quiet) {\n+            try outputIdList(&ctx.output, ids_to_delete.items);\n+        } else {\n+            try ctx.output.print(\"Would delete {d} issue(s):\\n\", .{ids_to_delete.items.len});\n+            for (ids_to_delete.items) |id| {\n+                try ctx.output.print(\"  {s}\\n\", .{id});\n+            }\n+        }\n+        return;\n+    }\n+\n+    // Perform the actual deletion\n     const now = std.time.timestamp();\n-    const updates = IssueStore.IssueUpdate{\n-        .status = .tombstone,\n-        .closed_at = now,\n-        .close_reason = \"deleted\",\n-    };\n+    var deleted_count: usize = 0;\n+    var not_found_count: usize = 0;\n \n-    ctx.store.update(delete_args.id, updates, now) catch {\n-        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"failed to delete issue\");\n-        return DeleteError.StorageError;\n-    };\n+    for (ids_to_delete.items) |id| {\n+        const issue_ref = ctx.store.getRef(id) orelse {\n+            not_found_count += 1;\n+            continue;\n+        };\n+\n+        if (issue_ref.status.eql(.tombstone)) {\n+            continue; // Already deleted\n+        }\n+\n+        if (delete_args.hard) {\n+            // Hard delete - remove from store entirely\n+            ctx.store.remove(id) catch {\n+                continue;\n+            };\n+        } else {\n+            // Soft delete - mark as tombstone\n+            const updates = IssueStore.IssueUpdate{\n+                .status = .tombstone,\n+                .closed_at = now,\n+                .close_reason = \"deleted\",\n+            };\n+            ctx.store.update(id, updates, now) catch {\n+                continue;\n+            };\n+        }\n+        deleted_count += 1;\n+    }\n \n     try ctx.saveIfAutoFlush();\n \n+    // For hard delete, truncate the WAL to ensure deleted issues don't\n+    // reappear when replaying WAL entries on next load.\n+    truncateWalIfNeeded(delete_args.hard, deleted_count, ctx.beads_dir, allocator);\n+\n+    // Output result\n     if (structured_output) {\n+        const id_slice = try createIdSlice(allocator, ids_to_delete);\n+        defer allocator.free(id_slice);\n         try ctx.output.printJson(DeleteResult{\n-            .success = true,\n-            .id = delete_args.id,\n+            .success = deleted_count > 0,\n+            .ids = id_slice,\n+            .deleted_count = deleted_count,\n         });\n+    } else if (global.robot) {\n+        try ctx.output.raw(\"OK\\t\");\n+        try ctx.output.print(\"{d}\\n\", .{deleted_count});\n+        try outputIdList(&ctx.output, ids_to_delete.items);\n     } else if (global.quiet) {\n-        try ctx.output.raw(delete_args.id);\n-        try ctx.output.raw(\"\\n\");\n+        try outputIdList(&ctx.output, ids_to_delete.items);\n     } else {\n-        try ctx.output.success(\"Deleted issue {s}\", .{delete_args.id});\n+        if (deleted_count == 1 and ids_to_delete.items.len == 1) {\n+            if (delete_args.hard) {\n+                try ctx.output.success(\"Permanently deleted issue {s}\", .{ids_to_delete.items[0]});\n+            } else {\n+                try ctx.output.success(\"Deleted issue {s}\", .{ids_to_delete.items[0]});\n+            }\n+        } else {\n+            if (delete_args.hard) {\n+                try ctx.output.success(\"Permanently deleted {d} issue(s)\", .{deleted_count});\n+            } else {\n+                try ctx.output.success(\"Deleted {d} issue(s)\", .{deleted_count});\n+            }\n+        }\n+\n+        if (not_found_count > 0) {\n+            try ctx.output.warn(\"{d} issue(s) not found\", .{not_found_count});\n+        }\n     }\n }\n \n@@ -85,12 +290,15 @@ test \"DeleteError enum exists\" {\n }\n \n test \"DeleteResult struct works\" {\n+    const ids = [_][]const u8{\"bd-abc123\"};\n     const result = DeleteResult{\n         .success = true,\n-        .id = \"bd-abc123\",\n+        .ids = &ids,\n+        .deleted_count = 1,\n     };\n     try std.testing.expect(result.success);\n-    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n+    try std.testing.expectEqual(@as(usize, 1), result.ids.?.len);\n+    try std.testing.expectEqualStrings(\"bd-abc123\", result.ids.?[0]);\n }\n \n test \"run detects uninitialized workspace\" {\n@@ -124,6 +332,6 @@ test \"run returns error for missing issue\" {\n     const delete_args = args.DeleteArgs{ .id = \"bd-nonexistent\" };\n     const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n \n-    const result = run(delete_args, global, allocator);\n-    try std.testing.expectError(DeleteError.IssueNotFound, result);\n+    // This should complete but report 0 deletions (issue not found is handled gracefully)\n+    try run(delete_args, global, allocator);\n }\ndiff --git a/src/cli/dep.zig b/src/cli/dep.zig\nindex 376b809..aea0996 100644\n--- a/src/cli/dep.zig\n+++ b/src/cli/dep.zig\n@@ -84,7 +84,7 @@ fn runAdd(\n         .dep_type = DependencyType.fromString(add_args.dep_type),\n         .created_at = now,\n         .created_by = global.actor,\n-        .metadata = null,\n+        .metadata = add_args.metadata,\n         .thread_id = null,\n     };\n \n@@ -160,24 +160,35 @@ fn runList(\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n-    const deps = try graph.getDependencies(list_args.id);\n-    defer graph.freeDependencies(deps);\n+    const direction = list_args.direction;\n+    const show_down = direction == .down or direction == .both;\n+    const show_up = direction == .up or direction == .both;\n \n-    const dependents = try graph.getDependents(list_args.id);\n-    defer graph.freeDependencies(dependents);\n+    var deps: []Dependency = &.{};\n+    var dependents: []Dependency = &.{};\n+\n+    if (show_down) {\n+        deps = try graph.getDependencies(list_args.id);\n+    }\n+    defer if (show_down) graph.freeDependencies(deps);\n+\n+    if (show_up) {\n+        dependents = try graph.getDependents(list_args.id);\n+    }\n+    defer if (show_up) graph.freeDependencies(dependents);\n \n     if (global.isStructuredOutput()) {\n         var depends_on_ids: ?[][]const u8 = null;\n         var blocks_ids: ?[][]const u8 = null;\n \n-        if (deps.len > 0) {\n+        if (show_down and deps.len > 0) {\n             depends_on_ids = try allocator.alloc([]const u8, deps.len);\n             for (deps, 0..) |dep, i| {\n                 depends_on_ids.?[i] = dep.depends_on_id;\n             }\n         }\n \n-        if (dependents.len > 0) {\n+        if (show_up and dependents.len > 0) {\n             blocks_ids = try allocator.alloc([]const u8, dependents.len);\n             for (dependents, 0..) |dep, i| {\n                 blocks_ids.?[i] = dep.issue_id;\n@@ -195,22 +206,30 @@ fn runList(\n             .blocks = blocks_ids,\n         });\n     } else {\n-        if (deps.len > 0) {\n-            try output.println(\"Depends on:\", .{});\n-            for (deps) |dep| {\n-                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+        if (show_down) {\n+            if (deps.len > 0) {\n+                try output.println(\"Depends on:\", .{});\n+                for (deps) |dep| {\n+                    if (dep.metadata) |meta| {\n+                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n+                    } else {\n+                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+                    }\n+                }\n+            } else {\n+                try output.println(\"Depends on: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Depends on: (none)\", .{});\n         }\n \n-        if (dependents.len > 0) {\n-            try output.println(\"Blocks:\", .{});\n-            for (dependents) |dep| {\n-                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+        if (show_up) {\n+            if (dependents.len > 0) {\n+                try output.println(\"Blocks:\", .{});\n+                for (dependents) |dep| {\n+                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+                }\n+            } else {\n+                try output.println(\"Blocks: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Blocks: (none)\", .{});\n         }\n     }\n }\n@@ -231,6 +250,7 @@ fn runTree(\n     allocator: std.mem.Allocator,\n ) !void {\n     const id = tree_args.id;\n+    const format = tree_args.format;\n \n     // Check if issue exists\n     const issue = try ctx.store.get(id);\n@@ -250,6 +270,9 @@ fn runTree(\n             .success = true,\n             .tree = root,\n         });\n+    } else if (format == .mermaid) {\n+        // Mermaid flowchart output\n+        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n     } else {\n         // ASCII tree output\n         try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n@@ -355,6 +378,160 @@ fn printTreeBranch(\n     }\n }\n \n+fn printMermaidTree(\n+    output: *common.Output,\n+    graph: *DependencyGraph,\n+    ctx: *CommandContext,\n+    root_id: []const u8,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    // Start Mermaid flowchart\n+    try output.println(\"```mermaid\", .{});\n+    try output.println(\"flowchart TD\", .{});\n+\n+    // Track visited nodes to avoid duplicates\n+    var visited: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var it = visited.keyIterator();\n+        while (it.next()) |key| allocator.free(key.*);\n+        visited.deinit(allocator);\n+    }\n+\n+    // Track emitted edges to avoid duplicates\n+    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var edge_it = emitted_edges.keyIterator();\n+        while (edge_it.next()) |key| allocator.free(key.*);\n+        emitted_edges.deinit(allocator);\n+    }\n+\n+    // Collect all nodes and edges starting from root\n+    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n+\n+    try output.println(\"```\", .{});\n+}\n+\n+fn collectMermaidNodes(\n+    output: *common.Output,\n+    graph: *DependencyGraph,\n+    ctx: *CommandContext,\n+    id: []const u8,\n+    visited: *std.StringHashMapUnmanaged(void),\n+    emitted_edges: *std.StringHashMapUnmanaged(void),\n+    allocator: std.mem.Allocator,\n+    depth: usize,\n+    max_depth: usize,\n+) !void {\n+    // Skip if already visited\n+    if (visited.contains(id)) return;\n+\n+    // Mark as visited\n+    const id_copy = try allocator.dupe(u8, id);\n+    errdefer allocator.free(id_copy);\n+    try visited.put(allocator, id_copy, {});\n+\n+    // Get issue details for node label\n+    const issue = try ctx.store.get(id);\n+    const safe_id = try sanitizeMermaidId(id, allocator);\n+    defer allocator.free(safe_id);\n+\n+    if (issue) |i| {\n+        var iss = i;\n+        defer iss.deinit(allocator);\n+        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n+        defer allocator.free(safe_title);\n+        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n+    } else {\n+        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n+    }\n+\n+    if (depth >= max_depth) return;\n+\n+    // Get dependencies (what this issue depends on)\n+    const deps = try graph.getDependencies(id);\n+    defer graph.freeDependencies(deps);\n+\n+    for (deps) |dep| {\n+        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n+        defer allocator.free(target_id);\n+\n+        // Create edge key for deduplication\n+        var edge_buf: [256]u8 = undefined;\n+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n+\n+        if (!emitted_edges.contains(edge_key)) {\n+            const edge_copy = try allocator.dupe(u8, edge_key);\n+            try emitted_edges.put(allocator, edge_copy, {});\n+\n+            // Emit edge with dependency type as label\n+            const dep_type_str = dep.dep_type.toString();\n+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n+        }\n+\n+        // Recurse into dependency\n+        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n+    }\n+\n+    // Get dependents (what depends on this issue)\n+    const dependents = try graph.getDependents(id);\n+    defer graph.freeDependencies(dependents);\n+\n+    for (dependents) |dep| {\n+        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n+        defer allocator.free(source_id);\n+\n+        // Create edge key for deduplication\n+        var edge_buf: [256]u8 = undefined;\n+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n+\n+        if (!emitted_edges.contains(edge_key)) {\n+            const edge_copy = try allocator.dupe(u8, edge_key);\n+            try emitted_edges.put(allocator, edge_copy, {});\n+\n+            const dep_type_str = dep.dep_type.toString();\n+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n+        }\n+\n+        // Recurse into dependent\n+        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n+    }\n+}\n+\n+fn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n+    // Replace characters that are invalid in Mermaid node IDs\n+    var result = try allocator.alloc(u8, id.len);\n+    for (id, 0..) |c, i| {\n+        result[i] = if (c == '-' or c == '.') '_' else c;\n+    }\n+    return result;\n+}\n+\n+fn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n+    // Escape special characters in Mermaid labels\n+    var count: usize = 0;\n+    for (label) |c| {\n+        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n+    }\n+\n+    var result = try allocator.alloc(u8, count);\n+    var i: usize = 0;\n+    for (label) |c| {\n+        if (c == '\"') {\n+            result[i] = '\\\\';\n+            result[i + 1] = '\"';\n+            i += 2;\n+        } else if (c == '\\\\') {\n+            result[i] = '\\\\';\n+            result[i + 1] = '\\\\';\n+            i += 2;\n+        } else {\n+            result[i] = c;\n+            i += 1;\n+        }\n+    }\n+    return result;\n+}\n+\n fn buildTreeNode(\n     graph: *DependencyGraph,\n     ctx: *CommandContext,\ndiff --git a/src/cli/label.zig b/src/cli/label.zig\nindex 942b031..a123004 100644\n--- a/src/cli/label.zig\n+++ b/src/cli/label.zig\n@@ -24,6 +24,9 @@ pub const LabelResult = struct {\n     labels: ?[]const []const u8 = null,\n     added: ?[]const []const u8 = null,\n     removed: ?[]const []const u8 = null,\n+    old_name: ?[]const u8 = null,\n+    new_name: ?[]const u8 = null,\n+    renamed_count: ?usize = null,\n     message: ?[]const u8 = null,\n };\n \n@@ -37,6 +40,7 @@ pub fn run(\n         .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n         .list => |list| try runList(list.id, global, allocator),\n         .list_all => try runListAll(global, allocator),\n+        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n     }\n }\n \n@@ -307,6 +311,78 @@ fn runListAll(\n     }\n }\n \n+fn runRename(\n+    old_name: []const u8,\n+    new_name: []const u8,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return LabelError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Count how many issues have this label renamed\n+    var renamed_count: usize = 0;\n+\n+    // Iterate through all issues\n+    for (ctx.store.issues.items) |*issue| {\n+        if (issue.status.eql(.tombstone)) continue;\n+\n+        // Check if issue has the old label\n+        var has_old_label = false;\n+        var old_label_idx: usize = 0;\n+        for (issue.labels, 0..) |label, idx| {\n+            if (std.mem.eql(u8, label, old_name)) {\n+                has_old_label = true;\n+                old_label_idx = idx;\n+                break;\n+            }\n+        }\n+\n+        if (has_old_label) {\n+            // Check if it already has the new label (avoid duplicates)\n+            var has_new_label = false;\n+            for (issue.labels) |label| {\n+                if (std.mem.eql(u8, label, new_name)) {\n+                    has_new_label = true;\n+                    break;\n+                }\n+            }\n+\n+            if (has_new_label) {\n+                // Remove the old label (new label already exists)\n+                try ctx.store.removeLabel(issue.id, old_name);\n+            } else {\n+                // Replace old label with new label in place\n+                // First remove old, then add new\n+                try ctx.store.removeLabel(issue.id, old_name);\n+                try ctx.store.addLabel(issue.id, new_name);\n+            }\n+            renamed_count += 1;\n+        }\n+    }\n+\n+    try ctx.saveIfAutoFlush();\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(LabelResult{\n+            .success = true,\n+            .old_name = old_name,\n+            .new_name = new_name,\n+            .renamed_count = renamed_count,\n+        });\n+    } else if (global.quiet) {\n+        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n+    } else {\n+        if (renamed_count > 0) {\n+            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n+        } else {\n+            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n+        }\n+    }\n+}\n+\n // --- Tests ---\n \n test \"LabelError enum exists\" {\ndiff --git a/src/output/mod.zig b/src/output/mod.zig\nindex 49cd59a..799b77d 100644\n--- a/src/output/mod.zig\n+++ b/src/output/mod.zig\n@@ -21,6 +21,7 @@ pub const OutputMode = enum {\n     rich, // Colors and formatting (TTY)\n     json, // Structured JSON output\n     quiet, // Minimal output (IDs only)\n+    robot, // Line-oriented machine-readable output for scripting\n };\n \n /// ANSI color escape codes.\n@@ -58,6 +59,7 @@ pub const Color = struct {\n pub const OutputOptions = struct {\n     json: bool = false,\n     toon: bool = false,\n+    robot: bool = false, // Line-oriented machine-readable output for scripting\n     quiet: bool = false,\n     silent: bool = false, // Suppress ALL output including errors (for tests)\n     no_color: bool = false,\n@@ -88,6 +90,8 @@ pub const Output = struct {\n         var mode: OutputMode = .plain;\n         if (opts.json or opts.toon) {\n             mode = .json;\n+        } else if (opts.robot) {\n+            mode = .robot;\n         } else if (opts.quiet or opts.silent) {\n             mode = .quiet;\n         } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n@@ -166,6 +170,7 @@ pub const Output = struct {\n             .quiet => try self.printIssueQuiet(issue),\n             .rich => try self.printIssueRich(issue),\n             .plain => try self.printIssuePlain(issue),\n+            .robot => try self.printIssueRobot(issue),\n         }\n     }\n \n@@ -176,6 +181,7 @@ pub const Output = struct {\n             .quiet => try self.printIssueListQuiet(issues),\n             .rich => try self.printIssueListRich(issues),\n             .plain => try self.printIssueListPlain(issues),\n+            .robot => try self.printIssueListRobot(issues),\n         }\n     }\n \n@@ -441,6 +447,29 @@ pub const Output = struct {\n         }\n     }\n \n+    // ========================================================================\n+    // Robot Mode Helpers (tab-separated, line-oriented for scripting)\n+    // ========================================================================\n+\n+    /// Print single issue in robot format: tab-separated key fields on one line.\n+    /// Format: ID<TAB>STATUS<TAB>PRIORITY<TAB>TYPE<TAB>TITLE\n+    fn printIssueRobot(self: *Self, issue: Issue) !void {\n+        try self.writeFormatted(\"{s}\\t{s}\\t{s}\\t{s}\\t{s}\\n\", .{\n+            issue.id,\n+            issue.status.toString(),\n+            issue.priority.toString(),\n+            issue.issue_type.toString(),\n+            issue.title,\n+        });\n+    }\n+\n+    /// Print issue list in robot format: one issue per line, tab-separated fields.\n+    fn printIssueListRobot(self: *Self, issues: []const Issue) !void {\n+        for (issues) |issue| {\n+            try self.printIssueRobot(issue);\n+        }\n+    }\n+\n     // ========================================================================\n     // Internal Helpers\n     // ========================================================================\ndiff --git a/src/storage/store.zig b/src/storage/store.zig\nindex c243178..89c2a41 100644\n--- a/src/storage/store.zig\n+++ b/src/storage/store.zig\n@@ -327,6 +327,39 @@ pub const IssueStore = struct {\n         try self.update(id, .{ .status = .tombstone }, now);\n     }\n \n+    /// Hard delete an issue by removing it from the store entirely.\n+    /// Unlike soft delete (tombstone), this permanently removes the issue.\n+    pub fn remove(self: *Self, id: []const u8) !void {\n+        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n+        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n+\n+        // Free the issue data\n+        self.issues.items[idx].deinit(self.allocator);\n+\n+        // Remove from index (free the key)\n+        if (self.id_index.fetchRemove(id)) |kv| {\n+            self.allocator.free(kv.key);\n+        }\n+\n+        // Remove from issues array using swap-remove for O(1)\n+        _ = self.issues.swapRemove(idx);\n+\n+        // Update the index for the swapped element (if any)\n+        if (idx < self.issues.items.len) {\n+            const swapped_id = self.issues.items[idx].id;\n+            if (self.id_index.getPtr(swapped_id)) |idx_ptr| {\n+                idx_ptr.* = idx;\n+            }\n+        }\n+\n+        // Also remove from dirty_ids if present\n+        if (self.dirty_ids.fetchRemove(id)) |kv| {\n+            self.allocator.free(kv.key);\n+        }\n+\n+        self.dirty = true;\n+    }\n+\n     /// Filters for listing issues.\n     pub const ListFilters = struct {\n         status: ?Status = null,","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013UaHHUiMf7GRRoPsfv4jD2","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the full diff to understand all changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":963,"cache_read_input_tokens":22374,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":963},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"3280d1a1-c8aa-47a4-abe1-3b62e7b600fa"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013UaHHUiMf7GRRoPsfv4jD2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CHYqozdSiurPUtL2SL1GAm","name":"Read","input":{"file_path":"/home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/d965594a-b540-4605-8ceb-7e84a6081b47/tool-results/toolu_01CwaCkThUTTJ4wkfKrMqLET.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":963,"cache_read_input_tokens":22374,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":963},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"d06413a2-38aa-47ad-9a98-9650e2fbfbe2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CHYqozdSiurPUtL2SL1GAm","type":"tool_result","content":"     1diff --git a/src/cli/args.zig b/src/cli/args.zig\n     2index 54a8db2..2de3b21 100644\n     3--- a/src/cli/args.zig\n     4+++ b/src/cli/args.zig\n     5@@ -9,6 +9,7 @@ const std = @import(\"std\");\n     6 pub const GlobalOptions = struct {\n     7     json: bool = false,\n     8     toon: bool = false,\n     9+    robot: bool = false, // Line-oriented machine-readable output for scripting\n    10     quiet: bool = false,\n    11     silent: bool = false, // Suppress ALL output including errors (for tests)\n    12     verbose: u8 = 0,\n    13@@ -25,6 +26,11 @@ pub const GlobalOptions = struct {\n    14     pub fn isStructuredOutput(self: GlobalOptions) bool {\n    15         return self.json or self.toon;\n    16     }\n    17+\n    18+    /// Returns true if any machine-readable output is enabled.\n    19+    pub fn isMachineOutput(self: GlobalOptions) bool {\n    20+        return self.json or self.toon or self.robot;\n    21+    }\n    22 };\n    23 \n    24 /// All available subcommands.\n    25@@ -170,7 +176,16 @@ pub const ReopenArgs = struct {\n    26 \n    27 /// Delete command arguments.\n    28 pub const DeleteArgs = struct {\n    29-    id: []const u8,\n    30+    /// Single issue ID to delete (mutually exclusive with from_file).\n    31+    id: ?[]const u8 = null,\n    32+    /// Path to file containing issue IDs to delete (one per line).\n    33+    from_file: ?[]const u8 = null,\n    34+    /// Delete issue and all its dependents recursively.\n    35+    cascade: bool = false,\n    36+    /// Prune from database immediately instead of marking as tombstone.\n    37+    hard: bool = false,\n    38+    /// Preview what would be deleted without making changes.\n    39+    dry_run: bool = false,\n    40 };\n    41 \n    42 /// Add-batch command arguments.\n    43@@ -332,12 +347,39 @@ pub const EpicArgs = struct {\n    44     subcommand: EpicSubcommand,\n    45 };\n    46 \n    47+/// Direction filter for dependency listing.\n    48+pub const DepDirection = enum {\n    49+    up, // What depends on this issue (dependents/blocked-by)\n    50+    down, // What this issue depends on\n    51+    both, // Both directions (default)\n    52+\n    53+    pub fn fromString(s: []const u8) ?DepDirection {\n    54+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n    55+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n    56+        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n    57+        return null;\n    58+    }\n    59+};\n    60+\n    61+/// Tree output formats for dep tree.\n    62+pub const TreeFormat = enum {\n    63+    ascii,\n    64+    mermaid,\n    65+\n    66+    pub fn fromString(s: []const u8) ?TreeFormat {\n    67+        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n    68+        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n    69+        return null;\n    70+    }\n    71+};\n    72+\n    73 /// Dependency subcommand variants.\n    74 pub const DepSubcommand = union(enum) {\n    75     add: struct {\n    76         child: []const u8,\n    77         parent: []const u8,\n    78         dep_type: []const u8 = \"blocks\",\n    79+        metadata: ?[]const u8 = null,\n    80     },\n    81     remove: struct {\n    82         child: []const u8,\n    83@@ -345,9 +387,11 @@ pub const DepSubcommand = union(enum) {\n    84     },\n    85     list: struct {\n    86         id: []const u8,\n    87+        direction: DepDirection = .both,\n    88     },\n    89     tree: struct {\n    90         id: []const u8,\n    91+        format: TreeFormat = .ascii,\n    92     },\n    93     cycles: void,\n    94 };\n    95@@ -391,6 +435,10 @@ pub const LabelSubcommand = union(enum) {\n    96         id: []const u8,\n    97     },\n    98     list_all: void,\n    99+    rename: struct {\n   100+        old_name: []const u8,\n   101+        new_name: []const u8,\n   102+    },\n   103 };\n   104 \n   105 /// Label command arguments.\n   106@@ -674,6 +722,10 @@ pub const ArgParser = struct {\n   107             global.stats = true;\n   108             return true;\n   109         }\n   110+        if (std.mem.eql(u8, arg, \"--robot\")) {\n   111+            global.robot = true;\n   112+            return true;\n   113+        }\n   114 \n   115         // Put back if not recognized\n   116         self.index -= 1;\n   117@@ -1012,8 +1064,30 @@ pub const ArgParser = struct {\n   118     }\n   119 \n   120     fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n   121-        const id = self.next() orelse return error.MissingRequiredArgument;\n   122-        return .{ .id = id };\n   123+        var result = DeleteArgs{};\n   124+\n   125+        while (self.hasNext()) {\n   126+            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n   127+                result.from_file = self.next() orelse return error.MissingFlagValue;\n   128+            } else if (self.consumeFlag(null, \"--cascade\")) {\n   129+                result.cascade = true;\n   130+            } else if (self.consumeFlag(null, \"--hard\")) {\n   131+                result.hard = true;\n   132+            } else if (self.consumeFlag(null, \"--dry-run\")) {\n   133+                result.dry_run = true;\n   134+            } else if (self.peekPositional()) |_| {\n   135+                if (result.id == null) {\n   136+                    result.id = self.next().?;\n   137+                } else break;\n   138+            } else break;\n   139+        }\n   140+\n   141+        // Require either id or from_file\n   142+        if (result.id == null and result.from_file == null) {\n   143+            return error.MissingRequiredArgument;\n   144+        }\n   145+\n   146+        return result;\n   147     }\n   148 \n   149     fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n   150@@ -1235,12 +1309,15 @@ pub const ArgParser = struct {\n   151             const child = self.next() orelse return error.MissingRequiredArgument;\n   152             const parent = self.next() orelse return error.MissingRequiredArgument;\n   153             var dep_type: []const u8 = \"blocks\";\n   154+            var metadata: ?[]const u8 = null;\n   155             while (self.hasNext()) {\n   156                 if (self.consumeFlag(\"-t\", \"--type\")) {\n   157                     dep_type = self.next() orelse return error.MissingFlagValue;\n   158+                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n   159+                    metadata = self.next() orelse return error.MissingFlagValue;\n   160                 } else break;\n   161             }\n   162-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n   163+            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n   164         }\n   165         if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n   166             const child = self.next() orelse return error.MissingRequiredArgument;\n   167@@ -1248,10 +1325,26 @@ pub const ArgParser = struct {\n   168             return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n   169         }\n   170         if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n   171-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n   172+            const id = self.next() orelse return error.MissingRequiredArgument;\n   173+            var direction: DepDirection = .both;\n   174+            while (self.hasNext()) {\n   175+                if (self.consumeFlag(\"-d\", \"--direction\")) {\n   176+                    const dir_str = self.next() orelse return error.MissingFlagValue;\n   177+                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n   178+                } else break;\n   179+            }\n   180+            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n   181         }\n   182         if (std.mem.eql(u8, subcmd, \"tree\")) {\n   183-            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n   184+            const id = self.next() orelse return error.MissingRequiredArgument;\n   185+            var format: TreeFormat = .ascii;\n   186+            while (self.hasNext()) {\n   187+                if (self.consumeFlag(\"-f\", \"--format\")) {\n   188+                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n   189+                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n   190+                } else break;\n   191+            }\n   192+            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n   193         }\n   194         if (std.mem.eql(u8, subcmd, \"cycles\")) {\n   195             return .{ .subcommand = .{ .cycles = {} } };\n   196@@ -1348,6 +1441,11 @@ pub const ArgParser = struct {\n   197         if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n   198             return .{ .subcommand = .{ .list_all = {} } };\n   199         }\n   200+        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n   201+            const old_name = self.next() orelse return error.MissingRequiredArgument;\n   202+            const new_name = self.next() orelse return error.MissingRequiredArgument;\n   203+            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n   204+        }\n   205         return error.UnknownSubcommand;\n   206     }\n   207 \n   208@@ -1897,12 +1995,34 @@ test \"parse reopen command\" {\n   209 }\n   210 \n   211 test \"parse delete command\" {\n   212-    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n   213-    var parser = ArgParser.init(std.testing.allocator, &args);\n   214+    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n   215+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n   216     const result = try parser.parse();\n   217 \n   218     try std.testing.expect(result.command == .delete);\n   219-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n   220+    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n   221+}\n   222+\n   223+test \"parse delete command with flags\" {\n   224+    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n   225+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n   226+    const result = try parser.parse();\n   227+\n   228+    try std.testing.expect(result.command == .delete);\n   229+    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n   230+    try std.testing.expect(result.command.delete.cascade);\n   231+    try std.testing.expect(result.command.delete.dry_run);\n   232+    try std.testing.expect(!result.command.delete.hard);\n   233+}\n   234+\n   235+test \"parse delete command with from-file\" {\n   236+    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n   237+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n   238+    const result = try parser.parse();\n   239+\n   240+    try std.testing.expect(result.command == .delete);\n   241+    try std.testing.expect(result.command.delete.id == null);\n   242+    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n   243 }\n   244 \n   245 test \"parse list command\" {\n   246@@ -2089,6 +2209,47 @@ test \"parse dep cycles command\" {\n   247     try std.testing.expect(result.command.dep.subcommand == .cycles);\n   248 }\n   249 \n   250+test \"parse dep add command with metadata\" {\n   251+    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n   252+    var parser = ArgParser.init(std.testing.allocator, &input);\n   253+    const result = try parser.parse();\n   254+\n   255+    const add = result.command.dep.subcommand.add;\n   256+    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n   257+    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n   258+    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n   259+    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n   260+}\n   261+\n   262+test \"parse dep list command with direction down\" {\n   263+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n   264+    var parser = ArgParser.init(std.testing.allocator, &input);\n   265+    const result = try parser.parse();\n   266+\n   267+    const list = result.command.dep.subcommand.list;\n   268+    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n   269+    try std.testing.expectEqual(DepDirection.down, list.direction);\n   270+}\n   271+\n   272+test \"parse dep list command with direction up\" {\n   273+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n   274+    var parser = ArgParser.init(std.testing.allocator, &input);\n   275+    const result = try parser.parse();\n   276+\n   277+    const list = result.command.dep.subcommand.list;\n   278+    try std.testing.expectEqual(DepDirection.up, list.direction);\n   279+}\n   280+\n   281+test \"parse dep tree command with format mermaid\" {\n   282+    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n   283+    var parser = ArgParser.init(std.testing.allocator, &input);\n   284+    const result = try parser.parse();\n   285+\n   286+    const tree = result.command.dep.subcommand.tree;\n   287+    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n   288+    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n   289+}\n   290+\n   291 test \"parse label add command\" {\n   292     const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n   293     var parser = ArgParser.init(std.testing.allocator, &args);\n   294@@ -2130,6 +2291,26 @@ test \"parse label list-all command\" {\n   295     try std.testing.expect(result.command.label.subcommand == .list_all);\n   296 }\n   297 \n   298+test \"parse label rename command\" {\n   299+    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n   300+    var parser = ArgParser.init(std.testing.allocator, &input);\n   301+    const result = try parser.parse();\n   302+\n   303+    const rename = result.command.label.subcommand.rename;\n   304+    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n   305+    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n   306+}\n   307+\n   308+test \"parse label mv command (alias for rename)\" {\n   309+    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n   310+    var parser = ArgParser.init(std.testing.allocator, &input);\n   311+    const result = try parser.parse();\n   312+\n   313+    const rename = result.command.label.subcommand.rename;\n   314+    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n   315+    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n   316+}\n   317+\n   318 test \"parse comments add command\" {\n   319     const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n   320     var parser = ArgParser.init(std.testing.allocator, &args);\n   321diff --git a/src/cli/close.zig b/src/cli/close.zig\n   322index e5f3e98..b2dc347 100644\n   323--- a/src/cli/close.zig\n   324+++ b/src/cli/close.zig\n   325@@ -142,6 +142,12 @@ fn outputSuccess(\n   326             .id = id,\n   327             .action = action,\n   328         });\n   329+    } else if (global.robot) {\n   330+        // Robot format: ACTION<TAB>ID\n   331+        try output.raw(action);\n   332+        try output.raw(\"\\t\");\n   333+        try output.raw(id);\n   334+        try output.raw(\"\\n\");\n   335     } else if (global.quiet) {\n   336         try output.raw(id);\n   337         try output.raw(\"\\n\");\n   338diff --git a/src/cli/common.zig b/src/cli/common.zig\n   339index 6034248..4d9634d 100644\n   340--- a/src/cli/common.zig\n   341+++ b/src/cli/common.zig\n   342@@ -51,6 +51,7 @@ pub const CommandContext = struct {\n   343         var output = Output.init(allocator, .{\n   344             .json = global.json,\n   345             .toon = global.toon,\n   346+            .robot = global.robot,\n   347             .quiet = global.quiet,\n   348             .silent = global.silent,\n   349             .no_color = global.no_color,\n   350@@ -268,9 +269,12 @@ pub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Outp\n   351     return Output.init(allocator, .{\n   352         .json = global.json,\n   353         .toon = global.toon,\n   354+        .robot = global.robot,\n   355         .quiet = global.quiet,\n   356         .silent = global.silent,\n   357         .no_color = global.no_color,\n   358+        .wrap = global.wrap,\n   359+        .stats = global.stats,\n   360     });\n   361 }\n   362 \n   363diff --git a/src/cli/delete.zig b/src/cli/delete.zig\n   364index a637a10..1d1bf79 100644\n   365--- a/src/cli/delete.zig\n   366+++ b/src/cli/delete.zig\n   367@@ -1,19 +1,54 @@\n   368 //! Delete command for beads_zig.\n   369 //!\n   370 //! `bz delete <id>` - Soft delete an issue (set status to tombstone)\n   371+//! `bz delete --from-file <path>` - Delete multiple issues from a file\n   372+//! `bz delete <id> --cascade` - Delete issue and all its dependents\n   373+//! `bz delete <id> --hard` - Permanently remove from database\n   374+//! `bz delete <id> --dry-run` - Preview what would be deleted\n   375 //!\n   376-//! This is a soft delete - the issue is marked as tombstone but remains\n   377+//! By default, this is a soft delete - the issue is marked as tombstone but remains\n   378 //! in the database for audit purposes. Use `bz list --all` to see tombstoned issues.\n   379 \n   380 const std = @import(\"std\");\n   381 const models = @import(\"../models/mod.zig\");\n   382+const storage = @import(\"../storage/mod.zig\");\n   383 const common = @import(\"common.zig\");\n   384 const args = @import(\"args.zig\");\n   385 const test_util = @import(\"../test_util.zig\");\n   386 \n   387 const Status = models.Status;\n   388+const Issue = models.Issue;\n   389 const IssueStore = common.IssueStore;\n   390 const CommandContext = common.CommandContext;\n   391+const DependencyGraph = common.DependencyGraph;\n   392+const Wal = storage.Wal;\n   393+const Output = @import(\"../output/mod.zig\").Output;\n   394+\n   395+/// Output a list of IDs, one per line (used for quiet/robot output).\n   396+fn outputIdList(output: *Output, ids: []const []const u8) !void {\n   397+    for (ids) |id| {\n   398+        try output.raw(id);\n   399+        try output.raw(\"\\n\");\n   400+    }\n   401+}\n   402+\n   403+/// Create a slice of IDs from the ArrayList (for JSON output).\n   404+fn createIdSlice(allocator: std.mem.Allocator, ids: std.ArrayListUnmanaged([]const u8)) ![]const []const u8 {\n   405+    const id_slice = try allocator.alloc([]const u8, ids.items.len);\n   406+    for (ids.items, 0..) |id, i| {\n   407+        id_slice[i] = id;\n   408+    }\n   409+    return id_slice;\n   410+}\n   411+\n   412+/// Truncate the WAL after hard delete to prevent deleted issues from reappearing.\n   413+fn truncateWalIfNeeded(hard: bool, deleted_count: usize, beads_dir: []const u8, allocator: std.mem.Allocator) void {\n   414+    if (!hard or deleted_count == 0) return;\n   415+\n   416+    var wal_obj = Wal.init(beads_dir, allocator) catch return;\n   417+    defer wal_obj.deinit();\n   418+    wal_obj.truncate() catch {};\n   419+}\n   420 \n   421 pub const DeleteError = error{\n   422     WorkspaceNotInitialized,\n   423@@ -21,12 +56,16 @@ pub const DeleteError = error{\n   424     AlreadyDeleted,\n   425     StorageError,\n   426     OutOfMemory,\n   427+    FileReadError,\n   428+    InvalidInput,\n   429 };\n   430 \n   431 pub const DeleteResult = struct {\n   432     success: bool,\n   433-    id: ?[]const u8 = null,\n   434+    ids: ?[]const []const u8 = null,\n   435+    deleted_count: ?usize = null,\n   436     message: ?[]const u8 = null,\n   437+    dry_run: bool = false,\n   438 };\n   439 \n   440 pub fn run(\n   441@@ -40,40 +79,206 @@ pub fn run(\n   442     defer ctx.deinit();\n   443 \n   444     const structured_output = global.isStructuredOutput();\n   445-    const issue_ref = ctx.store.getRef(delete_args.id) orelse {\n   446-        try common.outputNotFoundError(DeleteResult, &ctx.output, structured_output, delete_args.id, allocator);\n   447-        return DeleteError.IssueNotFound;\n   448-    };\n   449 \n   450-    if (issue_ref.status.eql(.tombstone)) {\n   451-        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"issue is already deleted\");\n   452-        return DeleteError.AlreadyDeleted;\n   453+    // Collect all IDs to delete\n   454+    var ids_to_delete: std.ArrayListUnmanaged([]const u8) = .{};\n   455+    defer ids_to_delete.deinit(allocator);\n   456+\n   457+    if (delete_args.from_file) |file_path| {\n   458+        // Read IDs from file\n   459+        const file = std.fs.cwd().openFile(file_path, .{}) catch {\n   460+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot open file\");\n   461+            return DeleteError.FileReadError;\n   462+        };\n   463+        defer file.close();\n   464+\n   465+        const content = file.readToEndAlloc(allocator, 1024 * 1024) catch {\n   466+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot read file\");\n   467+            return DeleteError.FileReadError;\n   468+        };\n   469+        defer allocator.free(content);\n   470+\n   471+        var lines = std.mem.splitScalar(u8, content, '\\n');\n   472+        while (lines.next()) |line| {\n   473+            const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n   474+            if (trimmed.len == 0) continue;\n   475+            if (trimmed[0] == '#') continue; // Skip comments\n   476+            const id_copy = try allocator.dupe(u8, trimmed);\n   477+            try ids_to_delete.append(allocator, id_copy);\n   478+        }\n   479+\n   480+        if (ids_to_delete.items.len == 0) {\n   481+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no valid IDs in file\");\n   482+            return DeleteError.InvalidInput;\n   483+        }\n   484+    } else if (delete_args.id) |id| {\n   485+        const id_copy = try allocator.dupe(u8, id);\n   486+        try ids_to_delete.append(allocator, id_copy);\n   487+    } else {\n   488+        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no issue ID specified\");\n   489+        return DeleteError.InvalidInput;\n   490+    }\n   491+    defer {\n   492+        for (ids_to_delete.items) |id| {\n   493+            allocator.free(id);\n   494+        }\n   495     }\n   496 \n   497+    // If cascade mode, expand to include all dependents\n   498+    if (delete_args.cascade) {\n   499+        var graph = ctx.createGraph();\n   500+        var expanded_ids: std.StringHashMapUnmanaged(void) = .{};\n   501+        defer {\n   502+            var key_it = expanded_ids.keyIterator();\n   503+            while (key_it.next()) |key| {\n   504+                allocator.free(key.*);\n   505+            }\n   506+            expanded_ids.deinit(allocator);\n   507+        }\n   508+\n   509+        // Add initial IDs\n   510+        for (ids_to_delete.items) |id| {\n   511+            if (!expanded_ids.contains(id)) {\n   512+                const id_copy = try allocator.dupe(u8, id);\n   513+                try expanded_ids.put(allocator, id_copy, {});\n   514+            }\n   515+        }\n   516+\n   517+        // Recursively add all dependents using BFS\n   518+        var work_queue: std.ArrayListUnmanaged([]const u8) = .{};\n   519+        defer work_queue.deinit(allocator);\n   520+\n   521+        for (ids_to_delete.items) |id| {\n   522+            try work_queue.append(allocator, id);\n   523+        }\n   524+\n   525+        while (work_queue.items.len > 0) {\n   526+            const current_id = work_queue.orderedRemove(0);\n   527+            const dependents = graph.getDependents(current_id) catch continue;\n   528+            defer graph.freeDependencies(dependents);\n   529+\n   530+            for (dependents) |dep| {\n   531+                if (!expanded_ids.contains(dep.issue_id)) {\n   532+                    const dep_id_copy = try allocator.dupe(u8, dep.issue_id);\n   533+                    try expanded_ids.put(allocator, dep_id_copy, {});\n   534+                    try work_queue.append(allocator, dep_id_copy);\n   535+                }\n   536+            }\n   537+        }\n   538+\n   539+        // Replace ids_to_delete with expanded set\n   540+        for (ids_to_delete.items) |id| {\n   541+            allocator.free(id);\n   542+        }\n   543+        ids_to_delete.clearRetainingCapacity();\n   544+\n   545+        var id_it = expanded_ids.keyIterator();\n   546+        while (id_it.next()) |key| {\n   547+            const id_copy = try allocator.dupe(u8, key.*);\n   548+            try ids_to_delete.append(allocator, id_copy);\n   549+        }\n   550+    }\n   551+\n   552+    // Dry run mode - just report what would be deleted\n   553+    if (delete_args.dry_run) {\n   554+        if (structured_output) {\n   555+            const id_slice = try createIdSlice(allocator, ids_to_delete);\n   556+            defer allocator.free(id_slice);\n   557+            try ctx.output.printJson(DeleteResult{\n   558+                .success = true,\n   559+                .ids = id_slice,\n   560+                .deleted_count = ids_to_delete.items.len,\n   561+                .dry_run = true,\n   562+                .message = \"dry run - no changes made\",\n   563+            });\n   564+        } else if (global.robot) {\n   565+            try ctx.output.raw(\"DRY_RUN\\t\");\n   566+            try ctx.output.print(\"{d}\\n\", .{ids_to_delete.items.len});\n   567+            try outputIdList(&ctx.output, ids_to_delete.items);\n   568+        } else if (global.quiet) {\n   569+            try outputIdList(&ctx.output, ids_to_delete.items);\n   570+        } else {\n   571+            try ctx.output.print(\"Would delete {d} issue(s):\\n\", .{ids_to_delete.items.len});\n   572+            for (ids_to_delete.items) |id| {\n   573+                try ctx.output.print(\"  {s}\\n\", .{id});\n   574+            }\n   575+        }\n   576+        return;\n   577+    }\n   578+\n   579+    // Perform the actual deletion\n   580     const now = std.time.timestamp();\n   581-    const updates = IssueStore.IssueUpdate{\n   582-        .status = .tombstone,\n   583-        .closed_at = now,\n   584-        .close_reason = \"deleted\",\n   585-    };\n   586+    var deleted_count: usize = 0;\n   587+    var not_found_count: usize = 0;\n   588 \n   589-    ctx.store.update(delete_args.id, updates, now) catch {\n   590-        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"failed to delete issue\");\n   591-        return DeleteError.StorageError;\n   592-    };\n   593+    for (ids_to_delete.items) |id| {\n   594+        const issue_ref = ctx.store.getRef(id) orelse {\n   595+            not_found_count += 1;\n   596+            continue;\n   597+        };\n   598+\n   599+        if (issue_ref.status.eql(.tombstone)) {\n   600+            continue; // Already deleted\n   601+        }\n   602+\n   603+        if (delete_args.hard) {\n   604+            // Hard delete - remove from store entirely\n   605+            ctx.store.remove(id) catch {\n   606+                continue;\n   607+            };\n   608+        } else {\n   609+            // Soft delete - mark as tombstone\n   610+            const updates = IssueStore.IssueUpdate{\n   611+                .status = .tombstone,\n   612+                .closed_at = now,\n   613+                .close_reason = \"deleted\",\n   614+            };\n   615+            ctx.store.update(id, updates, now) catch {\n   616+                continue;\n   617+            };\n   618+        }\n   619+        deleted_count += 1;\n   620+    }\n   621 \n   622     try ctx.saveIfAutoFlush();\n   623 \n   624+    // For hard delete, truncate the WAL to ensure deleted issues don't\n   625+    // reappear when replaying WAL entries on next load.\n   626+    truncateWalIfNeeded(delete_args.hard, deleted_count, ctx.beads_dir, allocator);\n   627+\n   628+    // Output result\n   629     if (structured_output) {\n   630+        const id_slice = try createIdSlice(allocator, ids_to_delete);\n   631+        defer allocator.free(id_slice);\n   632         try ctx.output.printJson(DeleteResult{\n   633-            .success = true,\n   634-            .id = delete_args.id,\n   635+            .success = deleted_count > 0,\n   636+            .ids = id_slice,\n   637+            .deleted_count = deleted_count,\n   638         });\n   639+    } else if (global.robot) {\n   640+        try ctx.output.raw(\"OK\\t\");\n   641+        try ctx.output.print(\"{d}\\n\", .{deleted_count});\n   642+        try outputIdList(&ctx.output, ids_to_delete.items);\n   643     } else if (global.quiet) {\n   644-        try ctx.output.raw(delete_args.id);\n   645-        try ctx.output.raw(\"\\n\");\n   646+        try outputIdList(&ctx.output, ids_to_delete.items);\n   647     } else {\n   648-        try ctx.output.success(\"Deleted issue {s}\", .{delete_args.id});\n   649+        if (deleted_count == 1 and ids_to_delete.items.len == 1) {\n   650+            if (delete_args.hard) {\n   651+                try ctx.output.success(\"Permanently deleted issue {s}\", .{ids_to_delete.items[0]});\n   652+            } else {\n   653+                try ctx.output.success(\"Deleted issue {s}\", .{ids_to_delete.items[0]});\n   654+            }\n   655+        } else {\n   656+            if (delete_args.hard) {\n   657+                try ctx.output.success(\"Permanently deleted {d} issue(s)\", .{deleted_count});\n   658+            } else {\n   659+                try ctx.output.success(\"Deleted {d} issue(s)\", .{deleted_count});\n   660+            }\n   661+        }\n   662+\n   663+        if (not_found_count > 0) {\n   664+            try ctx.output.warn(\"{d} issue(s) not found\", .{not_found_count});\n   665+        }\n   666     }\n   667 }\n   668 \n   669@@ -85,12 +290,15 @@ test \"DeleteError enum exists\" {\n   670 }\n   671 \n   672 test \"DeleteResult struct works\" {\n   673+    const ids = [_][]const u8{\"bd-abc123\"};\n   674     const result = DeleteResult{\n   675         .success = true,\n   676-        .id = \"bd-abc123\",\n   677+        .ids = &ids,\n   678+        .deleted_count = 1,\n   679     };\n   680     try std.testing.expect(result.success);\n   681-    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n   682+    try std.testing.expectEqual(@as(usize, 1), result.ids.?.len);\n   683+    try std.testing.expectEqualStrings(\"bd-abc123\", result.ids.?[0]);\n   684 }\n   685 \n   686 test \"run detects uninitialized workspace\" {\n   687@@ -124,6 +332,6 @@ test \"run returns error for missing issue\" {\n   688     const delete_args = args.DeleteArgs{ .id = \"bd-nonexistent\" };\n   689     const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   690 \n   691-    const result = run(delete_args, global, allocator);\n   692-    try std.testing.expectError(DeleteError.IssueNotFound, result);\n   693+    // This should complete but report 0 deletions (issue not found is handled gracefully)\n   694+    try run(delete_args, global, allocator);\n   695 }\n   696diff --git a/src/cli/dep.zig b/src/cli/dep.zig\n   697index 376b809..aea0996 100644\n   698--- a/src/cli/dep.zig\n   699+++ b/src/cli/dep.zig\n   700@@ -84,7 +84,7 @@ fn runAdd(\n   701         .dep_type = DependencyType.fromString(add_args.dep_type),\n   702         .created_at = now,\n   703         .created_by = global.actor,\n   704-        .metadata = null,\n   705+        .metadata = add_args.metadata,\n   706         .thread_id = null,\n   707     };\n   708 \n   709@@ -160,24 +160,35 @@ fn runList(\n   710     global: args.GlobalOptions,\n   711     allocator: std.mem.Allocator,\n   712 ) !void {\n   713-    const deps = try graph.getDependencies(list_args.id);\n   714-    defer graph.freeDependencies(deps);\n   715+    const direction = list_args.direction;\n   716+    const show_down = direction == .down or direction == .both;\n   717+    const show_up = direction == .up or direction == .both;\n   718 \n   719-    const dependents = try graph.getDependents(list_args.id);\n   720-    defer graph.freeDependencies(dependents);\n   721+    var deps: []Dependency = &.{};\n   722+    var dependents: []Dependency = &.{};\n   723+\n   724+    if (show_down) {\n   725+        deps = try graph.getDependencies(list_args.id);\n   726+    }\n   727+    defer if (show_down) graph.freeDependencies(deps);\n   728+\n   729+    if (show_up) {\n   730+        dependents = try graph.getDependents(list_args.id);\n   731+    }\n   732+    defer if (show_up) graph.freeDependencies(dependents);\n   733 \n   734     if (global.isStructuredOutput()) {\n   735         var depends_on_ids: ?[][]const u8 = null;\n   736         var blocks_ids: ?[][]const u8 = null;\n   737 \n   738-        if (deps.len > 0) {\n   739+        if (show_down and deps.len > 0) {\n   740             depends_on_ids = try allocator.alloc([]const u8, deps.len);\n   741             for (deps, 0..) |dep, i| {\n   742                 depends_on_ids.?[i] = dep.depends_on_id;\n   743             }\n   744         }\n   745 \n   746-        if (dependents.len > 0) {\n   747+        if (show_up and dependents.len > 0) {\n   748             blocks_ids = try allocator.alloc([]const u8, dependents.len);\n   749             for (dependents, 0..) |dep, i| {\n   750                 blocks_ids.?[i] = dep.issue_id;\n   751@@ -195,22 +206,30 @@ fn runList(\n   752             .blocks = blocks_ids,\n   753         });\n   754     } else {\n   755-        if (deps.len > 0) {\n   756-            try output.println(\"Depends on:\", .{});\n   757-            for (deps) |dep| {\n   758-                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n   759+        if (show_down) {\n   760+            if (deps.len > 0) {\n   761+                try output.println(\"Depends on:\", .{});\n   762+                for (deps) |dep| {\n   763+                    if (dep.metadata) |meta| {\n   764+                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n   765+                    } else {\n   766+                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n   767+                    }\n   768+                }\n   769+            } else {\n   770+                try output.println(\"Depends on: (none)\", .{});\n   771             }\n   772-        } else {\n   773-            try output.println(\"Depends on: (none)\", .{});\n   774         }\n   775 \n   776-        if (dependents.len > 0) {\n   777-            try output.println(\"Blocks:\", .{});\n   778-            for (dependents) |dep| {\n   779-                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n   780+        if (show_up) {\n   781+            if (dependents.len > 0) {\n   782+                try output.println(\"Blocks:\", .{});\n   783+                for (dependents) |dep| {\n   784+                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n   785+                }\n   786+            } else {\n   787+                try output.println(\"Blocks: (none)\", .{});\n   788             }\n   789-        } else {\n   790-            try output.println(\"Blocks: (none)\", .{});\n   791         }\n   792     }\n   793 }\n   794@@ -231,6 +250,7 @@ fn runTree(\n   795     allocator: std.mem.Allocator,\n   796 ) !void {\n   797     const id = tree_args.id;\n   798+    const format = tree_args.format;\n   799 \n   800     // Check if issue exists\n   801     const issue = try ctx.store.get(id);\n   802@@ -250,6 +270,9 @@ fn runTree(\n   803             .success = true,\n   804             .tree = root,\n   805         });\n   806+    } else if (format == .mermaid) {\n   807+        // Mermaid flowchart output\n   808+        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n   809     } else {\n   810         // ASCII tree output\n   811         try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n   812@@ -355,6 +378,160 @@ fn printTreeBranch(\n   813     }\n   814 }\n   815 \n   816+fn printMermaidTree(\n   817+    output: *common.Output,\n   818+    graph: *DependencyGraph,\n   819+    ctx: *CommandContext,\n   820+    root_id: []const u8,\n   821+    allocator: std.mem.Allocator,\n   822+) !void {\n   823+    // Start Mermaid flowchart\n   824+    try output.println(\"```mermaid\", .{});\n   825+    try output.println(\"flowchart TD\", .{});\n   826+\n   827+    // Track visited nodes to avoid duplicates\n   828+    var visited: std.StringHashMapUnmanaged(void) = .{};\n   829+    defer {\n   830+        var it = visited.keyIterator();\n   831+        while (it.next()) |key| allocator.free(key.*);\n   832+        visited.deinit(allocator);\n   833+    }\n   834+\n   835+    // Track emitted edges to avoid duplicates\n   836+    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n   837+    defer {\n   838+        var edge_it = emitted_edges.keyIterator();\n   839+        while (edge_it.next()) |key| allocator.free(key.*);\n   840+        emitted_edges.deinit(allocator);\n   841+    }\n   842+\n   843+    // Collect all nodes and edges starting from root\n   844+    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n   845+\n   846+    try output.println(\"```\", .{});\n   847+}\n   848+\n   849+fn collectMermaidNodes(\n   850+    output: *common.Output,\n   851+    graph: *DependencyGraph,\n   852+    ctx: *CommandContext,\n   853+    id: []const u8,\n   854+    visited: *std.StringHashMapUnmanaged(void),\n   855+    emitted_edges: *std.StringHashMapUnmanaged(void),\n   856+    allocator: std.mem.Allocator,\n   857+    depth: usize,\n   858+    max_depth: usize,\n   859+) !void {\n   860+    // Skip if already visited\n   861+    if (visited.contains(id)) return;\n   862+\n   863+    // Mark as visited\n   864+    const id_copy = try allocator.dupe(u8, id);\n   865+    errdefer allocator.free(id_copy);\n   866+    try visited.put(allocator, id_copy, {});\n   867+\n   868+    // Get issue details for node label\n   869+    const issue = try ctx.store.get(id);\n   870+    const safe_id = try sanitizeMermaidId(id, allocator);\n   871+    defer allocator.free(safe_id);\n   872+\n   873+    if (issue) |i| {\n   874+        var iss = i;\n   875+        defer iss.deinit(allocator);\n   876+        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n   877+        defer allocator.free(safe_title);\n   878+        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n   879+    } else {\n   880+        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n   881+    }\n   882+\n   883+    if (depth >= max_depth) return;\n   884+\n   885+    // Get dependencies (what this issue depends on)\n   886+    const deps = try graph.getDependencies(id);\n   887+    defer graph.freeDependencies(deps);\n   888+\n   889+    for (deps) |dep| {\n   890+        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n   891+        defer allocator.free(target_id);\n   892+\n   893+        // Create edge key for deduplication\n   894+        var edge_buf: [256]u8 = undefined;\n   895+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n   896+\n   897+        if (!emitted_edges.contains(edge_key)) {\n   898+            const edge_copy = try allocator.dupe(u8, edge_key);\n   899+            try emitted_edges.put(allocator, edge_copy, {});\n   900+\n   901+            // Emit edge with dependency type as label\n   902+            const dep_type_str = dep.dep_type.toString();\n   903+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n   904+        }\n   905+\n   906+        // Recurse into dependency\n   907+        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n   908+    }\n   909+\n   910+    // Get dependents (what depends on this issue)\n   911+    const dependents = try graph.getDependents(id);\n   912+    defer graph.freeDependencies(dependents);\n   913+\n   914+    for (dependents) |dep| {\n   915+        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n   916+        defer allocator.free(source_id);\n   917+\n   918+        // Create edge key for deduplication\n   919+        var edge_buf: [256]u8 = undefined;\n   920+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n   921+\n   922+        if (!emitted_edges.contains(edge_key)) {\n   923+            const edge_copy = try allocator.dupe(u8, edge_key);\n   924+            try emitted_edges.put(allocator, edge_copy, {});\n   925+\n   926+            const dep_type_str = dep.dep_type.toString();\n   927+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n   928+        }\n   929+\n   930+        // Recurse into dependent\n   931+        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n   932+    }\n   933+}\n   934+\n   935+fn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n   936+    // Replace characters that are invalid in Mermaid node IDs\n   937+    var result = try allocator.alloc(u8, id.len);\n   938+    for (id, 0..) |c, i| {\n   939+        result[i] = if (c == '-' or c == '.') '_' else c;\n   940+    }\n   941+    return result;\n   942+}\n   943+\n   944+fn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n   945+    // Escape special characters in Mermaid labels\n   946+    var count: usize = 0;\n   947+    for (label) |c| {\n   948+        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n   949+    }\n   950+\n   951+    var result = try allocator.alloc(u8, count);\n   952+    var i: usize = 0;\n   953+    for (label) |c| {\n   954+        if (c == '\"') {\n   955+            result[i] = '\\\\';\n   956+            result[i + 1] = '\"';\n   957+            i += 2;\n   958+        } else if (c == '\\\\') {\n   959+            result[i] = '\\\\';\n   960+            result[i + 1] = '\\\\';\n   961+            i += 2;\n   962+        } else {\n   963+            result[i] = c;\n   964+            i += 1;\n   965+        }\n   966+    }\n   967+    return result;\n   968+}\n   969+\n   970 fn buildTreeNode(\n   971     graph: *DependencyGraph,\n   972     ctx: *CommandContext,\n   973diff --git a/src/cli/label.zig b/src/cli/label.zig\n   974index 942b031..a123004 100644\n   975--- a/src/cli/label.zig\n   976+++ b/src/cli/label.zig\n   977@@ -24,6 +24,9 @@ pub const LabelResult = struct {\n   978     labels: ?[]const []const u8 = null,\n   979     added: ?[]const []const u8 = null,\n   980     removed: ?[]const []const u8 = null,\n   981+    old_name: ?[]const u8 = null,\n   982+    new_name: ?[]const u8 = null,\n   983+    renamed_count: ?usize = null,\n   984     message: ?[]const u8 = null,\n   985 };\n   986 \n   987@@ -37,6 +40,7 @@ pub fn run(\n   988         .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n   989         .list => |list| try runList(list.id, global, allocator),\n   990         .list_all => try runListAll(global, allocator),\n   991+        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n   992     }\n   993 }\n   994 \n   995@@ -307,6 +311,78 @@ fn runListAll(\n   996     }\n   997 }\n   998 \n   999+fn runRename(\n  1000+    old_name: []const u8,\n  1001+    new_name: []const u8,\n  1002+    global: args.GlobalOptions,\n  1003+    allocator: std.mem.Allocator,\n  1004+) !void {\n  1005+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n  1006+        return LabelError.WorkspaceNotInitialized;\n  1007+    };\n  1008+    defer ctx.deinit();\n  1009+\n  1010+    // Count how many issues have this label renamed\n  1011+    var renamed_count: usize = 0;\n  1012+\n  1013+    // Iterate through all issues\n  1014+    for (ctx.store.issues.items) |*issue| {\n  1015+        if (issue.status.eql(.tombstone)) continue;\n  1016+\n  1017+        // Check if issue has the old label\n  1018+        var has_old_label = false;\n  1019+        var old_label_idx: usize = 0;\n  1020+        for (issue.labels, 0..) |label, idx| {\n  1021+            if (std.mem.eql(u8, label, old_name)) {\n  1022+                has_old_label = true;\n  1023+                old_label_idx = idx;\n  1024+                break;\n  1025+            }\n  1026+        }\n  1027+\n  1028+        if (has_old_label) {\n  1029+            // Check if it already has the new label (avoid duplicates)\n  1030+            var has_new_label = false;\n  1031+            for (issue.labels) |label| {\n  1032+                if (std.mem.eql(u8, label, new_name)) {\n  1033+                    has_new_label = true;\n  1034+                    break;\n  1035+                }\n  1036+            }\n  1037+\n  1038+            if (has_new_label) {\n  1039+                // Remove the old label (new label already exists)\n  1040+                try ctx.store.removeLabel(issue.id, old_name);\n  1041+            } else {\n  1042+                // Replace old label with new label in place\n  1043+                // First remove old, then add new\n  1044+                try ctx.store.removeLabel(issue.id, old_name);\n  1045+                try ctx.store.addLabel(issue.id, new_name);\n  1046+            }\n  1047+            renamed_count += 1;\n  1048+        }\n  1049+    }\n  1050+\n  1051+    try ctx.saveIfAutoFlush();\n  1052+\n  1053+    if (global.isStructuredOutput()) {\n  1054+        try ctx.output.printJson(LabelResult{\n  1055+            .success = true,\n  1056+            .old_name = old_name,\n  1057+            .new_name = new_name,\n  1058+            .renamed_count = renamed_count,\n  1059+        });\n  1060+    } else if (global.quiet) {\n  1061+        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n  1062+    } else {\n  1063+        if (renamed_count > 0) {\n  1064+            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n  1065+        } else {\n  1066+            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n  1067+        }\n  1068+    }\n  1069+}\n  1070+\n  1071 // --- Tests ---\n  1072 \n  1073 test \"LabelError enum exists\" {\n  1074diff --git a/src/output/mod.zig b/src/output/mod.zig\n  1075index 49cd59a..799b77d 100644\n  1076--- a/src/output/mod.zig\n  1077+++ b/src/output/mod.zig\n  1078@@ -21,6 +21,7 @@ pub const OutputMode = enum {\n  1079     rich, // Colors and formatting (TTY)\n  1080     json, // Structured JSON output\n  1081     quiet, // Minimal output (IDs only)\n  1082+    robot, // Line-oriented machine-readable output for scripting\n  1083 };\n  1084 \n  1085 /// ANSI color escape codes.\n  1086@@ -58,6 +59,7 @@ pub const Color = struct {\n  1087 pub const OutputOptions = struct {\n  1088     json: bool = false,\n  1089     toon: bool = false,\n  1090+    robot: bool = false, // Line-oriented machine-readable output for scripting\n  1091     quiet: bool = false,\n  1092     silent: bool = false, // Suppress ALL output including errors (for tests)\n  1093     no_color: bool = false,\n  1094@@ -88,6 +90,8 @@ pub const Output = struct {\n  1095         var mode: OutputMode = .plain;\n  1096         if (opts.json or opts.toon) {\n  1097             mode = .json;\n  1098+        } else if (opts.robot) {\n  1099+            mode = .robot;\n  1100         } else if (opts.quiet or opts.silent) {\n  1101             mode = .quiet;\n  1102         } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n  1103@@ -166,6 +170,7 @@ pub const Output = struct {\n  1104             .quiet => try self.printIssueQuiet(issue),\n  1105             .rich => try self.printIssueRich(issue),\n  1106             .plain => try self.printIssuePlain(issue),\n  1107+            .robot => try self.printIssueRobot(issue),\n  1108         }\n  1109     }\n  1110 \n  1111@@ -176,6 +181,7 @@ pub const Output = struct {\n  1112             .quiet => try self.printIssueListQuiet(issues),\n  1113             .rich => try self.printIssueListRich(issues),\n  1114             .plain => try self.printIssueListPlain(issues),\n  1115+            .robot => try self.printIssueListRobot(issues),\n  1116         }\n  1117     }\n  1118 \n  1119@@ -441,6 +447,29 @@ pub const Output = struct {\n  1120         }\n  1121     }\n  1122 \n  1123+    // ========================================================================\n  1124+    // Robot Mode Helpers (tab-separated, line-oriented for scripting)\n  1125+    // ========================================================================\n  1126+\n  1127+    /// Print single issue in robot format: tab-separated key fields on one line.\n  1128+    /// Format: ID<TAB>STATUS<TAB>PRIORITY<TAB>TYPE<TAB>TITLE\n  1129+    fn printIssueRobot(self: *Self, issue: Issue) !void {\n  1130+        try self.writeFormatted(\"{s}\\t{s}\\t{s}\\t{s}\\t{s}\\n\", .{\n  1131+            issue.id,\n  1132+            issue.status.toString(),\n  1133+            issue.priority.toString(),\n  1134+            issue.issue_type.toString(),\n  1135+            issue.title,\n  1136+        });\n  1137+    }\n  1138+\n  1139+    /// Print issue list in robot format: one issue per line, tab-separated fields.\n  1140+    fn printIssueListRobot(self: *Self, issues: []const Issue) !void {\n  1141+        for (issues) |issue| {\n  1142+            try self.printIssueRobot(issue);\n  1143+        }\n  1144+    }\n  1145+\n  1146     // ========================================================================\n  1147     // Internal Helpers\n  1148     // ========================================================================\n  1149diff --git a/src/storage/store.zig b/src/storage/store.zig\n  1150index c243178..89c2a41 100644\n  1151--- a/src/storage/store.zig\n  1152+++ b/src/storage/store.zig\n  1153@@ -327,6 +327,39 @@ pub const IssueStore = struct {\n  1154         try self.update(id, .{ .status = .tombstone }, now);\n  1155     }\n  1156 \n  1157+    /// Hard delete an issue by removing it from the store entirely.\n  1158+    /// Unlike soft delete (tombstone), this permanently removes the issue.\n  1159+    pub fn remove(self: *Self, id: []const u8) !void {\n  1160+        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n  1161+        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n  1162+\n  1163+        // Free the issue data\n  1164+        self.issues.items[idx].deinit(self.allocator);\n  1165+\n  1166+        // Remove from index (free the key)\n  1167+        if (self.id_index.fetchRemove(id)) |kv| {\n  1168+            self.allocator.free(kv.key);\n  1169+        }\n  1170+\n  1171+        // Remove from issues array using swap-remove for O(1)\n  1172+        _ = self.issues.swapRemove(idx);\n  1173+\n  1174+        // Update the index for the swapped element (if any)\n  1175+        if (idx < self.issues.items.len) {\n  1176+            const swapped_id = self.issues.items[idx].id;\n  1177+            if (self.id_index.getPtr(swapped_id)) |idx_ptr| {\n  1178+                idx_ptr.* = idx;\n  1179+            }\n  1180+        }\n  1181+\n  1182+        // Also remove from dirty_ids if present\n  1183+        if (self.dirty_ids.fetchRemove(id)) |kv| {\n  1184+            self.allocator.free(kv.key);\n  1185+        }\n  1186+\n  1187+        self.dirty = true;\n  1188+    }\n  1189+\n  1190     /// Filters for listing issues.\n  1191     pub const ListFilters = struct {\n  1192         status: ?Status = null,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"3c5ceaa6-2b7d-4c0e-b6e1-081381ba1e50","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/d965594a-b540-4605-8ceb-7e84a6081b47/tool-results/toolu_01CwaCkThUTTJ4wkfKrMqLET.txt","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 54a8db2..2de3b21 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -9,6 +9,7 @@ const std = @import(\"std\");\n pub const GlobalOptions = struct {\n     json: bool = false,\n     toon: bool = false,\n+    robot: bool = false, // Line-oriented machine-readable output for scripting\n     quiet: bool = false,\n     silent: bool = false, // Suppress ALL output including errors (for tests)\n     verbose: u8 = 0,\n@@ -25,6 +26,11 @@ pub const GlobalOptions = struct {\n     pub fn isStructuredOutput(self: GlobalOptions) bool {\n         return self.json or self.toon;\n     }\n+\n+    /// Returns true if any machine-readable output is enabled.\n+    pub fn isMachineOutput(self: GlobalOptions) bool {\n+        return self.json or self.toon or self.robot;\n+    }\n };\n \n /// All available subcommands.\n@@ -170,7 +176,16 @@ pub const ReopenArgs = struct {\n \n /// Delete command arguments.\n pub const DeleteArgs = struct {\n-    id: []const u8,\n+    /// Single issue ID to delete (mutually exclusive with from_file).\n+    id: ?[]const u8 = null,\n+    /// Path to file containing issue IDs to delete (one per line).\n+    from_file: ?[]const u8 = null,\n+    /// Delete issue and all its dependents recursively.\n+    cascade: bool = false,\n+    /// Prune from database immediately instead of marking as tombstone.\n+    hard: bool = false,\n+    /// Preview what would be deleted without making changes.\n+    dry_run: bool = false,\n };\n \n /// Add-batch command arguments.\n@@ -332,12 +347,39 @@ pub const EpicArgs = struct {\n     subcommand: EpicSubcommand,\n };\n \n+/// Direction filter for dependency listing.\n+pub const DepDirection = enum {\n+    up, // What depends on this issue (dependents/blocked-by)\n+    down, // What this issue depends on\n+    both, // Both directions (default)\n+\n+    pub fn fromString(s: []const u8) ?DepDirection {\n+        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n+        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n+        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n+        return null;\n+    }\n+};\n+\n+/// Tree output formats for dep tree.\n+pub const TreeFormat = enum {\n+    ascii,\n+    mermaid,\n+\n+    pub fn fromString(s: []const u8) ?TreeFormat {\n+        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n+        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n+        return null;\n+    }\n+};\n+\n /// Dependency subcommand variants.\n pub const DepSubcommand = union(enum) {\n     add: struct {\n         child: []const u8,\n         parent: []const u8,\n         dep_type: []const u8 = \"blocks\",\n+        metadata: ?[]const u8 = null,\n     },\n     remove: struct {\n         child: []const u8,\n@@ -345,9 +387,11 @@ pub const DepSubcommand = union(enum) {\n     },\n     list: struct {\n         id: []const u8,\n+        direction: DepDirection = .both,\n     },\n     tree: struct {\n         id: []const u8,\n+        format: TreeFormat = .ascii,\n     },\n     cycles: void,\n };\n@@ -391,6 +435,10 @@ pub const LabelSubcommand = union(enum) {\n         id: []const u8,\n     },\n     list_all: void,\n+    rename: struct {\n+        old_name: []const u8,\n+        new_name: []const u8,\n+    },\n };\n \n /// Label command arguments.\n@@ -674,6 +722,10 @@ pub const ArgParser = struct {\n             global.stats = true;\n             return true;\n         }\n+        if (std.mem.eql(u8, arg, \"--robot\")) {\n+            global.robot = true;\n+            return true;\n+        }\n \n         // Put back if not recognized\n         self.index -= 1;\n@@ -1012,8 +1064,30 @@ pub const ArgParser = struct {\n     }\n \n     fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n-        const id = self.next() orelse return error.MissingRequiredArgument;\n-        return .{ .id = id };\n+        var result = DeleteArgs{};\n+\n+        while (self.hasNext()) {\n+            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n+                result.from_file = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--cascade\")) {\n+                result.cascade = true;\n+            } else if (self.consumeFlag(null, \"--hard\")) {\n+                result.hard = true;\n+            } else if (self.consumeFlag(null, \"--dry-run\")) {\n+                result.dry_run = true;\n+            } else if (self.peekPositional()) |_| {\n+                if (result.id == null) {\n+                    result.id = self.next().?;\n+                } else break;\n+            } else break;\n+        }\n+\n+        // Require either id or from_file\n+        if (result.id == null and result.from_file == null) {\n+            return error.MissingRequiredArgument;\n+        }\n+\n+        return result;\n     }\n \n     fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n@@ -1235,12 +1309,15 @@ pub const ArgParser = struct {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n             const parent = self.next() orelse return error.MissingRequiredArgument;\n             var dep_type: []const u8 = \"blocks\";\n+            var metadata: ?[]const u8 = null;\n             while (self.hasNext()) {\n                 if (self.consumeFlag(\"-t\", \"--type\")) {\n                     dep_type = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n+                    metadata = self.next() orelse return error.MissingFlagValue;\n                 } else break;\n             }\n-            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n+            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n             const child = self.next() orelse return error.MissingRequiredArgument;\n@@ -1248,10 +1325,26 @@ pub const ArgParser = struct {\n             return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n-            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n+            const id = self.next() orelse return error.MissingRequiredArgument;\n+            var direction: DepDirection = .both;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-d\", \"--direction\")) {\n+                    const dir_str = self.next() orelse return error.MissingFlagValue;\n+                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"tree\")) {\n-            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n+            const id = self.next() orelse return error.MissingRequiredArgument;\n+            var format: TreeFormat = .ascii;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-f\", \"--format\")) {\n+                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n+                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n         }\n         if (std.mem.eql(u8, subcmd, \"cycles\")) {\n             return .{ .subcommand = .{ .cycles = {} } };\n@@ -1348,6 +1441,11 @@ pub const ArgParser = struct {\n         if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n             return .{ .subcommand = .{ .list_all = {} } };\n         }\n+        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n+            const old_name = self.next() orelse return error.MissingRequiredArgument;\n+            const new_name = self.next() orelse return error.MissingRequiredArgument;\n+            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n+        }\n         return error.UnknownSubcommand;\n     }\n \n@@ -1897,12 +1995,34 @@ test \"parse reopen command\" {\n }\n \n test \"parse delete command\" {\n-    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n-    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n     const result = try parser.parse();\n \n     try std.testing.expect(result.command == .delete);\n-    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n+    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n+}\n+\n+test \"parse delete command with flags\" {\n+    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.command == .delete);\n+    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n+    try std.testing.expect(result.command.delete.cascade);\n+    try std.testing.expect(result.command.delete.dry_run);\n+    try std.testing.expect(!result.command.delete.hard);\n+}\n+\n+test \"parse delete command with from-file\" {\n+    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.command == .delete);\n+    try std.testing.expect(result.command.delete.id == null);\n+    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n }\n \n test \"parse list command\" {\n@@ -2089,6 +2209,47 @@ test \"parse dep cycles command\" {\n     try std.testing.expect(result.command.dep.subcommand == .cycles);\n }\n \n+test \"parse dep add command with metadata\" {\n+    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const add = result.command.dep.subcommand.add;\n+    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n+    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n+    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n+    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n+}\n+\n+test \"parse dep list command with direction down\" {\n+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const list = result.command.dep.subcommand.list;\n+    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n+    try std.testing.expectEqual(DepDirection.down, list.direction);\n+}\n+\n+test \"parse dep list command with direction up\" {\n+    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const list = result.command.dep.subcommand.list;\n+    try std.testing.expectEqual(DepDirection.up, list.direction);\n+}\n+\n+test \"parse dep tree command with format mermaid\" {\n+    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const tree = result.command.dep.subcommand.tree;\n+    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n+    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n+}\n+\n test \"parse label add command\" {\n     const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\n@@ -2130,6 +2291,26 @@ test \"parse label list-all command\" {\n     try std.testing.expect(result.command.label.subcommand == .list_all);\n }\n \n+test \"parse label rename command\" {\n+    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const rename = result.command.label.subcommand.rename;\n+    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n+    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n+}\n+\n+test \"parse label mv command (alias for rename)\" {\n+    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n+    var parser = ArgParser.init(std.testing.allocator, &input);\n+    const result = try parser.parse();\n+\n+    const rename = result.command.label.subcommand.rename;\n+    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n+    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n+}\n+\n test \"parse comments add command\" {\n     const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\ndiff --git a/src/cli/close.zig b/src/cli/close.zig\nindex e5f3e98..b2dc347 100644\n--- a/src/cli/close.zig\n+++ b/src/cli/close.zig\n@@ -142,6 +142,12 @@ fn outputSuccess(\n             .id = id,\n             .action = action,\n         });\n+    } else if (global.robot) {\n+        // Robot format: ACTION<TAB>ID\n+        try output.raw(action);\n+        try output.raw(\"\\t\");\n+        try output.raw(id);\n+        try output.raw(\"\\n\");\n     } else if (global.quiet) {\n         try output.raw(id);\n         try output.raw(\"\\n\");\ndiff --git a/src/cli/common.zig b/src/cli/common.zig\nindex 6034248..4d9634d 100644\n--- a/src/cli/common.zig\n+++ b/src/cli/common.zig\n@@ -51,6 +51,7 @@ pub const CommandContext = struct {\n         var output = Output.init(allocator, .{\n             .json = global.json,\n             .toon = global.toon,\n+            .robot = global.robot,\n             .quiet = global.quiet,\n             .silent = global.silent,\n             .no_color = global.no_color,\n@@ -268,9 +269,12 @@ pub fn initOutput(allocator: std.mem.Allocator, global: args.GlobalOptions) Outp\n     return Output.init(allocator, .{\n         .json = global.json,\n         .toon = global.toon,\n+        .robot = global.robot,\n         .quiet = global.quiet,\n         .silent = global.silent,\n         .no_color = global.no_color,\n+        .wrap = global.wrap,\n+        .stats = global.stats,\n     });\n }\n \ndiff --git a/src/cli/delete.zig b/src/cli/delete.zig\nindex a637a10..1d1bf79 100644\n--- a/src/cli/delete.zig\n+++ b/src/cli/delete.zig\n@@ -1,19 +1,54 @@\n //! Delete command for beads_zig.\n //!\n //! `bz delete <id>` - Soft delete an issue (set status to tombstone)\n+//! `bz delete --from-file <path>` - Delete multiple issues from a file\n+//! `bz delete <id> --cascade` - Delete issue and all its dependents\n+//! `bz delete <id> --hard` - Permanently remove from database\n+//! `bz delete <id> --dry-run` - Preview what would be deleted\n //!\n-//! This is a soft delete - the issue is marked as tombstone but remains\n+//! By default, this is a soft delete - the issue is marked as tombstone but remains\n //! in the database for audit purposes. Use `bz list --all` to see tombstoned issues.\n \n const std = @import(\"std\");\n const models = @import(\"../models/mod.zig\");\n+const storage = @import(\"../storage/mod.zig\");\n const common = @import(\"common.zig\");\n const args = @import(\"args.zig\");\n const test_util = @import(\"../test_util.zig\");\n \n const Status = models.Status;\n+const Issue = models.Issue;\n const IssueStore = common.IssueStore;\n const CommandContext = common.CommandContext;\n+const DependencyGraph = common.DependencyGraph;\n+const Wal = storage.Wal;\n+const Output = @import(\"../output/mod.zig\").Output;\n+\n+/// Output a list of IDs, one per line (used for quiet/robot output).\n+fn outputIdList(output: *Output, ids: []const []const u8) !void {\n+    for (ids) |id| {\n+        try output.raw(id);\n+        try output.raw(\"\\n\");\n+    }\n+}\n+\n+/// Create a slice of IDs from the ArrayList (for JSON output).\n+fn createIdSlice(allocator: std.mem.Allocator, ids: std.ArrayListUnmanaged([]const u8)) ![]const []const u8 {\n+    const id_slice = try allocator.alloc([]const u8, ids.items.len);\n+    for (ids.items, 0..) |id, i| {\n+        id_slice[i] = id;\n+    }\n+    return id_slice;\n+}\n+\n+/// Truncate the WAL after hard delete to prevent deleted issues from reappearing.\n+fn truncateWalIfNeeded(hard: bool, deleted_count: usize, beads_dir: []const u8, allocator: std.mem.Allocator) void {\n+    if (!hard or deleted_count == 0) return;\n+\n+    var wal_obj = Wal.init(beads_dir, allocator) catch return;\n+    defer wal_obj.deinit();\n+    wal_obj.truncate() catch {};\n+}\n \n pub const DeleteError = error{\n     WorkspaceNotInitialized,\n@@ -21,12 +56,16 @@ pub const DeleteError = error{\n     AlreadyDeleted,\n     StorageError,\n     OutOfMemory,\n+    FileReadError,\n+    InvalidInput,\n };\n \n pub const DeleteResult = struct {\n     success: bool,\n-    id: ?[]const u8 = null,\n+    ids: ?[]const []const u8 = null,\n+    deleted_count: ?usize = null,\n     message: ?[]const u8 = null,\n+    dry_run: bool = false,\n };\n \n pub fn run(\n@@ -40,40 +79,206 @@ pub fn run(\n     defer ctx.deinit();\n \n     const structured_output = global.isStructuredOutput();\n-    const issue_ref = ctx.store.getRef(delete_args.id) orelse {\n-        try common.outputNotFoundError(DeleteResult, &ctx.output, structured_output, delete_args.id, allocator);\n-        return DeleteError.IssueNotFound;\n-    };\n \n-    if (issue_ref.status.eql(.tombstone)) {\n-        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"issue is already deleted\");\n-        return DeleteError.AlreadyDeleted;\n+    // Collect all IDs to delete\n+    var ids_to_delete: std.ArrayListUnmanaged([]const u8) = .{};\n+    defer ids_to_delete.deinit(allocator);\n+\n+    if (delete_args.from_file) |file_path| {\n+        // Read IDs from file\n+        const file = std.fs.cwd().openFile(file_path, .{}) catch {\n+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot open file\");\n+            return DeleteError.FileReadError;\n+        };\n+        defer file.close();\n+\n+        const content = file.readToEndAlloc(allocator, 1024 * 1024) catch {\n+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot read file\");\n+            return DeleteError.FileReadError;\n+        };\n+        defer allocator.free(content);\n+\n+        var lines = std.mem.splitScalar(u8, content, '\\n');\n+        while (lines.next()) |line| {\n+            const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n+            if (trimmed.len == 0) continue;\n+            if (trimmed[0] == '#') continue; // Skip comments\n+            const id_copy = try allocator.dupe(u8, trimmed);\n+            try ids_to_delete.append(allocator, id_copy);\n+        }\n+\n+        if (ids_to_delete.items.len == 0) {\n+            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no valid IDs in file\");\n+            return DeleteError.InvalidInput;\n+        }\n+    } else if (delete_args.id) |id| {\n+        const id_copy = try allocator.dupe(u8, id);\n+        try ids_to_delete.append(allocator, id_copy);\n+    } else {\n+        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no issue ID specified\");\n+        return DeleteError.InvalidInput;\n+    }\n+    defer {\n+        for (ids_to_delete.items) |id| {\n+            allocator.free(id);\n+        }\n     }\n \n+    // If cascade mode, expand to include all dependents\n+    if (delete_args.cascade) {\n+        var graph = ctx.createGraph();\n+        var expanded_ids: std.StringHashMapUnmanaged(void) = .{};\n+        defer {\n+            var key_it = expanded_ids.keyIterator();\n+            while (key_it.next()) |key| {\n+                allocator.free(key.*);\n+            }\n+            expanded_ids.deinit(allocator);\n+        }\n+\n+        // Add initial IDs\n+        for (ids_to_delete.items) |id| {\n+            if (!expanded_ids.contains(id)) {\n+                const id_copy = try allocator.dupe(u8, id);\n+                try expanded_ids.put(allocator, id_copy, {});\n+            }\n+        }\n+\n+        // Recursively add all dependents using BFS\n+        var work_queue: std.ArrayListUnmanaged([]const u8) = .{};\n+        defer work_queue.deinit(allocator);\n+\n+        for (ids_to_delete.items) |id| {\n+            try work_queue.append(allocator, id);\n+        }\n+\n+        while (work_queue.items.len > 0) {\n+            const current_id = work_queue.orderedRemove(0);\n+            const dependents = graph.getDependents(current_id) catch continue;\n+            defer graph.freeDependencies(dependents);\n+\n+            for (dependents) |dep| {\n+                if (!expanded_ids.contains(dep.issue_id)) {\n+                    const dep_id_copy = try allocator.dupe(u8, dep.issue_id);\n+                    try expanded_ids.put(allocator, dep_id_copy, {});\n+                    try work_queue.append(allocator, dep_id_copy);\n+                }\n+            }\n+        }\n+\n+        // Replace ids_to_delete with expanded set\n+        for (ids_to_delete.items) |id| {\n+            allocator.free(id);\n+        }\n+        ids_to_delete.clearRetainingCapacity();\n+\n+        var id_it = expanded_ids.keyIterator();\n+        while (id_it.next()) |key| {\n+            const id_copy = try allocator.dupe(u8, key.*);\n+            try ids_to_delete.append(allocator, id_copy);\n+        }\n+    }\n+\n+    // Dry run mode - just report what would be deleted\n+    if (delete_args.dry_run) {\n+        if (structured_output) {\n+            const id_slice = try createIdSlice(allocator, ids_to_delete);\n+            defer allocator.free(id_slice);\n+            try ctx.output.printJson(DeleteResult{\n+                .success = true,\n+                .ids = id_slice,\n+                .deleted_count = ids_to_delete.items.len,\n+                .dry_run = true,\n+                .message = \"dry run - no changes made\",\n+            });\n+        } else if (global.robot) {\n+            try ctx.output.raw(\"DRY_RUN\\t\");\n+            try ctx.output.print(\"{d}\\n\", .{ids_to_delete.items.len});\n+            try outputIdList(&ctx.output, ids_to_delete.items);\n+        } else if (global.quiet) {\n+            try outputIdList(&ctx.output, ids_to_delete.items);\n+        } else {\n+            try ctx.output.print(\"Would delete {d} issue(s):\\n\", .{ids_to_delete.items.len});\n+            for (ids_to_delete.items) |id| {\n+                try ctx.output.print(\"  {s}\\n\", .{id});\n+            }\n+        }\n+        return;\n+    }\n+\n+    // Perform the actual deletion\n     const now = std.time.timestamp();\n-    const updates = IssueStore.IssueUpdate{\n-        .status = .tombstone,\n-        .closed_at = now,\n-        .close_reason = \"deleted\",\n-    };\n+    var deleted_count: usize = 0;\n+    var not_found_count: usize = 0;\n \n-    ctx.store.update(delete_args.id, updates, now) catch {\n-        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"failed to delete issue\");\n-        return DeleteError.StorageError;\n-    };\n+    for (ids_to_delete.items) |id| {\n+        const issue_ref = ctx.store.getRef(id) orelse {\n+            not_found_count += 1;\n+            continue;\n+        };\n+\n+        if (issue_ref.status.eql(.tombstone)) {\n+            continue; // Already deleted\n+        }\n+\n+        if (delete_args.hard) {\n+            // Hard delete - remove from store entirely\n+            ctx.store.remove(id) catch {\n+                continue;\n+            };\n+        } else {\n+            // Soft delete - mark as tombstone\n+            const updates = IssueStore.IssueUpdate{\n+                .status = .tombstone,\n+                .closed_at = now,\n+                .close_reason = \"deleted\",\n+            };\n+            ctx.store.update(id, updates, now) catch {\n+                continue;\n+            };\n+        }\n+        deleted_count += 1;\n+    }\n \n     try ctx.saveIfAutoFlush();\n \n+    // For hard delete, truncate the WAL to ensure deleted issues don't\n+    // reappear when replaying WAL entries on next load.\n+    truncateWalIfNeeded(delete_args.hard, deleted_count, ctx.beads_dir, allocator);\n+\n+    // Output result\n     if (structured_output) {\n+        const id_slice = try createIdSlice(allocator, ids_to_delete);\n+        defer allocator.free(id_slice);\n         try ctx.output.printJson(DeleteResult{\n-            .success = true,\n-            .id = delete_args.id,\n+            .success = deleted_count > 0,\n+            .ids = id_slice,\n+            .deleted_count = deleted_count,\n         });\n+    } else if (global.robot) {\n+        try ctx.output.raw(\"OK\\t\");\n+        try ctx.output.print(\"{d}\\n\", .{deleted_count});\n+        try outputIdList(&ctx.output, ids_to_delete.items);\n     } else if (global.quiet) {\n-        try ctx.output.raw(delete_args.id);\n-        try ctx.output.raw(\"\\n\");\n+        try outputIdList(&ctx.output, ids_to_delete.items);\n     } else {\n-        try ctx.output.success(\"Deleted issue {s}\", .{delete_args.id});\n+        if (deleted_count == 1 and ids_to_delete.items.len == 1) {\n+            if (delete_args.hard) {\n+                try ctx.output.success(\"Permanently deleted issue {s}\", .{ids_to_delete.items[0]});\n+            } else {\n+                try ctx.output.success(\"Deleted issue {s}\", .{ids_to_delete.items[0]});\n+            }\n+        } else {\n+            if (delete_args.hard) {\n+                try ctx.output.success(\"Permanently deleted {d} issue(s)\", .{deleted_count});\n+            } else {\n+                try ctx.output.success(\"Deleted {d} issue(s)\", .{deleted_count});\n+            }\n+        }\n+\n+        if (not_found_count > 0) {\n+            try ctx.output.warn(\"{d} issue(s) not found\", .{not_found_count});\n+        }\n     }\n }\n \n@@ -85,12 +290,15 @@ test \"DeleteError enum exists\" {\n }\n \n test \"DeleteResult struct works\" {\n+    const ids = [_][]const u8{\"bd-abc123\"};\n     const result = DeleteResult{\n         .success = true,\n-        .id = \"bd-abc123\",\n+        .ids = &ids,\n+        .deleted_count = 1,\n     };\n     try std.testing.expect(result.success);\n-    try std.testing.expectEqualStrings(\"bd-abc123\", result.id.?);\n+    try std.testing.expectEqual(@as(usize, 1), result.ids.?.len);\n+    try std.testing.expectEqualStrings(\"bd-abc123\", result.ids.?[0]);\n }\n \n test \"run detects uninitialized workspace\" {\n@@ -124,6 +332,6 @@ test \"run returns error for missing issue\" {\n     const delete_args = args.DeleteArgs{ .id = \"bd-nonexistent\" };\n     const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n \n-    const result = run(delete_args, global, allocator);\n-    try std.testing.expectError(DeleteError.IssueNotFound, result);\n+    // This should complete but report 0 deletions (issue not found is handled gracefully)\n+    try run(delete_args, global, allocator);\n }\ndiff --git a/src/cli/dep.zig b/src/cli/dep.zig\nindex 376b809..aea0996 100644\n--- a/src/cli/dep.zig\n+++ b/src/cli/dep.zig\n@@ -84,7 +84,7 @@ fn runAdd(\n         .dep_type = DependencyType.fromString(add_args.dep_type),\n         .created_at = now,\n         .created_by = global.actor,\n-        .metadata = null,\n+        .metadata = add_args.metadata,\n         .thread_id = null,\n     };\n \n@@ -160,24 +160,35 @@ fn runList(\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n-    const deps = try graph.getDependencies(list_args.id);\n-    defer graph.freeDependencies(deps);\n+    const direction = list_args.direction;\n+    const show_down = direction == .down or direction == .both;\n+    const show_up = direction == .up or direction == .both;\n \n-    const dependents = try graph.getDependents(list_args.id);\n-    defer graph.freeDependencies(dependents);\n+    var deps: []Dependency = &.{};\n+    var dependents: []Dependency = &.{};\n+\n+    if (show_down) {\n+        deps = try graph.getDependencies(list_args.id);\n+    }\n+    defer if (show_down) graph.freeDependencies(deps);\n+\n+    if (show_up) {\n+        dependents = try graph.getDependents(list_args.id);\n+    }\n+    defer if (show_up) graph.freeDependencies(dependents);\n \n     if (global.isStructuredOutput()) {\n         var depends_on_ids: ?[][]const u8 = null;\n         var blocks_ids: ?[][]const u8 = null;\n \n-        if (deps.len > 0) {\n+        if (show_down and deps.len > 0) {\n             depends_on_ids = try allocator.alloc([]const u8, deps.len);\n             for (deps, 0..) |dep, i| {\n                 depends_on_ids.?[i] = dep.depends_on_id;\n             }\n         }\n \n-        if (dependents.len > 0) {\n+        if (show_up and dependents.len > 0) {\n             blocks_ids = try allocator.alloc([]const u8, dependents.len);\n             for (dependents, 0..) |dep, i| {\n                 blocks_ids.?[i] = dep.issue_id;\n@@ -195,22 +206,30 @@ fn runList(\n             .blocks = blocks_ids,\n         });\n     } else {\n-        if (deps.len > 0) {\n-            try output.println(\"Depends on:\", .{});\n-            for (deps) |dep| {\n-                try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+        if (show_down) {\n+            if (deps.len > 0) {\n+                try output.println(\"Depends on:\", .{});\n+                for (deps) |dep| {\n+                    if (dep.metadata) |meta| {\n+                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n+                    } else {\n+                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n+                    }\n+                }\n+            } else {\n+                try output.println(\"Depends on: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Depends on: (none)\", .{});\n         }\n \n-        if (dependents.len > 0) {\n-            try output.println(\"Blocks:\", .{});\n-            for (dependents) |dep| {\n-                try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+        if (show_up) {\n+            if (dependents.len > 0) {\n+                try output.println(\"Blocks:\", .{});\n+                for (dependents) |dep| {\n+                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n+                }\n+            } else {\n+                try output.println(\"Blocks: (none)\", .{});\n             }\n-        } else {\n-            try output.println(\"Blocks: (none)\", .{});\n         }\n     }\n }\n@@ -231,6 +250,7 @@ fn runTree(\n     allocator: std.mem.Allocator,\n ) !void {\n     const id = tree_args.id;\n+    const format = tree_args.format;\n \n     // Check if issue exists\n     const issue = try ctx.store.get(id);\n@@ -250,6 +270,9 @@ fn runTree(\n             .success = true,\n             .tree = root,\n         });\n+    } else if (format == .mermaid) {\n+        // Mermaid flowchart output\n+        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n     } else {\n         // ASCII tree output\n         try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n@@ -355,6 +378,160 @@ fn printTreeBranch(\n     }\n }\n \n+fn printMermaidTree(\n+    output: *common.Output,\n+    graph: *DependencyGraph,\n+    ctx: *CommandContext,\n+    root_id: []const u8,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    // Start Mermaid flowchart\n+    try output.println(\"```mermaid\", .{});\n+    try output.println(\"flowchart TD\", .{});\n+\n+    // Track visited nodes to avoid duplicates\n+    var visited: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var it = visited.keyIterator();\n+        while (it.next()) |key| allocator.free(key.*);\n+        visited.deinit(allocator);\n+    }\n+\n+    // Track emitted edges to avoid duplicates\n+    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var edge_it = emitted_edges.keyIterator();\n+        while (edge_it.next()) |key| allocator.free(key.*);\n+        emitted_edges.deinit(allocator);\n+    }\n+\n+    // Collect all nodes and edges starting from root\n+    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n+\n+    try output.println(\"```\", .{});\n+}\n+\n+fn collectMermaidNodes(\n+    output: *common.Output,\n+    graph: *DependencyGraph,\n+    ctx: *CommandContext,\n+    id: []const u8,\n+    visited: *std.StringHashMapUnmanaged(void),\n+    emitted_edges: *std.StringHashMapUnmanaged(void),\n+    allocator: std.mem.Allocator,\n+    depth: usize,\n+    max_depth: usize,\n+) !void {\n+    // Skip if already visited\n+    if (visited.contains(id)) return;\n+\n+    // Mark as visited\n+    const id_copy = try allocator.dupe(u8, id);\n+    errdefer allocator.free(id_copy);\n+    try visited.put(allocator, id_copy, {});\n+\n+    // Get issue details for node label\n+    const issue = try ctx.store.get(id);\n+    const safe_id = try sanitizeMermaidId(id, allocator);\n+    defer allocator.free(safe_id);\n+\n+    if (issue) |i| {\n+        var iss = i;\n+        defer iss.deinit(allocator);\n+        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n+        defer allocator.free(safe_title);\n+        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n+    } else {\n+        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n+    }\n+\n+    if (depth >= max_depth) return;\n+\n+    // Get dependencies (what this issue depends on)\n+    const deps = try graph.getDependencies(id);\n+    defer graph.freeDependencies(deps);\n+\n+    for (deps) |dep| {\n+        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n+        defer allocator.free(target_id);\n+\n+        // Create edge key for deduplication\n+        var edge_buf: [256]u8 = undefined;\n+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n+\n+        if (!emitted_edges.contains(edge_key)) {\n+            const edge_copy = try allocator.dupe(u8, edge_key);\n+            try emitted_edges.put(allocator, edge_copy, {});\n+\n+            // Emit edge with dependency type as label\n+            const dep_type_str = dep.dep_type.toString();\n+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n+        }\n+\n+        // Recurse into dependency\n+        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n+    }\n+\n+    // Get dependents (what depends on this issue)\n+    const dependents = try graph.getDependents(id);\n+    defer graph.freeDependencies(dependents);\n+\n+    for (dependents) |dep| {\n+        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n+        defer allocator.free(source_id);\n+\n+        // Create edge key for deduplication\n+        var edge_buf: [256]u8 = undefined;\n+        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n+\n+        if (!emitted_edges.contains(edge_key)) {\n+            const edge_copy = try allocator.dupe(u8, edge_key);\n+            try emitted_edges.put(allocator, edge_copy, {});\n+\n+            const dep_type_str = dep.dep_type.toString();\n+            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n+        }\n+\n+        // Recurse into dependent\n+        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n+    }\n+}\n+\n+fn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n+    // Replace characters that are invalid in Mermaid node IDs\n+    var result = try allocator.alloc(u8, id.len);\n+    for (id, 0..) |c, i| {\n+        result[i] = if (c == '-' or c == '.') '_' else c;\n+    }\n+    return result;\n+}\n+\n+fn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n+    // Escape special characters in Mermaid labels\n+    var count: usize = 0;\n+    for (label) |c| {\n+        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n+    }\n+\n+    var result = try allocator.alloc(u8, count);\n+    var i: usize = 0;\n+    for (label) |c| {\n+        if (c == '\"') {\n+            result[i] = '\\\\';\n+            result[i + 1] = '\"';\n+            i += 2;\n+        } else if (c == '\\\\') {\n+            result[i] = '\\\\';\n+            result[i + 1] = '\\\\';\n+            i += 2;\n+        } else {\n+            result[i] = c;\n+            i += 1;\n+        }\n+    }\n+    return result;\n+}\n+\n fn buildTreeNode(\n     graph: *DependencyGraph,\n     ctx: *CommandContext,\ndiff --git a/src/cli/label.zig b/src/cli/label.zig\nindex 942b031..a123004 100644\n--- a/src/cli/label.zig\n+++ b/src/cli/label.zig\n@@ -24,6 +24,9 @@ pub const LabelResult = struct {\n     labels: ?[]const []const u8 = null,\n     added: ?[]const []const u8 = null,\n     removed: ?[]const []const u8 = null,\n+    old_name: ?[]const u8 = null,\n+    new_name: ?[]const u8 = null,\n+    renamed_count: ?usize = null,\n     message: ?[]const u8 = null,\n };\n \n@@ -37,6 +40,7 @@ pub fn run(\n         .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n         .list => |list| try runList(list.id, global, allocator),\n         .list_all => try runListAll(global, allocator),\n+        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n     }\n }\n \n@@ -307,6 +311,78 @@ fn runListAll(\n     }\n }\n \n+fn runRename(\n+    old_name: []const u8,\n+    new_name: []const u8,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return LabelError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Count how many issues have this label renamed\n+    var renamed_count: usize = 0;\n+\n+    // Iterate through all issues\n+    for (ctx.store.issues.items) |*issue| {\n+        if (issue.status.eql(.tombstone)) continue;\n+\n+        // Check if issue has the old label\n+        var has_old_label = false;\n+        var old_label_idx: usize = 0;\n+        for (issue.labels, 0..) |label, idx| {\n+            if (std.mem.eql(u8, label, old_name)) {\n+                has_old_label = true;\n+                old_label_idx = idx;\n+                break;\n+            }\n+        }\n+\n+        if (has_old_label) {\n+            // Check if it already has the new label (avoid duplicates)\n+            var has_new_label = false;\n+            for (issue.labels) |label| {\n+                if (std.mem.eql(u8, label, new_name)) {\n+                    has_new_label = true;\n+                    break;\n+                }\n+            }\n+\n+            if (has_new_label) {\n+                // Remove the old label (new label already exists)\n+                try ctx.store.removeLabel(issue.id, old_name);\n+            } else {\n+                // Replace old label with new label in place\n+                // First remove old, then add new\n+                try ctx.store.removeLabel(issue.id, old_name);\n+                try ctx.store.addLabel(issue.id, new_name);\n+            }\n+            renamed_count += 1;\n+        }\n+    }\n+\n+    try ctx.saveIfAutoFlush();\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(LabelResult{\n+            .success = true,\n+            .old_name = old_name,\n+            .new_name = new_name,\n+            .renamed_count = renamed_count,\n+        });\n+    } else if (global.quiet) {\n+        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n+    } else {\n+        if (renamed_count > 0) {\n+            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n+        } else {\n+            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n+        }\n+    }\n+}\n+\n // --- Tests ---\n \n test \"LabelError enum exists\" {\ndiff --git a/src/output/mod.zig b/src/output/mod.zig\nindex 49cd59a..799b77d 100644\n--- a/src/output/mod.zig\n+++ b/src/output/mod.zig\n@@ -21,6 +21,7 @@ pub const OutputMode = enum {\n     rich, // Colors and formatting (TTY)\n     json, // Structured JSON output\n     quiet, // Minimal output (IDs only)\n+    robot, // Line-oriented machine-readable output for scripting\n };\n \n /// ANSI color escape codes.\n@@ -58,6 +59,7 @@ pub const Color = struct {\n pub const OutputOptions = struct {\n     json: bool = false,\n     toon: bool = false,\n+    robot: bool = false, // Line-oriented machine-readable output for scripting\n     quiet: bool = false,\n     silent: bool = false, // Suppress ALL output including errors (for tests)\n     no_color: bool = false,\n@@ -88,6 +90,8 @@ pub const Output = struct {\n         var mode: OutputMode = .plain;\n         if (opts.json or opts.toon) {\n             mode = .json;\n+        } else if (opts.robot) {\n+            mode = .robot;\n         } else if (opts.quiet or opts.silent) {\n             mode = .quiet;\n         } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n@@ -166,6 +170,7 @@ pub const Output = struct {\n             .quiet => try self.printIssueQuiet(issue),\n             .rich => try self.printIssueRich(issue),\n             .plain => try self.printIssuePlain(issue),\n+            .robot => try self.printIssueRobot(issue),\n         }\n     }\n \n@@ -176,6 +181,7 @@ pub const Output = struct {\n             .quiet => try self.printIssueListQuiet(issues),\n             .rich => try self.printIssueListRich(issues),\n             .plain => try self.printIssueListPlain(issues),\n+            .robot => try self.printIssueListRobot(issues),\n         }\n     }\n \n@@ -441,6 +447,29 @@ pub const Output = struct {\n         }\n     }\n \n+    // ========================================================================\n+    // Robot Mode Helpers (tab-separated, line-oriented for scripting)\n+    // ========================================================================\n+\n+    /// Print single issue in robot format: tab-separated key fields on one line.\n+    /// Format: ID<TAB>STATUS<TAB>PRIORITY<TAB>TYPE<TAB>TITLE\n+    fn printIssueRobot(self: *Self, issue: Issue) !void {\n+        try self.writeFormatted(\"{s}\\t{s}\\t{s}\\t{s}\\t{s}\\n\", .{\n+            issue.id,\n+            issue.status.toString(),\n+            issue.priority.toString(),\n+            issue.issue_type.toString(),\n+            issue.title,\n+        });\n+    }\n+\n+    /// Print issue list in robot format: one issue per line, tab-separated fields.\n+    fn printIssueListRobot(self: *Self, issues: []const Issue) !void {\n+        for (issues) |issue| {\n+            try self.printIssueRobot(issue);\n+        }\n+    }\n+\n     // ========================================================================\n     // Internal Helpers\n     // ========================================================================\ndiff --git a/src/storage/store.zig b/src/storage/store.zig\nindex c243178..89c2a41 100644\n--- a/src/storage/store.zig\n+++ b/src/storage/store.zig\n@@ -327,6 +327,39 @@ pub const IssueStore = struct {\n         try self.update(id, .{ .status = .tombstone }, now);\n     }\n \n+    /// Hard delete an issue by removing it from the store entirely.\n+    /// Unlike soft delete (tombstone), this permanently removes the issue.\n+    pub fn remove(self: *Self, id: []const u8) !void {\n+        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n+        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n+\n+        // Free the issue data\n+        self.issues.items[idx].deinit(self.allocator);\n+\n+        // Remove from index (free the key)\n+        if (self.id_index.fetchRemove(id)) |kv| {\n+            self.allocator.free(kv.key);\n+        }\n+\n+        // Remove from issues array using swap-remove for O(1)\n+        _ = self.issues.swapRemove(idx);\n+\n+        // Update the index for the swapped element (if any)\n+        if (idx < self.issues.items.len) {\n+            const swapped_id = self.issues.items[idx].id;\n+            if (self.id_index.getPtr(swapped_id)) |idx_ptr| {\n+                idx_ptr.* = idx;\n+            }\n+        }\n+\n+        // Also remove from dirty_ids if present\n+        if (self.dirty_ids.fetchRemove(id)) |kv| {\n+            self.allocator.free(kv.key);\n+        }\n+\n+        self.dirty = true;\n+    }\n+\n     /// Filters for listing issues.\n     pub const ListFilters = struct {\n         status: ?Status = null,","numLines":1192,"startLine":1,"totalLines":1192}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GauCxaDKUJP4KejpKZC5DN","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a complete picture of the changes. Let me run the tests first to see if everything is working correctly, then look at each file for potential simplifications."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":19196,"cache_read_input_tokens":23337,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":19196},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"0700bb48-7631-41f0-a146-70876eadf5b2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GauCxaDKUJP4KejpKZC5DN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016tbqKeMkrb6WLPueBQrAwF","name":"Bash","input":{"command":"zig build test 2>&1 | tail -50","description":"Run tests to verify current state"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":19196,"cache_read_input_tokens":23337,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":19196},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"16e6fea8-db20-43a0-93d4-b69fc6ea87ea"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016tbqKeMkrb6WLPueBQrAwF","type":"tool_result","content":"628/669 id.hash.test.contentHash different for different flags...OK\n629/669 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n630/669 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n631/669 id.hash.test.contentHash ignores id field...OK\n632/669 id.hash.test.contentHash ignores timestamps...OK\n633/669 id.hash.test.contentHash with custom status...OK\n634/669 id.hash.test.contentHash with custom issue_type...OK\n635/669 config.yaml.test.parse simple key-value...OK\n636/669 config.yaml.test.parse with comments...OK\n637/669 config.yaml.test.parse nested structure...OK\n638/669 config.yaml.test.parse quoted values...OK\n639/669 config.yaml.test.parse empty value...OK\n640/669 config.yaml.test.get returns null for missing key...OK\n641/669 config.yaml.test.parse handles Windows line endings...OK\n642/669 config.yaml.test.parse ignores blank lines...OK\n643/669 tests.cli_test.test.bz version shows version info...OK\n644/669 tests.cli_test.test.bz help shows usage...OK\n645/669 tests.cli_test.test.bz --help shows usage...OK\n646/669 tests.cli_test.test.bz init creates workspace...OK\n647/669 tests.cli_test.test.bz init fails when already initialized...OK\n648/669 tests.cli_test.test.bz create returns ID...OK\n649/669 tests.cli_test.test.bz q returns ID...OK\n650/669 tests.cli_test.test.bz list returns issues...OK\n651/669 tests.cli_test.test.bz list --json returns output...OK\n652/669 tests.cli_test.test.bz show displays issue...OK\n653/669 tests.cli_test.test.bz show not-found returns error...OK\n654/669 tests.cli_test.test.bz close marks issue as closed...OK\n655/669 tests.cli_test.test.bz reopen reopens closed issue...OK\n656/669 tests.cli_test.test.bz delete soft deletes issue...OK\n657/669 tests.cli_test.test.bz search finds matching issues...OK\n658/669 tests.cli_test.test.bz dep add creates dependency...OK\n659/669 tests.cli_test.test.bz dep add rejects cycles...OK\n660/669 tests.cli_test.test.bz ready shows unblocked issues...OK\n661/669 tests.cli_test.test.bz blocked shows blocked issues...OK\n662/669 tests.cli_test.test.bz unknown command returns error...OK\n663/669 tests.cli_test.test.bz without workspace shows error...OK\n664/669 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n665/669 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n666/669 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 76 issues created\nOK\n667/669 tests.stress_test.test.sequential writes: single thread baseline...OK\n668/669 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n669/669 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 669 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"005cd18c-717a-4c77-b0bb-6674e878156e","tool_use_result":{"stdout":"628/669 id.hash.test.contentHash different for different flags...OK\n629/669 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n630/669 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n631/669 id.hash.test.contentHash ignores id field...OK\n632/669 id.hash.test.contentHash ignores timestamps...OK\n633/669 id.hash.test.contentHash with custom status...OK\n634/669 id.hash.test.contentHash with custom issue_type...OK\n635/669 config.yaml.test.parse simple key-value...OK\n636/669 config.yaml.test.parse with comments...OK\n637/669 config.yaml.test.parse nested structure...OK\n638/669 config.yaml.test.parse quoted values...OK\n639/669 config.yaml.test.parse empty value...OK\n640/669 config.yaml.test.get returns null for missing key...OK\n641/669 config.yaml.test.parse handles Windows line endings...OK\n642/669 config.yaml.test.parse ignores blank lines...OK\n643/669 tests.cli_test.test.bz version shows version info...OK\n644/669 tests.cli_test.test.bz help shows usage...OK\n645/669 tests.cli_test.test.bz --help shows usage...OK\n646/669 tests.cli_test.test.bz init creates workspace...OK\n647/669 tests.cli_test.test.bz init fails when already initialized...OK\n648/669 tests.cli_test.test.bz create returns ID...OK\n649/669 tests.cli_test.test.bz q returns ID...OK\n650/669 tests.cli_test.test.bz list returns issues...OK\n651/669 tests.cli_test.test.bz list --json returns output...OK\n652/669 tests.cli_test.test.bz show displays issue...OK\n653/669 tests.cli_test.test.bz show not-found returns error...OK\n654/669 tests.cli_test.test.bz close marks issue as closed...OK\n655/669 tests.cli_test.test.bz reopen reopens closed issue...OK\n656/669 tests.cli_test.test.bz delete soft deletes issue...OK\n657/669 tests.cli_test.test.bz search finds matching issues...OK\n658/669 tests.cli_test.test.bz dep add creates dependency...OK\n659/669 tests.cli_test.test.bz dep add rejects cycles...OK\n660/669 tests.cli_test.test.bz ready shows unblocked issues...OK\n661/669 tests.cli_test.test.bz blocked shows blocked issues...OK\n662/669 tests.cli_test.test.bz unknown command returns error...OK\n663/669 tests.cli_test.test.bz without workspace shows error...OK\n664/669 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n665/669 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n666/669 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 76 issues created\nOK\n667/669 tests.stress_test.test.sequential writes: single thread baseline...OK\n668/669 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n669/669 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 669 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0181VG9VKQ1QRUjs4UgSLanV","type":"message","role":"assistant","content":[{"type":"text","text":"All 669 tests pass. Now let me read through the modified files to look for simplification opportunities."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1053,"cache_read_input_tokens":42533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1053},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"9c6e2240-16ca-43c3-8bab-282d9865c242"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0181VG9VKQ1QRUjs4UgSLanV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dbv9XVoWFKvYdrf1rdzk4N","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/delete.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1053,"cache_read_input_tokens":42533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1053},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"6416e584-7c49-4c34-98dc-54a26e127a1e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dbv9XVoWFKvYdrf1rdzk4N","type":"tool_result","content":"     1//! Delete command for beads_zig.\n     2//!\n     3//! `bz delete <id>` - Soft delete an issue (set status to tombstone)\n     4//! `bz delete --from-file <path>` - Delete multiple issues from a file\n     5//! `bz delete <id> --cascade` - Delete issue and all its dependents\n     6//! `bz delete <id> --hard` - Permanently remove from database\n     7//! `bz delete <id> --dry-run` - Preview what would be deleted\n     8//!\n     9//! By default, this is a soft delete - the issue is marked as tombstone but remains\n    10//! in the database for audit purposes. Use `bz list --all` to see tombstoned issues.\n    11\n    12const std = @import(\"std\");\n    13const models = @import(\"../models/mod.zig\");\n    14const storage = @import(\"../storage/mod.zig\");\n    15const common = @import(\"common.zig\");\n    16const args = @import(\"args.zig\");\n    17const test_util = @import(\"../test_util.zig\");\n    18\n    19const Status = models.Status;\n    20const Issue = models.Issue;\n    21const IssueStore = common.IssueStore;\n    22const CommandContext = common.CommandContext;\n    23const DependencyGraph = common.DependencyGraph;\n    24const Wal = storage.Wal;\n    25const Output = @import(\"../output/mod.zig\").Output;\n    26\n    27/// Output a list of IDs, one per line (used for quiet/robot output).\n    28fn outputIdList(output: *Output, ids: []const []const u8) !void {\n    29    for (ids) |id| {\n    30        try output.raw(id);\n    31        try output.raw(\"\\n\");\n    32    }\n    33}\n    34\n    35/// Create a slice of IDs from the ArrayList (for JSON output).\n    36fn createIdSlice(allocator: std.mem.Allocator, ids: std.ArrayListUnmanaged([]const u8)) ![]const []const u8 {\n    37    const id_slice = try allocator.alloc([]const u8, ids.items.len);\n    38    for (ids.items, 0..) |id, i| {\n    39        id_slice[i] = id;\n    40    }\n    41    return id_slice;\n    42}\n    43\n    44/// Truncate the WAL after hard delete to prevent deleted issues from reappearing.\n    45fn truncateWalIfNeeded(hard: bool, deleted_count: usize, beads_dir: []const u8, allocator: std.mem.Allocator) void {\n    46    if (!hard or deleted_count == 0) return;\n    47\n    48    var wal_obj = Wal.init(beads_dir, allocator) catch return;\n    49    defer wal_obj.deinit();\n    50    wal_obj.truncate() catch {};\n    51}\n    52\n    53pub const DeleteError = error{\n    54    WorkspaceNotInitialized,\n    55    IssueNotFound,\n    56    AlreadyDeleted,\n    57    StorageError,\n    58    OutOfMemory,\n    59    FileReadError,\n    60    InvalidInput,\n    61};\n    62\n    63pub const DeleteResult = struct {\n    64    success: bool,\n    65    ids: ?[]const []const u8 = null,\n    66    deleted_count: ?usize = null,\n    67    message: ?[]const u8 = null,\n    68    dry_run: bool = false,\n    69};\n    70\n    71pub fn run(\n    72    delete_args: args.DeleteArgs,\n    73    global: args.GlobalOptions,\n    74    allocator: std.mem.Allocator,\n    75) !void {\n    76    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    77        return DeleteError.WorkspaceNotInitialized;\n    78    };\n    79    defer ctx.deinit();\n    80\n    81    const structured_output = global.isStructuredOutput();\n    82\n    83    // Collect all IDs to delete\n    84    var ids_to_delete: std.ArrayListUnmanaged([]const u8) = .{};\n    85    defer ids_to_delete.deinit(allocator);\n    86\n    87    if (delete_args.from_file) |file_path| {\n    88        // Read IDs from file\n    89        const file = std.fs.cwd().openFile(file_path, .{}) catch {\n    90            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot open file\");\n    91            return DeleteError.FileReadError;\n    92        };\n    93        defer file.close();\n    94\n    95        const content = file.readToEndAlloc(allocator, 1024 * 1024) catch {\n    96            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot read file\");\n    97            return DeleteError.FileReadError;\n    98        };\n    99        defer allocator.free(content);\n   100\n   101        var lines = std.mem.splitScalar(u8, content, '\\n');\n   102        while (lines.next()) |line| {\n   103            const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n   104            if (trimmed.len == 0) continue;\n   105            if (trimmed[0] == '#') continue; // Skip comments\n   106            const id_copy = try allocator.dupe(u8, trimmed);\n   107            try ids_to_delete.append(allocator, id_copy);\n   108        }\n   109\n   110        if (ids_to_delete.items.len == 0) {\n   111            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no valid IDs in file\");\n   112            return DeleteError.InvalidInput;\n   113        }\n   114    } else if (delete_args.id) |id| {\n   115        const id_copy = try allocator.dupe(u8, id);\n   116        try ids_to_delete.append(allocator, id_copy);\n   117    } else {\n   118        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no issue ID specified\");\n   119        return DeleteError.InvalidInput;\n   120    }\n   121    defer {\n   122        for (ids_to_delete.items) |id| {\n   123            allocator.free(id);\n   124        }\n   125    }\n   126\n   127    // If cascade mode, expand to include all dependents\n   128    if (delete_args.cascade) {\n   129        var graph = ctx.createGraph();\n   130        var expanded_ids: std.StringHashMapUnmanaged(void) = .{};\n   131        defer {\n   132            var key_it = expanded_ids.keyIterator();\n   133            while (key_it.next()) |key| {\n   134                allocator.free(key.*);\n   135            }\n   136            expanded_ids.deinit(allocator);\n   137        }\n   138\n   139        // Add initial IDs\n   140        for (ids_to_delete.items) |id| {\n   141            if (!expanded_ids.contains(id)) {\n   142                const id_copy = try allocator.dupe(u8, id);\n   143                try expanded_ids.put(allocator, id_copy, {});\n   144            }\n   145        }\n   146\n   147        // Recursively add all dependents using BFS\n   148        var work_queue: std.ArrayListUnmanaged([]const u8) = .{};\n   149        defer work_queue.deinit(allocator);\n   150\n   151        for (ids_to_delete.items) |id| {\n   152            try work_queue.append(allocator, id);\n   153        }\n   154\n   155        while (work_queue.items.len > 0) {\n   156            const current_id = work_queue.orderedRemove(0);\n   157            const dependents = graph.getDependents(current_id) catch continue;\n   158            defer graph.freeDependencies(dependents);\n   159\n   160            for (dependents) |dep| {\n   161                if (!expanded_ids.contains(dep.issue_id)) {\n   162                    const dep_id_copy = try allocator.dupe(u8, dep.issue_id);\n   163                    try expanded_ids.put(allocator, dep_id_copy, {});\n   164                    try work_queue.append(allocator, dep_id_copy);\n   165                }\n   166            }\n   167        }\n   168\n   169        // Replace ids_to_delete with expanded set\n   170        for (ids_to_delete.items) |id| {\n   171            allocator.free(id);\n   172        }\n   173        ids_to_delete.clearRetainingCapacity();\n   174\n   175        var id_it = expanded_ids.keyIterator();\n   176        while (id_it.next()) |key| {\n   177            const id_copy = try allocator.dupe(u8, key.*);\n   178            try ids_to_delete.append(allocator, id_copy);\n   179        }\n   180    }\n   181\n   182    // Dry run mode - just report what would be deleted\n   183    if (delete_args.dry_run) {\n   184        if (structured_output) {\n   185            const id_slice = try createIdSlice(allocator, ids_to_delete);\n   186            defer allocator.free(id_slice);\n   187            try ctx.output.printJson(DeleteResult{\n   188                .success = true,\n   189                .ids = id_slice,\n   190                .deleted_count = ids_to_delete.items.len,\n   191                .dry_run = true,\n   192                .message = \"dry run - no changes made\",\n   193            });\n   194        } else if (global.robot) {\n   195            try ctx.output.raw(\"DRY_RUN\\t\");\n   196            try ctx.output.print(\"{d}\\n\", .{ids_to_delete.items.len});\n   197            try outputIdList(&ctx.output, ids_to_delete.items);\n   198        } else if (global.quiet) {\n   199            try outputIdList(&ctx.output, ids_to_delete.items);\n   200        } else {\n   201            try ctx.output.print(\"Would delete {d} issue(s):\\n\", .{ids_to_delete.items.len});\n   202            for (ids_to_delete.items) |id| {\n   203                try ctx.output.print(\"  {s}\\n\", .{id});\n   204            }\n   205        }\n   206        return;\n   207    }\n   208\n   209    // Perform the actual deletion\n   210    const now = std.time.timestamp();\n   211    var deleted_count: usize = 0;\n   212    var not_found_count: usize = 0;\n   213\n   214    for (ids_to_delete.items) |id| {\n   215        const issue_ref = ctx.store.getRef(id) orelse {\n   216            not_found_count += 1;\n   217            continue;\n   218        };\n   219\n   220        if (issue_ref.status.eql(.tombstone)) {\n   221            continue; // Already deleted\n   222        }\n   223\n   224        if (delete_args.hard) {\n   225            // Hard delete - remove from store entirely\n   226            ctx.store.remove(id) catch {\n   227                continue;\n   228            };\n   229        } else {\n   230            // Soft delete - mark as tombstone\n   231            const updates = IssueStore.IssueUpdate{\n   232                .status = .tombstone,\n   233                .closed_at = now,\n   234                .close_reason = \"deleted\",\n   235            };\n   236            ctx.store.update(id, updates, now) catch {\n   237                continue;\n   238            };\n   239        }\n   240        deleted_count += 1;\n   241    }\n   242\n   243    try ctx.saveIfAutoFlush();\n   244\n   245    // For hard delete, truncate the WAL to ensure deleted issues don't\n   246    // reappear when replaying WAL entries on next load.\n   247    truncateWalIfNeeded(delete_args.hard, deleted_count, ctx.beads_dir, allocator);\n   248\n   249    // Output result\n   250    if (structured_output) {\n   251        const id_slice = try createIdSlice(allocator, ids_to_delete);\n   252        defer allocator.free(id_slice);\n   253        try ctx.output.printJson(DeleteResult{\n   254            .success = deleted_count > 0,\n   255            .ids = id_slice,\n   256            .deleted_count = deleted_count,\n   257        });\n   258    } else if (global.robot) {\n   259        try ctx.output.raw(\"OK\\t\");\n   260        try ctx.output.print(\"{d}\\n\", .{deleted_count});\n   261        try outputIdList(&ctx.output, ids_to_delete.items);\n   262    } else if (global.quiet) {\n   263        try outputIdList(&ctx.output, ids_to_delete.items);\n   264    } else {\n   265        if (deleted_count == 1 and ids_to_delete.items.len == 1) {\n   266            if (delete_args.hard) {\n   267                try ctx.output.success(\"Permanently deleted issue {s}\", .{ids_to_delete.items[0]});\n   268            } else {\n   269                try ctx.output.success(\"Deleted issue {s}\", .{ids_to_delete.items[0]});\n   270            }\n   271        } else {\n   272            if (delete_args.hard) {\n   273                try ctx.output.success(\"Permanently deleted {d} issue(s)\", .{deleted_count});\n   274            } else {\n   275                try ctx.output.success(\"Deleted {d} issue(s)\", .{deleted_count});\n   276            }\n   277        }\n   278\n   279        if (not_found_count > 0) {\n   280            try ctx.output.warn(\"{d} issue(s) not found\", .{not_found_count});\n   281        }\n   282    }\n   283}\n   284\n   285// --- Tests ---\n   286\n   287test \"DeleteError enum exists\" {\n   288    const err: DeleteError = DeleteError.IssueNotFound;\n   289    try std.testing.expect(err == DeleteError.IssueNotFound);\n   290}\n   291\n   292test \"DeleteResult struct works\" {\n   293    const ids = [_][]const u8{\"bd-abc123\"};\n   294    const result = DeleteResult{\n   295        .success = true,\n   296        .ids = &ids,\n   297        .deleted_count = 1,\n   298    };\n   299    try std.testing.expect(result.success);\n   300    try std.testing.expectEqual(@as(usize, 1), result.ids.?.len);\n   301    try std.testing.expectEqualStrings(\"bd-abc123\", result.ids.?[0]);\n   302}\n   303\n   304test \"run detects uninitialized workspace\" {\n   305    const allocator = std.testing.allocator;\n   306\n   307    const delete_args = args.DeleteArgs{ .id = \"bd-test\" };\n   308    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   309\n   310    const result = run(delete_args, global, allocator);\n   311    try std.testing.expectError(DeleteError.WorkspaceNotInitialized, result);\n   312}\n   313\n   314test \"run returns error for missing issue\" {\n   315    const allocator = std.testing.allocator;\n   316\n   317    const tmp_dir_path = try test_util.createTestDir(allocator, \"delete_missing\");\n   318    defer allocator.free(tmp_dir_path);\n   319    defer test_util.cleanupTestDir(tmp_dir_path);\n   320\n   321    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   322    defer allocator.free(data_path);\n   323\n   324    try std.fs.cwd().makeDir(data_path);\n   325\n   326    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   327    defer allocator.free(issues_path);\n   328\n   329    const f = try std.fs.cwd().createFile(issues_path, .{});\n   330    f.close();\n   331\n   332    const delete_args = args.DeleteArgs{ .id = \"bd-nonexistent\" };\n   333    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   334\n   335    // This should complete but report 0 deletions (issue not found is handled gracefully)\n   336    try run(delete_args, global, allocator);\n   337}\n   338\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"02865f53-5c2f-49f4-8212-97e40665a483","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/delete.zig","content":"//! Delete command for beads_zig.\n//!\n//! `bz delete <id>` - Soft delete an issue (set status to tombstone)\n//! `bz delete --from-file <path>` - Delete multiple issues from a file\n//! `bz delete <id> --cascade` - Delete issue and all its dependents\n//! `bz delete <id> --hard` - Permanently remove from database\n//! `bz delete <id> --dry-run` - Preview what would be deleted\n//!\n//! By default, this is a soft delete - the issue is marked as tombstone but remains\n//! in the database for audit purposes. Use `bz list --all` to see tombstoned issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Status = models.Status;\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst Wal = storage.Wal;\nconst Output = @import(\"../output/mod.zig\").Output;\n\n/// Output a list of IDs, one per line (used for quiet/robot output).\nfn outputIdList(output: *Output, ids: []const []const u8) !void {\n    for (ids) |id| {\n        try output.raw(id);\n        try output.raw(\"\\n\");\n    }\n}\n\n/// Create a slice of IDs from the ArrayList (for JSON output).\nfn createIdSlice(allocator: std.mem.Allocator, ids: std.ArrayListUnmanaged([]const u8)) ![]const []const u8 {\n    const id_slice = try allocator.alloc([]const u8, ids.items.len);\n    for (ids.items, 0..) |id, i| {\n        id_slice[i] = id;\n    }\n    return id_slice;\n}\n\n/// Truncate the WAL after hard delete to prevent deleted issues from reappearing.\nfn truncateWalIfNeeded(hard: bool, deleted_count: usize, beads_dir: []const u8, allocator: std.mem.Allocator) void {\n    if (!hard or deleted_count == 0) return;\n\n    var wal_obj = Wal.init(beads_dir, allocator) catch return;\n    defer wal_obj.deinit();\n    wal_obj.truncate() catch {};\n}\n\npub const DeleteError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    AlreadyDeleted,\n    StorageError,\n    OutOfMemory,\n    FileReadError,\n    InvalidInput,\n};\n\npub const DeleteResult = struct {\n    success: bool,\n    ids: ?[]const []const u8 = null,\n    deleted_count: ?usize = null,\n    message: ?[]const u8 = null,\n    dry_run: bool = false,\n};\n\npub fn run(\n    delete_args: args.DeleteArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DeleteError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const structured_output = global.isStructuredOutput();\n\n    // Collect all IDs to delete\n    var ids_to_delete: std.ArrayListUnmanaged([]const u8) = .{};\n    defer ids_to_delete.deinit(allocator);\n\n    if (delete_args.from_file) |file_path| {\n        // Read IDs from file\n        const file = std.fs.cwd().openFile(file_path, .{}) catch {\n            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot open file\");\n            return DeleteError.FileReadError;\n        };\n        defer file.close();\n\n        const content = file.readToEndAlloc(allocator, 1024 * 1024) catch {\n            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"cannot read file\");\n            return DeleteError.FileReadError;\n        };\n        defer allocator.free(content);\n\n        var lines = std.mem.splitScalar(u8, content, '\\n');\n        while (lines.next()) |line| {\n            const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n            if (trimmed.len == 0) continue;\n            if (trimmed[0] == '#') continue; // Skip comments\n            const id_copy = try allocator.dupe(u8, trimmed);\n            try ids_to_delete.append(allocator, id_copy);\n        }\n\n        if (ids_to_delete.items.len == 0) {\n            try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no valid IDs in file\");\n            return DeleteError.InvalidInput;\n        }\n    } else if (delete_args.id) |id| {\n        const id_copy = try allocator.dupe(u8, id);\n        try ids_to_delete.append(allocator, id_copy);\n    } else {\n        try common.outputErrorTyped(DeleteResult, &ctx.output, structured_output, \"no issue ID specified\");\n        return DeleteError.InvalidInput;\n    }\n    defer {\n        for (ids_to_delete.items) |id| {\n            allocator.free(id);\n        }\n    }\n\n    // If cascade mode, expand to include all dependents\n    if (delete_args.cascade) {\n        var graph = ctx.createGraph();\n        var expanded_ids: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var key_it = expanded_ids.keyIterator();\n            while (key_it.next()) |key| {\n                allocator.free(key.*);\n            }\n            expanded_ids.deinit(allocator);\n        }\n\n        // Add initial IDs\n        for (ids_to_delete.items) |id| {\n            if (!expanded_ids.contains(id)) {\n                const id_copy = try allocator.dupe(u8, id);\n                try expanded_ids.put(allocator, id_copy, {});\n            }\n        }\n\n        // Recursively add all dependents using BFS\n        var work_queue: std.ArrayListUnmanaged([]const u8) = .{};\n        defer work_queue.deinit(allocator);\n\n        for (ids_to_delete.items) |id| {\n            try work_queue.append(allocator, id);\n        }\n\n        while (work_queue.items.len > 0) {\n            const current_id = work_queue.orderedRemove(0);\n            const dependents = graph.getDependents(current_id) catch continue;\n            defer graph.freeDependencies(dependents);\n\n            for (dependents) |dep| {\n                if (!expanded_ids.contains(dep.issue_id)) {\n                    const dep_id_copy = try allocator.dupe(u8, dep.issue_id);\n                    try expanded_ids.put(allocator, dep_id_copy, {});\n                    try work_queue.append(allocator, dep_id_copy);\n                }\n            }\n        }\n\n        // Replace ids_to_delete with expanded set\n        for (ids_to_delete.items) |id| {\n            allocator.free(id);\n        }\n        ids_to_delete.clearRetainingCapacity();\n\n        var id_it = expanded_ids.keyIterator();\n        while (id_it.next()) |key| {\n            const id_copy = try allocator.dupe(u8, key.*);\n            try ids_to_delete.append(allocator, id_copy);\n        }\n    }\n\n    // Dry run mode - just report what would be deleted\n    if (delete_args.dry_run) {\n        if (structured_output) {\n            const id_slice = try createIdSlice(allocator, ids_to_delete);\n            defer allocator.free(id_slice);\n            try ctx.output.printJson(DeleteResult{\n                .success = true,\n                .ids = id_slice,\n                .deleted_count = ids_to_delete.items.len,\n                .dry_run = true,\n                .message = \"dry run - no changes made\",\n            });\n        } else if (global.robot) {\n            try ctx.output.raw(\"DRY_RUN\\t\");\n            try ctx.output.print(\"{d}\\n\", .{ids_to_delete.items.len});\n            try outputIdList(&ctx.output, ids_to_delete.items);\n        } else if (global.quiet) {\n            try outputIdList(&ctx.output, ids_to_delete.items);\n        } else {\n            try ctx.output.print(\"Would delete {d} issue(s):\\n\", .{ids_to_delete.items.len});\n            for (ids_to_delete.items) |id| {\n                try ctx.output.print(\"  {s}\\n\", .{id});\n            }\n        }\n        return;\n    }\n\n    // Perform the actual deletion\n    const now = std.time.timestamp();\n    var deleted_count: usize = 0;\n    var not_found_count: usize = 0;\n\n    for (ids_to_delete.items) |id| {\n        const issue_ref = ctx.store.getRef(id) orelse {\n            not_found_count += 1;\n            continue;\n        };\n\n        if (issue_ref.status.eql(.tombstone)) {\n            continue; // Already deleted\n        }\n\n        if (delete_args.hard) {\n            // Hard delete - remove from store entirely\n            ctx.store.remove(id) catch {\n                continue;\n            };\n        } else {\n            // Soft delete - mark as tombstone\n            const updates = IssueStore.IssueUpdate{\n                .status = .tombstone,\n                .closed_at = now,\n                .close_reason = \"deleted\",\n            };\n            ctx.store.update(id, updates, now) catch {\n                continue;\n            };\n        }\n        deleted_count += 1;\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    // For hard delete, truncate the WAL to ensure deleted issues don't\n    // reappear when replaying WAL entries on next load.\n    truncateWalIfNeeded(delete_args.hard, deleted_count, ctx.beads_dir, allocator);\n\n    // Output result\n    if (structured_output) {\n        const id_slice = try createIdSlice(allocator, ids_to_delete);\n        defer allocator.free(id_slice);\n        try ctx.output.printJson(DeleteResult{\n            .success = deleted_count > 0,\n            .ids = id_slice,\n            .deleted_count = deleted_count,\n        });\n    } else if (global.robot) {\n        try ctx.output.raw(\"OK\\t\");\n        try ctx.output.print(\"{d}\\n\", .{deleted_count});\n        try outputIdList(&ctx.output, ids_to_delete.items);\n    } else if (global.quiet) {\n        try outputIdList(&ctx.output, ids_to_delete.items);\n    } else {\n        if (deleted_count == 1 and ids_to_delete.items.len == 1) {\n            if (delete_args.hard) {\n                try ctx.output.success(\"Permanently deleted issue {s}\", .{ids_to_delete.items[0]});\n            } else {\n                try ctx.output.success(\"Deleted issue {s}\", .{ids_to_delete.items[0]});\n            }\n        } else {\n            if (delete_args.hard) {\n                try ctx.output.success(\"Permanently deleted {d} issue(s)\", .{deleted_count});\n            } else {\n                try ctx.output.success(\"Deleted {d} issue(s)\", .{deleted_count});\n            }\n        }\n\n        if (not_found_count > 0) {\n            try ctx.output.warn(\"{d} issue(s) not found\", .{not_found_count});\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"DeleteError enum exists\" {\n    const err: DeleteError = DeleteError.IssueNotFound;\n    try std.testing.expect(err == DeleteError.IssueNotFound);\n}\n\ntest \"DeleteResult struct works\" {\n    const ids = [_][]const u8{\"bd-abc123\"};\n    const result = DeleteResult{\n        .success = true,\n        .ids = &ids,\n        .deleted_count = 1,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 1), result.ids.?.len);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.ids.?[0]);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const delete_args = args.DeleteArgs{ .id = \"bd-test\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(delete_args, global, allocator);\n    try std.testing.expectError(DeleteError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns error for missing issue\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"delete_missing\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const delete_args = args.DeleteArgs{ .id = \"bd-nonexistent\" };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    // This should complete but report 0 deletions (issue not found is handled gracefully)\n    try run(delete_args, global, allocator);\n}\n","numLines":338,"startLine":1,"totalLines":338}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0181VG9VKQ1QRUjs4UgSLanV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FwCQ6GccSD8MMDDVPFLi1i","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/dep.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1053,"cache_read_input_tokens":42533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1053},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"99d8b4be-b646-490b-9f7c-72269e980b40"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FwCQ6GccSD8MMDDVPFLi1i","type":"tool_result","content":"     1//! Dependency management commands for beads_zig.\n     2//!\n     3//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n     4//! `bz dep remove <child> <parent>` - Remove dependency\n     5//! `bz dep list <id>` - List dependencies for an issue\n     6//!\n     7//! Manages relationships between issues.\n     8\n     9const std = @import(\"std\");\n    10const models = @import(\"../models/mod.zig\");\n    11const storage = @import(\"../storage/mod.zig\");\n    12const common = @import(\"common.zig\");\n    13const args = @import(\"args.zig\");\n    14const test_util = @import(\"../test_util.zig\");\n    15\n    16const Dependency = models.Dependency;\n    17const DependencyType = models.DependencyType;\n    18const CommandContext = common.CommandContext;\n    19const DependencyGraph = common.DependencyGraph;\n    20const DependencyGraphError = storage.DependencyGraphError;\n    21\n    22pub const DepError = error{\n    23    WorkspaceNotInitialized,\n    24    IssueNotFound,\n    25    CycleDetected,\n    26    SelfDependency,\n    27    StorageError,\n    28    OutOfMemory,\n    29};\n    30\n    31pub const DepResult = struct {\n    32    success: bool,\n    33    action: ?[]const u8 = null,\n    34    child: ?[]const u8 = null,\n    35    parent: ?[]const u8 = null,\n    36    depends_on: ?[]const []const u8 = null,\n    37    blocks: ?[]const []const u8 = null,\n    38    message: ?[]const u8 = null,\n    39};\n    40\n    41pub fn run(\n    42    dep_args: args.DepArgs,\n    43    global: args.GlobalOptions,\n    44    allocator: std.mem.Allocator,\n    45) !void {\n    46    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    47        return DepError.WorkspaceNotInitialized;\n    48    };\n    49    defer ctx.deinit();\n    50\n    51    var graph = ctx.createGraph();\n    52\n    53    switch (dep_args.subcommand) {\n    54        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n    55        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n    56        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n    57        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n    58        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    59    }\n    60}\n    61\n    62fn runAdd(\n    63    graph: *DependencyGraph,\n    64    ctx: *CommandContext,\n    65    add_args: anytype,\n    66    global: args.GlobalOptions,\n    67    allocator: std.mem.Allocator,\n    68) !void {\n    69    const structured_output = global.isStructuredOutput();\n    70    if (!try ctx.store.exists(add_args.child)) {\n    71        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n    72        return DepError.IssueNotFound;\n    73    }\n    74\n    75    if (!try ctx.store.exists(add_args.parent)) {\n    76        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n    77        return DepError.IssueNotFound;\n    78    }\n    79\n    80    const now = std.time.timestamp();\n    81    const dep = Dependency{\n    82        .issue_id = add_args.child,\n    83        .depends_on_id = add_args.parent,\n    84        .dep_type = DependencyType.fromString(add_args.dep_type),\n    85        .created_at = now,\n    86        .created_by = global.actor,\n    87        .metadata = add_args.metadata,\n    88        .thread_id = null,\n    89    };\n    90\n    91    graph.addDependency(dep) catch |err| {\n    92        const msg = switch (err) {\n    93            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n    94            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n    95            DependencyGraphError.IssueNotFound => \"issue not found\",\n    96            else => \"failed to add dependency\",\n    97        };\n    98        try outputError(&ctx.output, structured_output, msg);\n    99\n   100        return switch (err) {\n   101            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n   102            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n   103            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n   104            else => DepError.StorageError,\n   105        };\n   106    };\n   107\n   108    try ctx.saveIfAutoFlush();\n   109\n   110    if (structured_output) {\n   111        try ctx.output.printJson(DepResult{\n   112            .success = true,\n   113            .action = \"added\",\n   114            .child = add_args.child,\n   115            .parent = add_args.parent,\n   116        });\n   117    } else if (!global.quiet) {\n   118        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n   119    }\n   120}\n   121\n   122fn runRemove(\n   123    graph: *DependencyGraph,\n   124    ctx: *CommandContext,\n   125    remove_args: anytype,\n   126    global: args.GlobalOptions,\n   127) !void {\n   128    const structured_output = global.isStructuredOutput();\n   129    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n   130        const msg = if (err == DependencyGraphError.IssueNotFound)\n   131            \"issue not found\"\n   132        else\n   133            \"failed to remove dependency\";\n   134        try outputError(&ctx.output, structured_output, msg);\n   135\n   136        return if (err == DependencyGraphError.IssueNotFound)\n   137            DepError.IssueNotFound\n   138        else\n   139            DepError.StorageError;\n   140    };\n   141\n   142    try ctx.saveIfAutoFlush();\n   143\n   144    if (structured_output) {\n   145        try ctx.output.printJson(DepResult{\n   146            .success = true,\n   147            .action = \"removed\",\n   148            .child = remove_args.child,\n   149            .parent = remove_args.parent,\n   150        });\n   151    } else if (!global.quiet) {\n   152        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n   153    }\n   154}\n   155\n   156fn runList(\n   157    graph: *DependencyGraph,\n   158    output: *common.Output,\n   159    list_args: anytype,\n   160    global: args.GlobalOptions,\n   161    allocator: std.mem.Allocator,\n   162) !void {\n   163    const direction = list_args.direction;\n   164    const show_down = direction == .down or direction == .both;\n   165    const show_up = direction == .up or direction == .both;\n   166\n   167    var deps: []Dependency = &.{};\n   168    var dependents: []Dependency = &.{};\n   169\n   170    if (show_down) {\n   171        deps = try graph.getDependencies(list_args.id);\n   172    }\n   173    defer if (show_down) graph.freeDependencies(deps);\n   174\n   175    if (show_up) {\n   176        dependents = try graph.getDependents(list_args.id);\n   177    }\n   178    defer if (show_up) graph.freeDependencies(dependents);\n   179\n   180    if (global.isStructuredOutput()) {\n   181        var depends_on_ids: ?[][]const u8 = null;\n   182        var blocks_ids: ?[][]const u8 = null;\n   183\n   184        if (show_down and deps.len > 0) {\n   185            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n   186            for (deps, 0..) |dep, i| {\n   187                depends_on_ids.?[i] = dep.depends_on_id;\n   188            }\n   189        }\n   190\n   191        if (show_up and dependents.len > 0) {\n   192            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n   193            for (dependents, 0..) |dep, i| {\n   194                blocks_ids.?[i] = dep.issue_id;\n   195            }\n   196        }\n   197\n   198        defer {\n   199            if (depends_on_ids) |ids| allocator.free(ids);\n   200            if (blocks_ids) |ids| allocator.free(ids);\n   201        }\n   202\n   203        try output.printJson(DepResult{\n   204            .success = true,\n   205            .depends_on = depends_on_ids,\n   206            .blocks = blocks_ids,\n   207        });\n   208    } else {\n   209        if (show_down) {\n   210            if (deps.len > 0) {\n   211                try output.println(\"Depends on:\", .{});\n   212                for (deps) |dep| {\n   213                    if (dep.metadata) |meta| {\n   214                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n   215                    } else {\n   216                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n   217                    }\n   218                }\n   219            } else {\n   220                try output.println(\"Depends on: (none)\", .{});\n   221            }\n   222        }\n   223\n   224        if (show_up) {\n   225            if (dependents.len > 0) {\n   226                try output.println(\"Blocks:\", .{});\n   227                for (dependents) |dep| {\n   228                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n   229                }\n   230            } else {\n   231                try output.println(\"Blocks: (none)\", .{});\n   232            }\n   233        }\n   234    }\n   235}\n   236\n   237/// Tree node for JSON output.\n   238const TreeNode = struct {\n   239    id: []const u8,\n   240    title: []const u8,\n   241    status: []const u8,\n   242    children: ?[]const TreeNode = null,\n   243};\n   244\n   245fn runTree(\n   246    graph: *DependencyGraph,\n   247    ctx: *CommandContext,\n   248    tree_args: anytype,\n   249    global: args.GlobalOptions,\n   250    allocator: std.mem.Allocator,\n   251) !void {\n   252    const id = tree_args.id;\n   253    const format = tree_args.format;\n   254\n   255    // Check if issue exists\n   256    const issue = try ctx.store.get(id);\n   257    if (issue == null) {\n   258        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n   259        return DepError.IssueNotFound;\n   260    }\n   261    var i = issue.?;\n   262    defer i.deinit(allocator);\n   263\n   264    if (global.isStructuredOutput()) {\n   265        // Build tree structure for JSON output\n   266        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n   267        defer freeTreeNode(root, allocator);\n   268\n   269        try ctx.output.printJson(.{\n   270            .success = true,\n   271            .tree = root,\n   272        });\n   273    } else if (format == .mermaid) {\n   274        // Mermaid flowchart output\n   275        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n   276    } else {\n   277        // ASCII tree output\n   278        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n   279\n   280        // Show what this issue depends on (upstream dependencies)\n   281        const deps = try graph.getDependencies(id);\n   282        defer graph.freeDependencies(deps);\n   283\n   284        if (deps.len > 0) {\n   285            try ctx.output.println(\"Depends on:\", .{});\n   286            var visited: std.StringHashMapUnmanaged(void) = .{};\n   287            defer {\n   288                var it = visited.keyIterator();\n   289                while (it.next()) |key| allocator.free(key.*);\n   290                visited.deinit(allocator);\n   291            }\n   292\n   293            for (deps, 0..) |dep, idx| {\n   294                const is_last = (idx == deps.len - 1);\n   295                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n   296            }\n   297        }\n   298\n   299        // Show what depends on this issue (downstream dependents)\n   300        const dependents = try graph.getDependents(id);\n   301        defer graph.freeDependencies(dependents);\n   302\n   303        if (dependents.len > 0) {\n   304            try ctx.output.print(\"\\n\", .{});\n   305            try ctx.output.println(\"Blocked by this:\", .{});\n   306            for (dependents, 0..) |dep, idx| {\n   307                const is_last = (idx == dependents.len - 1);\n   308                const prefix = if (is_last) \"`-- \" else \"|-- \";\n   309                const dep_issue = try ctx.store.get(dep.issue_id);\n   310                if (dep_issue) |di| {\n   311                    var d = di;\n   312                    defer d.deinit(allocator);\n   313                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n   314                } else {\n   315                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n   316                }\n   317            }\n   318        }\n   319    }\n   320}\n   321\n   322fn printTreeBranch(\n   323    output: *common.Output,\n   324    graph: *DependencyGraph,\n   325    ctx: *CommandContext,\n   326    id: []const u8,\n   327    prefix: []const u8,\n   328    is_last: bool,\n   329    visited: *std.StringHashMapUnmanaged(void),\n   330    allocator: std.mem.Allocator,\n   331    depth: usize,\n   332    max_depth: usize,\n   333) !void {\n   334    // Check for cycles\n   335    if (visited.contains(id)) {\n   336        const branch = if (is_last) \"`-- \" else \"|-- \";\n   337        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n   338        return;\n   339    }\n   340\n   341    // Depth limit\n   342    if (depth >= max_depth) {\n   343        const branch = if (is_last) \"`-- \" else \"|-- \";\n   344        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n   345        return;\n   346    }\n   347\n   348    // Mark as visited\n   349    const id_copy = try allocator.dupe(u8, id);\n   350    errdefer allocator.free(id_copy);\n   351    try visited.put(allocator, id_copy, {});\n   352\n   353    // Get issue details\n   354    const issue = try ctx.store.get(id);\n   355    const branch = if (is_last) \"`-- \" else \"|-- \";\n   356\n   357    if (issue) |i| {\n   358        var iss = i;\n   359        defer iss.deinit(allocator);\n   360        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n   361    } else {\n   362        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n   363        return;\n   364    }\n   365\n   366    // Get dependencies of this issue\n   367    const deps = try graph.getDependencies(id);\n   368    defer graph.freeDependencies(deps);\n   369\n   370    // Build new prefix for children\n   371    var new_prefix_buf: [256]u8 = undefined;\n   372    const extension = if (is_last) \"    \" else \"|   \";\n   373    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n   374\n   375    for (deps, 0..) |dep, idx| {\n   376        const child_is_last = (idx == deps.len - 1);\n   377        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n   378    }\n   379}\n   380\n   381fn printMermaidTree(\n   382    output: *common.Output,\n   383    graph: *DependencyGraph,\n   384    ctx: *CommandContext,\n   385    root_id: []const u8,\n   386    allocator: std.mem.Allocator,\n   387) !void {\n   388    // Start Mermaid flowchart\n   389    try output.println(\"```mermaid\", .{});\n   390    try output.println(\"flowchart TD\", .{});\n   391\n   392    // Track visited nodes to avoid duplicates\n   393    var visited: std.StringHashMapUnmanaged(void) = .{};\n   394    defer {\n   395        var it = visited.keyIterator();\n   396        while (it.next()) |key| allocator.free(key.*);\n   397        visited.deinit(allocator);\n   398    }\n   399\n   400    // Track emitted edges to avoid duplicates\n   401    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n   402    defer {\n   403        var edge_it = emitted_edges.keyIterator();\n   404        while (edge_it.next()) |key| allocator.free(key.*);\n   405        emitted_edges.deinit(allocator);\n   406    }\n   407\n   408    // Collect all nodes and edges starting from root\n   409    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n   410\n   411    try output.println(\"```\", .{});\n   412}\n   413\n   414fn collectMermaidNodes(\n   415    output: *common.Output,\n   416    graph: *DependencyGraph,\n   417    ctx: *CommandContext,\n   418    id: []const u8,\n   419    visited: *std.StringHashMapUnmanaged(void),\n   420    emitted_edges: *std.StringHashMapUnmanaged(void),\n   421    allocator: std.mem.Allocator,\n   422    depth: usize,\n   423    max_depth: usize,\n   424) !void {\n   425    // Skip if already visited\n   426    if (visited.contains(id)) return;\n   427\n   428    // Mark as visited\n   429    const id_copy = try allocator.dupe(u8, id);\n   430    errdefer allocator.free(id_copy);\n   431    try visited.put(allocator, id_copy, {});\n   432\n   433    // Get issue details for node label\n   434    const issue = try ctx.store.get(id);\n   435    const safe_id = try sanitizeMermaidId(id, allocator);\n   436    defer allocator.free(safe_id);\n   437\n   438    if (issue) |i| {\n   439        var iss = i;\n   440        defer iss.deinit(allocator);\n   441        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n   442        defer allocator.free(safe_title);\n   443        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n   444    } else {\n   445        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n   446    }\n   447\n   448    if (depth >= max_depth) return;\n   449\n   450    // Get dependencies (what this issue depends on)\n   451    const deps = try graph.getDependencies(id);\n   452    defer graph.freeDependencies(deps);\n   453\n   454    for (deps) |dep| {\n   455        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n   456        defer allocator.free(target_id);\n   457\n   458        // Create edge key for deduplication\n   459        var edge_buf: [256]u8 = undefined;\n   460        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n   461\n   462        if (!emitted_edges.contains(edge_key)) {\n   463            const edge_copy = try allocator.dupe(u8, edge_key);\n   464            try emitted_edges.put(allocator, edge_copy, {});\n   465\n   466            // Emit edge with dependency type as label\n   467            const dep_type_str = dep.dep_type.toString();\n   468            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n   469        }\n   470\n   471        // Recurse into dependency\n   472        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n   473    }\n   474\n   475    // Get dependents (what depends on this issue)\n   476    const dependents = try graph.getDependents(id);\n   477    defer graph.freeDependencies(dependents);\n   478\n   479    for (dependents) |dep| {\n   480        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n   481        defer allocator.free(source_id);\n   482\n   483        // Create edge key for deduplication\n   484        var edge_buf: [256]u8 = undefined;\n   485        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n   486\n   487        if (!emitted_edges.contains(edge_key)) {\n   488            const edge_copy = try allocator.dupe(u8, edge_key);\n   489            try emitted_edges.put(allocator, edge_copy, {});\n   490\n   491            const dep_type_str = dep.dep_type.toString();\n   492            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n   493        }\n   494\n   495        // Recurse into dependent\n   496        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n   497    }\n   498}\n   499\n   500fn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n   501    // Replace characters that are invalid in Mermaid node IDs\n   502    var result = try allocator.alloc(u8, id.len);\n   503    for (id, 0..) |c, i| {\n   504        result[i] = if (c == '-' or c == '.') '_' else c;\n   505    }\n   506    return result;\n   507}\n   508\n   509fn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n   510    // Escape special characters in Mermaid labels\n   511    var count: usize = 0;\n   512    for (label) |c| {\n   513        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n   514    }\n   515\n   516    var result = try allocator.alloc(u8, count);\n   517    var i: usize = 0;\n   518    for (label) |c| {\n   519        if (c == '\"') {\n   520            result[i] = '\\\\';\n   521            result[i + 1] = '\"';\n   522            i += 2;\n   523        } else if (c == '\\\\') {\n   524            result[i] = '\\\\';\n   525            result[i + 1] = '\\\\';\n   526            i += 2;\n   527        } else {\n   528            result[i] = c;\n   529            i += 1;\n   530        }\n   531    }\n   532    return result;\n   533}\n   534\n   535fn buildTreeNode(\n   536    graph: *DependencyGraph,\n   537    ctx: *CommandContext,\n   538    id: []const u8,\n   539    allocator: std.mem.Allocator,\n   540    depth: usize,\n   541    max_depth: usize,\n   542) !TreeNode {\n   543    const issue = try ctx.store.get(id);\n   544    var title: []const u8 = \"(not found)\";\n   545    var status: []const u8 = \"unknown\";\n   546\n   547    if (issue) |i| {\n   548        var iss = i;\n   549        defer iss.deinit(allocator);\n   550        title = try allocator.dupe(u8, iss.title);\n   551        status = iss.status.toString();\n   552    }\n   553\n   554    if (depth >= max_depth) {\n   555        return TreeNode{\n   556            .id = try allocator.dupe(u8, id),\n   557            .title = title,\n   558            .status = try allocator.dupe(u8, status),\n   559            .children = null,\n   560        };\n   561    }\n   562\n   563    const deps = try graph.getDependencies(id);\n   564    defer graph.freeDependencies(deps);\n   565\n   566    var children: ?[]TreeNode = null;\n   567    if (deps.len > 0) {\n   568        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n   569        for (deps, 0..) |dep, idx| {\n   570            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n   571        }\n   572        children = child_nodes;\n   573    }\n   574\n   575    return TreeNode{\n   576        .id = try allocator.dupe(u8, id),\n   577        .title = title,\n   578        .status = try allocator.dupe(u8, status),\n   579        .children = children,\n   580    };\n   581}\n   582\n   583fn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n   584    allocator.free(node.id);\n   585    allocator.free(node.title);\n   586    allocator.free(node.status);\n   587    if (node.children) |children| {\n   588        for (children) |child| {\n   589            freeTreeNode(child, allocator);\n   590        }\n   591        allocator.free(children);\n   592    }\n   593}\n   594\n   595fn runCycles(\n   596    graph: *DependencyGraph,\n   597    output: *common.Output,\n   598    global: args.GlobalOptions,\n   599    allocator: std.mem.Allocator,\n   600) !void {\n   601    const cycles = try graph.detectCycles();\n   602    const structured_output = global.isStructuredOutput();\n   603\n   604    if (cycles) |c| {\n   605        defer graph.freeCycles(c);\n   606\n   607        if (structured_output) {\n   608            var cycle_strs = try allocator.alloc([]const u8, c.len);\n   609            defer allocator.free(cycle_strs);\n   610            for (c, 0..) |cycle, i| {\n   611                cycle_strs[i] = cycle;\n   612            }\n   613            try output.printJson(.{\n   614                .success = true,\n   615                .cycles_found = true,\n   616                .cycles = cycle_strs,\n   617            });\n   618        } else {\n   619            try output.warn(\"Cycles detected:\", .{});\n   620            for (c) |cycle| {\n   621                try output.print(\"  {s}\\n\", .{cycle});\n   622            }\n   623        }\n   624    } else {\n   625        if (structured_output) {\n   626            try output.printJson(.{\n   627                .success = true,\n   628                .cycles_found = false,\n   629            });\n   630        } else {\n   631            try output.success(\"No cycles detected\", .{});\n   632        }\n   633    }\n   634}\n   635\n   636fn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n   637    if (json_mode) {\n   638        try output.printJson(DepResult{\n   639            .success = false,\n   640            .message = message,\n   641        });\n   642    } else {\n   643        try output.err(\"{s}\", .{message});\n   644    }\n   645}\n   646\n   647// --- Tests ---\n   648\n   649test \"DepError enum exists\" {\n   650    const err: DepError = DepError.CycleDetected;\n   651    try std.testing.expect(err == DepError.CycleDetected);\n   652}\n   653\n   654test \"DepResult struct works\" {\n   655    const result = DepResult{\n   656        .success = true,\n   657        .action = \"added\",\n   658        .child = \"bd-child\",\n   659        .parent = \"bd-parent\",\n   660    };\n   661    try std.testing.expect(result.success);\n   662    try std.testing.expectEqualStrings(\"added\", result.action.?);\n   663}\n   664\n   665test \"run detects uninitialized workspace\" {\n   666    const allocator = std.testing.allocator;\n   667\n   668    const dep_args = args.DepArgs{\n   669        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   670    };\n   671    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   672\n   673    const result = run(dep_args, global, allocator);\n   674    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n   675}\n   676\n   677test \"runList returns empty for empty workspace\" {\n   678    const allocator = std.testing.allocator;\n   679\n   680    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n   681    defer allocator.free(tmp_dir_path);\n   682    defer test_util.cleanupTestDir(tmp_dir_path);\n   683\n   684    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   685    defer allocator.free(data_path);\n   686\n   687    try std.fs.cwd().makeDir(data_path);\n   688\n   689    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   690    defer allocator.free(issues_path);\n   691\n   692    const f = try std.fs.cwd().createFile(issues_path, .{});\n   693    f.close();\n   694\n   695    const dep_args = args.DepArgs{\n   696        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   697    };\n   698    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   699\n   700    try run(dep_args, global, allocator);\n   701}\n   702\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"8be5576b-632a-44eb-b5c3-9f3cc2164318","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/dep.zig","content":"//! Dependency management commands for beads_zig.\n//!\n//! `bz dep add <child> <parent> [--type blocks]` - Add dependency (child depends on parent)\n//! `bz dep remove <child> <parent>` - Remove dependency\n//! `bz dep list <id>` - List dependencies for an issue\n//!\n//! Manages relationships between issues.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst storage = @import(\"../storage/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Dependency = models.Dependency;\nconst DependencyType = models.DependencyType;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst DependencyGraphError = storage.DependencyGraphError;\n\npub const DepError = error{\n    WorkspaceNotInitialized,\n    IssueNotFound,\n    CycleDetected,\n    SelfDependency,\n    StorageError,\n    OutOfMemory,\n};\n\npub const DepResult = struct {\n    success: bool,\n    action: ?[]const u8 = null,\n    child: ?[]const u8 = null,\n    parent: ?[]const u8 = null,\n    depends_on: ?[]const []const u8 = null,\n    blocks: ?[]const []const u8 = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    dep_args: args.DepArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return DepError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var graph = ctx.createGraph();\n\n    switch (dep_args.subcommand) {\n        .add => |add| try runAdd(&graph, &ctx, add, global, allocator),\n        .remove => |remove| try runRemove(&graph, &ctx, remove, global),\n        .list => |list| try runList(&graph, &ctx.output, list, global, allocator),\n        .tree => |tree| try runTree(&graph, &ctx, tree, global, allocator),\n        .cycles => try runCycles(&graph, &ctx.output, global, allocator),\n    }\n}\n\nfn runAdd(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    add_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    if (!try ctx.store.exists(add_args.child)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.child, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    if (!try ctx.store.exists(add_args.parent)) {\n        try common.outputNotFoundError(DepResult, &ctx.output, structured_output, add_args.parent, allocator);\n        return DepError.IssueNotFound;\n    }\n\n    const now = std.time.timestamp();\n    const dep = Dependency{\n        .issue_id = add_args.child,\n        .depends_on_id = add_args.parent,\n        .dep_type = DependencyType.fromString(add_args.dep_type),\n        .created_at = now,\n        .created_by = global.actor,\n        .metadata = add_args.metadata,\n        .thread_id = null,\n    };\n\n    graph.addDependency(dep) catch |err| {\n        const msg = switch (err) {\n            DependencyGraphError.SelfDependency => \"cannot depend on self\",\n            DependencyGraphError.CycleDetected => \"adding dependency would create a cycle\",\n            DependencyGraphError.IssueNotFound => \"issue not found\",\n            else => \"failed to add dependency\",\n        };\n        try outputError(&ctx.output, structured_output, msg);\n\n        return switch (err) {\n            DependencyGraphError.SelfDependency => DepError.SelfDependency,\n            DependencyGraphError.CycleDetected => DepError.CycleDetected,\n            DependencyGraphError.IssueNotFound => DepError.IssueNotFound,\n            else => DepError.StorageError,\n        };\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"added\",\n            .child = add_args.child,\n            .parent = add_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Added dependency: {s} depends on {s}\", .{ add_args.child, add_args.parent });\n    }\n}\n\nfn runRemove(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    remove_args: anytype,\n    global: args.GlobalOptions,\n) !void {\n    const structured_output = global.isStructuredOutput();\n    graph.removeDependency(remove_args.child, remove_args.parent) catch |err| {\n        const msg = if (err == DependencyGraphError.IssueNotFound)\n            \"issue not found\"\n        else\n            \"failed to remove dependency\";\n        try outputError(&ctx.output, structured_output, msg);\n\n        return if (err == DependencyGraphError.IssueNotFound)\n            DepError.IssueNotFound\n        else\n            DepError.StorageError;\n    };\n\n    try ctx.saveIfAutoFlush();\n\n    if (structured_output) {\n        try ctx.output.printJson(DepResult{\n            .success = true,\n            .action = \"removed\",\n            .child = remove_args.child,\n            .parent = remove_args.parent,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.success(\"Removed dependency: {s} no longer depends on {s}\", .{ remove_args.child, remove_args.parent });\n    }\n}\n\nfn runList(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const direction = list_args.direction;\n    const show_down = direction == .down or direction == .both;\n    const show_up = direction == .up or direction == .both;\n\n    var deps: []Dependency = &.{};\n    var dependents: []Dependency = &.{};\n\n    if (show_down) {\n        deps = try graph.getDependencies(list_args.id);\n    }\n    defer if (show_down) graph.freeDependencies(deps);\n\n    if (show_up) {\n        dependents = try graph.getDependents(list_args.id);\n    }\n    defer if (show_up) graph.freeDependencies(dependents);\n\n    if (global.isStructuredOutput()) {\n        var depends_on_ids: ?[][]const u8 = null;\n        var blocks_ids: ?[][]const u8 = null;\n\n        if (show_down and deps.len > 0) {\n            depends_on_ids = try allocator.alloc([]const u8, deps.len);\n            for (deps, 0..) |dep, i| {\n                depends_on_ids.?[i] = dep.depends_on_id;\n            }\n        }\n\n        if (show_up and dependents.len > 0) {\n            blocks_ids = try allocator.alloc([]const u8, dependents.len);\n            for (dependents, 0..) |dep, i| {\n                blocks_ids.?[i] = dep.issue_id;\n            }\n        }\n\n        defer {\n            if (depends_on_ids) |ids| allocator.free(ids);\n            if (blocks_ids) |ids| allocator.free(ids);\n        }\n\n        try output.printJson(DepResult{\n            .success = true,\n            .depends_on = depends_on_ids,\n            .blocks = blocks_ids,\n        });\n    } else {\n        if (show_down) {\n            if (deps.len > 0) {\n                try output.println(\"Depends on:\", .{});\n                for (deps) |dep| {\n                    if (dep.metadata) |meta| {\n                        try output.print(\"  - {s} ({s}) [{s}]\\n\", .{ dep.depends_on_id, dep.dep_type.toString(), meta });\n                    } else {\n                        try output.print(\"  - {s} ({s})\\n\", .{ dep.depends_on_id, dep.dep_type.toString() });\n                    }\n                }\n            } else {\n                try output.println(\"Depends on: (none)\", .{});\n            }\n        }\n\n        if (show_up) {\n            if (dependents.len > 0) {\n                try output.println(\"Blocks:\", .{});\n                for (dependents) |dep| {\n                    try output.print(\"  - {s}\\n\", .{dep.issue_id});\n                }\n            } else {\n                try output.println(\"Blocks: (none)\", .{});\n            }\n        }\n    }\n}\n\n/// Tree node for JSON output.\nconst TreeNode = struct {\n    id: []const u8,\n    title: []const u8,\n    status: []const u8,\n    children: ?[]const TreeNode = null,\n};\n\nfn runTree(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    tree_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const id = tree_args.id;\n    const format = tree_args.format;\n\n    // Check if issue exists\n    const issue = try ctx.store.get(id);\n    if (issue == null) {\n        try common.outputNotFoundError(DepResult, &ctx.output, global.isStructuredOutput(), id, allocator);\n        return DepError.IssueNotFound;\n    }\n    var i = issue.?;\n    defer i.deinit(allocator);\n\n    if (global.isStructuredOutput()) {\n        // Build tree structure for JSON output\n        const root = try buildTreeNode(graph, ctx, id, allocator, 0, 5);\n        defer freeTreeNode(root, allocator);\n\n        try ctx.output.printJson(.{\n            .success = true,\n            .tree = root,\n        });\n    } else if (format == .mermaid) {\n        // Mermaid flowchart output\n        try printMermaidTree(&ctx.output, graph, ctx, id, allocator);\n    } else {\n        // ASCII tree output\n        try ctx.output.println(\"{s} - {s} [{s}]\", .{ id, i.title, i.status.toString() });\n\n        // Show what this issue depends on (upstream dependencies)\n        const deps = try graph.getDependencies(id);\n        defer graph.freeDependencies(deps);\n\n        if (deps.len > 0) {\n            try ctx.output.println(\"Depends on:\", .{});\n            var visited: std.StringHashMapUnmanaged(void) = .{};\n            defer {\n                var it = visited.keyIterator();\n                while (it.next()) |key| allocator.free(key.*);\n                visited.deinit(allocator);\n            }\n\n            for (deps, 0..) |dep, idx| {\n                const is_last = (idx == deps.len - 1);\n                try printTreeBranch(&ctx.output, graph, ctx, dep.depends_on_id, \"\", is_last, &visited, allocator, 0, 5);\n            }\n        }\n\n        // Show what depends on this issue (downstream dependents)\n        const dependents = try graph.getDependents(id);\n        defer graph.freeDependencies(dependents);\n\n        if (dependents.len > 0) {\n            try ctx.output.print(\"\\n\", .{});\n            try ctx.output.println(\"Blocked by this:\", .{});\n            for (dependents, 0..) |dep, idx| {\n                const is_last = (idx == dependents.len - 1);\n                const prefix = if (is_last) \"`-- \" else \"|-- \";\n                const dep_issue = try ctx.store.get(dep.issue_id);\n                if (dep_issue) |di| {\n                    var d = di;\n                    defer d.deinit(allocator);\n                    try ctx.output.print(\"{s}{s} - {s} [{s}]\\n\", .{ prefix, dep.issue_id, d.title, d.status.toString() });\n                } else {\n                    try ctx.output.print(\"{s}{s} (not found)\\n\", .{ prefix, dep.issue_id });\n                }\n            }\n        }\n    }\n}\n\nfn printTreeBranch(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    prefix: []const u8,\n    is_last: bool,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Check for cycles\n    if (visited.contains(id)) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (cycle)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Depth limit\n    if (depth >= max_depth) {\n        const branch = if (is_last) \"`-- \" else \"|-- \";\n        try output.print(\"{s}{s}{s} (...)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details\n    const issue = try ctx.store.get(id);\n    const branch = if (is_last) \"`-- \" else \"|-- \";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        try output.print(\"{s}{s}{s} - {s} [{s}]\\n\", .{ prefix, branch, id, iss.title, iss.status.toString() });\n    } else {\n        try output.print(\"{s}{s}{s} (not found)\\n\", .{ prefix, branch, id });\n        return;\n    }\n\n    // Get dependencies of this issue\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    // Build new prefix for children\n    var new_prefix_buf: [256]u8 = undefined;\n    const extension = if (is_last) \"    \" else \"|   \";\n    const new_prefix = std.fmt.bufPrint(&new_prefix_buf, \"{s}{s}\", .{ prefix, extension }) catch prefix;\n\n    for (deps, 0..) |dep, idx| {\n        const child_is_last = (idx == deps.len - 1);\n        try printTreeBranch(output, graph, ctx, dep.depends_on_id, new_prefix, child_is_last, visited, allocator, depth + 1, max_depth);\n    }\n}\n\nfn printMermaidTree(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    root_id: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    // Start Mermaid flowchart\n    try output.println(\"```mermaid\", .{});\n    try output.println(\"flowchart TD\", .{});\n\n    // Track visited nodes to avoid duplicates\n    var visited: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var it = visited.keyIterator();\n        while (it.next()) |key| allocator.free(key.*);\n        visited.deinit(allocator);\n    }\n\n    // Track emitted edges to avoid duplicates\n    var emitted_edges: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var edge_it = emitted_edges.keyIterator();\n        while (edge_it.next()) |key| allocator.free(key.*);\n        emitted_edges.deinit(allocator);\n    }\n\n    // Collect all nodes and edges starting from root\n    try collectMermaidNodes(output, graph, ctx, root_id, &visited, &emitted_edges, allocator, 0, 5);\n\n    try output.println(\"```\", .{});\n}\n\nfn collectMermaidNodes(\n    output: *common.Output,\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    visited: *std.StringHashMapUnmanaged(void),\n    emitted_edges: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !void {\n    // Skip if already visited\n    if (visited.contains(id)) return;\n\n    // Mark as visited\n    const id_copy = try allocator.dupe(u8, id);\n    errdefer allocator.free(id_copy);\n    try visited.put(allocator, id_copy, {});\n\n    // Get issue details for node label\n    const issue = try ctx.store.get(id);\n    const safe_id = try sanitizeMermaidId(id, allocator);\n    defer allocator.free(safe_id);\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        const safe_title = try sanitizeMermaidLabel(iss.title, allocator);\n        defer allocator.free(safe_title);\n        try output.print(\"    {s}[\\\"{s}: {s}\\\"]\\n\", .{ safe_id, id, safe_title });\n    } else {\n        try output.print(\"    {s}[\\\"{s}: (not found)\\\"]\\n\", .{ safe_id, id });\n    }\n\n    if (depth >= max_depth) return;\n\n    // Get dependencies (what this issue depends on)\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    for (deps) |dep| {\n        const target_id = try sanitizeMermaidId(dep.depends_on_id, allocator);\n        defer allocator.free(target_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ safe_id, target_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            // Emit edge with dependency type as label\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ safe_id, dep_type_str, target_id });\n        }\n\n        // Recurse into dependency\n        try collectMermaidNodes(output, graph, ctx, dep.depends_on_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n\n    // Get dependents (what depends on this issue)\n    const dependents = try graph.getDependents(id);\n    defer graph.freeDependencies(dependents);\n\n    for (dependents) |dep| {\n        const source_id = try sanitizeMermaidId(dep.issue_id, allocator);\n        defer allocator.free(source_id);\n\n        // Create edge key for deduplication\n        var edge_buf: [256]u8 = undefined;\n        const edge_key = std.fmt.bufPrint(&edge_buf, \"{s}->{s}\", .{ source_id, safe_id }) catch continue;\n\n        if (!emitted_edges.contains(edge_key)) {\n            const edge_copy = try allocator.dupe(u8, edge_key);\n            try emitted_edges.put(allocator, edge_copy, {});\n\n            const dep_type_str = dep.dep_type.toString();\n            try output.print(\"    {s} -->|{s}| {s}\\n\", .{ source_id, dep_type_str, safe_id });\n        }\n\n        // Recurse into dependent\n        try collectMermaidNodes(output, graph, ctx, dep.issue_id, visited, emitted_edges, allocator, depth + 1, max_depth);\n    }\n}\n\nfn sanitizeMermaidId(id: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Replace characters that are invalid in Mermaid node IDs\n    var result = try allocator.alloc(u8, id.len);\n    for (id, 0..) |c, i| {\n        result[i] = if (c == '-' or c == '.') '_' else c;\n    }\n    return result;\n}\n\nfn sanitizeMermaidLabel(label: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    // Escape special characters in Mermaid labels\n    var count: usize = 0;\n    for (label) |c| {\n        count += if (c == '\"' or c == '\\\\') @as(usize, 2) else @as(usize, 1);\n    }\n\n    var result = try allocator.alloc(u8, count);\n    var i: usize = 0;\n    for (label) |c| {\n        if (c == '\"') {\n            result[i] = '\\\\';\n            result[i + 1] = '\"';\n            i += 2;\n        } else if (c == '\\\\') {\n            result[i] = '\\\\';\n            result[i + 1] = '\\\\';\n            i += 2;\n        } else {\n            result[i] = c;\n            i += 1;\n        }\n    }\n    return result;\n}\n\nfn buildTreeNode(\n    graph: *DependencyGraph,\n    ctx: *CommandContext,\n    id: []const u8,\n    allocator: std.mem.Allocator,\n    depth: usize,\n    max_depth: usize,\n) !TreeNode {\n    const issue = try ctx.store.get(id);\n    var title: []const u8 = \"(not found)\";\n    var status: []const u8 = \"unknown\";\n\n    if (issue) |i| {\n        var iss = i;\n        defer iss.deinit(allocator);\n        title = try allocator.dupe(u8, iss.title);\n        status = iss.status.toString();\n    }\n\n    if (depth >= max_depth) {\n        return TreeNode{\n            .id = try allocator.dupe(u8, id),\n            .title = title,\n            .status = try allocator.dupe(u8, status),\n            .children = null,\n        };\n    }\n\n    const deps = try graph.getDependencies(id);\n    defer graph.freeDependencies(deps);\n\n    var children: ?[]TreeNode = null;\n    if (deps.len > 0) {\n        var child_nodes = try allocator.alloc(TreeNode, deps.len);\n        for (deps, 0..) |dep, idx| {\n            child_nodes[idx] = try buildTreeNode(graph, ctx, dep.depends_on_id, allocator, depth + 1, max_depth);\n        }\n        children = child_nodes;\n    }\n\n    return TreeNode{\n        .id = try allocator.dupe(u8, id),\n        .title = title,\n        .status = try allocator.dupe(u8, status),\n        .children = children,\n    };\n}\n\nfn freeTreeNode(node: TreeNode, allocator: std.mem.Allocator) void {\n    allocator.free(node.id);\n    allocator.free(node.title);\n    allocator.free(node.status);\n    if (node.children) |children| {\n        for (children) |child| {\n            freeTreeNode(child, allocator);\n        }\n        allocator.free(children);\n    }\n}\n\nfn runCycles(\n    graph: *DependencyGraph,\n    output: *common.Output,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    const cycles = try graph.detectCycles();\n    const structured_output = global.isStructuredOutput();\n\n    if (cycles) |c| {\n        defer graph.freeCycles(c);\n\n        if (structured_output) {\n            var cycle_strs = try allocator.alloc([]const u8, c.len);\n            defer allocator.free(cycle_strs);\n            for (c, 0..) |cycle, i| {\n                cycle_strs[i] = cycle;\n            }\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = true,\n                .cycles = cycle_strs,\n            });\n        } else {\n            try output.warn(\"Cycles detected:\", .{});\n            for (c) |cycle| {\n                try output.print(\"  {s}\\n\", .{cycle});\n            }\n        }\n    } else {\n        if (structured_output) {\n            try output.printJson(.{\n                .success = true,\n                .cycles_found = false,\n            });\n        } else {\n            try output.success(\"No cycles detected\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(DepResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"DepError enum exists\" {\n    const err: DepError = DepError.CycleDetected;\n    try std.testing.expect(err == DepError.CycleDetected);\n}\n\ntest \"DepResult struct works\" {\n    const result = DepResult{\n        .success = true,\n        .action = \"added\",\n        .child = \"bd-child\",\n        .parent = \"bd-parent\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"added\", result.action.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(dep_args, global, allocator);\n    try std.testing.expectError(DepError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList returns empty for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"dep_list_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const dep_args = args.DepArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(dep_args, global, allocator);\n}\n","numLines":702,"startLine":1,"totalLines":702}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VApseJvvzSDkENgQmx5Ne8","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check the label.zig, args.zig, and output/mod.zig files for potential simplifications."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14765,"cache_read_input_tokens":43586,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14765},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"28dc9b4c-6d34-4dc6-89f0-69a8d2d1a0ff"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VApseJvvzSDkENgQmx5Ne8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PzCCZ36jTHSFabrkyffhrA","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14765,"cache_read_input_tokens":43586,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14765},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"a8d2d1aa-fb67-42fd-9c17-7ed40bbede2a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PzCCZ36jTHSFabrkyffhrA","type":"tool_result","content":"     1//! Label commands for beads_zig.\n     2//!\n     3//! `bz label add <id> <labels...>` - Add labels to an issue\n     4//! `bz label remove <id> <labels...>` - Remove labels from an issue\n     5//! `bz label list <id>` - List labels on an issue\n     6//! `bz label list-all` - List all labels in the project\n     7\n     8const std = @import(\"std\");\n     9const common = @import(\"common.zig\");\n    10const args = @import(\"args.zig\");\n    11\n    12const CommandContext = common.CommandContext;\n    13\n    14pub const LabelError = error{\n    15    WorkspaceNotInitialized,\n    16    StorageError,\n    17    IssueNotFound,\n    18    OutOfMemory,\n    19};\n    20\n    21pub const LabelResult = struct {\n    22    success: bool,\n    23    id: ?[]const u8 = null,\n    24    labels: ?[]const []const u8 = null,\n    25    added: ?[]const []const u8 = null,\n    26    removed: ?[]const []const u8 = null,\n    27    old_name: ?[]const u8 = null,\n    28    new_name: ?[]const u8 = null,\n    29    renamed_count: ?usize = null,\n    30    message: ?[]const u8 = null,\n    31};\n    32\n    33pub fn run(\n    34    label_args: args.LabelArgs,\n    35    global: args.GlobalOptions,\n    36    allocator: std.mem.Allocator,\n    37) !void {\n    38    switch (label_args.subcommand) {\n    39        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n    40        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n    41        .list => |list| try runList(list.id, global, allocator),\n    42        .list_all => try runListAll(global, allocator),\n    43        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    44    }\n    45}\n    46\n    47fn runAdd(\n    48    id: []const u8,\n    49    labels: []const []const u8,\n    50    global: args.GlobalOptions,\n    51    allocator: std.mem.Allocator,\n    52) !void {\n    53    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    54        return LabelError.WorkspaceNotInitialized;\n    55    };\n    56    defer ctx.deinit();\n    57\n    58    // Verify issue exists\n    59    if (!try ctx.store.exists(id)) {\n    60        if (global.isStructuredOutput()) {\n    61            try ctx.output.printJson(LabelResult{\n    62                .success = false,\n    63                .id = id,\n    64                .message = \"issue not found\",\n    65            });\n    66        } else {\n    67            try ctx.output.err(\"issue not found: {s}\", .{id});\n    68        }\n    69        return LabelError.IssueNotFound;\n    70    }\n    71\n    72    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    73    defer added_labels.deinit(allocator);\n    74\n    75    for (labels) |label| {\n    76        // Check if already has label\n    77        const existing = try ctx.store.getLabels(id);\n    78        defer {\n    79            for (existing) |lbl| {\n    80                allocator.free(lbl);\n    81            }\n    82            allocator.free(existing);\n    83        }\n    84\n    85        var has_label = false;\n    86        for (existing) |existing_label| {\n    87            if (std.mem.eql(u8, existing_label, label)) {\n    88                has_label = true;\n    89                break;\n    90            }\n    91        }\n    92\n    93        if (!has_label) {\n    94            try ctx.store.addLabel(id, label);\n    95            try added_labels.append(allocator, label);\n    96        }\n    97    }\n    98\n    99    try ctx.saveIfAutoFlush();\n   100\n   101    if (global.isStructuredOutput()) {\n   102        try ctx.output.printJson(LabelResult{\n   103            .success = true,\n   104            .id = id,\n   105            .added = added_labels.items,\n   106        });\n   107    } else if (global.quiet) {\n   108        for (added_labels.items) |label| {\n   109            try ctx.output.print(\"{s}\\n\", .{label});\n   110        }\n   111    } else {\n   112        if (added_labels.items.len > 0) {\n   113            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n   114        } else {\n   115            try ctx.output.info(\"No new labels added (already present)\", .{});\n   116        }\n   117    }\n   118}\n   119\n   120fn runRemove(\n   121    id: []const u8,\n   122    labels: []const []const u8,\n   123    global: args.GlobalOptions,\n   124    allocator: std.mem.Allocator,\n   125) !void {\n   126    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   127        return LabelError.WorkspaceNotInitialized;\n   128    };\n   129    defer ctx.deinit();\n   130\n   131    // Verify issue exists\n   132    if (!try ctx.store.exists(id)) {\n   133        if (global.isStructuredOutput()) {\n   134            try ctx.output.printJson(LabelResult{\n   135                .success = false,\n   136                .id = id,\n   137                .message = \"issue not found\",\n   138            });\n   139        } else {\n   140            try ctx.output.err(\"issue not found: {s}\", .{id});\n   141        }\n   142        return LabelError.IssueNotFound;\n   143    }\n   144\n   145    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n   146    defer removed_labels.deinit(allocator);\n   147\n   148    for (labels) |label| {\n   149        // Check if has label\n   150        const existing = try ctx.store.getLabels(id);\n   151        defer {\n   152            for (existing) |lbl| {\n   153                allocator.free(lbl);\n   154            }\n   155            allocator.free(existing);\n   156        }\n   157\n   158        var has_label = false;\n   159        for (existing) |existing_label| {\n   160            if (std.mem.eql(u8, existing_label, label)) {\n   161                has_label = true;\n   162                break;\n   163            }\n   164        }\n   165\n   166        if (has_label) {\n   167            try ctx.store.removeLabel(id, label);\n   168            try removed_labels.append(allocator, label);\n   169        }\n   170    }\n   171\n   172    try ctx.saveIfAutoFlush();\n   173\n   174    if (global.isStructuredOutput()) {\n   175        try ctx.output.printJson(LabelResult{\n   176            .success = true,\n   177            .id = id,\n   178            .removed = removed_labels.items,\n   179        });\n   180    } else if (global.quiet) {\n   181        for (removed_labels.items) |label| {\n   182            try ctx.output.print(\"{s}\\n\", .{label});\n   183        }\n   184    } else {\n   185        if (removed_labels.items.len > 0) {\n   186            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n   187        } else {\n   188            try ctx.output.info(\"No labels removed (not present)\", .{});\n   189        }\n   190    }\n   191}\n   192\n   193fn runList(\n   194    id: []const u8,\n   195    global: args.GlobalOptions,\n   196    allocator: std.mem.Allocator,\n   197) !void {\n   198    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   199        return LabelError.WorkspaceNotInitialized;\n   200    };\n   201    defer ctx.deinit();\n   202\n   203    // Verify issue exists\n   204    if (!try ctx.store.exists(id)) {\n   205        if (global.isStructuredOutput()) {\n   206            try ctx.output.printJson(LabelResult{\n   207                .success = false,\n   208                .id = id,\n   209                .message = \"issue not found\",\n   210            });\n   211        } else {\n   212            try ctx.output.err(\"issue not found: {s}\", .{id});\n   213        }\n   214        return LabelError.IssueNotFound;\n   215    }\n   216\n   217    const label_list = try ctx.store.getLabels(id);\n   218    defer {\n   219        for (label_list) |lbl| {\n   220            allocator.free(lbl);\n   221        }\n   222        allocator.free(label_list);\n   223    }\n   224\n   225    if (global.isStructuredOutput()) {\n   226        try ctx.output.printJson(LabelResult{\n   227            .success = true,\n   228            .id = id,\n   229            .labels = label_list,\n   230        });\n   231    } else if (global.quiet) {\n   232        for (label_list) |label| {\n   233            try ctx.output.print(\"{s}\\n\", .{label});\n   234        }\n   235    } else {\n   236        if (label_list.len == 0) {\n   237            try ctx.output.info(\"No labels on {s}\", .{id});\n   238        } else {\n   239            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n   240            for (label_list) |label| {\n   241                try ctx.output.print(\"  {s}\\n\", .{label});\n   242            }\n   243        }\n   244    }\n   245}\n   246\n   247fn runListAll(\n   248    global: args.GlobalOptions,\n   249    allocator: std.mem.Allocator,\n   250) !void {\n   251    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   252        return LabelError.WorkspaceNotInitialized;\n   253    };\n   254    defer ctx.deinit();\n   255\n   256    // Collect all unique labels across all issues\n   257    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n   258    defer {\n   259        var key_it = all_labels.keyIterator();\n   260        while (key_it.next()) |key| {\n   261            allocator.free(key.*);\n   262        }\n   263        all_labels.deinit(allocator);\n   264    }\n   265\n   266    for (ctx.store.issues.items) |issue| {\n   267        if (issue.status.eql(.tombstone)) continue;\n   268\n   269        for (issue.labels) |label| {\n   270            if (!all_labels.contains(label)) {\n   271                const label_copy = try allocator.dupe(u8, label);\n   272                try all_labels.put(allocator, label_copy, {});\n   273            }\n   274        }\n   275    }\n   276\n   277    // Convert to sorted slice\n   278    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n   279    defer label_list.deinit(allocator);\n   280\n   281    var key_it = all_labels.keyIterator();\n   282    while (key_it.next()) |key| {\n   283        try label_list.append(allocator, key.*);\n   284    }\n   285\n   286    // Sort alphabetically\n   287    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n   288        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n   289            return std.mem.lessThan(u8, a, b);\n   290        }\n   291    }.lessThan);\n   292\n   293    if (global.isStructuredOutput()) {\n   294        try ctx.output.printJson(LabelResult{\n   295            .success = true,\n   296            .labels = label_list.items,\n   297        });\n   298    } else if (global.quiet) {\n   299        for (label_list.items) |label| {\n   300            try ctx.output.print(\"{s}\\n\", .{label});\n   301        }\n   302    } else {\n   303        if (label_list.items.len == 0) {\n   304            try ctx.output.info(\"No labels in project\", .{});\n   305        } else {\n   306            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n   307            for (label_list.items) |label| {\n   308                try ctx.output.print(\"  {s}\\n\", .{label});\n   309            }\n   310        }\n   311    }\n   312}\n   313\n   314fn runRename(\n   315    old_name: []const u8,\n   316    new_name: []const u8,\n   317    global: args.GlobalOptions,\n   318    allocator: std.mem.Allocator,\n   319) !void {\n   320    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   321        return LabelError.WorkspaceNotInitialized;\n   322    };\n   323    defer ctx.deinit();\n   324\n   325    // Count how many issues have this label renamed\n   326    var renamed_count: usize = 0;\n   327\n   328    // Iterate through all issues\n   329    for (ctx.store.issues.items) |*issue| {\n   330        if (issue.status.eql(.tombstone)) continue;\n   331\n   332        // Check if issue has the old label\n   333        var has_old_label = false;\n   334        var old_label_idx: usize = 0;\n   335        for (issue.labels, 0..) |label, idx| {\n   336            if (std.mem.eql(u8, label, old_name)) {\n   337                has_old_label = true;\n   338                old_label_idx = idx;\n   339                break;\n   340            }\n   341        }\n   342\n   343        if (has_old_label) {\n   344            // Check if it already has the new label (avoid duplicates)\n   345            var has_new_label = false;\n   346            for (issue.labels) |label| {\n   347                if (std.mem.eql(u8, label, new_name)) {\n   348                    has_new_label = true;\n   349                    break;\n   350                }\n   351            }\n   352\n   353            if (has_new_label) {\n   354                // Remove the old label (new label already exists)\n   355                try ctx.store.removeLabel(issue.id, old_name);\n   356            } else {\n   357                // Replace old label with new label in place\n   358                // First remove old, then add new\n   359                try ctx.store.removeLabel(issue.id, old_name);\n   360                try ctx.store.addLabel(issue.id, new_name);\n   361            }\n   362            renamed_count += 1;\n   363        }\n   364    }\n   365\n   366    try ctx.saveIfAutoFlush();\n   367\n   368    if (global.isStructuredOutput()) {\n   369        try ctx.output.printJson(LabelResult{\n   370            .success = true,\n   371            .old_name = old_name,\n   372            .new_name = new_name,\n   373            .renamed_count = renamed_count,\n   374        });\n   375    } else if (global.quiet) {\n   376        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n   377    } else {\n   378        if (renamed_count > 0) {\n   379            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n   380        } else {\n   381            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n   382        }\n   383    }\n   384}\n   385\n   386// --- Tests ---\n   387\n   388test \"LabelError enum exists\" {\n   389    const err: LabelError = LabelError.WorkspaceNotInitialized;\n   390    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n   391}\n   392\n   393test \"LabelResult struct works\" {\n   394    const result = LabelResult{\n   395        .success = true,\n   396        .id = \"bd-test\",\n   397    };\n   398    try std.testing.expect(result.success);\n   399    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n   400}\n   401\n   402test \"runAdd detects uninitialized workspace\" {\n   403    const allocator = std.testing.allocator;\n   404    const labels = [_][]const u8{\"test\"};\n   405\n   406    const label_args = args.LabelArgs{\n   407        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n   408    };\n   409    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   410\n   411    const result = run(label_args, global, allocator);\n   412    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   413}\n   414\n   415test \"runList detects uninitialized workspace\" {\n   416    const allocator = std.testing.allocator;\n   417\n   418    const label_args = args.LabelArgs{\n   419        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n   420    };\n   421    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   422\n   423    const result = run(label_args, global, allocator);\n   424    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   425}\n   426\n   427test \"runListAll detects uninitialized workspace\" {\n   428    const allocator = std.testing.allocator;\n   429\n   430    const label_args = args.LabelArgs{\n   431        .subcommand = .{ .list_all = {} },\n   432    };\n   433    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   434\n   435    const result = run(label_args, global, allocator);\n   436    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n   437}\n   438\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"b4f80e3e-a619-4d90-92fc-3bcdf1caf907","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","content":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runRename(\n    old_name: []const u8,\n    new_name: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count how many issues have this label renamed\n    var renamed_count: usize = 0;\n\n    // Iterate through all issues\n    for (ctx.store.issues.items) |*issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }\n\n        if (has_old_label) {\n            // Check if it already has the new label (avoid duplicates)\n            var has_new_label = false;\n            for (issue.labels) |label| {\n                if (std.mem.eql(u8, label, new_name)) {\n                    has_new_label = true;\n                    break;\n                }\n            }\n\n            if (has_new_label) {\n                // Remove the old label (new label already exists)\n                try ctx.store.removeLabel(issue.id, old_name);\n            } else {\n                // Replace old label with new label in place\n                // First remove old, then add new\n                try ctx.store.removeLabel(issue.id, old_name);\n                try ctx.store.addLabel(issue.id, new_name);\n            }\n            renamed_count += 1;\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .old_name = old_name,\n            .new_name = new_name,\n            .renamed_count = renamed_count,\n        });\n    } else if (global.quiet) {\n        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n    } else {\n        if (renamed_count > 0) {\n            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n        } else {\n            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","numLines":438,"startLine":1,"totalLines":438}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VApseJvvzSDkENgQmx5Ne8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PVUe33DHDdcgRPgTtDn8Ke","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14765,"cache_read_input_tokens":43586,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14765},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"4b202b31-def5-4a27-8d10-3e392994a5ce"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PVUe33DHDdcgRPgTtDn8Ke","type":"tool_result","content":"     1//! Output formatting for beads_zig.\n     2//!\n     3//! Provides a unified interface for displaying output in different modes:\n     4//! - plain: No colors, basic formatting (default for non-TTY)\n     5//! - rich: Colors and formatting (default for TTY)\n     6//! - json: Structured JSON output for machine consumption\n     7//! - quiet: Minimal output (IDs only)\n     8//!\n     9//! Respects NO_COLOR environment variable and --no-color flag.\n    10\n    11const std = @import(\"std\");\n    12const models = @import(\"../models/mod.zig\");\n    13const Issue = models.Issue;\n    14const Status = models.Status;\n    15const Priority = models.Priority;\n    16const IssueType = models.IssueType;\n    17\n    18/// Output mode determines formatting and verbosity.\n    19pub const OutputMode = enum {\n    20    plain, // No colors, basic formatting\n    21    rich, // Colors and formatting (TTY)\n    22    json, // Structured JSON output\n    23    quiet, // Minimal output (IDs only)\n    24    robot, // Line-oriented machine-readable output for scripting\n    25};\n    26\n    27/// ANSI color escape codes.\n    28pub const Color = struct {\n    29    pub const reset = \"\\x1b[0m\";\n    30    pub const bold = \"\\x1b[1m\";\n    31    pub const dim = \"\\x1b[2m\";\n    32    pub const italic = \"\\x1b[3m\";\n    33    pub const underline = \"\\x1b[4m\";\n    34\n    35    pub const red = \"\\x1b[31m\";\n    36    pub const green = \"\\x1b[32m\";\n    37    pub const yellow = \"\\x1b[33m\";\n    38    pub const blue = \"\\x1b[34m\";\n    39    pub const magenta = \"\\x1b[35m\";\n    40    pub const cyan = \"\\x1b[36m\";\n    41    pub const white = \"\\x1b[37m\";\n    42    pub const gray = \"\\x1b[90m\";\n    43\n    44    pub const bright_red = \"\\x1b[91m\";\n    45    pub const bright_green = \"\\x1b[92m\";\n    46    pub const bright_yellow = \"\\x1b[93m\";\n    47    pub const bright_blue = \"\\x1b[94m\";\n    48    pub const bright_magenta = \"\\x1b[95m\";\n    49    pub const bright_cyan = \"\\x1b[96m\";\n    50\n    51    pub const bg_red = \"\\x1b[41m\";\n    52    pub const bg_green = \"\\x1b[42m\";\n    53    pub const bg_yellow = \"\\x1b[43m\";\n    54    pub const bg_blue = \"\\x1b[44m\";\n    55};\n    56\n    57/// Global options that affect output formatting.\n    58/// This mirrors the relevant fields from cli.args.GlobalOptions.\n    59pub const OutputOptions = struct {\n    60    json: bool = false,\n    61    toon: bool = false,\n    62    robot: bool = false, // Line-oriented machine-readable output for scripting\n    63    quiet: bool = false,\n    64    silent: bool = false, // Suppress ALL output including errors (for tests)\n    65    no_color: bool = false,\n    66    wrap: bool = false, // Wrap long lines in plain text output\n    67    stats: bool = false, // Show token savings stats for TOON output\n    68};\n    69\n    70/// Output formatter for consistent CLI output across all modes.\n    71pub const Output = struct {\n    72    mode: OutputMode,\n    73    toon: bool,\n    74    silent: bool, // Suppress ALL output including errors (for tests)\n    75    wrap: bool, // Wrap long lines in plain text output\n    76    stats: bool, // Show token savings stats for TOON output\n    77    stdout: std.fs.File,\n    78    stderr: std.fs.File,\n    79    allocator: std.mem.Allocator,\n    80    /// Terminal width for line wrapping (default: 80)\n    81    terminal_width: usize = 80,\n    82\n    83    const Self = @This();\n    84\n    85    /// Initialize output formatter based on global options and TTY detection.\n    86    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n    87        const stdout = std.fs.File.stdout();\n    88        const stderr = std.fs.File.stderr();\n    89\n    90        var mode: OutputMode = .plain;\n    91        if (opts.json or opts.toon) {\n    92            mode = .json;\n    93        } else if (opts.robot) {\n    94            mode = .robot;\n    95        } else if (opts.quiet or opts.silent) {\n    96            mode = .quiet;\n    97        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n    98            mode = .rich;\n    99        }\n   100\n   101        // Try to get terminal width, default to 80\n   102        const terminal_width: usize = getTerminalWidth() orelse 80;\n   103\n   104        return .{\n   105            .mode = mode,\n   106            .toon = opts.toon,\n   107            .silent = opts.silent,\n   108            .wrap = opts.wrap,\n   109            .stats = opts.stats,\n   110            .stdout = stdout,\n   111            .stderr = stderr,\n   112            .allocator = allocator,\n   113            .terminal_width = terminal_width,\n   114        };\n   115    }\n   116\n   117    /// Initialize with explicit mode (useful for testing).\n   118    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n   119        return .{\n   120            .mode = mode,\n   121            .toon = false,\n   122            .silent = false,\n   123            .wrap = false,\n   124            .stats = false,\n   125            .stdout = std.fs.File.stdout(),\n   126            .stderr = std.fs.File.stderr(),\n   127            .allocator = allocator,\n   128            .terminal_width = 80,\n   129        };\n   130    }\n   131\n   132    /// Initialize for testing with custom file handles.\n   133    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n   134        return .{\n   135            .mode = mode,\n   136            .toon = false,\n   137            .silent = false,\n   138            .wrap = false,\n   139            .stats = false,\n   140            .stdout = stdout,\n   141            .stderr = stderr,\n   142            .allocator = allocator,\n   143            .terminal_width = 80,\n   144        };\n   145    }\n   146\n   147    /// Initialize with silent mode (suppresses ALL output including errors).\n   148    pub fn initSilent(allocator: std.mem.Allocator) Self {\n   149        return .{\n   150            .mode = .quiet,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"51c3937b-fb3f-46b3-8862-1cc341cdbe26","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/output/mod.zig","content":"//! Output formatting for beads_zig.\n//!\n//! Provides a unified interface for displaying output in different modes:\n//! - plain: No colors, basic formatting (default for non-TTY)\n//! - rich: Colors and formatting (default for TTY)\n//! - json: Structured JSON output for machine consumption\n//! - quiet: Minimal output (IDs only)\n//!\n//! Respects NO_COLOR environment variable and --no-color flag.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\n\n/// Output mode determines formatting and verbosity.\npub const OutputMode = enum {\n    plain, // No colors, basic formatting\n    rich, // Colors and formatting (TTY)\n    json, // Structured JSON output\n    quiet, // Minimal output (IDs only)\n    robot, // Line-oriented machine-readable output for scripting\n};\n\n/// ANSI color escape codes.\npub const Color = struct {\n    pub const reset = \"\\x1b[0m\";\n    pub const bold = \"\\x1b[1m\";\n    pub const dim = \"\\x1b[2m\";\n    pub const italic = \"\\x1b[3m\";\n    pub const underline = \"\\x1b[4m\";\n\n    pub const red = \"\\x1b[31m\";\n    pub const green = \"\\x1b[32m\";\n    pub const yellow = \"\\x1b[33m\";\n    pub const blue = \"\\x1b[34m\";\n    pub const magenta = \"\\x1b[35m\";\n    pub const cyan = \"\\x1b[36m\";\n    pub const white = \"\\x1b[37m\";\n    pub const gray = \"\\x1b[90m\";\n\n    pub const bright_red = \"\\x1b[91m\";\n    pub const bright_green = \"\\x1b[92m\";\n    pub const bright_yellow = \"\\x1b[93m\";\n    pub const bright_blue = \"\\x1b[94m\";\n    pub const bright_magenta = \"\\x1b[95m\";\n    pub const bright_cyan = \"\\x1b[96m\";\n\n    pub const bg_red = \"\\x1b[41m\";\n    pub const bg_green = \"\\x1b[42m\";\n    pub const bg_yellow = \"\\x1b[43m\";\n    pub const bg_blue = \"\\x1b[44m\";\n};\n\n/// Global options that affect output formatting.\n/// This mirrors the relevant fields from cli.args.GlobalOptions.\npub const OutputOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n};\n\n/// Output formatter for consistent CLI output across all modes.\npub const Output = struct {\n    mode: OutputMode,\n    toon: bool,\n    silent: bool, // Suppress ALL output including errors (for tests)\n    wrap: bool, // Wrap long lines in plain text output\n    stats: bool, // Show token savings stats for TOON output\n    stdout: std.fs.File,\n    stderr: std.fs.File,\n    allocator: std.mem.Allocator,\n    /// Terminal width for line wrapping (default: 80)\n    terminal_width: usize = 80,\n\n    const Self = @This();\n\n    /// Initialize output formatter based on global options and TTY detection.\n    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n        const stdout = std.fs.File.stdout();\n        const stderr = std.fs.File.stderr();\n\n        var mode: OutputMode = .plain;\n        if (opts.json or opts.toon) {\n            mode = .json;\n        } else if (opts.robot) {\n            mode = .robot;\n        } else if (opts.quiet or opts.silent) {\n            mode = .quiet;\n        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n            mode = .rich;\n        }\n\n        // Try to get terminal width, default to 80\n        const terminal_width: usize = getTerminalWidth() orelse 80;\n\n        return .{\n            .mode = mode,\n            .toon = opts.toon,\n            .silent = opts.silent,\n            .wrap = opts.wrap,\n            .stats = opts.stats,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n            .terminal_width = terminal_width,\n        };\n    }\n\n    /// Initialize with explicit mode (useful for testing).\n    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .wrap = false,\n            .stats = false,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n            .terminal_width = 80,\n        };\n    }\n\n    /// Initialize for testing with custom file handles.\n    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .wrap = false,\n            .stats = false,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n            .terminal_width = 80,\n        };\n    }\n\n    /// Initialize with silent mode (suppresses ALL output including errors).\n    pub fn initSilent(allocator: std.mem.Allocator) Self {\n        return .{\n            .mode = .quiet,","numLines":150,"startLine":1,"totalLines":1048}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GF6h4rb2sfJRvSHtC3zJgt","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of all the changes. Let me identify potential simplifications:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7887,"cache_read_input_tokens":58351,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7887},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"db372ff0-6e76-4265-8f12-a55a782b81f3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GF6h4rb2sfJRvSHtC3zJgt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KFB7D6WtJ7eK6WpXmt5EtP","name":"TodoWrite","input":{"todos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"in_progress","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing simplification changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7887,"cache_read_input_tokens":58351,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7887},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"fdce6602-3d33-40c4-9ef6-610bd44846b0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KFB7D6WtJ7eK6WpXmt5EtP","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"d2549fc5-2a3e-4aa3-831a-99ff6fe833b5","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"in_progress","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing simplification changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017KzU7mtKFTsw1rAuiXogry","type":"message","role":"assistant","content":[{"type":"text","text":"I found a simplification opportunity in `label.zig` - the `old_label_idx` variable is set but never used. Let me fix that."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":253,"cache_read_input_tokens":66238,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"1c046f35-4aab-4fdc-827c-720c240661a3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017KzU7mtKFTsw1rAuiXogry","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T6iQ9JjrjdShA8rVHQASvU","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/label.zig","old_string":"        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }","new_string":"        // Check if issue has the old label\n        var has_old_label = false;\n        for (issue.labels) |label| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                break;\n            }\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":253,"cache_read_input_tokens":66238,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"1e87ec09-44f7-4aec-a3ab-b74a9083ee34"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T6iQ9JjrjdShA8rVHQASvU","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/label.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"6058c362-bb40-4ba6-9ab4-27542ed6170e","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/label.zig","oldString":"        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }","newString":"        // Check if issue has the old label\n        var has_old_label = false;\n        for (issue.labels) |label| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                break;\n            }\n        }","originalFile":"//! Label commands for beads_zig.\n//!\n//! `bz label add <id> <labels...>` - Add labels to an issue\n//! `bz label remove <id> <labels...>` - Remove labels from an issue\n//! `bz label list <id>` - List labels on an issue\n//! `bz label list-all` - List all labels in the project\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\n\nconst CommandContext = common.CommandContext;\n\npub const LabelError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    IssueNotFound,\n    OutOfMemory,\n};\n\npub const LabelResult = struct {\n    success: bool,\n    id: ?[]const u8 = null,\n    labels: ?[]const []const u8 = null,\n    added: ?[]const []const u8 = null,\n    removed: ?[]const []const u8 = null,\n    old_name: ?[]const u8 = null,\n    new_name: ?[]const u8 = null,\n    renamed_count: ?usize = null,\n    message: ?[]const u8 = null,\n};\n\npub fn run(\n    label_args: args.LabelArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (label_args.subcommand) {\n        .add => |add| try runAdd(add.id, add.labels, global, allocator),\n        .remove => |remove| try runRemove(remove.id, remove.labels, global, allocator),\n        .list => |list| try runList(list.id, global, allocator),\n        .list_all => try runListAll(global, allocator),\n        .rename => |rename| try runRename(rename.old_name, rename.new_name, global, allocator),\n    }\n}\n\nfn runAdd(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var added_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer added_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if already has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (!has_label) {\n            try ctx.store.addLabel(id, label);\n            try added_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .added = added_labels.items,\n        });\n    } else if (global.quiet) {\n        for (added_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (added_labels.items.len > 0) {\n            try ctx.output.success(\"Added {d} label(s) to {s}\", .{ added_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No new labels added (already present)\", .{});\n        }\n    }\n}\n\nfn runRemove(\n    id: []const u8,\n    labels: []const []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    var removed_labels: std.ArrayListUnmanaged([]const u8) = .{};\n    defer removed_labels.deinit(allocator);\n\n    for (labels) |label| {\n        // Check if has label\n        const existing = try ctx.store.getLabels(id);\n        defer {\n            for (existing) |lbl| {\n                allocator.free(lbl);\n            }\n            allocator.free(existing);\n        }\n\n        var has_label = false;\n        for (existing) |existing_label| {\n            if (std.mem.eql(u8, existing_label, label)) {\n                has_label = true;\n                break;\n            }\n        }\n\n        if (has_label) {\n            try ctx.store.removeLabel(id, label);\n            try removed_labels.append(allocator, label);\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .removed = removed_labels.items,\n        });\n    } else if (global.quiet) {\n        for (removed_labels.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (removed_labels.items.len > 0) {\n            try ctx.output.success(\"Removed {d} label(s) from {s}\", .{ removed_labels.items.len, id });\n        } else {\n            try ctx.output.info(\"No labels removed (not present)\", .{});\n        }\n    }\n}\n\nfn runList(\n    id: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Verify issue exists\n    if (!try ctx.store.exists(id)) {\n        if (global.isStructuredOutput()) {\n            try ctx.output.printJson(LabelResult{\n                .success = false,\n                .id = id,\n                .message = \"issue not found\",\n            });\n        } else {\n            try ctx.output.err(\"issue not found: {s}\", .{id});\n        }\n        return LabelError.IssueNotFound;\n    }\n\n    const label_list = try ctx.store.getLabels(id);\n    defer {\n        for (label_list) |lbl| {\n            allocator.free(lbl);\n        }\n        allocator.free(label_list);\n    }\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .id = id,\n            .labels = label_list,\n        });\n    } else if (global.quiet) {\n        for (label_list) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.len == 0) {\n            try ctx.output.info(\"No labels on {s}\", .{id});\n        } else {\n            try ctx.output.println(\"Labels on {s} ({d}):\", .{ id, label_list.len });\n            for (label_list) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runListAll(\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Collect all unique labels across all issues\n    var all_labels: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var key_it = all_labels.keyIterator();\n        while (key_it.next()) |key| {\n            allocator.free(key.*);\n        }\n        all_labels.deinit(allocator);\n    }\n\n    for (ctx.store.issues.items) |issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        for (issue.labels) |label| {\n            if (!all_labels.contains(label)) {\n                const label_copy = try allocator.dupe(u8, label);\n                try all_labels.put(allocator, label_copy, {});\n            }\n        }\n    }\n\n    // Convert to sorted slice\n    var label_list: std.ArrayListUnmanaged([]const u8) = .{};\n    defer label_list.deinit(allocator);\n\n    var key_it = all_labels.keyIterator();\n    while (key_it.next()) |key| {\n        try label_list.append(allocator, key.*);\n    }\n\n    // Sort alphabetically\n    std.mem.sortUnstable([]const u8, label_list.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .labels = label_list.items,\n        });\n    } else if (global.quiet) {\n        for (label_list.items) |label| {\n            try ctx.output.print(\"{s}\\n\", .{label});\n        }\n    } else {\n        if (label_list.items.len == 0) {\n            try ctx.output.info(\"No labels in project\", .{});\n        } else {\n            try ctx.output.println(\"Labels ({d}):\", .{label_list.items.len});\n            for (label_list.items) |label| {\n                try ctx.output.print(\"  {s}\\n\", .{label});\n            }\n        }\n    }\n}\n\nfn runRename(\n    old_name: []const u8,\n    new_name: []const u8,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return LabelError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Count how many issues have this label renamed\n    var renamed_count: usize = 0;\n\n    // Iterate through all issues\n    for (ctx.store.issues.items) |*issue| {\n        if (issue.status.eql(.tombstone)) continue;\n\n        // Check if issue has the old label\n        var has_old_label = false;\n        var old_label_idx: usize = 0;\n        for (issue.labels, 0..) |label, idx| {\n            if (std.mem.eql(u8, label, old_name)) {\n                has_old_label = true;\n                old_label_idx = idx;\n                break;\n            }\n        }\n\n        if (has_old_label) {\n            // Check if it already has the new label (avoid duplicates)\n            var has_new_label = false;\n            for (issue.labels) |label| {\n                if (std.mem.eql(u8, label, new_name)) {\n                    has_new_label = true;\n                    break;\n                }\n            }\n\n            if (has_new_label) {\n                // Remove the old label (new label already exists)\n                try ctx.store.removeLabel(issue.id, old_name);\n            } else {\n                // Replace old label with new label in place\n                // First remove old, then add new\n                try ctx.store.removeLabel(issue.id, old_name);\n                try ctx.store.addLabel(issue.id, new_name);\n            }\n            renamed_count += 1;\n        }\n    }\n\n    try ctx.saveIfAutoFlush();\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(LabelResult{\n            .success = true,\n            .old_name = old_name,\n            .new_name = new_name,\n            .renamed_count = renamed_count,\n        });\n    } else if (global.quiet) {\n        try ctx.output.print(\"{d}\\n\", .{renamed_count});\n    } else {\n        if (renamed_count > 0) {\n            try ctx.output.success(\"Renamed label '{s}' to '{s}' on {d} issue(s)\", .{ old_name, new_name, renamed_count });\n        } else {\n            try ctx.output.info(\"No issues found with label '{s}'\", .{old_name});\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"LabelError enum exists\" {\n    const err: LabelError = LabelError.WorkspaceNotInitialized;\n    try std.testing.expect(err == LabelError.WorkspaceNotInitialized);\n}\n\ntest \"LabelResult struct works\" {\n    const result = LabelResult{\n        .success = true,\n        .id = \"bd-test\",\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"bd-test\", result.id.?);\n}\n\ntest \"runAdd detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n    const labels = [_][]const u8{\"test\"};\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .add = .{ .id = \"bd-test\", .labels = &labels } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runList detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list = .{ .id = \"bd-test\" } },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n\ntest \"runListAll detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const label_args = args.LabelArgs{\n        .subcommand = .{ .list_all = {} },\n    };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(label_args, global, allocator);\n    try std.testing.expectError(LabelError.WorkspaceNotInitialized, result);\n}\n","structuredPatch":[{"oldStart":331,"oldLines":11,"newStart":331,"newLines":9,"lines":[" ","         // Check if issue has the old label","         var has_old_label = false;","-        var old_label_idx: usize = 0;","-        for (issue.labels, 0..) |label, idx| {","+        for (issue.labels) |label| {","             if (std.mem.eql(u8, label, old_name)) {","                 has_old_label = true;","-                old_label_idx = idx;","                 break;","             }","         }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01S1aLBtnin311uiuRw3rfij","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Wd9PeuV4LM3UeHww3ZdY9n","name":"TodoWrite","input":{"todos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"in_progress","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing simplification changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":381,"cache_read_input_tokens":66491,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":381},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"5b754b99-551e-4582-9994-706ca1c858d0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Wd9PeuV4LM3UeHww3ZdY9n","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"b103229f-b677-4335-89b6-ba3f568c7f4a","tool_use_result":{"oldTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"in_progress","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing simplification changes"}],"newTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"in_progress","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing simplification changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GuMkuJ4mzuGt8LUUwbvAW4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KPvVSG6vMFakxXk5WaWATC","name":"Bash","input":{"command":"zig build test 2>&1 | tail -20","description":"Run tests to verify simplification didn't break anything"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":234,"cache_read_input_tokens":66872,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":234},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"393e19d2-34d9-4223-a2c2-b5bcd4b4e88f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KPvVSG6vMFakxXk5WaWATC","type":"tool_result","content":"658/669 tests.cli_test.test.bz dep add creates dependency...OK\n659/669 tests.cli_test.test.bz dep add rejects cycles...OK\n660/669 tests.cli_test.test.bz ready shows unblocked issues...OK\n661/669 tests.cli_test.test.bz blocked shows blocked issues...OK\n662/669 tests.cli_test.test.bz unknown command returns error...OK\n663/669 tests.cli_test.test.bz without workspace shows error...OK\n664/669 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n665/669 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n666/669 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n667/669 tests.stress_test.test.sequential writes: single thread baseline...OK\n668/669 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n669/669 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 669 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"e33319d4-e6aa-4924-bf85-8187d1db3cdb","tool_use_result":{"stdout":"658/669 tests.cli_test.test.bz dep add creates dependency...OK\n659/669 tests.cli_test.test.bz dep add rejects cycles...OK\n660/669 tests.cli_test.test.bz ready shows unblocked issues...OK\n661/669 tests.cli_test.test.bz blocked shows blocked issues...OK\n662/669 tests.cli_test.test.bz unknown command returns error...OK\n663/669 tests.cli_test.test.bz without workspace shows error...OK\n664/669 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n665/669 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n666/669 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 72 issues created\nOK\n667/669 tests.stress_test.test.sequential writes: single thread baseline...OK\n668/669 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n669/669 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 669 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Tee3bQavGUKA7bDStrUbNT","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Let me check git diff to see what we're committing."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":430,"cache_read_input_tokens":67106,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":430},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"7bed53da-f189-438c-b473-ff66f6ba1c6c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Tee3bQavGUKA7bDStrUbNT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SHgiy6NtaZo6HgrjHh29QW","name":"Bash","input":{"command":"git diff src/","description":"Check diff of source changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":430,"cache_read_input_tokens":67106,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":430},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"a3fae4c9-1b8e-4bab-9dd1-c177a75d5aff"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SHgiy6NtaZo6HgrjHh29QW","type":"tool_result","content":"diff --git a/src/cli/label.zig b/src/cli/label.zig\nindex a123004..e9a2f0f 100644\n--- a/src/cli/label.zig\n+++ b/src/cli/label.zig\n@@ -331,11 +331,9 @@ fn runRename(\n \n         // Check if issue has the old label\n         var has_old_label = false;\n-        var old_label_idx: usize = 0;\n-        for (issue.labels, 0..) |label, idx| {\n+        for (issue.labels) |label| {\n             if (std.mem.eql(u8, label, old_name)) {\n                 has_old_label = true;\n-                old_label_idx = idx;\n                 break;\n             }\n         }","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"af4a91d7-d95d-4723-8715-3235f9f92981","tool_use_result":{"stdout":"diff --git a/src/cli/label.zig b/src/cli/label.zig\nindex a123004..e9a2f0f 100644\n--- a/src/cli/label.zig\n+++ b/src/cli/label.zig\n@@ -331,11 +331,9 @@ fn runRename(\n \n         // Check if issue has the old label\n         var has_old_label = false;\n-        var old_label_idx: usize = 0;\n-        for (issue.labels, 0..) |label, idx| {\n+        for (issue.labels) |label| {\n             if (std.mem.eql(u8, label, old_name)) {\n                 has_old_label = true;\n-                old_label_idx = idx;\n                 break;\n             }\n         }","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015PvLcecPChstxbcxMdxssx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A7aV94dAne8yqbBfiftaAi","name":"TodoWrite","input":{"todos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"in_progress","activeForm":"Committing simplification changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":315,"cache_read_input_tokens":67536,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":315},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"b798d207-7a15-4e35-92dd-feea6274b1ad"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A7aV94dAne8yqbBfiftaAi","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"88d7af30-8e78-4b5a-9ea7-7b05727e7085","tool_use_result":{"oldTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"in_progress","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing simplification changes"}],"newTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"in_progress","activeForm":"Committing simplification changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0113AdywGEP2esRTZYxUpJ2W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RFTMgxD7z4EN2RDBRehQyS","name":"Bash","input":{"command":"git log --oneline -5","description":"Check recent commit style"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":234,"cache_read_input_tokens":67851,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":234},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"09244ea0-26ce-42cb-a35e-88284e4ac258"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RFTMgxD7z4EN2RDBRehQyS","type":"tool_result","content":"c83e1d7 feat(cli): add dep enhancements and label rename command\n59a6295 Plan mode: complete 2 tasks\nbc77fd8 refactor(delete): extract duplicate output patterns into helpers\n895d523 feat(cli): add --robot output mode and delete command enhancements\na43d90d Plan mode: complete 2 tasks","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"b9b76679-34fa-4018-94ff-25dd577865be","tool_use_result":{"stdout":"c83e1d7 feat(cli): add dep enhancements and label rename command\n59a6295 Plan mode: complete 2 tasks\nbc77fd8 refactor(delete): extract duplicate output patterns into helpers\n895d523 feat(cli): add --robot output mode and delete command enhancements\na43d90d Plan mode: complete 2 tasks","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TvskxWAe363krK82HXFKyr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NxQUVRpAauAw4dAQeCh26D","name":"Bash","input":{"command":"git add src/cli/label.zig && git commit -m \"$(cat <<'EOF'\nrefactor(label): remove unused variable in rename function\n\nThe old_label_idx variable was set but never used since label removal\nis done by name rather than index.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the simplification"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":175,"cache_read_input_tokens":68085,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":175},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"5d79ac74-0154-4488-bfad-44c0bce2e287"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NxQUVRpAauAw4dAQeCh26D","type":"tool_result","content":"[dev-hotschmoe 58dae39] refactor(label): remove unused variable in rename function\n 1 file changed, 1 insertion(+), 3 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"cd910964-4217-4dc8-9fee-f719302c1ec2","tool_use_result":{"stdout":"[dev-hotschmoe 58dae39] refactor(label): remove unused variable in rename function\n 1 file changed, 1 insertion(+), 3 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01N5PJ7EsP2894LEr1vmM1HF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018TfSqw65neWfbdWQPfKkKY","name":"TodoWrite","input":{"todos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"completed","activeForm":"Committing simplification changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":216,"cache_read_input_tokens":68260,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":216},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"89654046-af72-4a06-860a-fb46882448df"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018TfSqw65neWfbdWQPfKkKY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"3142c5f1-0de9-46b7-a0a9-098d6301023d","tool_use_result":{"oldTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"in_progress","activeForm":"Committing simplification changes"}],"newTodos":[{"content":"Identify code simplification opportunities in modified files","status":"completed","activeForm":"Identifying code simplification opportunities"},{"content":"Apply simplification: remove unused old_label_idx variable in label.zig","status":"completed","activeForm":"Removing unused variable in label.zig"},{"content":"Run tests to verify changes don't break functionality","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"completed","activeForm":"Committing simplification changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VpWKJVhxuEabrm3fQJEgAY","type":"message","role":"assistant","content":[{"type":"text","text":"Code review and simplification complete.\n\n**Summary:**\n\nReviewed the code changes from the \"Plan mode batch\" task across these files:\n- `src/cli/args.zig` - New flags (--robot, --cascade, --hard, --dry-run), new enums (DepDirection, TreeFormat), new subcommands\n- `src/cli/delete.zig` - Batch delete, cascade delete, hard delete, dry-run mode\n- `src/cli/dep.zig` - Direction filtering, metadata support, Mermaid tree output\n- `src/cli/label.zig` - Label rename command\n- `src/cli/close.zig` - Robot output mode\n- `src/cli/common.zig` - Robot mode propagation\n- `src/output/mod.zig` - Robot output mode\n- `src/storage/store.zig` - Hard delete (remove) function\n\n**Simplification applied:**\n- Removed unused `old_label_idx` variable in `label.zig:runRename()` - the variable was being set but never used since label removal is done by name, not by index.\n\nAll 669 tests pass after the change."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":68476,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":232},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","uuid":"ddad695d-a341-44ab-85fb-c5e068d02419"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":90689,"duration_api_ms":90015,"num_turns":19,"result":"Code review and simplification complete.\n\n**Summary:**\n\nReviewed the code changes from the \"Plan mode batch\" task across these files:\n- `src/cli/args.zig` - New flags (--robot, --cascade, --hard, --dry-run), new enums (DepDirection, TreeFormat), new subcommands\n- `src/cli/delete.zig` - Batch delete, cascade delete, hard delete, dry-run mode\n- `src/cli/dep.zig` - Direction filtering, metadata support, Mermaid tree output\n- `src/cli/label.zig` - Label rename command\n- `src/cli/close.zig` - Robot output mode\n- `src/cli/common.zig` - Robot mode propagation\n- `src/output/mod.zig` - Robot output mode\n- `src/storage/store.zig` - Hard delete (remove) function\n\n**Simplification applied:**\n- Removed unused `old_label_idx` variable in `label.zig:runRename()` - the variable was being set but never used since label removal is done by name, not by index.\n\nAll 669 tests pass after the change.","session_id":"d965594a-b540-4605-8ceb-7e84a6081b47","total_cost_usd":0.8349405,"usage":{"input_tokens":2,"cache_creation_input_tokens":50732,"cache_read_input_tokens":836726,"output_tokens":2770,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":50732,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":2770,"cacheReadInputTokens":836726,"cacheCreationInputTokens":50732,"webSearchRequests":0,"costUSD":0.804698,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":8940,"outputTokens":380,"cacheReadInputTokens":0,"cacheCreationInputTokens":15522,"webSearchRequests":0,"costUSD":0.030242500000000005,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"6a78b0f7-657f-4f60-958c-d2cacb7319d1"}
