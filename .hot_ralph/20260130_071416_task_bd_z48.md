I'll implement the SQLite connection wrapper for beads_zig. Let me start by exploring the existing project structure to understand what's already in place.Let me read the existing storage/mod.zig and root.zig to understand the current structure.Now I have a good understanding of the project structure. I need to:
1. Create `src/storage/sqlite.zig` with the SQLite connection wrapper
2. Update `src/storage/mod.zig` to export the Database, Statement, and transaction

Let me also check how the build.zig handles SQLite include paths - I need to understand how to properly import the C SQLite header.Now let me create the SQLite wrapper. I'll need to modify the build.zig to properly set up SQLite C imports for the library module as well, since currently it only sets up linking for exe and test targets, not the module itself.Now let me update the storage/mod.zig to export the sqlite module.Now let me run the tests to validate the implementation.I need to fix the type for the error message parameter. The sqlite3_exec expects a `[*c][*c]u8` (C-style pointer to pointer), not a pointer to optional slice.All tests pass. Let me also run the tests with verbose output to confirm all the sqlite tests are running.There's a flaky test failure in `id.generator.test.generated IDs are unique` - this is an unrelated pre-existing test that has a collision issue. This is not related to my SQLite implementation. Let me run the tests again to confirm it's flaky.This is a pre-existing bug in the ID generator test - it's generating collisions with a short 3-character hash. Let me check if this is a known issue and run only the sqlite tests to confirm my implementation works.The sqlite tests pass. Let me also run tests filtered to storage module to see all our tests.The test filter isn't working as expected - it seems to be running all tests. Let me check the id/generator.zig to see the flaky test - this is a pre-existing issue unrelated to my implementation.I see - there's a pre-existing issue with the ID generator test. With 3-character hashes (36^3 = 46,656 possibilities), even with 100 iterations, collisions can happen due to poor randomness or seed issues. This is unrelated to my SQLite implementation.

Let me verify my specific tests work by looking at what happens with the sqlite filter:All 8 SQLite tests pass. The pre-existing ID generator test failure is unrelated to this task.Now let me commit the changes with the appropriate message.The task is complete. Here's a summary:

**Implemented SQLite connection wrapper** in `src/storage/sqlite.zig`:

- **Database struct**: Connection management with automatic PRAGMA configuration (WAL mode, foreign keys, 5s busy timeout)
- **Statement struct**: Prepared statement with bind functions (`bindText`, `bindInt`, `bindInt32`, `bindNull`, `bindOptionalInt`, `bindOptionalInt32`) and column getters (`columnText`, `columnInt`, `columnInt32`, `columnOptionalInt`, `columnOptionalInt32`, `columnBool`)
- **Transaction helpers**: `transaction()` (with context) and `transactionSimple()` for automatic commit/rollback
- **Error handling**: `SqliteError` enum with `OpenFailed`, `PrepareFailed`, `BindFailed`, `StepFailed`, `ExecuteFailed`, `BusyTimeout`, `Corrupt`

**8 passing tests** covering:
1. Database open/close in-memory
2. Exec creates table
3. Statement prepare, bind, and step
4. Bind null and columnOptionalInt
5. Statement reset allows reuse
6. Transaction commits on success
7. Transaction rolls back on error
8. PRAGMA settings applied correctly

**Note**: There's a pre-existing flaky test in `id/generator.zig` (`generated IDs are unique`) that occasionally fails due to collisions with 3-character hashes. This is unrelated to this implementation.