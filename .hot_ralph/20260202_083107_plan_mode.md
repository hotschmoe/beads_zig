{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"ba0cbf74-03e4-44a6-8524-ca67107316b3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GgirG8Kq8P24jHhw8FL8BN","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement these two tasks in order. Let me start by exploring the codebase to understand the current structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20933,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20933},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c8340e5c-b24c-4408-a648-a91111da188a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GgirG8Kq8P24jHhw8FL8BN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fpwdjj1VVCX4knwkFECkcs","name":"Task","input":{"subagent_type":"Explore","prompt":"I need to implement two features in beads_zig:\n1. Add --parent and --recursive filters for hierarchy filtering\n2. Add CSV output format with --fields option\n\nPlease help me understand:\n1. How CLI arguments are parsed (look at src/cli/args.zig)\n2. How list/ready commands work (look at src/cli/ for list.zig, ready.zig)\n3. How output formatting works (look at src/output/)\n4. How the dependency graph tracks parent-child relationships (look at src/storage/graph.zig)\n5. What existing filter patterns exist that I can follow\n\nBe thorough and provide file paths and key code structures."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20933,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20933},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"deba4fac-2b50-47ee-9a3c-1a0394fc60f7"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>InputValidationError: Task failed due to the following issue:\nThe required parameter `description` is missing</tool_use_error>","is_error":true,"tool_use_id":"toolu_01Fpwdjj1VVCX4knwkFECkcs"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"fce27268-76f7-4b05-859f-2a64da3da472","tool_use_result":"InputValidationError: [\n  {\n    \"expected\": \"string\",\n    \"code\": \"invalid_type\",\n    \"path\": [\n      \"description\"\n    ],\n    \"message\": \"Invalid input: expected string, received undefined\"\n  }\n]"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017bCPpiFhfC266upXziwHCA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","name":"Task","input":{"description":"Explore codebase structure","subagent_type":"Explore","prompt":"I need to implement two features in beads_zig:\n1. Add --parent and --recursive filters for hierarchy filtering\n2. Add CSV output format with --fields option\n\nPlease help me understand:\n1. How CLI arguments are parsed (look at src/cli/args.zig)\n2. How list/ready commands work (look at src/cli/ for list.zig, ready.zig)\n3. How output formatting works (look at src/output/)\n4. How the dependency graph tracks parent-child relationships (look at src/storage/graph.zig)\n5. What existing filter patterns exist that I can follow\n\nBe thorough and provide file paths and key code structures."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":305,"cache_read_input_tokens":38909,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":305},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1940a68f-9d60-4517-a502-15e9da79a2ab"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"I need to implement two features in beads_zig:\n1. Add --parent and --recursive filters for hierarchy filtering\n2. Add CSV output format with --fields option\n\nPlease help me understand:\n1. How CLI arguments are parsed (look at src/cli/args.zig)\n2. How list/ready commands work (look at src/cli/ for list.zig, ready.zig)\n3. How output formatting works (look at src/output/)\n4. How the dependency graph tracks parent-child relationships (look at src/storage/graph.zig)\n5. What existing filter patterns exist that I can follow\n\nBe thorough and provide file paths and key code structures."}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7f277ebe-dbd5-4aa0-ad7b-a28a822d0fb0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EaxUMMorVHjqNfzoswvyGa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YMJDfanCvS2uJBht8LBefd","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3964,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3964},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2673c466-77ee-4a5d-b5e8-2723289f1adc"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EaxUMMorVHjqNfzoswvyGa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RjBFK4tnVfmyQhmQmMhpgr","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3964,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3964},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b72d842f-8280-47a7-a976-d2c75f942a09"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (27174 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01YMJDfanCvS2uJBht8LBefd"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"9025f3e1-d148-4767-a783-fada330f8c0d","tool_use_result":"Error: File content (27174 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RjBFK4tnVfmyQhmQmMhpgr","type":"tool_result","content":"     1→//! Dependency graph operations for beads_zig.\n     2→//!\n     3→//! Provides dependency management including:\n     4→//! - Add/remove dependencies\n     5→//! - Cycle detection (DFS algorithm)\n     6→//! - Query dependencies and dependents\n     7→//! - Ready/blocked issue queries\n     8→\n     9→const std = @import(\"std\");\n    10→const store_mod = @import(\"store.zig\");\n    11→const IssueStore = store_mod.IssueStore;\n    12→const Issue = @import(\"../models/issue.zig\").Issue;\n    13→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    14→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    15→const Status = @import(\"../models/status.zig\").Status;\n    16→\n    17→pub const DependencyGraphError = error{\n    18→    SelfDependency,\n    19→    CycleDetected,\n    20→    DependencyNotFound,\n    21→    IssueNotFound,\n    22→};\n    23→\n    24→pub const DependencyGraph = struct {\n    25→    store: *IssueStore,\n    26→    allocator: std.mem.Allocator,\n    27→\n    28→    const Self = @This();\n    29→\n    30→    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n    31→        return .{\n    32→            .store = store,\n    33→            .allocator = allocator,\n    34→        };\n    35→    }\n    36→\n    37→    /// Add a dependency (issue_id depends on depends_on_id).\n    38→    /// Returns error.SelfDependency if trying to depend on self.\n    39→    /// Returns error.CycleDetected if adding would create a cycle.\n    40→    pub fn addDependency(self: *Self, dep: Dependency) !void {\n    41→        // Check for self-dependency\n    42→        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n    43→            return DependencyGraphError.SelfDependency;\n    44→        }\n    45→\n    46→        // Check if issue exists\n    47→        const issue = self.store.getRef(dep.issue_id) orelse\n    48→            return DependencyGraphError.IssueNotFound;\n    49→\n    50→        // Check for cycles before inserting\n    51→        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n    52→            return DependencyGraphError.CycleDetected;\n    53→        }\n    54→\n    55→        // Check if dependency already exists\n    56→        for (issue.dependencies) |existing| {\n    57→            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n    58→                return; // Already exists, no-op\n    59→            }\n    60→        }\n    61→\n    62→        // Clone and add the dependency\n    63→        const cloned = try cloneDependency(dep, self.allocator);\n    64→        errdefer freeDependency(@constCast(&cloned), self.allocator);\n    65→\n    66→        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n    67→        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n    68→        new_deps[issue.dependencies.len] = cloned;\n    69→\n    70→        // Only free the old array, not the dependency contents (they're now in new_deps)\n    71→        if (issue.dependencies.len > 0) {\n    72→            self.allocator.free(issue.dependencies);\n    73→        }\n    74→        issue.dependencies = new_deps;\n    75→\n    76→        try self.store.markDirty(dep.issue_id);\n    77→    }\n    78→\n    79→    /// Remove a dependency.\n    80→    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n    81→        const issue = self.store.getRef(issue_id) orelse\n    82→            return DependencyGraphError.IssueNotFound;\n    83→\n    84→        var found_idx: ?usize = null;\n    85→        for (issue.dependencies, 0..) |dep, i| {\n    86→            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n    87→                found_idx = i;\n    88→                break;\n    89→            }\n    90→        }\n    91→\n    92→        if (found_idx) |fi| {\n    93→            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n    94→\n    95→            if (issue.dependencies.len == 1) {\n    96→                self.allocator.free(issue.dependencies);\n    97→                issue.dependencies = &[_]Dependency{};\n    98→            } else {\n    99→                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n   100→                var j: usize = 0;\n   101→                for (issue.dependencies, 0..) |dep, i| {\n   102→                    if (i != fi) {\n   103→                        new_deps[j] = dep;\n   104→                        j += 1;\n   105→                    }\n   106→                }\n   107→                self.allocator.free(issue.dependencies);\n   108→                issue.dependencies = new_deps;\n   109→            }\n   110→\n   111→            try self.store.markDirty(issue_id);\n   112→        }\n   113→    }\n   114→\n   115→    /// Get dependencies for an issue (what it depends on).\n   116→    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n   117→        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n   118→\n   119→        if (issue.dependencies.len == 0) return &[_]Dependency{};\n   120→\n   121→        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n   122→        errdefer self.allocator.free(deps);\n   123→\n   124→        for (issue.dependencies, 0..) |dep, i| {\n   125→            deps[i] = try cloneDependency(dep, self.allocator);\n   126→        }\n   127→\n   128→        return deps;\n   129→    }\n   130→\n   131→    /// Get dependents of an issue (what depends on it).\n   132→    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n   133→        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n   134→        errdefer {\n   135→            for (deps.items) |*dep| {\n   136→                freeDependency(dep, self.allocator);\n   137→            }\n   138→            deps.deinit(self.allocator);\n   139→        }\n   140→\n   141→        for (self.store.getAllRef()) |issue| {\n   142→            for (issue.dependencies) |dep| {\n   143→                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n   144→                    const cloned = try cloneDependency(dep, self.allocator);\n   145→                    try deps.append(self.allocator, cloned);\n   146→                }\n   147→            }\n   148→        }\n   149→\n   150→        return deps.toOwnedSlice(self.allocator);\n   151→    }\n   152→\n   153→    /// Check if adding a dependency would create a cycle.\n   154→    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n   155→    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n   156→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   157→        defer {\n   158→            var key_it = visited.keyIterator();\n   159→            while (key_it.next()) |key| {\n   160→                self.allocator.free(key.*);\n   161→            }\n   162→            visited.deinit(self.allocator);\n   163→        }\n   164→\n   165→        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n   166→    }\n   167→\n   168→    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n   169→        if (std.mem.eql(u8, from, target)) return true;\n   170→        if (visited.contains(from)) return false;\n   171→\n   172→        const from_copy = try self.allocator.dupe(u8, from);\n   173→        errdefer self.allocator.free(from_copy);\n   174→        try visited.put(self.allocator, from_copy, {});\n   175→\n   176→        const issue = self.store.getRef(from) orelse return false;\n   177→\n   178→        for (issue.dependencies) |dep| {\n   179→            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n   180→                return true;\n   181→            }\n   182→        }\n   183→        return false;\n   184→    }\n   185→\n   186→    /// Detect all cycles in the dependency graph.\n   187→    /// Returns array of cycle paths, or null if no cycles.\n   188→    pub fn detectCycles(self: *Self) !?[][]const u8 {\n   189→        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n   190→        defer {\n   191→            var it = all_issues.keyIterator();\n   192→            while (it.next()) |key| {\n   193→                self.allocator.free(key.*);\n   194→            }\n   195→            all_issues.deinit(self.allocator);\n   196→        }\n   197→\n   198→        // Collect all issue IDs involved in dependencies\n   199→        for (self.store.getAllRef()) |issue| {\n   200→            if (issue.dependencies.len > 0) {\n   201→                if (!all_issues.contains(issue.id)) {\n   202→                    const id_copy = try self.allocator.dupe(u8, issue.id);\n   203→                    try all_issues.put(self.allocator, id_copy, {});\n   204→                }\n   205→                for (issue.dependencies) |dep| {\n   206→                    if (!all_issues.contains(dep.depends_on_id)) {\n   207→                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n   208→                        try all_issues.put(self.allocator, id_copy, {});\n   209→                    }\n   210→                }\n   211→            }\n   212→        }\n   213→\n   214→        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n   215→        errdefer {\n   216→            for (cycles.items) |c| {\n   217→                self.allocator.free(c);\n   218→            }\n   219→            cycles.deinit(self.allocator);\n   220→        }\n   221→\n   222→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   223→        defer visited.deinit(self.allocator);\n   224→\n   225→        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n   226→        defer rec_stack.deinit(self.allocator);\n   227→\n   228→        var it = all_issues.keyIterator();\n   229→        while (it.next()) |key| {\n   230→            if (!visited.contains(key.*)) {\n   231→                var path: std.ArrayListUnmanaged([]const u8) = .{};\n   232→                defer path.deinit(self.allocator);\n   233→\n   234→                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n   235→                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n   236→                    try cycles.append(self.allocator, cycle_str);\n   237→                }\n   238→            }\n   239→        }\n   240→\n   241→        if (cycles.items.len == 0) {\n   242→            return null;\n   243→        }\n   244→\n   245→        return try cycles.toOwnedSlice(self.allocator);\n   246→    }\n   247→\n   248→    fn detectCycleDfs(\n   249→        self: *Self,\n   250→        node: []const u8,\n   251→        visited: *std.StringHashMapUnmanaged(void),\n   252→        rec_stack: *std.StringHashMapUnmanaged(void),\n   253→        path: *std.ArrayListUnmanaged([]const u8),\n   254→    ) !bool {\n   255→        try visited.put(self.allocator, node, {});\n   256→        try rec_stack.put(self.allocator, node, {});\n   257→        try path.append(self.allocator, node);\n   258→\n   259→        const issue = self.store.getRef(node) orelse {\n   260→            _ = path.pop();\n   261→            _ = rec_stack.remove(node);\n   262→            return false;\n   263→        };\n   264→\n   265→        for (issue.dependencies) |dep| {\n   266→            if (!visited.contains(dep.depends_on_id)) {\n   267→                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n   268→                    return true;\n   269→                }\n   270→            } else if (rec_stack.contains(dep.depends_on_id)) {\n   271→                try path.append(self.allocator, dep.depends_on_id);\n   272→                return true;\n   273→            }\n   274→        }\n   275→\n   276→        _ = rec_stack.remove(node);\n   277→        _ = path.pop();\n   278→        return false;\n   279→    }\n   280→\n   281→    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n   282→    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n   283→        const now = std.time.timestamp();\n   284→\n   285→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   286→        errdefer {\n   287→            for (results.items) |*issue| {\n   288→                issue.deinit(self.allocator);\n   289→            }\n   290→            results.deinit(self.allocator);\n   291→        }\n   292→\n   293→        for (self.store.getAllRef()) |issue| {\n   294→            // Must be open (or deferred if include_deferred is set)\n   295→            if (statusEql(issue.status, .deferred)) {\n   296→                if (!include_deferred) continue;\n   297→            } else if (!statusEql(issue.status, .open)) {\n   298→                continue;\n   299→            }\n   300→\n   301→            // Must not be deferred to future (unless including deferred)\n   302→            if (!include_deferred) {\n   303→                if (issue.defer_until.value) |defer_time| {\n   304→                    if (defer_time > now) continue;\n   305→                }\n   306→            }\n   307→\n   308→            // Must not have any open blockers\n   309→            var has_open_blocker = false;\n   310→            for (issue.dependencies) |dep| {\n   311→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   312→                    if (!statusEql(blocker.status, .closed) and\n   313→                        !statusEql(blocker.status, .tombstone))\n   314→                    {\n   315→                        has_open_blocker = true;\n   316→                        break;\n   317→                    }\n   318→                }\n   319→            }\n   320→            if (has_open_blocker) continue;\n   321→\n   322→            try results.append(self.allocator, try issue.clone(self.allocator));\n   323→        }\n   324→\n   325→        // Sort by priority then created_at\n   326→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   327→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   328→                if (a.priority.value != b.priority.value) {\n   329→                    return a.priority.value < b.priority.value;\n   330→                }\n   331→                return a.created_at.value < b.created_at.value;\n   332→            }\n   333→        }.lessThan);\n   334→\n   335→        return results.toOwnedSlice(self.allocator);\n   336→    }\n   337→\n   338→    /// Get all blocked issues (open issues with unresolved dependencies).\n   339→    pub fn getBlockedIssues(self: *Self) ![]Issue {\n   340→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   341→        errdefer {\n   342→            for (results.items) |*issue| {\n   343→                issue.deinit(self.allocator);\n   344→            }\n   345→            results.deinit(self.allocator);\n   346→        }\n   347→\n   348→        for (self.store.getAllRef()) |issue| {\n   349→            // Must be open\n   350→            if (!statusEql(issue.status, .open)) continue;\n   351→\n   352→            // Must have at least one open blocker\n   353→            var has_open_blocker = false;\n   354→            for (issue.dependencies) |dep| {\n   355→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   356→                    if (!statusEql(blocker.status, .closed) and\n   357→                        !statusEql(blocker.status, .tombstone))\n   358→                    {\n   359→                        has_open_blocker = true;\n   360→                        break;\n   361→                    }\n   362→                }\n   363→            }\n   364→            if (!has_open_blocker) continue;\n   365→\n   366→            try results.append(self.allocator, try issue.clone(self.allocator));\n   367→        }\n   368→\n   369→        // Sort by priority then created_at\n   370→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   371→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   372→                if (a.priority.value != b.priority.value) {\n   373→                    return a.priority.value < b.priority.value;\n   374→                }\n   375→                return a.created_at.value < b.created_at.value;\n   376→            }\n   377→        }.lessThan);\n   378→\n   379→        return results.toOwnedSlice(self.allocator);\n   380→    }\n   381→\n   382→    /// Get blockers for an issue (open issues that this issue depends on).\n   383→    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n   384→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   385→        errdefer {\n   386→            for (results.items) |*issue| {\n   387→                issue.deinit(self.allocator);\n   388→            }\n   389→            results.deinit(self.allocator);\n   390→        }\n   391→\n   392→        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n   393→\n   394→        for (issue.dependencies) |dep| {\n   395→            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   396→                if (!statusEql(blocker.status, .closed) and\n   397→                    !statusEql(blocker.status, .tombstone))\n   398→                {\n   399→                    try results.append(self.allocator, try blocker.clone(self.allocator));\n   400→                }\n   401→            }\n   402→        }\n   403→\n   404→        return results.toOwnedSlice(self.allocator);\n   405→    }\n   406→\n   407→    /// Free an array of dependencies.\n   408→    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n   409→        for (deps) |*dep| {\n   410→            freeDependency(dep, self.allocator);\n   411→        }\n   412→        self.allocator.free(deps);\n   413→    }\n   414→\n   415→    /// Free an array of issues.\n   416→    pub fn freeIssues(self: *Self, issues: []Issue) void {\n   417→        for (issues) |*issue| {\n   418→            issue.deinit(self.allocator);\n   419→        }\n   420→        self.allocator.free(issues);\n   421→    }\n   422→\n   423→    /// Free an array of cycle strings.\n   424→    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n   425→        for (cycles) |c| {\n   426→            self.allocator.free(c);\n   427→        }\n   428→        self.allocator.free(cycles);\n   429→    }\n   430→};\n   431→\n   432→// Helper functions\n   433→fn statusEql(a: Status, b: Status) bool {\n   434→    const Tag = std.meta.Tag(Status);\n   435→    const tag_a: Tag = a;\n   436→    const tag_b: Tag = b;\n   437→    if (tag_a != tag_b) return false;\n   438→    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n   439→}\n   440→\n   441→fn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n   442→    var result: Dependency = undefined;\n   443→\n   444→    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n   445→    errdefer allocator.free(result.issue_id);\n   446→\n   447→    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n   448→    errdefer allocator.free(result.depends_on_id);\n   449→\n   450→    result.dep_type = switch (dep.dep_type) {\n   451→        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n   452→        else => dep.dep_type,\n   453→    };\n   454→\n   455→    result.created_at = dep.created_at;\n   456→    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n   457→    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n   458→    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n   459→\n   460→    return result;\n   461→}\n   462→\n   463→fn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n   464→    allocator.free(dep.issue_id);\n   465→    allocator.free(dep.depends_on_id);\n   466→    switch (dep.dep_type) {\n   467→        .custom => |s| allocator.free(s),\n   468→        else => {},\n   469→    }\n   470→    if (dep.created_by) |c| allocator.free(c);\n   471→    if (dep.metadata) |m| allocator.free(m);\n   472→    if (dep.thread_id) |t| allocator.free(t);\n   473→}\n   474→\n   475→// --- Tests ---\n   476→\n   477→test \"DependencyGraph rejects self-dependency\" {\n   478→    const allocator = std.testing.allocator;\n   479→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   480→    defer store.deinit();\n   481→\n   482→    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n   483→\n   484→    var graph = DependencyGraph.init(&store, allocator);\n   485→\n   486→    const dep = Dependency{\n   487→        .issue_id = \"bd-self\",\n   488→        .depends_on_id = \"bd-self\",\n   489→        .dep_type = .blocks,\n   490→        .created_at = 1706540000,\n   491→        .created_by = null,\n   492→        .metadata = null,\n   493→        .thread_id = null,\n   494→    };\n   495→\n   496→    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n   497→}\n   498→\n   499→test \"DependencyGraph rejects direct cycle\" {\n   500→    const allocator = std.testing.allocator;\n   501→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   502→    defer store.deinit();\n   503→\n   504→    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n   505→    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n   506→\n   507→    var graph = DependencyGraph.init(&store, allocator);\n   508→\n   509→    // A depends on B\n   510→    try graph.addDependency(.{\n   511→        .issue_id = \"bd-a\",\n   512→        .depends_on_id = \"bd-b\",\n   513→        .dep_type = .blocks,\n   514→        .created_at = 1706540000,\n   515→        .created_by = null,\n   516→        .metadata = null,\n   517→        .thread_id = null,\n   518→    });\n   519→\n   520→    // B depends on A would create a cycle\n   521→    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n   522→        .issue_id = \"bd-b\",\n   523→        .depends_on_id = \"bd-a\",\n   524→        .dep_type = .blocks,\n   525→        .created_at = 1706540000,\n   526→        .created_by = null,\n   527→        .metadata = null,\n   528→        .thread_id = null,\n   529→    }));\n   530→}\n   531→\n   532→test \"DependencyGraph rejects indirect cycle\" {\n   533→    const allocator = std.testing.allocator;\n   534→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   535→    defer store.deinit();\n   536→\n   537→    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n   538→    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n   539→    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n   540→\n   541→    var graph = DependencyGraph.init(&store, allocator);\n   542→\n   543→    // A depends on B\n   544→    try graph.addDependency(.{\n   545→        .issue_id = \"bd-a\",\n   546→        .depends_on_id = \"bd-b\",\n   547→        .dep_type = .blocks,\n   548→        .created_at = 1706540000,\n   549→        .created_by = null,\n   550→        .metadata = null,\n   551→        .thread_id = null,\n   552→    });\n   553→\n   554→    // B depends on C\n   555→    try graph.addDependency(.{\n   556→        .issue_id = \"bd-b\",\n   557→        .depends_on_id = \"bd-c\",\n   558→        .dep_type = .blocks,\n   559→        .created_at = 1706540000,\n   560→        .created_by = null,\n   561→        .metadata = null,\n   562→        .thread_id = null,\n   563→    });\n   564→\n   565→    // C depends on A would create a cycle\n   566→    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n   567→        .issue_id = \"bd-c\",\n   568→        .depends_on_id = \"bd-a\",\n   569→        .dep_type = .blocks,\n   570→        .created_at = 1706540000,\n   571→        .created_by = null,\n   572→        .metadata = null,\n   573→        .thread_id = null,\n   574→    }));\n   575→}\n   576→\n   577→test \"DependencyGraph getReadyIssues excludes blocked\" {\n   578→    const allocator = std.testing.allocator;\n   579→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   580→    defer store.deinit();\n   581→\n   582→    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n   583→    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n   584→    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n   585→\n   586→    var graph = DependencyGraph.init(&store, allocator);\n   587→\n   588→    try graph.addDependency(.{\n   589→        .issue_id = \"bd-blocked\",\n   590→        .depends_on_id = \"bd-blocker\",\n   591→        .dep_type = .blocks,\n   592→        .created_at = 1706540000,\n   593→        .created_by = null,\n   594→        .metadata = null,\n   595→        .thread_id = null,\n   596→    });\n   597→\n   598→    const ready = try graph.getReadyIssues(false);\n   599→    defer graph.freeIssues(ready);\n   600→\n   601→    try std.testing.expectEqual(@as(usize, 2), ready.len);\n   602→\n   603→    // Verify blocked is not in the list\n   604→    for (ready) |issue| {\n   605→        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n   606→    }\n   607→}\n   608→\n   609→test \"DependencyGraph getReadyIssues includes when blocker closed\" {\n   610→    const allocator = std.testing.allocator;\n   611→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   612→    defer store.deinit();\n   613→\n   614→    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n   615→    blocker.status = .closed;\n   616→    try store.insert(blocker);\n   617→    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n   618→\n   619→    var graph = DependencyGraph.init(&store, allocator);\n   620→\n   621→    try graph.addDependency(.{\n   622→        .issue_id = \"bd-child\",\n   623→        .depends_on_id = \"bd-blocker\",\n   624→        .dep_type = .blocks,\n   625→        .created_at = 1706540000,\n   626→        .created_by = null,\n   627→        .metadata = null,\n   628→        .thread_id = null,\n   629→    });\n   630→\n   631→    const ready = try graph.getReadyIssues(false);\n   632→    defer graph.freeIssues(ready);\n   633→\n   634→    try std.testing.expectEqual(@as(usize, 1), ready.len);\n   635→    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n   636→}\n   637→\n   638→test \"DependencyGraph getBlockedIssues returns only blocked\" {\n   639→    const allocator = std.testing.allocator;\n   640→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   641→    defer store.deinit();\n   642→\n   643→    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n   644→    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n   645→    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n   646→\n   647→    var graph = DependencyGraph.init(&store, allocator);\n   648→\n   649→    try graph.addDependency(.{\n   650→        .issue_id = \"bd-blocked\",\n   651→        .depends_on_id = \"bd-blocker\",\n   652→        .dep_type = .blocks,\n   653→        .created_at = 1706540000,\n   654→        .created_by = null,\n   655→        .metadata = null,\n   656→        .thread_id = null,\n   657→    });\n   658→\n   659→    const blocked = try graph.getBlockedIssues();\n   660→    defer graph.freeIssues(blocked);\n   661→\n   662→    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n   663→    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n   664→}\n   665→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d12d5fa5-aef9-4d13-8801-c65b09f07ed3"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EaxUMMorVHjqNfzoswvyGa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QU3HB8J7XNsD1XQeo65hrM","name":"Glob","input":{"pattern":"src/cli/*.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3964,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3964},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"f2b2dd0c-979e-484e-aca7-ce8e0b221570"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01QU3HB8J7XNsD1XQeo65hrM"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"9c1e7ac5-f5f6-4419-9d89-e1d207d1c19c","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01EaxUMMorVHjqNfzoswvyGa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VSRB4hSCEbcvkid9hM1QEm","name":"Glob","input":{"pattern":"src/output/*.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3964,"cache_read_input_tokens":9216,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3964},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"bbc26f4e-68be-4acb-a49c-59f343365278"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_01VSRB4hSCEbcvkid9hM1QEm"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"dde39a87-8729-4098-8b21-d5f9aa1d7e67","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NGR3iC7AvNZwZcEEcKM24f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VV8ugBSAjuCdrLaNQc7eHz","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig/src/cli -name \"*.zig\" -type f | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9695,"cache_read_input_tokens":13180,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9695},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"24626c9c-5db4-434a-978f-36013be3f90a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VV8ugBSAjuCdrLaNQc7eHz","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/cli/upgrade.zig\n/home/hotschmoe/beads_zig/src/cli/label.zig\n/home/hotschmoe/beads_zig/src/cli/close.zig\n/home/hotschmoe/beads_zig/src/cli/update.zig\n/home/hotschmoe/beads_zig/src/cli/help.zig\n/home/hotschmoe/beads_zig/src/cli/mod.zig\n/home/hotschmoe/beads_zig/src/cli/version.zig\n/home/hotschmoe/beads_zig/src/cli/delete.zig\n/home/hotschmoe/beads_zig/src/cli/audit.zig\n/home/hotschmoe/beads_zig/src/cli/common.zig\n/home/hotschmoe/beads_zig/src/cli/schema.zig\n/home/hotschmoe/beads_zig/src/cli/comments.zig\n/home/hotschmoe/beads_zig/src/cli/batch.zig\n/home/hotschmoe/beads_zig/src/cli/list.zig\n/home/hotschmoe/beads_zig/src/cli/args.zig\n/home/hotschmoe/beads_zig/src/cli/stats.zig\n/home/hotschmoe/beads_zig/src/cli/sync.zig\n/home/hotschmoe/beads_zig/src/cli/show.zig\n/home/hotschmoe/beads_zig/src/cli/orphans.zig\n/home/hotschmoe/beads_zig/src/cli/metrics.zig","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4e6f6d61-cfe8-46ba-8a6d-7a4232ee95c6"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NGR3iC7AvNZwZcEEcKM24f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C5L2f4A9BGrgrM8aqj3X5J","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig/src/output -name \"*.zig\" -type f"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9695,"cache_read_input_tokens":13180,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9695},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2a1b00e1-62fe-4a58-a067-167acc6c5e44"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C5L2f4A9BGrgrM8aqj3X5J","type":"tool_result","content":"/home/hotschmoe/beads_zig/src/output/mod.zig","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"dcc3388d-4e75-4d90-9bc0-1b4ab8ec8ff0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01NGR3iC7AvNZwZcEEcKM24f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01792WACe5mEpRXTDMLCGd7x","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9695,"cache_read_input_tokens":13180,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9695},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"dba8a016-875a-453d-943f-4945dd9cb34f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01792WACe5mEpRXTDMLCGd7x","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    quiet: bool = false,\n    13→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    14→    verbose: u8 = 0,\n    15→    no_color: bool = false,\n    16→    data_path: ?[]const u8 = null,\n    17→    actor: ?[]const u8 = null,\n    18→    lock_timeout: u32 = 5000,\n    19→    no_auto_flush: bool = false,\n    20→    no_auto_import: bool = false,\n    21→\n    22→    /// Returns true if structured output (JSON or TOON) is enabled.\n    23→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    24→        return self.json or self.toon;\n    25→    }\n    26→};\n    27→\n    28→/// All available subcommands.\n    29→pub const Command = union(enum) {\n    30→    // Workspace\n    31→    init: InitArgs,\n    32→    info: void,\n    33→    stats: void,\n    34→    doctor: void,\n    35→    config: ConfigArgs,\n    36→    orphans: OrphansArgs,\n    37→    lint: LintArgs,\n    38→    where: void,\n    39→\n    40→    // Issue CRUD\n    41→    create: CreateArgs,\n    42→    q: QuickArgs,\n    43→    show: ShowArgs,\n    44→    update: UpdateArgs,\n    45→    close: CloseArgs,\n    46→    reopen: ReopenArgs,\n    47→    delete: DeleteArgs,\n    48→\n    49→    // Batch Operations\n    50→    add_batch: AddBatchArgs,\n    51→    import_cmd: ImportArgs,\n    52→\n    53→    // Query\n    54→    list: ListArgs,\n    55→    ready: ReadyArgs,\n    56→    blocked: BlockedArgs,\n    57→    search: SearchArgs,\n    58→    stale: StaleArgs,\n    59→    count: CountArgs,\n    60→    defer_cmd: DeferArgs,\n    61→    undefer: UndeferArgs,\n    62→\n    63→    // Dependencies\n    64→    dep: DepArgs,\n    65→    graph: GraphArgs,\n    66→\n    67→    // Epics\n    68→    epic: EpicArgs,\n    69→\n    70→    // Labels\n    71→    label: LabelArgs,\n    72→\n    73→    // Comments\n    74→    comments: CommentsArgs,\n    75→\n    76→    // Audit\n    77→    history: HistoryArgs,\n    78→    audit: AuditArgs,\n    79→\n    80→    // Changelog\n    81→    changelog: ChangelogArgs,\n    82→\n    83→    // Sync\n    84→    sync: SyncArgs,\n    85→\n    86→    // System\n    87→    version: void,\n    88→    schema: void,\n    89→    completions: CompletionsArgs,\n    90→    metrics: MetricsArgs,\n    91→\n    92→    // Saved Queries\n    93→    query: QueryArgs,\n    94→\n    95→    // Self-upgrade\n    96→    upgrade: UpgradeArgs,\n    97→\n    98→    // Help\n    99→    help: HelpArgs,\n   100→};\n   101→\n   102→/// Init command arguments.\n   103→pub const InitArgs = struct {\n   104→    prefix: []const u8 = \"bd\",\n   105→};\n   106→\n   107→/// Create command arguments.\n   108→pub const CreateArgs = struct {\n   109→    title: []const u8,\n   110→    description: ?[]const u8 = null,\n   111→    issue_type: ?[]const u8 = null,\n   112→    priority: ?[]const u8 = null,\n   113→    assignee: ?[]const u8 = null,\n   114→    owner: ?[]const u8 = null,\n   115→    design: ?[]const u8 = null,\n   116→    acceptance_criteria: ?[]const u8 = null,\n   117→    external_ref: ?[]const u8 = null,\n   118→    labels: []const []const u8 = &[_][]const u8{},\n   119→    deps: []const []const u8 = &[_][]const u8{},\n   120→    due: ?[]const u8 = null,\n   121→    estimate: ?i32 = null,\n   122→    ephemeral: bool = false, // Local-only, not written to JSONL\n   123→};\n   124→\n   125→/// Quick capture command arguments.\n   126→pub const QuickArgs = struct {\n   127→    title: []const u8,\n   128→    priority: ?[]const u8 = null,\n   129→};\n   130→\n   131→/// Show command arguments.\n   132→pub const ShowArgs = struct {\n   133→    id: []const u8,\n   134→    with_comments: bool = true,\n   135→    with_history: bool = false,\n   136→};\n   137→\n   138→/// Update command arguments.\n   139→pub const UpdateArgs = struct {\n   140→    id: []const u8,\n   141→    title: ?[]const u8 = null,\n   142→    description: ?[]const u8 = null,\n   143→    issue_type: ?[]const u8 = null,\n   144→    priority: ?[]const u8 = null,\n   145→    assignee: ?[]const u8 = null,\n   146→    owner: ?[]const u8 = null,\n   147→    design: ?[]const u8 = null,\n   148→    acceptance_criteria: ?[]const u8 = null,\n   149→    external_ref: ?[]const u8 = null,\n   150→    status: ?[]const u8 = null,\n   151→    /// Expected version for optimistic locking (compare-and-swap).\n   152→    expected_version: ?u64 = null,\n   153→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   154→    claim: bool = false,\n   155→};\n   156→\n   157→/// Close command arguments.\n   158→pub const CloseArgs = struct {\n   159→    id: []const u8,\n   160→    reason: ?[]const u8 = null,\n   161→    session: ?[]const u8 = null,\n   162→};\n   163→\n   164→/// Reopen command arguments.\n   165→pub const ReopenArgs = struct {\n   166→    id: []const u8,\n   167→};\n   168→\n   169→/// Delete command arguments.\n   170→pub const DeleteArgs = struct {\n   171→    id: []const u8,\n   172→};\n   173→\n   174→/// Add-batch command arguments.\n   175→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   176→pub const AddBatchArgs = struct {\n   177→    file: ?[]const u8 = null, // Read from file instead of stdin\n   178→    format: BatchFormat = .titles, // Input format\n   179→};\n   180→\n   181→/// Batch input format.\n   182→pub const BatchFormat = enum {\n   183→    titles, // One title per line\n   184→    jsonl, // Full JSONL format (one issue per line)\n   185→\n   186→    pub fn fromString(s: []const u8) ?BatchFormat {\n   187→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   188→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   189→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   190→        return null;\n   191→    }\n   192→};\n   193→\n   194→/// Import command arguments.\n   195→/// Imports issues from a JSONL file with single lock acquisition.\n   196→pub const ImportArgs = struct {\n   197→    file: []const u8, // Path to JSONL file (required)\n   198→    merge: bool = false, // Merge instead of replace\n   199→    dry_run: bool = false, // Show what would be imported without importing\n   200→};\n   201→\n   202→/// Sort field options for list command.\n   203→pub const SortField = enum {\n   204→    created_at,\n   205→    updated_at,\n   206→    priority,\n   207→\n   208→    pub fn fromString(s: []const u8) ?SortField {\n   209→        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n   210→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   211→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   212→        return null;\n   213→    }\n   214→};\n   215→\n   216→/// List command arguments.\n   217→pub const ListArgs = struct {\n   218→    status: ?[]const u8 = null,\n   219→    priority: ?[]const u8 = null,\n   220→    priority_min: ?[]const u8 = null,\n   221→    priority_max: ?[]const u8 = null,\n   222→    issue_type: ?[]const u8 = null,\n   223→    assignee: ?[]const u8 = null,\n   224→    label: ?[]const u8 = null,\n   225→    label_any: []const []const u8 = &[_][]const u8{},\n   226→    title_contains: ?[]const u8 = null,\n   227→    desc_contains: ?[]const u8 = null,\n   228→    notes_contains: ?[]const u8 = null,\n   229→    limit: ?u32 = null,\n   230→    all: bool = false,\n   231→    overdue: bool = false,\n   232→    include_deferred: bool = false,\n   233→    sort: SortField = .created_at,\n   234→    sort_desc: bool = true,\n   235→};\n   236→\n   237→/// Ready command arguments.\n   238→pub const ReadyArgs = struct {\n   239→    limit: ?u32 = null,\n   240→    priority_min: ?[]const u8 = null,\n   241→    priority_max: ?[]const u8 = null,\n   242→    title_contains: ?[]const u8 = null,\n   243→    desc_contains: ?[]const u8 = null,\n   244→    notes_contains: ?[]const u8 = null,\n   245→    overdue: bool = false,\n   246→    include_deferred: bool = false,\n   247→};\n   248→\n   249→/// Blocked command arguments.\n   250→pub const BlockedArgs = struct {\n   251→    limit: ?u32 = null,\n   252→    priority_min: ?[]const u8 = null,\n   253→    priority_max: ?[]const u8 = null,\n   254→    title_contains: ?[]const u8 = null,\n   255→    desc_contains: ?[]const u8 = null,\n   256→    notes_contains: ?[]const u8 = null,\n   257→};\n   258→\n   259→/// Search command arguments.\n   260→pub const SearchArgs = struct {\n   261→    query: []const u8,\n   262→    limit: ?u32 = null,\n   263→};\n   264→\n   265→/// Stale command arguments.\n   266→pub const StaleArgs = struct {\n   267→    days: u32 = 30,\n   268→    limit: ?u32 = null,\n   269→};\n   270→\n   271→/// Count command arguments.\n   272→pub const CountArgs = struct {\n   273→    group_by: ?[]const u8 = null,\n   274→};\n   275→\n   276→/// Defer command arguments.\n   277→pub const DeferArgs = struct {\n   278→    id: []const u8,\n   279→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   280→    reason: ?[]const u8 = null,\n   281→};\n   282→\n   283→/// Undefer command arguments.\n   284→pub const UndeferArgs = struct {\n   285→    id: []const u8,\n   286→};\n   287→\n   288→/// Epic subcommand variants.\n   289→pub const EpicSubcommand = union(enum) {\n   290→    create: struct {\n   291→        title: []const u8,\n   292→        description: ?[]const u8 = null,\n   293→        priority: ?[]const u8 = null,\n   294→    },\n   295→    add: struct {\n   296→        epic_id: []const u8,\n   297→        issue_id: []const u8,\n   298→    },\n   299→    remove: struct {\n   300→        epic_id: []const u8,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"71e74649-4aec-41ec-aeb5-a5065c2e6f6b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XzXZp2tnTaox434SNrFcwQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dy4SaoFJf3Jo2zBWaKufBe","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":500,"offset":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4460,"cache_read_input_tokens":22875,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4460},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8c5823e4-19c6-4190-b778-528821531f71"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dy4SaoFJf3Jo2zBWaKufBe","type":"tool_result","content":"   300→        epic_id: []const u8,\n   301→        issue_id: []const u8,\n   302→    },\n   303→    list: struct {\n   304→        epic_id: []const u8,\n   305→    },\n   306→};\n   307→\n   308→/// Epic command arguments.\n   309→pub const EpicArgs = struct {\n   310→    subcommand: EpicSubcommand,\n   311→};\n   312→\n   313→/// Dependency subcommand variants.\n   314→pub const DepSubcommand = union(enum) {\n   315→    add: struct {\n   316→        child: []const u8,\n   317→        parent: []const u8,\n   318→        dep_type: []const u8 = \"blocks\",\n   319→    },\n   320→    remove: struct {\n   321→        child: []const u8,\n   322→        parent: []const u8,\n   323→    },\n   324→    list: struct {\n   325→        id: []const u8,\n   326→    },\n   327→    tree: struct {\n   328→        id: []const u8,\n   329→    },\n   330→    cycles: void,\n   331→};\n   332→\n   333→/// Dependency command arguments.\n   334→pub const DepArgs = struct {\n   335→    subcommand: DepSubcommand,\n   336→};\n   337→\n   338→/// Graph command output formats.\n   339→pub const GraphFormat = enum {\n   340→    ascii,\n   341→    dot,\n   342→\n   343→    pub fn fromString(s: []const u8) ?GraphFormat {\n   344→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   345→        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n   346→        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n   347→        return null;\n   348→    }\n   349→};\n   350→\n   351→/// Graph command arguments.\n   352→pub const GraphArgs = struct {\n   353→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   354→    format: GraphFormat = .ascii,\n   355→    depth: ?u32 = null, // Max depth for tree traversal\n   356→};\n   357→\n   358→/// Label subcommand variants.\n   359→pub const LabelSubcommand = union(enum) {\n   360→    add: struct {\n   361→        id: []const u8,\n   362→        labels: []const []const u8,\n   363→    },\n   364→    remove: struct {\n   365→        id: []const u8,\n   366→        labels: []const []const u8,\n   367→    },\n   368→    list: struct {\n   369→        id: []const u8,\n   370→    },\n   371→    list_all: void,\n   372→};\n   373→\n   374→/// Label command arguments.\n   375→pub const LabelArgs = struct {\n   376→    subcommand: LabelSubcommand,\n   377→};\n   378→\n   379→/// Comments subcommand variants.\n   380→pub const CommentsSubcommand = union(enum) {\n   381→    add: struct {\n   382→        id: []const u8,\n   383→        text: []const u8,\n   384→    },\n   385→    list: struct {\n   386→        id: []const u8,\n   387→    },\n   388→};\n   389→\n   390→/// Comments command arguments.\n   391→pub const CommentsArgs = struct {\n   392→    subcommand: CommentsSubcommand,\n   393→};\n   394→\n   395→/// History command arguments.\n   396→pub const HistoryArgs = struct {\n   397→    id: []const u8,\n   398→};\n   399→\n   400→/// Audit command arguments.\n   401→pub const AuditArgs = struct {\n   402→    limit: ?u32 = null,\n   403→};\n   404→\n   405→/// Changelog command arguments.\n   406→pub const ChangelogArgs = struct {\n   407→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   408→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   409→    limit: ?u32 = null,\n   410→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   411→};\n   412→\n   413→/// Sync command arguments.\n   414→pub const SyncArgs = struct {\n   415→    flush_only: bool = false,\n   416→    import_only: bool = false,\n   417→};\n   418→\n   419→/// Shell completion types.\n   420→pub const Shell = enum {\n   421→    bash,\n   422→    zsh,\n   423→    fish,\n   424→    powershell,\n   425→\n   426→    pub fn fromString(s: []const u8) ?Shell {\n   427→        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n   428→        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n   429→        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n   430→        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n   431→        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n   432→        return null;\n   433→    }\n   434→};\n   435→\n   436→/// Completions command arguments.\n   437→pub const CompletionsArgs = struct {\n   438→    shell: Shell,\n   439→};\n   440→\n   441→/// Metrics command arguments.\n   442→pub const MetricsArgs = struct {\n   443→    reset: bool = false, // Reset metrics after displaying\n   444→};\n   445→\n   446→/// Help command arguments.\n   447→pub const HelpArgs = struct {\n   448→    topic: ?[]const u8 = null,\n   449→};\n   450→\n   451→/// Config subcommand variants.\n   452→pub const ConfigSubcommand = union(enum) {\n   453→    get: struct {\n   454→        key: []const u8,\n   455→    },\n   456→    set: struct {\n   457→        key: []const u8,\n   458→        value: []const u8,\n   459→    },\n   460→    list: void,\n   461→};\n   462→\n   463→/// Config command arguments.\n   464→pub const ConfigArgs = struct {\n   465→    subcommand: ConfigSubcommand,\n   466→};\n   467→\n   468→/// Query subcommand variants.\n   469→pub const QuerySubcommand = union(enum) {\n   470→    save: struct {\n   471→        name: []const u8,\n   472→        status: ?[]const u8 = null,\n   473→        priority: ?[]const u8 = null,\n   474→        issue_type: ?[]const u8 = null,\n   475→        assignee: ?[]const u8 = null,\n   476→        label: ?[]const u8 = null,\n   477→        limit: ?u32 = null,\n   478→    },\n   479→    run: struct {\n   480→        name: []const u8,\n   481→    },\n   482→    list: void,\n   483→    delete: struct {\n   484→        name: []const u8,\n   485→    },\n   486→};\n   487→\n   488→/// Query command arguments.\n   489→pub const QueryArgs = struct {\n   490→    subcommand: QuerySubcommand,\n   491→};\n   492→\n   493→/// Upgrade command arguments.\n   494→pub const UpgradeArgs = struct {\n   495→    check_only: bool = false,\n   496→    version: ?[]const u8 = null,\n   497→};\n   498→\n   499→/// Orphans command arguments.\n   500→pub const OrphansArgs = struct {\n   501→    limit: ?u32 = null,\n   502→    hierarchy_only: bool = false,\n   503→    deps_only: bool = false,\n   504→};\n   505→\n   506→/// Lint command arguments.\n   507→pub const LintArgs = struct {\n   508→    limit: ?u32 = null,\n   509→};\n   510→\n   511→/// Result of parsing command-line arguments.\n   512→pub const ParseResult = struct {\n   513→    global: GlobalOptions,\n   514→    command: Command,\n   515→\n   516→    /// Free any memory allocated during parsing (labels, deps slices).\n   517→    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n   518→        switch (self.command) {\n   519→            .create => |create| {\n   520→                if (create.labels.len > 0) allocator.free(create.labels);\n   521→                if (create.deps.len > 0) allocator.free(create.deps);\n   522→            },\n   523→            .list => |list_cmd| {\n   524→                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n   525→            },\n   526→            .label => |label_cmd| {\n   527→                switch (label_cmd.subcommand) {\n   528→                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n   529→                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n   530→                    else => {},\n   531→                }\n   532→            },\n   533→            else => {},\n   534→        }\n   535→    }\n   536→};\n   537→\n   538→/// Errors that can occur during argument parsing.\n   539→pub const ParseError = error{\n   540→    UnknownCommand,\n   541→    MissingRequiredArgument,\n   542→    InvalidArgument,\n   543→    UnknownFlag,\n   544→    MissingFlagValue,\n   545→    InvalidFlagValue,\n   546→    InvalidShell,\n   547→    UnknownSubcommand,\n   548→};\n   549→\n   550→/// Command-line argument parser.\n   551→pub const ArgParser = struct {\n   552→    allocator: std.mem.Allocator,\n   553→    args: []const []const u8,\n   554→    index: usize = 0,\n   555→\n   556→    const Self = @This();\n   557→\n   558→    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n   559→        return .{\n   560→            .allocator = allocator,\n   561→            .args = args,\n   562→        };\n   563→    }\n   564→\n   565→    /// Parse all arguments into a ParseResult.\n   566→    pub fn parse(self: *Self) ParseError!ParseResult {\n   567→        var global = GlobalOptions{};\n   568→\n   569→        // Parse global flags first\n   570→        while (self.hasNext()) {\n   571→            const arg = self.peek().?;\n   572→            if (std.mem.startsWith(u8, arg, \"-\")) {\n   573→                if (self.parseGlobalFlag(&global)) |consumed| {\n   574→                    if (!consumed) break;\n   575→                } else |_| {\n   576→                    break;\n   577→                }\n   578→            } else {\n   579→                break;\n   580→            }\n   581→        }\n   582→\n   583→        // Parse subcommand\n   584→        const cmd_str = self.next() orelse {\n   585→            return .{\n   586→                .global = global,\n   587→                .command = .{ .help = .{ .topic = null } },\n   588→            };\n   589→        };\n   590→\n   591→        const command = try self.parseCommand(cmd_str);\n   592→\n   593→        return .{\n   594→            .global = global,\n   595→            .command = command,\n   596→        };\n   597→    }\n   598→\n   599→    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n   600→        const arg = self.next().?;\n   601→\n   602→        if (std.mem.eql(u8, arg, \"--json\")) {\n   603→            global.json = true;\n   604→            return true;\n   605→        }\n   606→        if (std.mem.eql(u8, arg, \"--toon\")) {\n   607→            global.toon = true;\n   608→            return true;\n   609→        }\n   610→        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   611→            global.quiet = true;\n   612→            return true;\n   613→        }\n   614→        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   615→            global.verbose +|= 1;\n   616→            return true;\n   617→        }\n   618→        if (std.mem.eql(u8, arg, \"-vv\")) {\n   619→            global.verbose +|= 2;\n   620→            return true;\n   621→        }\n   622→        if (std.mem.eql(u8, arg, \"--no-color\")) {\n   623→            global.no_color = true;\n   624→            return true;\n   625→        }\n   626→        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n   627→            global.no_auto_flush = true;\n   628→            return true;\n   629→        }\n   630→        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n   631→            global.no_auto_import = true;\n   632→            return true;\n   633→        }\n   634→        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n   635→            global.data_path = self.next() orelse return error.MissingFlagValue;\n   636→            return true;\n   637→        }\n   638→        if (std.mem.eql(u8, arg, \"--actor\")) {\n   639→            global.actor = self.next() orelse return error.MissingFlagValue;\n   640→            return true;\n   641→        }\n   642→        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n   643→            const val = self.next() orelse return error.MissingFlagValue;\n   644→            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n   645→            return true;\n   646→        }\n   647→\n   648→        // Put back if not recognized\n   649→        self.index -= 1;\n   650→        return error.UnknownFlag;\n   651→    }\n   652→\n   653→    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n   654→        // Workspace\n   655→        if (std.mem.eql(u8, cmd, \"init\")) {\n   656→            return .{ .init = try self.parseInitArgs() };\n   657→        }\n   658→        if (std.mem.eql(u8, cmd, \"info\")) {\n   659→            return .{ .info = {} };\n   660→        }\n   661→        if (std.mem.eql(u8, cmd, \"stats\")) {\n   662→            return .{ .stats = {} };\n   663→        }\n   664→        if (std.mem.eql(u8, cmd, \"doctor\")) {\n   665→            return .{ .doctor = {} };\n   666→        }\n   667→        if (std.mem.eql(u8, cmd, \"config\")) {\n   668→            return .{ .config = try self.parseConfigArgs() };\n   669→        }\n   670→        if (std.mem.eql(u8, cmd, \"orphans\")) {\n   671→            return .{ .orphans = try self.parseOrphansArgs() };\n   672→        }\n   673→        if (std.mem.eql(u8, cmd, \"lint\")) {\n   674→            return .{ .lint = try self.parseLintArgs() };\n   675→        }\n   676→        if (std.mem.eql(u8, cmd, \"where\")) {\n   677→            return .{ .where = {} };\n   678→        }\n   679→\n   680→        // Issue CRUD\n   681→        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n   682→            return .{ .create = try self.parseCreateArgs() };\n   683→        }\n   684→        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n   685→            return .{ .q = try self.parseQuickArgs() };\n   686→        }\n   687→        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n   688→            return .{ .show = try self.parseShowArgs() };\n   689→        }\n   690→        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n   691→            return .{ .update = try self.parseUpdateArgs() };\n   692→        }\n   693→        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n   694→            return .{ .close = try self.parseCloseArgs() };\n   695→        }\n   696→        if (std.mem.eql(u8, cmd, \"reopen\")) {\n   697→            return .{ .reopen = try self.parseReopenArgs() };\n   698→        }\n   699→        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n   700→            return .{ .delete = try self.parseDeleteArgs() };\n   701→        }\n   702→\n   703→        // Batch Operations\n   704→        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n   705→            return .{ .add_batch = try self.parseAddBatchArgs() };\n   706→        }\n   707→        if (std.mem.eql(u8, cmd, \"import\")) {\n   708→            return .{ .import_cmd = try self.parseImportArgs() };\n   709→        }\n   710→\n   711→        // Query\n   712→        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n   713→            return .{ .list = try self.parseListArgs() };\n   714→        }\n   715→        if (std.mem.eql(u8, cmd, \"ready\")) {\n   716→            return .{ .ready = try self.parseReadyArgs() };\n   717→        }\n   718→        if (std.mem.eql(u8, cmd, \"blocked\")) {\n   719→            return .{ .blocked = try self.parseBlockedArgs() };\n   720→        }\n   721→        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n   722→            return .{ .search = try self.parseSearchArgs() };\n   723→        }\n   724→        if (std.mem.eql(u8, cmd, \"stale\")) {\n   725→            return .{ .stale = try self.parseStaleArgs() };\n   726→        }\n   727→        if (std.mem.eql(u8, cmd, \"count\")) {\n   728→            return .{ .count = try self.parseCountArgs() };\n   729→        }\n   730→        if (std.mem.eql(u8, cmd, \"defer\")) {\n   731→            return .{ .defer_cmd = try self.parseDeferArgs() };\n   732→        }\n   733→        if (std.mem.eql(u8, cmd, \"undefer\")) {\n   734→            return .{ .undefer = try self.parseUndeferArgs() };\n   735→        }\n   736→\n   737→        // Dependencies\n   738→        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n   739→            return .{ .dep = try self.parseDepArgs() };\n   740→        }\n   741→        if (std.mem.eql(u8, cmd, \"graph\")) {\n   742→            return .{ .graph = try self.parseGraphArgs() };\n   743→        }\n   744→\n   745→        // Epics\n   746→        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n   747→            return .{ .epic = try self.parseEpicArgs() };\n   748→        }\n   749→\n   750→        // Labels\n   751→        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n   752→            return .{ .label = try self.parseLabelArgs() };\n   753→        }\n   754→\n   755→        // Comments\n   756→        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n   757→            return .{ .comments = try self.parseCommentsArgs() };\n   758→        }\n   759→\n   760→        // Audit\n   761→        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n   762→            return .{ .history = try self.parseHistoryArgs() };\n   763→        }\n   764→        if (std.mem.eql(u8, cmd, \"audit\")) {\n   765→            return .{ .audit = try self.parseAuditArgs() };\n   766→        }\n   767→\n   768→        // Changelog\n   769→        if (std.mem.eql(u8, cmd, \"changelog\")) {\n   770→            return .{ .changelog = try self.parseChangelogArgs() };\n   771→        }\n   772→\n   773→        // Sync\n   774→        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n   775→            return .{ .sync = try self.parseSyncArgs() };\n   776→        }\n   777→\n   778→        // System\n   779→        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n   780→            return .{ .version = {} };\n   781→        }\n   782→        if (std.mem.eql(u8, cmd, \"schema\")) {\n   783→            return .{ .schema = {} };\n   784→        }\n   785→        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n   786→            return .{ .completions = try self.parseCompletionsArgs() };\n   787→        }\n   788→        if (std.mem.eql(u8, cmd, \"metrics\")) {\n   789→            return .{ .metrics = try self.parseMetricsArgs() };\n   790→        }\n   791→\n   792→        // Saved Queries\n   793→        if (std.mem.eql(u8, cmd, \"query\")) {\n   794→            return .{ .query = try self.parseQueryArgs() };\n   795→        }\n   796→\n   797→        // Self-upgrade\n   798→        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n   799→            return .{ .upgrade = try self.parseUpgradeArgs() };\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4a1f4d62-c9e8-4105-b7b7-63ac675b6582"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XzXZp2tnTaox434SNrFcwQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SpTKZCeAnQGHVJjFj4Kar8","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4460,"cache_read_input_tokens":22875,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4460},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"66c34fb5-247c-4acc-9a71-5d3d80803901"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SpTKZCeAnQGHVJjFj4Kar8","type":"tool_result","content":"     1→//! List command for beads_zig.\n     2→//!\n     3→//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n     4→//!\n     5→//! Lists issues with optional filters.\n     6→\n     7→const std = @import(\"std\");\n     8→const models = @import(\"../models/mod.zig\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const test_util = @import(\"../test_util.zig\");\n    12→\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = common.IssueStore;\n    18→const CommandContext = common.CommandContext;\n    19→\n    20→pub const ListError = error{\n    21→    WorkspaceNotInitialized,\n    22→    InvalidFilter,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→};\n    26→\n    27→pub const ListResult = struct {\n    28→    success: bool,\n    29→    issues: ?[]const IssueCompact = null,\n    30→    count: ?usize = null,\n    31→    message: ?[]const u8 = null,\n    32→\n    33→    const IssueCompact = struct {\n    34→        id: []const u8,\n    35→        title: []const u8,\n    36→        status: []const u8,\n    37→        priority: u3,\n    38→        issue_type: []const u8,\n    39→        assignee: ?[]const u8 = null,\n    40→    };\n    41→};\n    42→\n    43→pub fn run(\n    44→    list_args: args.ListArgs,\n    45→    global: args.GlobalOptions,\n    46→    allocator: std.mem.Allocator,\n    47→) !void {\n    48→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    49→        return ListError.WorkspaceNotInitialized;\n    50→    };\n    51→    defer ctx.deinit();\n    52→\n    53→    var filters = IssueStore.ListFilters{};\n    54→\n    55→    if (list_args.status) |s| {\n    56→        filters.status = Status.fromString(s);\n    57→    } else if (!list_args.all) {\n    58→        filters.status = .open;\n    59→    }\n    60→\n    61→    if (list_args.priority) |p| {\n    62→        filters.priority = Priority.fromString(p) catch {\n    63→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n    64→            return ListError.InvalidFilter;\n    65→        };\n    66→    }\n    67→\n    68→    if (list_args.priority_min) |p| {\n    69→        filters.priority_min = Priority.fromString(p) catch {\n    70→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n    71→            return ListError.InvalidFilter;\n    72→        };\n    73→    }\n    74→\n    75→    if (list_args.priority_max) |p| {\n    76→        filters.priority_max = Priority.fromString(p) catch {\n    77→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n    78→            return ListError.InvalidFilter;\n    79→        };\n    80→    }\n    81→\n    82→    if (list_args.issue_type) |t| {\n    83→        filters.issue_type = IssueType.fromString(t);\n    84→    }\n    85→\n    86→    if (list_args.assignee) |a| {\n    87→        filters.assignee = a;\n    88→    }\n    89→\n    90→    if (list_args.label) |l| {\n    91→        filters.label = l;\n    92→    }\n    93→\n    94→    if (list_args.label_any.len > 0) {\n    95→        filters.label_any = list_args.label_any;\n    96→    }\n    97→\n    98→    if (list_args.title_contains) |t| {\n    99→        filters.title_contains = t;\n   100→    }\n   101→\n   102→    if (list_args.desc_contains) |d| {\n   103→        filters.desc_contains = d;\n   104→    }\n   105→\n   106→    if (list_args.notes_contains) |n| {\n   107→        filters.notes_contains = n;\n   108→    }\n   109→\n   110→    if (list_args.limit) |n| {\n   111→        filters.limit = n;\n   112→    }\n   113→\n   114→    // Apply overdue filter\n   115→    filters.overdue = list_args.overdue;\n   116→\n   117→    // Apply include_deferred filter\n   118→    filters.include_deferred = list_args.include_deferred;\n   119→\n   120→    // Apply sort options\n   121→    filters.order_by = switch (list_args.sort) {\n   122→        .created_at => .created_at,\n   123→        .updated_at => .updated_at,\n   124→        .priority => .priority,\n   125→    };\n   126→    filters.order_desc = list_args.sort_desc;\n   127→\n   128→    const issues = try ctx.store.list(filters);\n   129→    defer {\n   130→        for (issues) |*issue| {\n   131→            var i = issue.*;\n   132→            i.deinit(allocator);\n   133→        }\n   134→        allocator.free(issues);\n   135→    }\n   136→\n   137→    if (global.isStructuredOutput()) {\n   138→        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n   139→        defer allocator.free(compact_issues);\n   140→\n   141→        for (issues, 0..) |issue, i| {\n   142→            compact_issues[i] = .{\n   143→                .id = issue.id,\n   144→                .title = issue.title,\n   145→                .status = issue.status.toString(),\n   146→                .priority = issue.priority.value,\n   147→                .issue_type = issue.issue_type.toString(),\n   148→                .assignee = issue.assignee,\n   149→            };\n   150→        }\n   151→\n   152→        try ctx.output.printJson(ListResult{\n   153→            .success = true,\n   154→            .issues = compact_issues,\n   155→            .count = issues.len,\n   156→        });\n   157→    } else {\n   158→        try ctx.output.printIssueList(issues);\n   159→        if (!global.quiet and issues.len == 0) {\n   160→            try ctx.output.info(\"No issues found\", .{});\n   161→        }\n   162→    }\n   163→}\n   164→\n   165→fn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n   166→    if (structured_mode) {\n   167→        try output.printJson(ListResult{\n   168→            .success = false,\n   169→            .message = message,\n   170→        });\n   171→    } else {\n   172→        try output.err(\"{s}\", .{message});\n   173→    }\n   174→}\n   175→\n   176→// --- Tests ---\n   177→\n   178→test \"ListError enum exists\" {\n   179→    const err: ListError = ListError.WorkspaceNotInitialized;\n   180→    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n   181→}\n   182→\n   183→test \"ListResult struct works\" {\n   184→    const result = ListResult{\n   185→        .success = true,\n   186→        .count = 5,\n   187→    };\n   188→    try std.testing.expect(result.success);\n   189→    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n   190→}\n   191→\n   192→test \"run detects uninitialized workspace\" {\n   193→    const allocator = std.testing.allocator;\n   194→\n   195→    const list_args = args.ListArgs{};\n   196→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   197→\n   198→    const result = run(list_args, global, allocator);\n   199→    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n   200→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b5cd7058-25ca-40d1-ab4c-421b40bcc6a5"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Cu5m9mVF6hNogAqRZpLDq7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CRYUcFgAiAQHk2BuqSPVwJ","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9461,"cache_read_input_tokens":27335,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9461},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c18087d7-cf84-44af-9ab6-2e24e2825f7d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CRYUcFgAiAQHk2BuqSPVwJ","type":"tool_result","content":"     1→//! Ready and blocked commands for beads_zig.\n     2→//!\n     3→//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n     4→//! `bz blocked [-n LIMIT]` - Show blocked issues\n     5→//!\n     6→//! Workflow queries for finding actionable work.\n     7→\n     8→const std = @import(\"std\");\n     9→const models = @import(\"../models/mod.zig\");\n    10→const store = @import(\"../storage/store.zig\");\n    11→const common = @import(\"common.zig\");\n    12→const args = @import(\"args.zig\");\n    13→const test_util = @import(\"../test_util.zig\");\n    14→\n    15→const Issue = models.Issue;\n    16→const Priority = models.Priority;\n    17→const CommandContext = common.CommandContext;\n    18→const DependencyGraph = common.DependencyGraph;\n    19→const containsIgnoreCase = store.containsIgnoreCase;\n    20→\n    21→pub const ReadyError = error{\n    22→    WorkspaceNotInitialized,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→    InvalidFilter,\n    26→};\n    27→\n    28→pub const ReadyResult = struct {\n    29→    success: bool,\n    30→    issues: ?[]const IssueCompact = null,\n    31→    count: ?usize = null,\n    32→    message: ?[]const u8 = null,\n    33→\n    34→    const IssueCompact = struct {\n    35→        id: []const u8,\n    36→        title: []const u8,\n    37→        priority: u3,\n    38→    };\n    39→};\n    40→\n    41→pub const BlockedResult = struct {\n    42→    success: bool,\n    43→    issues: ?[]const BlockedIssue = null,\n    44→    count: ?usize = null,\n    45→    message: ?[]const u8 = null,\n    46→\n    47→    const BlockedIssue = struct {\n    48→        id: []const u8,\n    49→        title: []const u8,\n    50→        priority: u3,\n    51→        blocked_by: []const []const u8,\n    52→    };\n    53→};\n    54→\n    55→pub fn run(\n    56→    ready_args: args.ReadyArgs,\n    57→    global: args.GlobalOptions,\n    58→    allocator: std.mem.Allocator,\n    59→) !void {\n    60→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    61→        return ReadyError.WorkspaceNotInitialized;\n    62→    };\n    63→    defer ctx.deinit();\n    64→\n    65→    // Parse priority filters\n    66→    var priority_min: ?Priority = null;\n    67→    var priority_max: ?Priority = null;\n    68→    if (ready_args.priority_min) |p| {\n    69→        priority_min = Priority.fromString(p) catch {\n    70→            try ctx.output.err(\"invalid priority-min value\", .{});\n    71→            return ReadyError.InvalidFilter;\n    72→        };\n    73→    }\n    74→    if (ready_args.priority_max) |p| {\n    75→        priority_max = Priority.fromString(p) catch {\n    76→            try ctx.output.err(\"invalid priority-max value\", .{});\n    77→            return ReadyError.InvalidFilter;\n    78→        };\n    79→    }\n    80→\n    81→    var graph = ctx.createGraph();\n    82→    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    83→    defer graph.freeIssues(issues);\n    84→\n    85→    // Apply filters\n    86→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    87→    defer allocator.free(filtered);\n    88→\n    89→    const display_issues = applyLimit(filtered, ready_args.limit);\n    90→\n    91→    if (global.isStructuredOutput()) {\n    92→        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n    93→        defer allocator.free(compact_issues);\n    94→\n    95→        for (display_issues, 0..) |issue, i| {\n    96→            compact_issues[i] = .{\n    97→                .id = issue.id,\n    98→                .title = issue.title,\n    99→                .priority = issue.priority.value,\n   100→            };\n   101→        }\n   102→\n   103→        try ctx.output.printJson(ReadyResult{\n   104→            .success = true,\n   105→            .issues = compact_issues,\n   106→            .count = display_issues.len,\n   107→        });\n   108→    } else {\n   109→        try ctx.output.printIssueList(display_issues);\n   110→        if (!global.quiet and display_issues.len == 0) {\n   111→            try ctx.output.info(\"No ready issues\", .{});\n   112→        }\n   113→    }\n   114→}\n   115→\n   116→pub fn runBlocked(\n   117→    blocked_args: args.BlockedArgs,\n   118→    global: args.GlobalOptions,\n   119→    allocator: std.mem.Allocator,\n   120→) !void {\n   121→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   122→        return ReadyError.WorkspaceNotInitialized;\n   123→    };\n   124→    defer ctx.deinit();\n   125→\n   126→    // Parse priority filters\n   127→    var priority_min: ?Priority = null;\n   128→    var priority_max: ?Priority = null;\n   129→    if (blocked_args.priority_min) |p| {\n   130→        priority_min = Priority.fromString(p) catch {\n   131→            try ctx.output.err(\"invalid priority-min value\", .{});\n   132→            return ReadyError.InvalidFilter;\n   133→        };\n   134→    }\n   135→    if (blocked_args.priority_max) |p| {\n   136→        priority_max = Priority.fromString(p) catch {\n   137→            try ctx.output.err(\"invalid priority-max value\", .{});\n   138→            return ReadyError.InvalidFilter;\n   139→        };\n   140→    }\n   141→\n   142→    var graph = ctx.createGraph();\n   143→    const issues = try graph.getBlockedIssues();\n   144→    defer graph.freeIssues(issues);\n   145→\n   146→    // Apply filters (blocked command doesn't support overdue filter)\n   147→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n   148→    defer allocator.free(filtered);\n   149→\n   150→    const display_issues = applyLimit(filtered, blocked_args.limit);\n   151→\n   152→    if (global.isStructuredOutput()) {\n   153→        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n   154→        defer {\n   155→            for (blocked_issues) |bi| {\n   156→                allocator.free(bi.blocked_by);\n   157→            }\n   158→            allocator.free(blocked_issues);\n   159→        }\n   160→\n   161→        for (display_issues, 0..) |issue, i| {\n   162→            const blockers = try graph.getBlockers(issue.id);\n   163→            defer graph.freeIssues(blockers);\n   164→\n   165→            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n   166→            for (blockers, 0..) |blocker, j| {\n   167→                blocker_ids[j] = blocker.id;\n   168→            }\n   169→\n   170→            blocked_issues[i] = .{\n   171→                .id = issue.id,\n   172→                .title = issue.title,\n   173→                .priority = issue.priority.value,\n   174→                .blocked_by = blocker_ids,\n   175→            };\n   176→        }\n   177→\n   178→        try ctx.output.printJson(BlockedResult{\n   179→            .success = true,\n   180→            .issues = blocked_issues,\n   181→            .count = display_issues.len,\n   182→        });\n   183→    } else {\n   184→        for (display_issues) |issue| {\n   185→            const blockers = try graph.getBlockers(issue.id);\n   186→            defer graph.freeIssues(blockers);\n   187→\n   188→            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n   189→\n   190→            if (blockers.len > 0) {\n   191→                try ctx.output.print(\"  blocked by: \", .{});\n   192→                for (blockers, 0..) |blocker, j| {\n   193→                    if (j > 0) try ctx.output.print(\", \", .{});\n   194→                    try ctx.output.print(\"{s}\", .{blocker.id});\n   195→                }\n   196→                try ctx.output.print(\"\\n\", .{});\n   197→            }\n   198→        }\n   199→\n   200→        if (!global.quiet and display_issues.len == 0) {\n   201→            try ctx.output.info(\"No blocked issues\", .{});\n   202→        }\n   203→    }\n   204→}\n   205→\n   206→fn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n   207→    if (limit) |n| {\n   208→        if (n < issues.len) {\n   209→            return issues[0..n];\n   210→        }\n   211→    }\n   212→    return issues;\n   213→}\n   214→\n   215→fn applyFilters(\n   216→    allocator: std.mem.Allocator,\n   217→    issues: []Issue,\n   218→    priority_min: ?Priority,\n   219→    priority_max: ?Priority,\n   220→    title_contains: ?[]const u8,\n   221→    desc_contains: ?[]const u8,\n   222→    notes_contains: ?[]const u8,\n   223→    overdue_only: bool,\n   224→) ![]Issue {\n   225→    // No filters - return original slice\n   226→    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n   227→        return try allocator.dupe(Issue, issues);\n   228→    }\n   229→\n   230→    const now = std.time.timestamp();\n   231→    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n   232→    errdefer filtered.deinit(allocator);\n   233→\n   234→    for (issues) |issue| {\n   235→        // Priority range filters (lower value = higher priority)\n   236→        if (priority_min) |min_p| {\n   237→            if (issue.priority.value < min_p.value) continue;\n   238→        }\n   239→        if (priority_max) |max_p| {\n   240→            if (issue.priority.value > max_p.value) continue;\n   241→        }\n   242→\n   243→        // Substring filters (case-insensitive)\n   244→        if (title_contains) |query| {\n   245→            if (!containsIgnoreCase(issue.title, query)) continue;\n   246→        }\n   247→        if (desc_contains) |query| {\n   248→            if (issue.description) |desc| {\n   249→                if (!containsIgnoreCase(desc, query)) continue;\n   250→            } else continue;\n   251→        }\n   252→        if (notes_contains) |query| {\n   253→            if (issue.notes) |notes| {\n   254→                if (!containsIgnoreCase(notes, query)) continue;\n   255→            } else continue;\n   256→        }\n   257→\n   258→        // Overdue filter: only include issues past their due date\n   259→        if (overdue_only) {\n   260→            if (issue.due_at.value) |due_time| {\n   261→                if (due_time >= now) continue;\n   262→            } else continue;\n   263→        }\n   264→\n   265→        try filtered.append(allocator, issue);\n   266→    }\n   267→\n   268→    return filtered.toOwnedSlice(allocator);\n   269→}\n   270→\n   271→// --- Tests ---\n   272→\n   273→test \"ReadyError enum exists\" {\n   274→    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n   275→    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n   276→}\n   277→\n   278→test \"ReadyResult struct works\" {\n   279→    const result = ReadyResult{\n   280→        .success = true,\n   281→        .count = 3,\n   282→    };\n   283→    try std.testing.expect(result.success);\n   284→    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n   285→}\n   286→\n   287→test \"BlockedResult struct works\" {\n   288→    const result = BlockedResult{\n   289→        .success = true,\n   290→        .count = 2,\n   291→    };\n   292→    try std.testing.expect(result.success);\n   293→    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n   294→}\n   295→\n   296→test \"run detects uninitialized workspace\" {\n   297→    const allocator = std.testing.allocator;\n   298→\n   299→    const ready_args = args.ReadyArgs{};\n   300→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   301→\n   302→    const result = run(ready_args, global, allocator);\n   303→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   304→}\n   305→\n   306→test \"runBlocked detects uninitialized workspace\" {\n   307→    const allocator = std.testing.allocator;\n   308→\n   309→    const blocked_args = args.BlockedArgs{};\n   310→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   311→\n   312→    const result = runBlocked(blocked_args, global, allocator);\n   313→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   314→}\n   315→\n   316→test \"run returns empty list for empty workspace\" {\n   317→    const allocator = std.testing.allocator;\n   318→\n   319→    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n   320→    defer allocator.free(tmp_dir_path);\n   321→    defer test_util.cleanupTestDir(tmp_dir_path);\n   322→\n   323→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   324→    defer allocator.free(data_path);\n   325→\n   326→    try std.fs.cwd().makeDir(data_path);\n   327→\n   328→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   329→    defer allocator.free(issues_path);\n   330→\n   331→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   332→    f.close();\n   333→\n   334→    const ready_args = args.ReadyArgs{};\n   335→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   336→\n   337→    try run(ready_args, global, allocator);\n   338→}\n   339→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"783300ff-da49-45d4-ae75-3b1ad5082334"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Cu5m9mVF6hNogAqRZpLDq7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ft8dXk7zj5piMaqnzfVSpF","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9461,"cache_read_input_tokens":27335,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9461},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b60b650f-2fa5-4983-b012-6984213eadf8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ft8dXk7zj5piMaqnzfVSpF","type":"tool_result","content":"     1→//! Output formatting for beads_zig.\n     2→//!\n     3→//! Provides a unified interface for displaying output in different modes:\n     4→//! - plain: No colors, basic formatting (default for non-TTY)\n     5→//! - rich: Colors and formatting (default for TTY)\n     6→//! - json: Structured JSON output for machine consumption\n     7→//! - quiet: Minimal output (IDs only)\n     8→//!\n     9→//! Respects NO_COLOR environment variable and --no-color flag.\n    10→\n    11→const std = @import(\"std\");\n    12→const models = @import(\"../models/mod.zig\");\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→\n    18→/// Output mode determines formatting and verbosity.\n    19→pub const OutputMode = enum {\n    20→    plain, // No colors, basic formatting\n    21→    rich, // Colors and formatting (TTY)\n    22→    json, // Structured JSON output\n    23→    quiet, // Minimal output (IDs only)\n    24→};\n    25→\n    26→/// ANSI color escape codes.\n    27→pub const Color = struct {\n    28→    pub const reset = \"\\x1b[0m\";\n    29→    pub const bold = \"\\x1b[1m\";\n    30→    pub const dim = \"\\x1b[2m\";\n    31→    pub const italic = \"\\x1b[3m\";\n    32→    pub const underline = \"\\x1b[4m\";\n    33→\n    34→    pub const red = \"\\x1b[31m\";\n    35→    pub const green = \"\\x1b[32m\";\n    36→    pub const yellow = \"\\x1b[33m\";\n    37→    pub const blue = \"\\x1b[34m\";\n    38→    pub const magenta = \"\\x1b[35m\";\n    39→    pub const cyan = \"\\x1b[36m\";\n    40→    pub const white = \"\\x1b[37m\";\n    41→    pub const gray = \"\\x1b[90m\";\n    42→\n    43→    pub const bright_red = \"\\x1b[91m\";\n    44→    pub const bright_green = \"\\x1b[92m\";\n    45→    pub const bright_yellow = \"\\x1b[93m\";\n    46→    pub const bright_blue = \"\\x1b[94m\";\n    47→    pub const bright_magenta = \"\\x1b[95m\";\n    48→    pub const bright_cyan = \"\\x1b[96m\";\n    49→\n    50→    pub const bg_red = \"\\x1b[41m\";\n    51→    pub const bg_green = \"\\x1b[42m\";\n    52→    pub const bg_yellow = \"\\x1b[43m\";\n    53→    pub const bg_blue = \"\\x1b[44m\";\n    54→};\n    55→\n    56→/// Global options that affect output formatting.\n    57→/// This mirrors the relevant fields from cli.args.GlobalOptions.\n    58→pub const OutputOptions = struct {\n    59→    json: bool = false,\n    60→    toon: bool = false,\n    61→    quiet: bool = false,\n    62→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    63→    no_color: bool = false,\n    64→};\n    65→\n    66→/// Output formatter for consistent CLI output across all modes.\n    67→pub const Output = struct {\n    68→    mode: OutputMode,\n    69→    toon: bool,\n    70→    silent: bool, // Suppress ALL output including errors (for tests)\n    71→    stdout: std.fs.File,\n    72→    stderr: std.fs.File,\n    73→    allocator: std.mem.Allocator,\n    74→\n    75→    const Self = @This();\n    76→\n    77→    /// Initialize output formatter based on global options and TTY detection.\n    78→    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n    79→        const stdout = std.fs.File.stdout();\n    80→        const stderr = std.fs.File.stderr();\n    81→\n    82→        var mode: OutputMode = .plain;\n    83→        if (opts.json or opts.toon) {\n    84→            mode = .json;\n    85→        } else if (opts.quiet or opts.silent) {\n    86→            mode = .quiet;\n    87→        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n    88→            mode = .rich;\n    89→        }\n    90→\n    91→        return .{\n    92→            .mode = mode,\n    93→            .toon = opts.toon,\n    94→            .silent = opts.silent,\n    95→            .stdout = stdout,\n    96→            .stderr = stderr,\n    97→            .allocator = allocator,\n    98→        };\n    99→    }\n   100→\n   101→    /// Initialize with explicit mode (useful for testing).\n   102→    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n   103→        return .{\n   104→            .mode = mode,\n   105→            .toon = false,\n   106→            .silent = false,\n   107→            .stdout = std.fs.File.stdout(),\n   108→            .stderr = std.fs.File.stderr(),\n   109→            .allocator = allocator,\n   110→        };\n   111→    }\n   112→\n   113→    /// Initialize for testing with custom file handles.\n   114→    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n   115→        return .{\n   116→            .mode = mode,\n   117→            .toon = false,\n   118→            .silent = false,\n   119→            .stdout = stdout,\n   120→            .stderr = stderr,\n   121→            .allocator = allocator,\n   122→        };\n   123→    }\n   124→\n   125→    /// Initialize with silent mode (suppresses ALL output including errors).\n   126→    pub fn initSilent(allocator: std.mem.Allocator) Self {\n   127→        return .{\n   128→            .mode = .quiet,\n   129→            .toon = false,\n   130→            .silent = true,\n   131→            .stdout = std.fs.File.stdout(),\n   132→            .stderr = std.fs.File.stderr(),\n   133→            .allocator = allocator,\n   134→        };\n   135→    }\n   136→\n   137→    // ========================================================================\n   138→    // Issue Display\n   139→    // ========================================================================\n   140→\n   141→    /// Print a single issue in the appropriate format.\n   142→    pub fn printIssue(self: *Self, issue: Issue) !void {\n   143→        switch (self.mode) {\n   144→            .json => try self.printIssueJson(issue),\n   145→            .quiet => try self.printIssueQuiet(issue),\n   146→            .rich => try self.printIssueRich(issue),\n   147→            .plain => try self.printIssuePlain(issue),\n   148→        }\n   149→    }\n   150→\n   151→    /// Print a list of issues in the appropriate format.\n   152→    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n   153→        switch (self.mode) {\n   154→            .json => try self.printIssueListJson(issues),\n   155→            .quiet => try self.printIssueListQuiet(issues),\n   156→            .rich => try self.printIssueListRich(issues),\n   157→            .plain => try self.printIssueListPlain(issues),\n   158→        }\n   159→    }\n   160→\n   161→    // ========================================================================\n   162→    // Generic Messages\n   163→    // ========================================================================\n   164→\n   165→    /// Print a formatted message to stdout.\n   166→    pub fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   167→        if (self.mode == .quiet) return;\n   168→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   169→        defer self.allocator.free(msg);\n   170→        try self.stdout.writeAll(msg);\n   171→    }\n   172→\n   173→    /// Print a formatted message to stdout with newline.\n   174→    pub fn println(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   175→        if (self.mode == .quiet) return;\n   176→        const msg = try std.fmt.allocPrint(self.allocator, fmt ++ \"\\n\", args);\n   177→        defer self.allocator.free(msg);\n   178→        try self.stdout.writeAll(msg);\n   179→    }\n   180→\n   181→    /// Print a success message (green in rich mode).\n   182→    pub fn success(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   183→        if (self.mode == .quiet) return;\n   184→        if (self.mode == .rich) try self.stdout.writeAll(Color.green);\n   185→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   186→        defer self.allocator.free(msg);\n   187→        try self.stdout.writeAll(msg);\n   188→        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n   189→        try self.stdout.writeAll(\"\\n\");\n   190→    }\n   191→\n   192→    /// Print an error message to stderr (red in rich mode).\n   193→    pub fn err(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   194→        if (self.silent) return;\n   195→        if (self.mode == .rich) try self.stderr.writeAll(Color.red);\n   196→        const msg = try std.fmt.allocPrint(self.allocator, \"error: \" ++ fmt, args);\n   197→        defer self.allocator.free(msg);\n   198→        try self.stderr.writeAll(msg);\n   199→        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n   200→        try self.stderr.writeAll(\"\\n\");\n   201→    }\n   202→\n   203→    /// Print a warning message to stderr (yellow in rich mode).\n   204→    pub fn warn(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   205→        if (self.silent or self.mode == .quiet) return;\n   206→        if (self.mode == .rich) try self.stderr.writeAll(Color.yellow);\n   207→        const msg = try std.fmt.allocPrint(self.allocator, \"warning: \" ++ fmt, args);\n   208→        defer self.allocator.free(msg);\n   209→        try self.stderr.writeAll(msg);\n   210→        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n   211→        try self.stderr.writeAll(\"\\n\");\n   212→    }\n   213→\n   214→    /// Print an info message (cyan in rich mode).\n   215→    pub fn info(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   216→        if (self.mode == .quiet) return;\n   217→        if (self.mode == .rich) try self.stdout.writeAll(Color.cyan);\n   218→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   219→        defer self.allocator.free(msg);\n   220→        try self.stdout.writeAll(msg);\n   221→        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n   222→        try self.stdout.writeAll(\"\\n\");\n   223→    }\n   224→\n   225→    /// Print raw bytes to stdout (bypasses mode checks).\n   226→    pub fn raw(self: *Self, bytes: []const u8) !void {\n   227→        try self.stdout.writeAll(bytes);\n   228→    }\n   229→\n   230→    /// Print raw JSON value to stdout (for JSON mode).\n   231→    /// If toon mode is enabled, converts JSON to TOON format for reduced token usage.\n   232→    pub fn printJson(self: *Self, value: anytype) !void {\n   233→        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n   234→        defer self.allocator.free(json_bytes);\n   235→\n   236→        if (self.toon) {\n   237→            const toon = @import(\"toon_zig\");\n   238→            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |convert_err| {\n   239→                try self.stderr.writeAll(\"error: failed to convert to TOON format\\n\");\n   240→                return convert_err;\n   241→            };\n   242→            defer self.allocator.free(toon_bytes);\n   243→            try self.stdout.writeAll(toon_bytes);\n   244→        } else {\n   245→            try self.stdout.writeAll(json_bytes);\n   246→        }\n   247→        try self.stdout.writeAll(\"\\n\");\n   248→    }\n   249→\n   250→    // ========================================================================\n   251→    // JSON Mode Helpers\n   252→    // ========================================================================\n   253→\n   254→    fn printIssueJson(self: *Self, issue: Issue) !void {\n   255→        try self.printJson(issue);\n   256→    }\n   257→\n   258→    fn printIssueListJson(self: *Self, issues: []const Issue) !void {\n   259→        try self.printJson(issues);\n   260→    }\n   261→\n   262→    // ========================================================================\n   263→    // Plain Mode Helpers\n   264→    // ========================================================================\n   265→\n   266→    fn printIssuePlain(self: *Self, issue: Issue) !void {\n   267→        try self.writeFormatted(\"ID: {s}\\n\", .{issue.id});\n   268→        try self.writeFormatted(\"Title: {s}\\n\", .{issue.title});\n   269→        try self.writeFormatted(\"Status: {s}\\n\", .{issue.status.toString()});\n   270→        try self.writeFormatted(\"Priority: {s}\\n\", .{issue.priority.toString()});\n   271→        try self.writeFormatted(\"Type: {s}\\n\", .{issue.issue_type.toString()});\n   272→\n   273→        if (issue.description) |desc| {\n   274→            try self.writeFormatted(\"Description: {s}\\n\", .{desc});\n   275→        }\n   276→        if (issue.assignee) |assignee| {\n   277→            try self.writeFormatted(\"Assignee: {s}\\n\", .{assignee});\n   278→        }\n   279→        if (issue.labels.len > 0) {\n   280→            try self.stdout.writeAll(\"Labels: \");\n   281→            for (issue.labels, 0..) |label, i| {\n   282→                if (i > 0) try self.stdout.writeAll(\", \");\n   283→                try self.stdout.writeAll(label);\n   284→            }\n   285→            try self.stdout.writeAll(\"\\n\");\n   286→        }\n   287→        if (issue.due_at.value) |due| {\n   288→            try self.writeFormatted(\"Due: {d}\\n\", .{due});\n   289→        }\n   290→\n   291→        try self.writeFormatted(\"Created: {d}\\n\", .{issue.created_at.value});\n   292→        try self.writeFormatted(\"Updated: {d}\\n\", .{issue.updated_at.value});\n   293→    }\n   294→\n   295→    fn printIssueListPlain(self: *Self, issues: []const Issue) !void {\n   296→        for (issues) |issue| {\n   297→            const status_abbrev = abbreviateStatus(issue.status);\n   298→            try self.writeFormatted(\"{s}  [{s}] {s}\\n\", .{\n   299→                issue.id,\n   300→                status_abbrev,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b882bb96-f7eb-4211-ba42-8ea80c5c26ab"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014vCe4ebWdqFheRQZrCpqWT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NZQmfd7QzWXP9tBCspnkQF","name":"Grep","input":{"pattern":"fn parseListArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9095,"cache_read_input_tokens":36796,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9095},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"12cfd027-041b-48c1-aea9-fd98039b4af9"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_014vCe4ebWdqFheRQZrCpqWT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015B2n4metSzefNXcuZ64tyY","name":"Grep","input":{"pattern":"fn parseReadyArgs","path":"/home/hotschmoe/beads_zig/src/cli/args.zig","output_mode":"content","context":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9095,"cache_read_input_tokens":36796,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9095},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"550d924c-17a9-4aa2-828b-df502d9384b1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NZQmfd7QzWXP9tBCspnkQF","type":"tool_result","content":"998-                // Positional argument is treated as file path\n999-                if (result.file == null) {\n1000-                    result.file = self.next().?;\n1001-                } else break;\n1002-            } else break;\n1003-        }\n1004-        return result;\n1005-    }\n1006-\n1007-    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n1008-        var result = ImportArgs{ .file = undefined };\n1009-        var file_set = false;\n1010-\n1011-        while (self.hasNext()) {\n1012-            if (self.consumeFlag(\"-m\", \"--merge\")) {\n1013-                result.merge = true;\n1014-            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n1015-                result.dry_run = true;\n1016-            } else if (self.peekPositional()) |_| {\n1017-                if (!file_set) {\n1018-                    result.file = self.next().?;\n1019-                    file_set = true;\n1020-                } else break;\n1021-            } else break;\n1022-        }\n1023-\n1024-        if (!file_set) return error.MissingRequiredArgument;\n1025-        return result;\n1026-    }\n1027-\n1028:    fn parseListArgs(self: *Self) ParseError!ListArgs {\n1029-        var result = ListArgs{};\n1030-        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n1031-\n1032-        while (self.hasNext()) {\n1033-            if (self.consumeFlag(\"-s\", \"--status\")) {\n1034-                result.status = self.next() orelse return error.MissingFlagValue;\n1035-            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n1036-                result.priority = self.next() orelse return error.MissingFlagValue;\n1037-            } else if (self.consumeFlag(null, \"--priority-min\")) {\n1038-                result.priority_min = self.next() orelse return error.MissingFlagValue;\n1039-            } else if (self.consumeFlag(null, \"--priority-max\")) {\n1040-                result.priority_max = self.next() orelse return error.MissingFlagValue;\n1041-            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n1042-                result.issue_type = self.next() orelse return error.MissingFlagValue;\n1043-            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n1044-                result.assignee = self.next() orelse return error.MissingFlagValue;\n1045-            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n1046-                result.label = self.next() orelse return error.MissingFlagValue;\n1047-            } else if (self.consumeFlag(null, \"--label-any\")) {\n1048-                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n1049-            } else if (self.consumeFlag(null, \"--title-contains\")) {\n1050-                result.title_contains = self.next() orelse return error.MissingFlagValue;\n1051-            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n1052-                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n1053-            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n1054-                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n1055-            } else if (try self.parseLimitFlag()) |limit| {\n1056-                result.limit = limit;\n1057-            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n1058-                result.all = true;"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a5487ce2-7fa4-4ce6-86aa-75606f34712f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015B2n4metSzefNXcuZ64tyY","type":"tool_result","content":"1050-                result.title_contains = self.next() orelse return error.MissingFlagValue;\n1051-            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n1052-                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n1053-            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n1054-                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n1055-            } else if (try self.parseLimitFlag()) |limit| {\n1056-                result.limit = limit;\n1057-            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n1058-                result.all = true;\n1059-            } else if (self.consumeFlag(null, \"--overdue\")) {\n1060-                result.overdue = true;\n1061-            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n1062-                result.include_deferred = true;\n1063-            } else if (self.consumeFlag(null, \"--sort\")) {\n1064-                const sort_str = self.next() orelse return error.MissingFlagValue;\n1065-                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n1066-            } else if (self.consumeFlag(null, \"--asc\")) {\n1067-                result.sort_desc = false;\n1068-            } else if (self.consumeFlag(null, \"--desc\")) {\n1069-                result.sort_desc = true;\n1070-            } else break;\n1071-        }\n1072-\n1073-        if (label_any_list.items.len > 0) {\n1074-            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n1075-        }\n1076-\n1077-        return result;\n1078-    }\n1079-\n1080:    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n1081-        var result = ReadyArgs{};\n1082-        while (self.hasNext()) {\n1083-            if (try self.parseLimitFlag()) |limit| {\n1084-                result.limit = limit;\n1085-            } else if (self.consumeFlag(null, \"--priority-min\")) {\n1086-                result.priority_min = self.next() orelse return error.MissingFlagValue;\n1087-            } else if (self.consumeFlag(null, \"--priority-max\")) {\n1088-                result.priority_max = self.next() orelse return error.MissingFlagValue;\n1089-            } else if (self.consumeFlag(null, \"--title-contains\")) {\n1090-                result.title_contains = self.next() orelse return error.MissingFlagValue;\n1091-            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n1092-                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n1093-            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n1094-                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n1095-            } else if (self.consumeFlag(null, \"--overdue\")) {\n1096-                result.overdue = true;\n1097-            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n1098-                result.include_deferred = true;\n1099-            } else break;\n1100-        }\n1101-        return result;\n1102-    }\n1103-\n1104-    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n1105-        var result = BlockedArgs{};\n1106-        while (self.hasNext()) {\n1107-            if (try self.parseLimitFlag()) |limit| {\n1108-                result.limit = limit;\n1109-            } else if (self.consumeFlag(null, \"--priority-min\")) {\n1110-                result.priority_min = self.next() orelse return error.MissingFlagValue;"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"5dc5d278-4d31-4cb5-b08f-8554c557f21b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A2rfgiYGpFB3SFyRJgKc7r","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0139YvW64C8fYTurreufALBt","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2478,"cache_read_input_tokens":45891,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2478},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"0ff9559b-7b5c-4ac2-9e9b-74d272742476"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0139YvW64C8fYTurreufALBt","type":"tool_result","content":"     1→//! In-memory issue store for beads_zig.\n     2→//!\n     3→//! Provides CRUD operations for issues using in-memory storage with:\n     4→//! - Arena allocator for issue memory management\n     5→//! - ArrayList + StringHashMap for fast ID lookup\n     6→//! - Dirty tracking for sync operations\n     7→//! - JSONL persistence via JsonlFile\n     8→\n     9→const std = @import(\"std\");\n    10→const JsonlFile = @import(\"jsonl.zig\").JsonlFile;\n    11→const Issue = @import(\"../models/issue.zig\").Issue;\n    12→const Rfc3339Timestamp = @import(\"../models/issue.zig\").Rfc3339Timestamp;\n    13→const OptionalRfc3339Timestamp = @import(\"../models/issue.zig\").OptionalRfc3339Timestamp;\n    14→const Status = @import(\"../models/status.zig\").Status;\n    15→const Priority = @import(\"../models/priority.zig\").Priority;\n    16→const IssueType = @import(\"../models/issue_type.zig\").IssueType;\n    17→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    18→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    19→const Comment = @import(\"../models/comment.zig\").Comment;\n    20→\n    21→pub const IssueStoreError = error{\n    22→    IssueNotFound,\n    23→    DuplicateId,\n    24→    InvalidIssue,\n    25→    VersionMismatch,\n    26→};\n    27→\n    28→/// Result of loading the store with corruption tracking.\n    29→pub const StoreLoadResult = struct {\n    30→    /// Number of corrupt JSONL entries skipped.\n    31→    jsonl_corruption_count: usize = 0,\n    32→    /// Line numbers of corrupt JSONL entries (1-indexed).\n    33→    jsonl_corrupt_lines: []const usize = &.{},\n    34→\n    35→    pub fn hasCorruption(self: StoreLoadResult) bool {\n    36→        return self.jsonl_corruption_count > 0;\n    37→    }\n    38→\n    39→    pub fn deinit(self: *StoreLoadResult, allocator: std.mem.Allocator) void {\n    40→        if (self.jsonl_corrupt_lines.len > 0) {\n    41→            allocator.free(self.jsonl_corrupt_lines);\n    42→        }\n    43→    }\n    44→};\n    45→\n    46→pub const IssueStore = struct {\n    47→    allocator: std.mem.Allocator,\n    48→    issues: std.ArrayListUnmanaged(Issue),\n    49→    id_index: std.StringHashMapUnmanaged(usize),\n    50→    dirty_ids: std.StringHashMapUnmanaged(i64),\n    51→    dirty: bool,\n    52→    jsonl_path: []const u8,\n    53→\n    54→    const Self = @This();\n    55→\n    56→    pub fn init(allocator: std.mem.Allocator, jsonl_path: []const u8) Self {\n    57→        return .{\n    58→            .allocator = allocator,\n    59→            .issues = .{},\n    60→            .id_index = .{},\n    61→            .dirty_ids = .{},\n    62→            .dirty = false,\n    63→            .jsonl_path = jsonl_path,\n    64→        };\n    65→    }\n    66→\n    67→    pub fn deinit(self: *Self) void {\n    68→        for (self.issues.items) |*issue| {\n    69→            issue.deinit(self.allocator);\n    70→        }\n    71→        self.issues.deinit(self.allocator);\n    72→\n    73→        var id_it = self.id_index.keyIterator();\n    74→        while (id_it.next()) |key| {\n    75→            self.allocator.free(key.*);\n    76→        }\n    77→        self.id_index.deinit(self.allocator);\n    78→\n    79→        var dirty_it = self.dirty_ids.keyIterator();\n    80→        while (dirty_it.next()) |key| {\n    81→            self.allocator.free(key.*);\n    82→        }\n    83→        self.dirty_ids.deinit(self.allocator);\n    84→    }\n    85→\n    86→    /// Load issues from the JSONL file into memory.\n    87→    pub fn loadFromFile(self: *Self) !void {\n    88→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n    89→        const loaded_issues = try jsonl.readAll();\n    90→        defer self.allocator.free(loaded_issues);\n    91→\n    92→        for (loaded_issues) |issue| {\n    93→            const id_copy = try self.allocator.dupe(u8, issue.id);\n    94→            errdefer self.allocator.free(id_copy);\n    95→\n    96→            const idx = self.issues.items.len;\n    97→            try self.issues.append(self.allocator, issue);\n    98→            try self.id_index.put(self.allocator, id_copy, idx);\n    99→        }\n   100→\n   101→        self.dirty = false;\n   102→    }\n   103→\n   104→    /// Load issues from the JSONL file with graceful corruption recovery.\n   105→    /// Logs and skips corrupt entries instead of failing.\n   106→    /// Returns statistics about the load including corruption count.\n   107→    pub fn loadFromFileWithRecovery(self: *Self) !StoreLoadResult {\n   108→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n   109→        var load_result = try jsonl.readAllWithRecovery();\n   110→        // Take ownership of corrupt_lines before freeing issues slice\n   111→        const corrupt_lines = load_result.corrupt_lines;\n   112→        load_result.corrupt_lines = &.{}; // Prevent double-free\n   113→        errdefer if (corrupt_lines.len > 0) self.allocator.free(corrupt_lines);\n   114→\n   115→        const loaded_issues = load_result.issues;\n   116→        defer self.allocator.free(loaded_issues);\n   117→\n   118→        for (loaded_issues) |issue| {\n   119→            const id_copy = try self.allocator.dupe(u8, issue.id);\n   120→            errdefer self.allocator.free(id_copy);\n   121→\n   122→            const idx = self.issues.items.len;\n   123→            try self.issues.append(self.allocator, issue);\n   124→            try self.id_index.put(self.allocator, id_copy, idx);\n   125→        }\n   126→\n   127→        self.dirty = false;\n   128→\n   129→        return StoreLoadResult{\n   130→            .jsonl_corruption_count = load_result.corruption_count,\n   131→            .jsonl_corrupt_lines = corrupt_lines,\n   132→        };\n   133→    }\n   134→\n   135→    /// Save all issues to the JSONL file.\n   136→    pub fn saveToFile(self: *Self) !void {\n   137→        var jsonl = JsonlFile.init(self.jsonl_path, self.allocator);\n   138→        try jsonl.writeAll(self.issues.items);\n   139→        self.dirty = false;\n   140→\n   141→        // Clear dirty tracking\n   142→        var dirty_it = self.dirty_ids.keyIterator();\n   143→        while (dirty_it.next()) |key| {\n   144→            self.allocator.free(key.*);\n   145→        }\n   146→        self.dirty_ids.clearRetainingCapacity();\n   147→    }\n   148→\n   149→    /// Insert a new issue into the store.\n   150→    pub fn insert(self: *Self, issue: Issue) !void {\n   151→        if (self.id_index.contains(issue.id)) {\n   152→            return IssueStoreError.DuplicateId;\n   153→        }\n   154→\n   155→        const cloned = try issue.clone(self.allocator);\n   156→        errdefer {\n   157→            var c = cloned;\n   158→            c.deinit(self.allocator);\n   159→        }\n   160→\n   161→        const id_copy = try self.allocator.dupe(u8, cloned.id);\n   162→        errdefer self.allocator.free(id_copy);\n   163→\n   164→        const idx = self.issues.items.len;\n   165→        try self.issues.append(self.allocator, cloned);\n   166→        try self.id_index.put(self.allocator, id_copy, idx);\n   167→\n   168→        try self.markDirty(issue.id);\n   169→    }\n   170→\n   171→    /// Get an issue by ID (without embedded relations).\n   172→    pub fn get(self: *Self, id: []const u8) !?Issue {\n   173→        const idx = self.id_index.get(id) orelse return null;\n   174→        if (idx >= self.issues.items.len) return null;\n   175→\n   176→        return try self.issues.items[idx].clone(self.allocator);\n   177→    }\n   178→\n   179→    /// Get an issue with all embedded relations (labels, deps, comments).\n   180→    /// Since we store everything in-memory, this just returns the issue as-is.\n   181→    pub fn getWithRelations(self: *Self, id: []const u8) !?Issue {\n   182→        return try self.get(id);\n   183→    }\n   184→\n   185→    /// Get a reference to the stored issue (no clone).\n   186→    /// Caller must NOT free or modify the returned issue.\n   187→    pub fn getRef(self: *Self, id: []const u8) ?*Issue {\n   188→        const idx = self.id_index.get(id) orelse return null;\n   189→        if (idx >= self.issues.items.len) return null;\n   190→        return &self.issues.items[idx];\n   191→    }\n   192→\n   193→    /// Fields that can be updated on an issue.\n   194→    pub const IssueUpdate = struct {\n   195→        title: ?[]const u8 = null,\n   196→        description: ?[]const u8 = null,\n   197→        design: ?[]const u8 = null,\n   198→        acceptance_criteria: ?[]const u8 = null,\n   199→        notes: ?[]const u8 = null,\n   200→        status: ?Status = null,\n   201→        priority: ?Priority = null,\n   202→        issue_type: ?IssueType = null,\n   203→        assignee: ?[]const u8 = null,\n   204→        owner: ?[]const u8 = null,\n   205→        estimated_minutes: ?i32 = null,\n   206→        closed_at: ?i64 = null,\n   207→        close_reason: ?[]const u8 = null,\n   208→        closed_by_session: ?[]const u8 = null,\n   209→        due_at: ?i64 = null,\n   210→        defer_until: ?i64 = null,\n   211→        external_ref: ?[]const u8 = null,\n   212→        source_system: ?[]const u8 = null,\n   213→        pinned: ?bool = null,\n   214→        is_template: ?bool = null,\n   215→        content_hash: ?[]const u8 = null,\n   216→\n   217→        /// Expected version for optimistic locking.\n   218→        /// If set, update will fail with VersionMismatch if issue.version != expected_version.\n   219→        expected_version: ?u64 = null,\n   220→    };\n   221→\n   222→    /// Update an issue with the given fields.\n   223→    /// If updates.expected_version is set, performs optimistic locking check.\n   224→    pub fn update(self: *Self, id: []const u8, updates: IssueUpdate, now: i64) !void {\n   225→        const idx = self.id_index.get(id) orelse return IssueStoreError.IssueNotFound;\n   226→        if (idx >= self.issues.items.len) return IssueStoreError.IssueNotFound;\n   227→\n   228→        var issue = &self.issues.items[idx];\n   229→\n   230→        // Optimistic locking check\n   231→        if (updates.expected_version) |expected| {\n   232→            if (issue.version != expected) {\n   233→                return IssueStoreError.VersionMismatch;\n   234→            }\n   235→        }\n   236→\n   237→        // Increment version on every update\n   238→        issue.version += 1;\n   239→\n   240→        // Update timestamp\n   241→        issue.updated_at = Rfc3339Timestamp{ .value = now };\n   242→\n   243→        // Apply updates\n   244→        if (updates.title) |v| {\n   245→            self.allocator.free(issue.title);\n   246→            issue.title = try self.allocator.dupe(u8, v);\n   247→        }\n   248→        if (updates.description) |v| {\n   249→            if (issue.description) |d| self.allocator.free(d);\n   250→            issue.description = try self.allocator.dupe(u8, v);\n   251→        }\n   252→        if (updates.design) |v| {\n   253→            if (issue.design) |d| self.allocator.free(d);\n   254→            issue.design = try self.allocator.dupe(u8, v);\n   255→        }\n   256→        if (updates.acceptance_criteria) |v| {\n   257→            if (issue.acceptance_criteria) |a| self.allocator.free(a);\n   258→            issue.acceptance_criteria = try self.allocator.dupe(u8, v);\n   259→        }\n   260→        if (updates.notes) |v| {\n   261→            if (issue.notes) |n| self.allocator.free(n);\n   262→            issue.notes = try self.allocator.dupe(u8, v);\n   263→        }\n   264→        if (updates.status) |v| {\n   265→            freeStatus(issue.status, self.allocator);\n   266→            issue.status = try cloneStatus(v, self.allocator);\n   267→        }\n   268→        if (updates.priority) |v| {\n   269→            issue.priority = v;\n   270→        }\n   271→        if (updates.issue_type) |v| {\n   272→            freeIssueType(issue.issue_type, self.allocator);\n   273→            issue.issue_type = try cloneIssueType(v, self.allocator);\n   274→        }\n   275→        if (updates.assignee) |v| {\n   276→            if (issue.assignee) |a| self.allocator.free(a);\n   277→            issue.assignee = try self.allocator.dupe(u8, v);\n   278→        }\n   279→        if (updates.owner) |v| {\n   280→            if (issue.owner) |o| self.allocator.free(o);\n   281→            issue.owner = try self.allocator.dupe(u8, v);\n   282→        }\n   283→        if (updates.estimated_minutes) |v| {\n   284→            issue.estimated_minutes = v;\n   285→        }\n   286→        if (updates.closed_at) |v| {\n   287→            issue.closed_at = OptionalRfc3339Timestamp{ .value = v };\n   288→        }\n   289→        if (updates.close_reason) |v| {\n   290→            if (issue.close_reason) |r| self.allocator.free(r);\n   291→            issue.close_reason = try self.allocator.dupe(u8, v);\n   292→        }\n   293→        if (updates.closed_by_session) |v| {\n   294→            if (issue.closed_by_session) |s| self.allocator.free(s);\n   295→            issue.closed_by_session = try self.allocator.dupe(u8, v);\n   296→        }\n   297→        if (updates.due_at) |v| {\n   298→            issue.due_at = OptionalRfc3339Timestamp{ .value = v };\n   299→        }\n   300→        if (updates.defer_until) |v| {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"056120c2-3887-45ed-9fd1-7cb47f50d634"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A2rfgiYGpFB3SFyRJgKc7r","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QJ4CV6XjEhuBfuvExtLHcg","name":"Bash","input":{"command":"grep -n \"pub const ListFilters\" /home/hotschmoe/beads_zig/src/storage/store.zig | head -5"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2478,"cache_read_input_tokens":45891,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2478},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8f968a6f-39a5-49b4-bf9f-aa80e7602354"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QJ4CV6XjEhuBfuvExtLHcg","type":"tool_result","content":"331:    pub const ListFilters = struct {","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a2d90b33-46a6-4d0a-ac3a-4cd280de8198"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015PH3W7vQjY4XniSATgxpS5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hsr3yi479MxksYhNyP3TW9","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/store.zig","limit":200,"offset":331}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4793,"cache_read_input_tokens":48369,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4793},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4ffa14cd-734d-4995-af26-aac5452f3bff"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hsr3yi479MxksYhNyP3TW9","type":"tool_result","content":"   331→    pub const ListFilters = struct {\n   332→        status: ?Status = null,\n   333→        priority: ?Priority = null,\n   334→        priority_min: ?Priority = null,\n   335→        priority_max: ?Priority = null,\n   336→        issue_type: ?IssueType = null,\n   337→        assignee: ?[]const u8 = null,\n   338→        label: ?[]const u8 = null,\n   339→        label_any: []const []const u8 = &[_][]const u8{},\n   340→        title_contains: ?[]const u8 = null,\n   341→        desc_contains: ?[]const u8 = null,\n   342→        notes_contains: ?[]const u8 = null,\n   343→        include_tombstones: bool = false,\n   344→        overdue: bool = false,\n   345→        include_deferred: bool = false,\n   346→        limit: ?u32 = null,\n   347→        offset: ?u32 = null,\n   348→        order_by: OrderBy = .created_at,\n   349→        order_desc: bool = true,\n   350→\n   351→        pub const OrderBy = enum {\n   352→            created_at,\n   353→            updated_at,\n   354→            priority,\n   355→        };\n   356→    };\n   357→\n   358→    /// List issues with optional filters.\n   359→    pub fn list(self: *Self, filters: ListFilters) ![]Issue {\n   360→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   361→        errdefer {\n   362→            for (results.items) |*issue| {\n   363→                issue.deinit(self.allocator);\n   364→            }\n   365→            results.deinit(self.allocator);\n   366→        }\n   367→\n   368→        const now = if (filters.overdue) std.time.timestamp() else 0;\n   369→\n   370→        for (self.issues.items) |issue| {\n   371→            // Filter tombstones\n   372→            if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n   373→                continue;\n   374→            }\n   375→\n   376→            // Apply filters\n   377→            if (filters.status) |s| {\n   378→                // When include_deferred is set, allow deferred issues through even when filtering for open\n   379→                const status_matches = statusEql(issue.status, s);\n   380→                const deferred_allowed = filters.include_deferred and statusEql(issue.status, .deferred);\n   381→                if (!status_matches and !deferred_allowed) continue;\n   382→            }\n   383→            if (filters.priority) |p| {\n   384→                if (issue.priority.value != p.value) continue;\n   385→            }\n   386→            if (filters.issue_type) |t| {\n   387→                if (!issueTypeEql(issue.issue_type, t)) continue;\n   388→            }\n   389→            if (filters.assignee) |a| {\n   390→                if (issue.assignee == null) continue;\n   391→                if (!std.mem.eql(u8, issue.assignee.?, a)) continue;\n   392→            }\n   393→            if (filters.label) |lbl| {\n   394→                var found = false;\n   395→                for (issue.labels) |label| {\n   396→                    if (std.mem.eql(u8, label, lbl)) {\n   397→                        found = true;\n   398→                        break;\n   399→                    }\n   400→                }\n   401→                if (!found) continue;\n   402→            }\n   403→\n   404→            // label_any: OR logic - issue must have at least ONE of the specified labels\n   405→            if (filters.label_any.len > 0) {\n   406→                var found_any = false;\n   407→                for (filters.label_any) |any_label| {\n   408→                    for (issue.labels) |issue_label| {\n   409→                        if (std.mem.eql(u8, issue_label, any_label)) {\n   410→                            found_any = true;\n   411→                            break;\n   412→                        }\n   413→                    }\n   414→                    if (found_any) break;\n   415→                }\n   416→                if (!found_any) continue;\n   417→            }\n   418→\n   419→            // Priority range filters (lower value = higher priority)\n   420→            if (filters.priority_min) |min_p| {\n   421→                if (issue.priority.value < min_p.value) continue;\n   422→            }\n   423→            if (filters.priority_max) |max_p| {\n   424→                if (issue.priority.value > max_p.value) continue;\n   425→            }\n   426→\n   427→            // Substring filters (case-insensitive)\n   428→            if (filters.title_contains) |query| {\n   429→                if (!containsIgnoreCase(issue.title, query)) continue;\n   430→            }\n   431→            if (filters.desc_contains) |query| {\n   432→                if (issue.description) |desc| {\n   433→                    if (!containsIgnoreCase(desc, query)) continue;\n   434→                } else continue;\n   435→            }\n   436→            if (filters.notes_contains) |query| {\n   437→                if (issue.notes) |notes| {\n   438→                    if (!containsIgnoreCase(notes, query)) continue;\n   439→                } else continue;\n   440→            }\n   441→\n   442→            // Overdue filter: only include issues past their due date\n   443→            if (filters.overdue) {\n   444→                if (issue.due_at.value) |due_time| {\n   445→                    if (due_time >= now) continue;\n   446→                } else continue;\n   447→            }\n   448→\n   449→            try results.append(self.allocator, try issue.clone(self.allocator));\n   450→        }\n   451→\n   452→        // Sort\n   453→        const SortContext = struct {\n   454→            order_by: ListFilters.OrderBy,\n   455→            order_desc: bool,\n   456→        };\n   457→        const ctx = SortContext{ .order_by = filters.order_by, .order_desc = filters.order_desc };\n   458→\n   459→        std.mem.sortUnstable(Issue, results.items, ctx, struct {\n   460→            fn lessThan(c: SortContext, a: Issue, b: Issue) bool {\n   461→                const cmp: i64 = switch (c.order_by) {\n   462→                    .created_at => a.created_at.value - b.created_at.value,\n   463→                    .updated_at => a.updated_at.value - b.updated_at.value,\n   464→                    .priority => @as(i64, a.priority.value) - @as(i64, b.priority.value),\n   465→                };\n   466→                return if (c.order_desc) cmp > 0 else cmp < 0;\n   467→            }\n   468→        }.lessThan);\n   469→\n   470→        // Apply offset and limit\n   471→        var start: usize = 0;\n   472→        if (filters.offset) |off| {\n   473→            start = @min(off, results.items.len);\n   474→        }\n   475→\n   476→        var end: usize = results.items.len;\n   477→        if (filters.limit) |lim| {\n   478→            end = @min(start + lim, results.items.len);\n   479→        }\n   480→\n   481→        // Free items outside the range\n   482→        for (results.items[0..start]) |*issue| {\n   483→            issue.deinit(self.allocator);\n   484→        }\n   485→        for (results.items[end..]) |*issue| {\n   486→            issue.deinit(self.allocator);\n   487→        }\n   488→\n   489→        // Return slice\n   490→        const slice = try self.allocator.dupe(Issue, results.items[start..end]);\n   491→        results.deinit(self.allocator);\n   492→        return slice;\n   493→    }\n   494→\n   495→    /// Result from counting issues.\n   496→    pub const CountResult = struct {\n   497→        key: []const u8,\n   498→        count: u64,\n   499→    };\n   500→\n   501→    /// Count issues, optionally grouped by a field.\n   502→    pub fn count(self: *Self, group_by: ?GroupBy) ![]CountResult {\n   503→        var counts: std.StringHashMapUnmanaged(u64) = .{};\n   504→        defer counts.deinit(self.allocator);\n   505→\n   506→        for (self.issues.items) |issue| {\n   507→            if (statusEql(issue.status, .tombstone)) continue;\n   508→\n   509→            const key_str: []const u8 = if (group_by) |g| switch (g) {\n   510→                .status => issue.status.toString(),\n   511→                .priority => switch (issue.priority.value) {\n   512→                    0 => \"0\",\n   513→                    1 => \"1\",\n   514→                    2 => \"2\",\n   515→                    3 => \"3\",\n   516→                    4 => \"4\",\n   517→                    else => unreachable,\n   518→                },\n   519→                .issue_type => issue.issue_type.toString(),\n   520→                .assignee => issue.assignee orelse \"(unassigned)\",\n   521→            } else \"total\";\n   522→\n   523→            const entry = counts.getOrPutValue(self.allocator, key_str, 0) catch continue;\n   524→            entry.value_ptr.* += 1;\n   525→        }\n   526→\n   527→        var results: std.ArrayListUnmanaged(CountResult) = .{};\n   528→        errdefer {\n   529→            for (results.items) |r| {\n   530→                self.allocator.free(r.key);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c049c912-7d9a-466a-bca9-30f56b221e9c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015PH3W7vQjY4XniSATgxpS5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019PMVe1yCRoYoyU7MDSttjX","name":"Bash","input":{"command":"grep -n \"pub fn list\" /home/hotschmoe/beads_zig/src/storage/store.zig | head -3"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4793,"cache_read_input_tokens":48369,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4793},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"e18b455c-bc87-4c73-85f3-4a53daee955f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019PMVe1yCRoYoyU7MDSttjX","type":"tool_result","content":"359:    pub fn list(self: *Self, filters: ListFilters) ![]Issue {","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"96c12d0a-0f4f-4513-9ca3-d24f27077fa2"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DZEnkMBoEMehr9NmhENx5f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WQGHK5FUg9pqbgzqNyr3hM","name":"Bash","input":{"command":"grep -rn \"csv\\|CSV\" /home/hotschmoe/beads_zig/src/ 2>/dev/null | head -10"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3185,"cache_read_input_tokens":53162,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3185},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7bfa99db-fe31-463b-ba27-d6629f6c9a2f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WQGHK5FUg9pqbgzqNyr3hM","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4a42569a-75a5-47c5-aacc-f0b9a663159a"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DZEnkMBoEMehr9NmhENx5f","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0119RgKZ9UZMkYnSbFnWEqLK","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","limit":400,"offset":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3185,"cache_read_input_tokens":53162,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3185},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7ba1f420-ec5d-4993-bbf6-321868975f01"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0119RgKZ9UZMkYnSbFnWEqLK","type":"tool_result","content":"   300→                status_abbrev,\n   301→                issue.title,\n   302→            });\n   303→        }\n   304→    }\n   305→\n   306→    // ========================================================================\n   307→    // Rich Mode Helpers (ANSI colors)\n   308→    // ========================================================================\n   309→\n   310→    fn printIssueRich(self: *Self, issue: Issue) !void {\n   311→        // Bold ID\n   312→        try self.writeFormatted(\"{s}{s}{s}\\n\", .{ Color.bold, issue.id, Color.reset });\n   313→\n   314→        // Title\n   315→        try self.writeFormatted(\"  {s}\\n\", .{issue.title});\n   316→\n   317→        // Status with color\n   318→        const status_color = getStatusColor(issue.status);\n   319→        try self.writeFormatted(\"  Status: {s}{s}{s}\\n\", .{ status_color, issue.status.toString(), Color.reset });\n   320→\n   321→        // Priority with color\n   322→        const priority_color = getPriorityColor(issue.priority);\n   323→        try self.writeFormatted(\"  Priority: {s}{s}{s}\\n\", .{ priority_color, issue.priority.toString(), Color.reset });\n   324→\n   325→        // Type\n   326→        try self.writeFormatted(\"  Type: {s}\\n\", .{issue.issue_type.toString()});\n   327→\n   328→        // Optional fields\n   329→        if (issue.description) |desc| {\n   330→            try self.writeFormatted(\"  Description: {s}{s}{s}\\n\", .{ Color.dim, desc, Color.reset });\n   331→        }\n   332→        if (issue.assignee) |assignee| {\n   333→            try self.writeFormatted(\"  Assignee: {s}{s}{s}\\n\", .{ Color.cyan, assignee, Color.reset });\n   334→        }\n   335→        if (issue.labels.len > 0) {\n   336→            try self.stdout.writeAll(\"  Labels: \");\n   337→            for (issue.labels, 0..) |label, i| {\n   338→                if (i > 0) try self.stdout.writeAll(\", \");\n   339→                try self.writeFormatted(\"{s}{s}{s}\", .{ Color.magenta, label, Color.reset });\n   340→            }\n   341→            try self.stdout.writeAll(\"\\n\");\n   342→        }\n   343→    }\n   344→\n   345→    fn printIssueListRich(self: *Self, issues: []const Issue) !void {\n   346→        for (issues) |issue| {\n   347→            const status_color = getStatusColor(issue.status);\n   348→            const priority_color = getPriorityColor(issue.priority);\n   349→            const status_abbrev = abbreviateStatus(issue.status);\n   350→\n   351→            try self.writeFormatted(\"{s}{s}{s}  {s}[{s}]{s}  {s}{s}{s}  {s}\\n\", .{\n   352→                Color.bold,\n   353→                issue.id,\n   354→                Color.reset,\n   355→                status_color,\n   356→                status_abbrev,\n   357→                Color.reset,\n   358→                priority_color,\n   359→                priorityIndicator(issue.priority),\n   360→                Color.reset,\n   361→                issue.title,\n   362→            });\n   363→        }\n   364→    }\n   365→\n   366→    // ========================================================================\n   367→    // Quiet Mode Helpers\n   368→    // ========================================================================\n   369→\n   370→    fn printIssueQuiet(self: *Self, issue: Issue) !void {\n   371→        try self.writeFormatted(\"{s}\\n\", .{issue.id});\n   372→    }\n   373→\n   374→    fn printIssueListQuiet(self: *Self, issues: []const Issue) !void {\n   375→        for (issues) |issue| {\n   376→            try self.writeFormatted(\"{s}\\n\", .{issue.id});\n   377→        }\n   378→    }\n   379→\n   380→    // ========================================================================\n   381→    // Internal Helpers\n   382→    // ========================================================================\n   383→\n   384→    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   385→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   386→        defer self.allocator.free(msg);\n   387→        try self.stdout.writeAll(msg);\n   388→    }\n   389→};\n   390→\n   391→// ============================================================================\n   392→// Helper Functions\n   393→// ============================================================================\n   394→\n   395→/// Check if NO_COLOR environment variable is set (cross-platform).\n   396→fn checkNoColorEnv() bool {\n   397→    // Per NO_COLOR spec, only existence matters, not the value\n   398→    return std.process.hasEnvVarConstant(\"NO_COLOR\");\n   399→}\n   400→\n   401→/// Get ANSI color for a status.\n   402→fn getStatusColor(status: Status) []const u8 {\n   403→    return switch (status) {\n   404→        .open => Color.green,\n   405→        .in_progress => Color.yellow,\n   406→        .blocked => Color.red,\n   407→        .deferred => Color.gray,\n   408→        .closed => Color.gray,\n   409→        .tombstone => Color.dim,\n   410→        .pinned => Color.bright_cyan,\n   411→        .custom => Color.blue,\n   412→    };\n   413→}\n   414→\n   415→/// Get ANSI color for a priority.\n   416→fn getPriorityColor(priority: Priority) []const u8 {\n   417→    return switch (priority.value) {\n   418→        0 => Color.bright_red, // critical\n   419→        1 => Color.red, // high\n   420→        2 => Color.yellow, // medium\n   421→        3 => Color.green, // low\n   422→        4 => Color.gray, // backlog\n   423→        else => Color.reset,\n   424→    };\n   425→}\n   426→\n   427→/// Get short status abbreviation.\n   428→fn abbreviateStatus(status: Status) []const u8 {\n   429→    return switch (status) {\n   430→        .open => \"OPEN\",\n   431→        .in_progress => \"PROG\",\n   432→        .blocked => \"BLKD\",\n   433→        .deferred => \"DEFR\",\n   434→        .closed => \"DONE\",\n   435→        .tombstone => \"DEL \",\n   436→        .pinned => \"PIN \",\n   437→        .custom => \"CUST\",\n   438→    };\n   439→}\n   440→\n   441→/// Get priority indicator symbol.\n   442→fn priorityIndicator(priority: Priority) []const u8 {\n   443→    return switch (priority.value) {\n   444→        0 => \"!!!\",\n   445→        1 => \"!! \",\n   446→        2 => \"!  \",\n   447→        3 => \".  \",\n   448→        4 => \"   \",\n   449→        else => \"   \",\n   450→    };\n   451→}\n   452→\n   453→// ============================================================================\n   454→// Tests\n   455→// ============================================================================\n   456→\n   457→test \"OutputMode enum values\" {\n   458→    try std.testing.expectEqual(OutputMode.plain, OutputMode.plain);\n   459→    try std.testing.expectEqual(OutputMode.rich, OutputMode.rich);\n   460→    try std.testing.expectEqual(OutputMode.json, OutputMode.json);\n   461→    try std.testing.expectEqual(OutputMode.quiet, OutputMode.quiet);\n   462→}\n   463→\n   464→test \"Output.init with json option\" {\n   465→    const allocator = std.testing.allocator;\n   466→    const opts = OutputOptions{ .json = true };\n   467→    const output = Output.init(allocator, opts);\n   468→    try std.testing.expectEqual(OutputMode.json, output.mode);\n   469→    try std.testing.expect(!output.toon);\n   470→}\n   471→\n   472→test \"Output.init with toon option\" {\n   473→    const allocator = std.testing.allocator;\n   474→    const opts = OutputOptions{ .toon = true };\n   475→    const output = Output.init(allocator, opts);\n   476→    try std.testing.expectEqual(OutputMode.json, output.mode);\n   477→    try std.testing.expect(output.toon);\n   478→}\n   479→\n   480→test \"Output.init with quiet option\" {\n   481→    const allocator = std.testing.allocator;\n   482→    const opts = OutputOptions{ .quiet = true };\n   483→    const output = Output.init(allocator, opts);\n   484→    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n   485→}\n   486→\n   487→test \"Output.init with no_color option forces plain mode\" {\n   488→    const allocator = std.testing.allocator;\n   489→    const opts = OutputOptions{ .no_color = true };\n   490→    const output = Output.init(allocator, opts);\n   491→    try std.testing.expectEqual(OutputMode.plain, output.mode);\n   492→}\n   493→\n   494→test \"Output.init json overrides quiet\" {\n   495→    const allocator = std.testing.allocator;\n   496→    const opts = OutputOptions{ .json = true, .quiet = true };\n   497→    const output = Output.init(allocator, opts);\n   498→    try std.testing.expectEqual(OutputMode.json, output.mode);\n   499→}\n   500→\n   501→test \"Output.initWithMode sets explicit mode\" {\n   502→    const allocator = std.testing.allocator;\n   503→    const output = Output.initWithMode(allocator, .rich);\n   504→    try std.testing.expectEqual(OutputMode.rich, output.mode);\n   505→}\n   506→\n   507→test \"abbreviateStatus returns 4-char strings\" {\n   508→    const statuses = [_]Status{\n   509→        .open,\n   510→        .in_progress,\n   511→        .blocked,\n   512→        .deferred,\n   513→        .closed,\n   514→        .tombstone,\n   515→        .pinned,\n   516→        .{ .custom = \"test\" },\n   517→    };\n   518→    for (statuses) |status| {\n   519→        const abbrev = abbreviateStatus(status);\n   520→        try std.testing.expectEqual(@as(usize, 4), abbrev.len);\n   521→    }\n   522→}\n   523→\n   524→test \"priorityIndicator returns 3-char strings\" {\n   525→    var p: u3 = 0;\n   526→    while (p <= 4) : (p += 1) {\n   527→        const priority = Priority{ .value = p };\n   528→        const indicator = priorityIndicator(priority);\n   529→        try std.testing.expectEqual(@as(usize, 3), indicator.len);\n   530→    }\n   531→}\n   532→\n   533→test \"getStatusColor returns valid ANSI codes\" {\n   534→    const statuses = [_]Status{\n   535→        .open,\n   536→        .in_progress,\n   537→        .blocked,\n   538→        .deferred,\n   539→        .closed,\n   540→        .tombstone,\n   541→        .pinned,\n   542→        .{ .custom = \"test\" },\n   543→    };\n   544→    for (statuses) |status| {\n   545→        const color = getStatusColor(status);\n   546→        try std.testing.expect(color.len > 0);\n   547→        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n   548→    }\n   549→}\n   550→\n   551→test \"getPriorityColor returns valid ANSI codes\" {\n   552→    var p: u3 = 0;\n   553→    while (p <= 4) : (p += 1) {\n   554→        const priority = Priority{ .value = p };\n   555→        const color = getPriorityColor(priority);\n   556→        try std.testing.expect(color.len > 0);\n   557→        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n   558→    }\n   559→}\n   560→\n   561→test \"Color constants are valid ANSI escape sequences\" {\n   562→    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n   563→    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n   564→    try std.testing.expect(std.mem.startsWith(u8, Color.red, \"\\x1b[\"));\n   565→    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n   566→    try std.testing.expect(std.mem.startsWith(u8, Color.yellow, \"\\x1b[\"));\n   567→    try std.testing.expect(std.mem.startsWith(u8, Color.blue, \"\\x1b[\"));\n   568→    try std.testing.expect(std.mem.startsWith(u8, Color.gray, \"\\x1b[\"));\n   569→}\n   570→\n   571→test \"Output printIssueListQuiet writes IDs only\" {\n   572→    // Test the quiet formatting logic directly\n   573→    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n   574→    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n   575→    const issues = [_]Issue{ issue1, issue2 };\n   576→\n   577→    // In quiet mode, printIssueListQuiet outputs \"{id}\\n\" for each issue\n   578→    // Verify the expected output format\n   579→    try std.testing.expectEqualStrings(\"bd-abc123\", issue1.id);\n   580→    try std.testing.expectEqualStrings(\"bd-def456\", issue2.id);\n   581→    try std.testing.expectEqual(@as(usize, 2), issues.len);\n   582→}\n   583→\n   584→test \"Output printIssueListPlain writes formatted lines\" {\n   585→    // Test the plain formatting logic via abbreviateStatus and Issue fields\n   586→    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n   587→\n   588→    // Verify issue fields are correct\n   589→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   590→    try std.testing.expectEqualStrings(\"Test issue\", issue.title);\n   591→    try std.testing.expectEqual(Status.open, issue.status);\n   592→\n   593→    // Verify status abbreviation\n   594→    const status_abbrev = abbreviateStatus(issue.status);\n   595→    try std.testing.expectEqualStrings(\"OPEN\", status_abbrev);\n   596→}\n   597→\n   598→test \"Output printIssueListRich includes ANSI codes\" {\n   599→    // Test that rich mode formatting uses ANSI codes\n   600→    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n   601→\n   602→    // Verify issue fields\n   603→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   604→\n   605→    // Verify rich mode uses color codes\n   606→    const status_color = getStatusColor(issue.status);\n   607→    try std.testing.expect(std.mem.startsWith(u8, status_color, \"\\x1b[\"));\n   608→\n   609→    const priority_color = getPriorityColor(issue.priority);\n   610→    try std.testing.expect(std.mem.startsWith(u8, priority_color, \"\\x1b[\"));\n   611→\n   612→    // Verify Color.bold is used\n   613→    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n   614→}\n   615→\n   616→test \"Output printIssueListJson produces valid JSON array\" {\n   617→    const allocator = std.testing.allocator;\n   618→\n   619→    // Test JSON serialization directly\n   620→    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n   621→    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n   622→    const issues = [_]Issue{ issue1, issue2 };\n   623→\n   624→    // Serialize to JSON\n   625→    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n   626→    defer allocator.free(json_bytes);\n   627→\n   628→    // Verify it starts with [ and contains expected data\n   629→    try std.testing.expect(std.mem.startsWith(u8, json_bytes, \"[\"));\n   630→    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-abc123\") != null);\n   631→    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-def456\") != null);\n   632→\n   633→    // Verify it can be parsed back\n   634→    const parsed = try std.json.parseFromSlice([]const Issue, allocator, json_bytes, .{});\n   635→    defer parsed.deinit();\n   636→    try std.testing.expectEqual(@as(usize, 2), parsed.value.len);\n   637→}\n   638→\n   639→test \"Output.err formats error messages correctly\" {\n   640→    const allocator = std.testing.allocator;\n   641→\n   642→    // Test the error message formatting\n   643→    const msg = try std.fmt.allocPrint(allocator, \"error: \" ++ \"something went wrong: {s}\", .{\"test error\"});\n   644→    defer allocator.free(msg);\n   645→\n   646→    try std.testing.expect(std.mem.indexOf(u8, msg, \"error:\") != null);\n   647→    try std.testing.expect(std.mem.indexOf(u8, msg, \"test error\") != null);\n   648→}\n   649→\n   650→test \"Output.warn formats warning messages correctly\" {\n   651→    const allocator = std.testing.allocator;\n   652→\n   653→    // Test the warning message formatting\n   654→    const msg = try std.fmt.allocPrint(allocator, \"warning: \" ++ \"this is a warning: {s}\", .{\"be careful\"});\n   655→    defer allocator.free(msg);\n   656→\n   657→    try std.testing.expect(std.mem.indexOf(u8, msg, \"warning:\") != null);\n   658→    try std.testing.expect(std.mem.indexOf(u8, msg, \"be careful\") != null);\n   659→}\n   660→\n   661→test \"Output quiet mode suppresses print but not err\" {\n   662→    const allocator = std.testing.allocator;\n   663→\n   664→    // Test quiet mode behavior through Output struct logic\n   665→    const output = Output.initWithMode(allocator, .quiet);\n   666→\n   667→    // Verify quiet mode is set\n   668→    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n   669→\n   670→    // The print/println/success/warn methods check mode == .quiet and return early\n   671→    // The err method does NOT check for quiet mode (always prints)\n   672→    // This is the documented behavior we're testing\n   673→}\n   674→\n   675→test \"Output.success uses green color in rich mode\" {\n   676→    const allocator = std.testing.allocator;\n   677→\n   678→    // Test that success would use green color in rich mode\n   679→    const output = Output.initWithMode(allocator, .rich);\n   680→    try std.testing.expectEqual(OutputMode.rich, output.mode);\n   681→\n   682→    // Verify Color.green is a valid ANSI escape\n   683→    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n   684→    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n   685→}\n   686→\n   687→test \"Output.printIssue in plain mode shows all fields\" {\n   688→    // Test issue field access and formatting\n   689→    var issue = Issue.init(\"bd-abc123\", \"Test issue title\", 1706540000);\n   690→    issue.description = \"A test description\";\n   691→    issue.assignee = \"alice@example.com\";\n   692→\n   693→    // Verify all fields that would be printed\n   694→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   695→    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n   696→    try std.testing.expectEqual(Status.open, issue.status);\n   697→    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n   698→    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n   699→    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"69525cb8-13b4-4728-911e-7764db98e68f"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01YJGYTxe9xTvqeWjBJNpEa2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FvJjsKCwjxmYaoNr8FuM4W","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/issue.zig","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6065,"cache_read_input_tokens":56347,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6065},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"318b1797-498d-4f07-8b80-d440c24b1b84"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FvJjsKCwjxmYaoNr8FuM4W","type":"tool_result","content":"     1→//! Issue struct - the primary entity in beads_zig.\n     2→//!\n     3→//! Issues track tasks, bugs, features, and other work items. All fields align\n     4→//! with beads_rust for JSONL compatibility. Timestamps are Unix epoch internally\n     5→//! but serialize to RFC3339 format in JSON for JSONL export.\n     6→\n     7→const std = @import(\"std\");\n     8→const Status = @import(\"status.zig\").Status;\n     9→const Priority = @import(\"priority.zig\").Priority;\n    10→const IssueType = @import(\"issue_type.zig\").IssueType;\n    11→const Dependency = @import(\"dependency.zig\").Dependency;\n    12→const Comment = @import(\"comment.zig\").Comment;\n    13→const timestamp = @import(\"timestamp.zig\");\n    14→\n    15→/// Validation errors for Issue.\n    16→pub const IssueError = error{\n    17→    EmptyTitle,\n    18→    TitleTooLong,\n    19→    EmptyId,\n    20→};\n    21→\n    22→/// RFC3339 timestamp wrapper for JSON serialization.\n    23→/// Stores Unix epoch internally but serializes as RFC3339 string.\n    24→pub const Rfc3339Timestamp = struct {\n    25→    value: i64,\n    26→\n    27→    const Self = @This();\n    28→\n    29→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    30→        const epoch_seconds = std.time.epoch.EpochSeconds{ .secs = @intCast(self.value) };\n    31→        const day_seconds = epoch_seconds.getDaySeconds();\n    32→        const epoch_day = epoch_seconds.getEpochDay();\n    33→        const year_day = epoch_day.calculateYearDay();\n    34→        const month_day = year_day.calculateMonthDay();\n    35→\n    36→        var buf: [25]u8 = undefined;\n    37→        const formatted = std.fmt.bufPrint(&buf, \"{d:0>4}-{d:0>2}-{d:0>2}T{d:0>2}:{d:0>2}:{d:0>2}Z\", .{\n    38→            year_day.year,\n    39→            @as(u32, month_day.month.numeric()),\n    40→            @as(u32, month_day.day_index) + 1,\n    41→            day_seconds.getHoursIntoDay(),\n    42→            day_seconds.getMinutesIntoHour(),\n    43→            day_seconds.getSecondsIntoMinute(),\n    44→        }) catch unreachable;\n    45→\n    46→        try jws.write(formatted);\n    47→    }\n    48→\n    49→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    50→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    51→        const str = switch (token) {\n    52→            .string, .allocated_string => |s| s,\n    53→            else => return error.UnexpectedToken,\n    54→        };\n    55→        return Self{ .value = timestamp.parseRfc3339(str) orelse return error.InvalidCharacter };\n    56→    }\n    57→\n    58→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    59→        _ = allocator;\n    60→        _ = options;\n    61→        return switch (source) {\n    62→            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    63→            .integer => |i| Self{ .value = i },\n    64→            else => error.UnexpectedToken,\n    65→        };\n    66→    }\n    67→};\n    68→\n    69→/// Optional RFC3339 timestamp wrapper for nullable timestamp fields.\n    70→pub const OptionalRfc3339Timestamp = struct {\n    71→    value: ?i64,\n    72→\n    73→    const Self = @This();\n    74→\n    75→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    76→        if (self.value) |v| {\n    77→            const ts = Rfc3339Timestamp{ .value = v };\n    78→            try ts.jsonStringify(jws);\n    79→        } else {\n    80→            try jws.write(null);\n    81→        }\n    82→    }\n    83→\n    84→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    85→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    86→        return switch (token) {\n    87→            .null => Self{ .value = null },\n    88→            .string, .allocated_string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    89→            else => error.UnexpectedToken,\n    90→        };\n    91→    }\n    92→\n    93→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    94→        _ = allocator;\n    95→        _ = options;\n    96→        return switch (source) {\n    97→            .null => Self{ .value = null },\n    98→            .string => |s| Self{ .value = timestamp.parseRfc3339(s) orelse return error.InvalidCharacter },\n    99→            .integer => |i| Self{ .value = i },\n   100→            else => error.UnexpectedToken,\n   101→        };\n   102→    }\n   103→};\n   104→\n   105→/// The primary issue entity. All fields align with beads_rust for JSONL compatibility.\n   106→pub const Issue = struct {\n   107→    // Identity\n   108→    id: []const u8,\n   109→    content_hash: ?[]const u8,\n   110→\n   111→    // Content\n   112→    title: []const u8,\n   113→    description: ?[]const u8,\n   114→    design: ?[]const u8,\n   115→    acceptance_criteria: ?[]const u8,\n   116→    notes: ?[]const u8,\n   117→\n   118→    // Classification\n   119→    status: Status,\n   120→    priority: Priority,\n   121→    issue_type: IssueType,\n   122→\n   123→    // Assignment\n   124→    assignee: ?[]const u8,\n   125→    owner: ?[]const u8,\n   126→\n   127→    // Timestamps (Unix epoch seconds, serialized as RFC3339)\n   128→    created_at: Rfc3339Timestamp,\n   129→    created_by: ?[]const u8,\n   130→    updated_at: Rfc3339Timestamp,\n   131→    closed_at: OptionalRfc3339Timestamp,\n   132→    close_reason: ?[]const u8,\n   133→    closed_by_session: ?[]const u8 = null,\n   134→\n   135→    // Scheduling\n   136→    due_at: OptionalRfc3339Timestamp,\n   137→    defer_until: OptionalRfc3339Timestamp,\n   138→    estimated_minutes: ?i32,\n   139→\n   140→    // External references\n   141→    external_ref: ?[]const u8,\n   142→    source_system: ?[]const u8,\n   143→\n   144→    // Flags\n   145→    pinned: bool,\n   146→    is_template: bool,\n   147→    ephemeral: bool = false, // Local-only, not written to JSONL\n   148→\n   149→    // Version for optimistic locking (incremented on every update)\n   150→    version: u64 = 1,\n   151→\n   152→    // Embedded relations (populated on read, not stored in issues table)\n   153→    labels: []const []const u8,\n   154→    dependencies: []const Dependency,\n   155→    comments: []const Comment,\n   156→\n   157→    const Self = @This();\n   158→\n   159→    /// Validate that the issue has all required fields and constraints.\n   160→    pub fn validate(self: Self) IssueError!void {\n   161→        if (self.id.len == 0) return IssueError.EmptyId;\n   162→        if (self.title.len == 0) return IssueError.EmptyTitle;\n   163→        if (self.title.len > 500) return IssueError.TitleTooLong;\n   164→    }\n   165→\n   166→    /// Check equality between two Issues (compares all fields except embedded relations).\n   167→    pub fn eql(a: Self, b: Self) bool {\n   168→        if (!std.mem.eql(u8, a.id, b.id)) return false;\n   169→        if (!optionalStrEql(a.content_hash, b.content_hash)) return false;\n   170→        if (!std.mem.eql(u8, a.title, b.title)) return false;\n   171→        if (!optionalStrEql(a.description, b.description)) return false;\n   172→        if (!optionalStrEql(a.design, b.design)) return false;\n   173→        if (!optionalStrEql(a.acceptance_criteria, b.acceptance_criteria)) return false;\n   174→        if (!optionalStrEql(a.notes, b.notes)) return false;\n   175→        if (!statusEql(a.status, b.status)) return false;\n   176→        if (a.priority.value != b.priority.value) return false;\n   177→        if (!issueTypeEql(a.issue_type, b.issue_type)) return false;\n   178→        if (!optionalStrEql(a.assignee, b.assignee)) return false;\n   179→        if (!optionalStrEql(a.owner, b.owner)) return false;\n   180→        if (a.created_at.value != b.created_at.value) return false;\n   181→        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n   182→        if (a.updated_at.value != b.updated_at.value) return false;\n   183→        if (a.closed_at.value != b.closed_at.value) return false;\n   184→        if (!optionalStrEql(a.close_reason, b.close_reason)) return false;\n   185→        if (!optionalStrEql(a.closed_by_session, b.closed_by_session)) return false;\n   186→        if (a.due_at.value != b.due_at.value) return false;\n   187→        if (a.defer_until.value != b.defer_until.value) return false;\n   188→        if (a.estimated_minutes != b.estimated_minutes) return false;\n   189→        if (!optionalStrEql(a.external_ref, b.external_ref)) return false;\n   190→        if (!optionalStrEql(a.source_system, b.source_system)) return false;\n   191→        if (a.pinned != b.pinned) return false;\n   192→        if (a.is_template != b.is_template) return false;\n   193→        if (a.ephemeral != b.ephemeral) return false;\n   194→        if (a.version != b.version) return false;\n   195→        return true;\n   196→    }\n   197→\n   198→    /// Clone the issue with deep copy of all allocated strings.\n   199→    pub fn clone(self: Self, allocator: std.mem.Allocator) !Self {\n   200→        var result: Self = undefined;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"44f7055b-032e-487d-aaeb-01a4a165497e"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Vu1gEKRXpJjeEakfcfUqrd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CY9dvcoUXvawkt4GUu5Rbj","name":"Bash","input":{"command":"grep -n \"epic\\|parent\\|parent_id\" /home/hotschmoe/beads_zig/src/models/issue.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3373,"cache_read_input_tokens":62412,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3373},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"ae04294c-4bc6-4878-b297-fa54c1642c10"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CY9dvcoUXvawkt4GUu5Rbj","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"875cc511-ad9a-4a5d-a6e2-0aa46326d85b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Vu1gEKRXpJjeEakfcfUqrd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NZnVs1K8XsgU3WJkBwvjVL","name":"Bash","input":{"command":"find /home/hotschmoe/beads_zig/src/cli -name \"epic.zig\" -exec wc -l {} \\;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3373,"cache_read_input_tokens":62412,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3373},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"61af72cf-94db-4af1-8d5f-b510da6ac4de"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NZnVs1K8XsgU3WJkBwvjVL","type":"tool_result","content":"458 /home/hotschmoe/beads_zig/src/cli/epic.zig","is_error":false}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8d8d67cc-281b-4a96-9b92-3c15191f7bf3"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AYoWn1HWvFyoDZHEMcEk4z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LwsMY2qz8Fq9onwB4PLZAt","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/epic.zig","limit":250}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":307,"cache_read_input_tokens":65785,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":307},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8bcd0136-bf8f-4828-860c-2d359b124c86"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LwsMY2qz8Fq9onwB4PLZAt","type":"tool_result","content":"     1→//! Epic management commands for beads_zig.\n     2→//!\n     3→//! `bz epic create <title>` - Create a new epic (issue with type=epic)\n     4→//! `bz epic add <epic_id> <issue_id>` - Add an issue to an epic\n     5→//! `bz epic remove <epic_id> <issue_id>` - Remove an issue from an epic\n     6→//! `bz epic list <epic_id>` - List issues in an epic\n     7→//!\n     8→//! Epics are high-level issues that contain other issues. The relationship\n     9→//! is modeled using the parent_child dependency type.\n    10→\n    11→const std = @import(\"std\");\n    12→const models = @import(\"../models/mod.zig\");\n    13→const storage = @import(\"../storage/mod.zig\");\n    14→const id_gen = @import(\"../id/mod.zig\");\n    15→const common = @import(\"common.zig\");\n    16→const args = @import(\"args.zig\");\n    17→const test_util = @import(\"../test_util.zig\");\n    18→\n    19→const Issue = models.Issue;\n    20→const Priority = models.Priority;\n    21→const Dependency = models.Dependency;\n    22→const CommandContext = common.CommandContext;\n    23→const DependencyGraph = common.DependencyGraph;\n    24→const DependencyGraphError = storage.DependencyGraphError;\n    25→\n    26→pub const EpicError = error{\n    27→    WorkspaceNotInitialized,\n    28→    EpicNotFound,\n    29→    IssueNotFound,\n    30→    NotAnEpic,\n    31→    StorageError,\n    32→    OutOfMemory,\n    33→    EmptyTitle,\n    34→    TitleTooLong,\n    35→    InvalidPriority,\n    36→};\n    37→\n    38→pub const EpicResult = struct {\n    39→    success: bool,\n    40→    id: ?[]const u8 = null,\n    41→    epic_id: ?[]const u8 = null,\n    42→    issue_id: ?[]const u8 = null,\n    43→    action: ?[]const u8 = null,\n    44→    issues: ?[]const IssueInfo = null,\n    45→    message: ?[]const u8 = null,\n    46→};\n    47→\n    48→const IssueInfo = struct {\n    49→    id: []const u8,\n    50→    title: []const u8,\n    51→    status: []const u8,\n    52→    priority: u8,\n    53→};\n    54→\n    55→pub fn run(\n    56→    epic_args: args.EpicArgs,\n    57→    global: args.GlobalOptions,\n    58→    allocator: std.mem.Allocator,\n    59→) !void {\n    60→    switch (epic_args.subcommand) {\n    61→        .create => |create| try runCreate(create, global, allocator),\n    62→        .add => |add| try runAdd(add, global, allocator),\n    63→        .remove => |remove| try runRemove(remove, global, allocator),\n    64→        .list => |list| try runList(list, global, allocator),\n    65→    }\n    66→}\n    67→\n    68→fn runCreate(\n    69→    create_args: anytype,\n    70→    global: args.GlobalOptions,\n    71→    allocator: std.mem.Allocator,\n    72→) !void {\n    73→    var output = common.initOutput(allocator, global);\n    74→    const structured_output = global.isStructuredOutput();\n    75→\n    76→    if (create_args.title.len == 0) {\n    77→        try common.outputErrorTyped(EpicResult, &output, structured_output, \"title cannot be empty\");\n    78→        return EpicError.EmptyTitle;\n    79→    }\n    80→    if (create_args.title.len > 500) {\n    81→        try common.outputErrorTyped(EpicResult, &output, structured_output, \"title exceeds 500 character limit\");\n    82→        return EpicError.TitleTooLong;\n    83→    }\n    84→\n    85→    const beads_dir = global.data_path orelse \".beads\";\n    86→    const issues_path = try std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" });\n    87→    defer allocator.free(issues_path);\n    88→\n    89→    std.fs.cwd().access(issues_path, .{}) catch |err| {\n    90→        if (err == error.FileNotFound) {\n    91→            try common.outputErrorTyped(EpicResult, &output, structured_output, \"workspace not initialized. Run 'bz init' first.\");\n    92→            return EpicError.WorkspaceNotInitialized;\n    93→        }\n    94→        try common.outputErrorTyped(EpicResult, &output, structured_output, \"cannot access workspace\");\n    95→        return EpicError.StorageError;\n    96→    };\n    97→\n    98→    var store = storage.IssueStore.init(allocator, issues_path);\n    99→    defer store.deinit();\n   100→\n   101→    store.loadFromFile() catch |err| {\n   102→        if (err != error.FileNotFound) {\n   103→            try common.outputErrorTyped(EpicResult, &output, structured_output, \"failed to load issues\");\n   104→            return EpicError.StorageError;\n   105→        }\n   106→    };\n   107→\n   108→    const priority = if (create_args.priority) |p|\n   109→        Priority.fromString(p) catch {\n   110→            try common.outputErrorTyped(EpicResult, &output, structured_output, \"invalid priority value\");\n   111→            return EpicError.InvalidPriority;\n   112→        }\n   113→    else\n   114→        Priority.MEDIUM;\n   115→\n   116→    const actor = global.actor orelse common.getDefaultActor();\n   117→    const prefix = try common.getConfigPrefix(allocator, beads_dir);\n   118→    defer allocator.free(prefix);\n   119→\n   120→    var generator = id_gen.IdGenerator.init(prefix);\n   121→    const issue_count = store.countTotal();\n   122→    const issue_id = try generator.generate(allocator, issue_count);\n   123→    defer allocator.free(issue_id);\n   124→\n   125→    const now = std.time.timestamp();\n   126→    var issue = Issue.init(issue_id, create_args.title, now);\n   127→    issue.description = create_args.description;\n   128→    issue.priority = priority;\n   129→    issue.issue_type = .epic;\n   130→    issue.created_by = actor;\n   131→\n   132→    store.insert(issue) catch {\n   133→        try common.outputErrorTyped(EpicResult, &output, structured_output, \"failed to create epic\");\n   134→        return EpicError.StorageError;\n   135→    };\n   136→\n   137→    if (!global.no_auto_flush) {\n   138→        store.saveToFile() catch {\n   139→            try common.outputErrorTyped(EpicResult, &output, structured_output, \"failed to save issues\");\n   140→            return EpicError.StorageError;\n   141→        };\n   142→    }\n   143→\n   144→    if (structured_output) {\n   145→        try output.printJson(EpicResult{\n   146→            .success = true,\n   147→            .id = issue_id,\n   148→            .action = \"created\",\n   149→        });\n   150→    } else if (global.quiet) {\n   151→        try output.raw(issue_id);\n   152→        try output.raw(\"\\n\");\n   153→    } else {\n   154→        try output.success(\"Created epic {s}\", .{issue_id});\n   155→    }\n   156→}\n   157→\n   158→fn runAdd(\n   159→    add_args: anytype,\n   160→    global: args.GlobalOptions,\n   161→    allocator: std.mem.Allocator,\n   162→) !void {\n   163→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   164→        return EpicError.WorkspaceNotInitialized;\n   165→    };\n   166→    defer ctx.deinit();\n   167→\n   168→    const structured_output = global.isStructuredOutput();\n   169→\n   170→    const epic = try ctx.store.get(add_args.epic_id);\n   171→    if (epic == null) {\n   172→        try common.outputNotFoundError(EpicResult, &ctx.output, structured_output, add_args.epic_id, allocator);\n   173→        return EpicError.EpicNotFound;\n   174→    }\n   175→    var e = epic.?;\n   176→    defer e.deinit(allocator);\n   177→\n   178→    if (e.issue_type != .epic) {\n   179→        if (structured_output) {\n   180→            try ctx.output.printJson(EpicResult{\n   181→                .success = false,\n   182→                .message = \"issue is not an epic\",\n   183→            });\n   184→        } else {\n   185→            try ctx.output.err(\"issue {s} is not an epic (type: {s})\", .{ add_args.epic_id, e.issue_type.toString() });\n   186→        }\n   187→        return EpicError.NotAnEpic;\n   188→    }\n   189→\n   190→    if (!try ctx.store.exists(add_args.issue_id)) {\n   191→        try common.outputNotFoundError(EpicResult, &ctx.output, structured_output, add_args.issue_id, allocator);\n   192→        return EpicError.IssueNotFound;\n   193→    }\n   194→\n   195→    var graph = ctx.createGraph();\n   196→    const now = std.time.timestamp();\n   197→    const dep = Dependency{\n   198→        .issue_id = add_args.issue_id,\n   199→        .depends_on_id = add_args.epic_id,\n   200→        .dep_type = .parent_child,\n   201→        .created_at = now,\n   202→        .created_by = global.actor,\n   203→        .metadata = null,\n   204→        .thread_id = null,\n   205→    };\n   206→\n   207→    graph.addDependency(dep) catch |err| {\n   208→        const msg = switch (err) {\n   209→            DependencyGraphError.SelfDependency => \"cannot add epic to itself\",\n   210→            DependencyGraphError.CycleDetected => \"adding to epic would create a cycle\",\n   211→            DependencyGraphError.IssueNotFound => \"issue not found\",\n   212→            else => \"failed to add issue to epic\",\n   213→        };\n   214→        if (structured_output) {\n   215→            try ctx.output.printJson(EpicResult{ .success = false, .message = msg });\n   216→        } else {\n   217→            try ctx.output.err(\"{s}\", .{msg});\n   218→        }\n   219→        return EpicError.StorageError;\n   220→    };\n   221→\n   222→    try ctx.saveIfAutoFlush();\n   223→\n   224→    if (structured_output) {\n   225→        try ctx.output.printJson(EpicResult{\n   226→            .success = true,\n   227→            .epic_id = add_args.epic_id,\n   228→            .issue_id = add_args.issue_id,\n   229→            .action = \"added\",\n   230→        });\n   231→    } else if (!global.quiet) {\n   232→        try ctx.output.success(\"Added {s} to epic {s}\", .{ add_args.issue_id, add_args.epic_id });\n   233→    }\n   234→}\n   235→\n   236→fn runRemove(\n   237→    remove_args: anytype,\n   238→    global: args.GlobalOptions,\n   239→    allocator: std.mem.Allocator,\n   240→) !void {\n   241→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   242→        return EpicError.WorkspaceNotInitialized;\n   243→    };\n   244→    defer ctx.deinit();\n   245→\n   246→    const structured_output = global.isStructuredOutput();\n   247→\n   248→    var graph = ctx.createGraph();\n   249→\n   250→    graph.removeDependency(remove_args.issue_id, remove_args.epic_id) catch |err| {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a75d5993-7215-4b97-b498-5506da204dd7"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01SQQYEctuHyXV7WHHNB4tu5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LAmtniTF1frgHgXimFTbUQ","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/models/dependency.zig","limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3752,"cache_read_input_tokens":66092,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3752},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8be7d8d5-0d6c-4fde-9b36-1a1fbfafae33"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LAmtniTF1frgHgXimFTbUQ","type":"tool_result","content":"     1→//! Dependency types and the Dependency struct for tracking relationships between issues.\n     2→//!\n     3→//! Dependencies model the relationships between issues - blocking relationships,\n     4→//! parent-child hierarchies, and other associations. The dependency graph\n     5→//! enables the \"ready\" query (issues with no blockers) and cycle detection.\n     6→\n     7→const std = @import(\"std\");\n     8→\n     9→/// Dependency relationship types between issues.\n    10→pub const DependencyType = union(enum) {\n    11→    blocks,\n    12→    parent_child,\n    13→    conditional_blocks,\n    14→    waits_for,\n    15→    related,\n    16→    discovered_from,\n    17→    replies_to,\n    18→    relates_to,\n    19→    duplicates,\n    20→    supersedes,\n    21→    caused_by,\n    22→    custom: []const u8,\n    23→\n    24→    const Self = @This();\n    25→\n    26→    /// Convert DependencyType to its string representation.\n    27→    pub fn toString(self: Self) []const u8 {\n    28→        return switch (self) {\n    29→            .blocks => \"blocks\",\n    30→            .parent_child => \"parent_child\",\n    31→            .conditional_blocks => \"conditional_blocks\",\n    32→            .waits_for => \"waits_for\",\n    33→            .related => \"related\",\n    34→            .discovered_from => \"discovered_from\",\n    35→            .replies_to => \"replies_to\",\n    36→            .relates_to => \"relates_to\",\n    37→            .duplicates => \"duplicates\",\n    38→            .supersedes => \"supersedes\",\n    39→            .caused_by => \"caused_by\",\n    40→            .custom => |s| s,\n    41→        };\n    42→    }\n    43→\n    44→    /// Parse a string into a DependencyType (case-insensitive for known values).\n    45→    /// Returns .custom for unknown values.\n    46→    pub fn fromString(s: []const u8) Self {\n    47→        if (std.ascii.eqlIgnoreCase(s, \"blocks\")) return .blocks;\n    48→        if (std.ascii.eqlIgnoreCase(s, \"parent_child\")) return .parent_child;\n    49→        if (std.ascii.eqlIgnoreCase(s, \"conditional_blocks\")) return .conditional_blocks;\n    50→        if (std.ascii.eqlIgnoreCase(s, \"waits_for\")) return .waits_for;\n    51→        if (std.ascii.eqlIgnoreCase(s, \"related\")) return .related;\n    52→        if (std.ascii.eqlIgnoreCase(s, \"discovered_from\")) return .discovered_from;\n    53→        if (std.ascii.eqlIgnoreCase(s, \"replies_to\")) return .replies_to;\n    54→        if (std.ascii.eqlIgnoreCase(s, \"relates_to\")) return .relates_to;\n    55→        if (std.ascii.eqlIgnoreCase(s, \"duplicates\")) return .duplicates;\n    56→        if (std.ascii.eqlIgnoreCase(s, \"supersedes\")) return .supersedes;\n    57→        if (std.ascii.eqlIgnoreCase(s, \"caused_by\")) return .caused_by;\n    58→        return .{ .custom = s };\n    59→    }\n    60→\n    61→    /// Check equality between two DependencyTypes.\n    62→    pub fn eql(a: Self, b: Self) bool {\n    63→        const Tag = std.meta.Tag(Self);\n    64→        const tag_a: Tag = a;\n    65→        const tag_b: Tag = b;\n    66→        if (tag_a != tag_b) return false;\n    67→        return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n    68→    }\n    69→\n    70→    /// JSON serialization for std.json.\n    71→    pub fn jsonStringify(self: Self, jws: anytype) !void {\n    72→        try jws.write(self.toString());\n    73→    }\n    74→\n    75→    /// JSON deserialization for std.json.\n    76→    pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n    77→        const token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);\n    78→        const str = switch (token) {\n    79→            .string, .allocated_string => |s| s,\n    80→            else => return error.UnexpectedToken,\n    81→        };\n    82→        return fromString(str);\n    83→    }\n    84→\n    85→    /// JSON deserialization from already-parsed value.\n    86→    pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) !Self {\n    87→        _ = allocator;\n    88→        _ = options;\n    89→        return switch (source) {\n    90→            .string => |s| fromString(s),\n    91→            else => error.UnexpectedToken,\n    92→        };\n    93→    }\n    94→};\n    95→\n    96→/// A dependency relationship between two issues.\n    97→/// issue_id depends ON depends_on_id (issue_id is blocked BY depends_on_id).\n    98→pub const Dependency = struct {\n    99→    issue_id: []const u8,\n   100→    depends_on_id: []const u8,\n   101→    dep_type: DependencyType,\n   102→    created_at: i64,\n   103→    created_by: ?[]const u8,\n   104→    metadata: ?[]const u8,\n   105→    thread_id: ?[]const u8,\n   106→\n   107→    const Self = @This();\n   108→\n   109→    /// Check deep equality between two Dependencies.\n   110→    pub fn eql(a: Self, b: Self) bool {\n   111→        if (!std.mem.eql(u8, a.issue_id, b.issue_id)) return false;\n   112→        if (!std.mem.eql(u8, a.depends_on_id, b.depends_on_id)) return false;\n   113→        if (!DependencyType.eql(a.dep_type, b.dep_type)) return false;\n   114→        if (a.created_at != b.created_at) return false;\n   115→        if (!optionalStrEql(a.created_by, b.created_by)) return false;\n   116→        if (!optionalStrEql(a.metadata, b.metadata)) return false;\n   117→        if (!optionalStrEql(a.thread_id, b.thread_id)) return false;\n   118→        return true;\n   119→    }\n   120→\n   121→    fn optionalStrEql(a: ?[]const u8, b: ?[]const u8) bool {\n   122→        const a_val = a orelse return b == null;\n   123→        const b_val = b orelse return false;\n   124→        return std.mem.eql(u8, a_val, b_val);\n   125→    }\n   126→};\n   127→\n   128→// --- DependencyType Tests ---\n   129→\n   130→test \"DependencyType.toString returns correct strings for known types\" {\n   131→    try std.testing.expectEqualStrings(\"blocks\", (DependencyType{ .blocks = {} }).toString());\n   132→    try std.testing.expectEqualStrings(\"parent_child\", (DependencyType{ .parent_child = {} }).toString());\n   133→    try std.testing.expectEqualStrings(\"conditional_blocks\", (DependencyType{ .conditional_blocks = {} }).toString());\n   134→    try std.testing.expectEqualStrings(\"waits_for\", (DependencyType{ .waits_for = {} }).toString());\n   135→    try std.testing.expectEqualStrings(\"related\", (DependencyType{ .related = {} }).toString());\n   136→    try std.testing.expectEqualStrings(\"discovered_from\", (DependencyType{ .discovered_from = {} }).toString());\n   137→    try std.testing.expectEqualStrings(\"replies_to\", (DependencyType{ .replies_to = {} }).toString());\n   138→    try std.testing.expectEqualStrings(\"relates_to\", (DependencyType{ .relates_to = {} }).toString());\n   139→    try std.testing.expectEqualStrings(\"duplicates\", (DependencyType{ .duplicates = {} }).toString());\n   140→    try std.testing.expectEqualStrings(\"supersedes\", (DependencyType{ .supersedes = {} }).toString());\n   141→    try std.testing.expectEqualStrings(\"caused_by\", (DependencyType{ .caused_by = {} }).toString());\n   142→}\n   143→\n   144→test \"DependencyType.toString returns custom string for custom type\" {\n   145→    const custom = DependencyType{ .custom = \"my_custom_dep\" };\n   146→    try std.testing.expectEqualStrings(\"my_custom_dep\", custom.toString());\n   147→}\n   148→\n   149→test \"DependencyType.fromString parses known types correctly\" {\n   150→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"blocks\"));\n   151→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"parent_child\"));\n   152→    try std.testing.expectEqual(DependencyType.conditional_blocks, DependencyType.fromString(\"conditional_blocks\"));\n   153→    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"waits_for\"));\n   154→    try std.testing.expectEqual(DependencyType.related, DependencyType.fromString(\"related\"));\n   155→    try std.testing.expectEqual(DependencyType.discovered_from, DependencyType.fromString(\"discovered_from\"));\n   156→    try std.testing.expectEqual(DependencyType.replies_to, DependencyType.fromString(\"replies_to\"));\n   157→    try std.testing.expectEqual(DependencyType.relates_to, DependencyType.fromString(\"relates_to\"));\n   158→    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"duplicates\"));\n   159→    try std.testing.expectEqual(DependencyType.supersedes, DependencyType.fromString(\"supersedes\"));\n   160→    try std.testing.expectEqual(DependencyType.caused_by, DependencyType.fromString(\"caused_by\"));\n   161→}\n   162→\n   163→test \"DependencyType.fromString is case-insensitive\" {\n   164→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"BLOCKS\"));\n   165→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"Blocks\"));\n   166→    try std.testing.expectEqual(DependencyType.blocks, DependencyType.fromString(\"bLoCkS\"));\n   167→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"PARENT_CHILD\"));\n   168→    try std.testing.expectEqual(DependencyType.parent_child, DependencyType.fromString(\"Parent_Child\"));\n   169→    try std.testing.expectEqual(DependencyType.waits_for, DependencyType.fromString(\"WAITS_FOR\"));\n   170→    try std.testing.expectEqual(DependencyType.duplicates, DependencyType.fromString(\"DUPLICATES\"));\n   171→}\n   172→\n   173→test \"DependencyType.fromString returns custom for unknown values\" {\n   174→    const result = DependencyType.fromString(\"unknown_dep_type\");\n   175→    switch (result) {\n   176→        .custom => |s| try std.testing.expectEqualStrings(\"unknown_dep_type\", s),\n   177→        else => return error.TestExpectedCustom,\n   178→    }\n   179→}\n   180→\n   181→test \"DependencyType toString/fromString roundtrip for known types\" {\n   182→    const dep_types = [_]DependencyType{\n   183→        .blocks,\n   184→        .parent_child,\n   185→        .conditional_blocks,\n   186→        .waits_for,\n   187→        .related,\n   188→        .discovered_from,\n   189→        .replies_to,\n   190→        .relates_to,\n   191→        .duplicates,\n   192→        .supersedes,\n   193→        .caused_by,\n   194→    };\n   195→\n   196→    for (dep_types) |dep_type| {\n   197→        const str = dep_type.toString();\n   198→        const parsed = DependencyType.fromString(str);\n   199→        try std.testing.expectEqual(dep_type, parsed);\n   200→    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a1004015-4a2e-49cb-a601-c2356d74cdba"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C4JYT2ow9YhRiQz1CTATU8","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me create a comprehensive analysis document:\n\n## Comprehensive Implementation Guide for beads_zig Features\n\nBased on my thorough exploration of the codebase, here's everything you need to know to implement the two features:\n\n---\n\n### 1. CLI ARGUMENT PARSING STRUCTURE\n\n**File**: `/home/hotschmoe/beads_zig/src/cli/args.zig`\n\nThe argument parsing follows a clear pattern:\n\n#### Key Structures:\n- **GlobalOptions** (lines 8-26): Global flags like `--json`, `--toon`, `--quiet`, `--verbose`, `--no-color`, etc.\n- **ListArgs** (lines 216-235): List command arguments including filters\n- **ReadyArgs** (lines 237-247): Ready command arguments\n- **ParseResult** (lines 512-536): Result of parsing with global options and command\n\n#### Parsing Pattern (Lines 1028-1078):\n```zig\nfn parseListArgs(self: *Self) ParseError!ListArgs {\n    var result = ListArgs{};\n    \n    while (self.hasNext()) {\n        if (self.consumeFlag(\"-s\", \"--status\")) {\n            result.status = self.next() orelse return error.MissingFlagValue;\n        } else if (self.consumeFlag(null, \"--priority-min\")) {\n            result.priority_min = self.next() orelse return error.MissingFlagValue;\n        } else if (self.consumeFlag(null, \"--overdue\")) {\n            result.overdue = true;\n        }\n        // ... more flags\n    }\n    return result;\n}\n```\n\n#### Key Methods:\n- `consumeFlag(short, long)`: Check if flag matches and consume it\n- `next()`: Get next argument value\n- `hasNext()`: Check if more args remain\n- Boolean flags use `consumeFlag()` with no value extraction\n- Flags with values call `self.next()` after `consumeFlag()`\n\n---\n\n### 2. LIST & READY COMMANDS IMPLEMENTATION\n\n**Files**: \n- `/home/hotschmoe/beads_zig/src/cli/list.zig` (163 lines)\n- `/home/hotschmoe/beads_zig/src/cli/ready.zig` (339 lines)\n\n#### List Command Flow:\n1. Create `CommandContext` (handles store initialization)\n2. Build `IssueStore.ListFilters` struct from arguments\n3. Call `ctx.store.list(filters)` \n4. Format output based on mode (plain, rich, json, quiet)\n\n**Key Pattern** (lines 43-163):\n```zig\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n    \n    // Set filters from list_args\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    }\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {...};\n    }\n    // ... more filters\n    \n    const issues = try ctx.store.list(filters);\n    defer { /* cleanup */ }\n    \n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(ListResult{...});\n    } else {\n        try ctx.output.printIssueList(issues);\n    }\n}\n```\n\n#### Ready Command Filter Application (lines 215-269):\n```zig\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // Returns early if no filters\n    if (priority_min == null and priority_max == null and ...) {\n        return try allocator.dupe(Issue, issues);\n    }\n    \n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    \n    for (issues) |issue| {\n        // Skip with continue if doesn't match\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        try filtered.append(allocator, issue);\n    }\n    \n    return filtered.toOwnedSlice(allocator);\n}\n```\n\n---\n\n### 3. STORAGE LAYER & FILTERS\n\n**File**: `/home/hotschmoe/beads_zig/src/storage/store.zig`\n\n#### ListFilters Struct (lines 331-356):\n```zig\npub const ListFilters = struct {\n    status: ?Status = null,\n    priority: ?Priority = null,\n    priority_min: ?Priority = null,\n    priority_max: ?Priority = null,\n    issue_type: ?IssueType = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    include_tombstones: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    limit: ?u32 = null,\n    offset: ?u32 = null,\n    order_by: OrderBy = .created_at,\n    order_desc: bool = true,\n\n    pub const OrderBy = enum {\n        created_at,\n        updated_at,\n        priority,\n    };\n};\n```\n\n#### List Function (lines 359-493):\n- Iterates all issues and applies filters (continue pattern for exclusion)\n- Sorts results using custom comparator\n- Applies offset/limit\n- Returns owned slice to caller\n\n**Filter Pattern**:\n```zig\nfor (self.issues.items) |issue| {\n    // Skip tombstones\n    if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n        continue;\n    }\n    \n    // Apply all filters with early exit\n    if (filters.status) |s| { ... if (!match) continue; }\n    if (filters.priority) |p| { if (issue.priority.value != p.value) continue; }\n    if (filters.priority_min) |min_p| { \n        if (issue.priority.value < min_p.value) continue; \n    }\n    \n    try results.append(self.allocator, try issue.clone(self.allocator));\n}\n```\n\n---\n\n### 4. OUTPUT FORMATTING SYSTEM\n\n**File**: `/home/hotschmoe/beads_zig/src/output/mod.zig` (699 lines)\n\n#### OutputMode Enum (lines 19-24):\n```zig\npub const OutputMode = enum {\n    plain,   // No colors, basic formatting\n    rich,    // Colors and formatting (TTY)\n    json,    // Structured JSON output\n    quiet,   // Minimal output (IDs only)\n};\n```\n\n#### Output Interface:\n```zig\npub const Output = struct {\n    mode: OutputMode,\n    toon: bool,\n    silent: bool,\n    stdout: std.fs.File,\n    stderr: std.fs.File,\n    allocator: std.mem.Allocator,\n    \n    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueListJson(issues),\n            .quiet => try self.printIssueListQuiet(issues),\n            .rich => try self.printIssueListRich(issues),\n            .plain => try self.printIssueListPlain(issues),\n        }\n    }\n    \n    pub fn printJson(self: *Self, value: anytype) !void {\n        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n        defer self.allocator.free(json_bytes);\n        \n        if (self.toon) {\n            // Convert to TOON format (token-optimized)\n            const toon = @import(\"toon_zig\");\n            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |err| {...};\n            defer self.allocator.free(toon_bytes);\n            try self.stdout.writeAll(toon_bytes);\n        } else {\n            try self.stdout.writeAll(json_bytes);\n        }\n        try self.stdout.writeAll(\"\\n\");\n    }\n};\n```\n\n#### Format Methods (by mode):\n- **Plain** (lines 295-303): No colors, simple formatting\n- **Rich** (lines 345-364): ANSI colors, formatted output\n- **JSON** (lines 254-260): Structured JSON serialization\n- **Quiet** (lines 374-378): IDs only\n\n---\n\n### 5. DEPENDENCY GRAPH & HIERARCHY\n\n**File**: `/home/hotschmoe/beads_zig/src/storage/graph.zig` (665 lines)\n\n#### DependencyGraph Structure (lines 24-35):\n```zig\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n    \n    // Key methods:\n    pub fn addDependency(self: *Self, dep: Dependency) !void { ... }\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void { ... }\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency { ... }\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency { ... }\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool { ... }\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue { ... }\n    pub fn getBlockedIssues(self: *Self) ![]Issue { ... }\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue { ... }\n};\n```\n\n#### DependencyType Variants (src/models/dependency.zig, lines 10-22):\n```zig\npub const DependencyType = union(enum) {\n    blocks,\n    parent_child,           // <-- Hierarchy relationship!\n    conditional_blocks,\n    waits_for,\n    related,\n    discovered_from,\n    replies_to,\n    relates_to,\n    duplicates,\n    supersedes,\n    caused_by,\n    custom: []const u8,\n};\n```\n\n#### Dependency Structure (lines 98-106):\n```zig\npub const Dependency = struct {\n    issue_id: []const u8,       // Child/dependent issue\n    depends_on_id: []const u8,  // Parent/blocking issue\n    dep_type: DependencyType,\n    created_at: i64,\n    created_by: ?[]const u8,\n    metadata: ?[]const u8,\n    thread_id: ?[]const u8,\n};\n```\n\n---\n\n### 6. EPIC COMMAND HIERARCHY PATTERN\n\n**File**: `/home/hotschmoe/beads_zig/src/cli/epic.zig` (458 lines)\n\nShows real hierarchy usage pattern (lines 195-206):\n```zig\nvar graph = ctx.createGraph();\nconst now = std.time.timestamp();\nconst dep = Dependency{\n    .issue_id = add_args.issue_id,           // Child issue\n    .depends_on_id = add_args.epic_id,       // Parent epic\n    .dep_type = .parent_child,               // Hierarchy type!\n    .created_at = now,\n    .created_by = global.actor,\n    .metadata = null,\n    .thread_id = null,\n};\n\ngraph.addDependency(dep) catch |err| {\n    const msg = switch (err) {\n        DependencyGraphError.SelfDependency => \"cannot add epic to itself\",\n        DependencyGraphError.CycleDetected => \"adding to epic would create a cycle\",\n        DependencyGraphError.IssueNotFound => \"issue not found\",\n        else => \"failed to add issue to epic\",\n    };\n    // ... error handling\n};\n```\n\n**Key Pattern**: Parent-child hierarchies are implemented using `DependencyType.parent_child`, where:\n- `issue_id` = child/member\n- `depends_on_id` = parent/container\n\n---\n\n### 7. ISSUE MODEL & AVAILABLE FIELDS\n\n**File**: `/home/hotschmoe/beads_zig/src/models/issue.zig` (lines 106-156)\n\nAll available fields for CSV output:\n```zig\npub const Issue = struct {\n    // Identity\n    id: []const u8,\n    content_hash: ?[]const u8,\n    \n    // Content\n    title: []const u8,\n    description: ?[]const u8,\n    design: ?[]const u8,\n    acceptance_criteria: ?[]const u8,\n    notes: ?[]const u8,\n    \n    // Classification\n    status: Status,\n    priority: Priority,\n    issue_type: IssueType,\n    \n    // Assignment\n    assignee: ?[]const u8,\n    owner: ?[]const u8,\n    \n    // Timestamps (Unix epoch, serialized as RFC3339)\n    created_at: Rfc3339Timestamp,\n    created_by: ?[]const u8,\n    updated_at: Rfc3339Timestamp,\n    closed_at: OptionalRfc3339Timestamp,\n    close_reason: ?[]const u8,\n    closed_by_session: ?[]const u8,\n    \n    // Scheduling\n    due_at: OptionalRfc3339Timestamp,\n    defer_until: OptionalRfc3339Timestamp,\n    estimated_minutes: ?i32,\n    \n    // External references\n    external_ref: ?[]const u8,\n    source_system: ?[]const u8,\n    \n    // Flags\n    pinned: bool,\n    is_template: bool,\n    ephemeral: bool,\n    \n    // Metadata\n    version: u64,\n    \n    // Embedded relations (can be populated)\n    labels: []const []const u8,\n    dependencies: []const Dependency,\n    comments: []const Comment,\n};\n```\n\n---\n\n### SUMMARY: KEY FILES & PATTERNS\n\n| Task | File | Key Structures | Pattern |\n|------|------|----------------|---------|\n| **1. Add --parent/--recursive filters** | `src/cli/args.zig` (ListArgs, ReadyArgs) | Add fields to struct | Follow `overdue`, `include_deferred` pattern |\n| | `src/cli/list.zig`, `ready.zig` | Run function | Query graph for parent/child dependencies |\n| | `src/storage/graph.zig` | DependencyGraph | Use `getDependents()` to find children, `getDependencies()` for parents |\n| **2. Add CSV output format** | `src/cli/args.zig` (GlobalOptions) | Add `csv: bool` or create `OutputFormat` enum | Boolean flag or enum with json/toon/csv/plain |\n| | `src/output/mod.zig` (OutputMode) | Add `.csv` variant | Implement `printIssueListCsv()` method |\n| | Command files (list.zig, ready.zig) | Output routing | Call appropriate format method based on flag |\n\n---\n\n### IMPLEMENTATION STEPS SUMMARY\n\n**For --parent and --recursive filters:**\n1. Add `parent: ?[]const u8` and `recursive: bool` to `ListArgs` and `ReadyArgs`\n2. In `parseListArgs/parseReadyArgs`, consume flags similar to `--overdue`\n3. In list/ready command, after graph creation, filter using:\n   - `--parent <id>`: Get all issues with parent_child dep where depends_on_id = <id>\n   - `--recursive`: Recursively find all descendants\n4. Use `graph.getDependents(issue_id)` to find children (where dep.dep_type == parent_child)\n\n**For CSV output with --fields:**\n1. Add `csv: bool` to `GlobalOptions` (or use enum for output format)\n2. Add `--csv` flag parsing in `parseGlobalFlag`\n3. Add CSV output mode to `OutputMode` enum\n4. Add `--fields` argument to global options or command args\n5. Implement CSV formatter in `output/mod.zig` that:\n   - Accepts field list (id,title,status,priority,assignee,due_at, etc.)\n   - Escapes fields containing commas/quotes\n   - Writes CSV header + data rows\n\nBoth features follow established patterns in the codebase for maximum consistency!"},{"type":"text","text":"agentId: a4034ee (for resuming to continue this agent's work if needed)"}]}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4697d9f5-c550-4d54-8398-450b4cd7a9db","tool_use_result":{"status":"completed","prompt":"I need to implement two features in beads_zig:\n1. Add --parent and --recursive filters for hierarchy filtering\n2. Add CSV output format with --fields option\n\nPlease help me understand:\n1. How CLI arguments are parsed (look at src/cli/args.zig)\n2. How list/ready commands work (look at src/cli/ for list.zig, ready.zig)\n3. How output formatting works (look at src/output/)\n4. How the dependency graph tracks parent-child relationships (look at src/storage/graph.zig)\n5. What existing filter patterns exist that I can follow\n\nBe thorough and provide file paths and key code structures.","agentId":"a4034ee","content":[{"type":"text","text":"Perfect! Now I have all the information I need. Let me create a comprehensive analysis document:\n\n## Comprehensive Implementation Guide for beads_zig Features\n\nBased on my thorough exploration of the codebase, here's everything you need to know to implement the two features:\n\n---\n\n### 1. CLI ARGUMENT PARSING STRUCTURE\n\n**File**: `/home/hotschmoe/beads_zig/src/cli/args.zig`\n\nThe argument parsing follows a clear pattern:\n\n#### Key Structures:\n- **GlobalOptions** (lines 8-26): Global flags like `--json`, `--toon`, `--quiet`, `--verbose`, `--no-color`, etc.\n- **ListArgs** (lines 216-235): List command arguments including filters\n- **ReadyArgs** (lines 237-247): Ready command arguments\n- **ParseResult** (lines 512-536): Result of parsing with global options and command\n\n#### Parsing Pattern (Lines 1028-1078):\n```zig\nfn parseListArgs(self: *Self) ParseError!ListArgs {\n    var result = ListArgs{};\n    \n    while (self.hasNext()) {\n        if (self.consumeFlag(\"-s\", \"--status\")) {\n            result.status = self.next() orelse return error.MissingFlagValue;\n        } else if (self.consumeFlag(null, \"--priority-min\")) {\n            result.priority_min = self.next() orelse return error.MissingFlagValue;\n        } else if (self.consumeFlag(null, \"--overdue\")) {\n            result.overdue = true;\n        }\n        // ... more flags\n    }\n    return result;\n}\n```\n\n#### Key Methods:\n- `consumeFlag(short, long)`: Check if flag matches and consume it\n- `next()`: Get next argument value\n- `hasNext()`: Check if more args remain\n- Boolean flags use `consumeFlag()` with no value extraction\n- Flags with values call `self.next()` after `consumeFlag()`\n\n---\n\n### 2. LIST & READY COMMANDS IMPLEMENTATION\n\n**Files**: \n- `/home/hotschmoe/beads_zig/src/cli/list.zig` (163 lines)\n- `/home/hotschmoe/beads_zig/src/cli/ready.zig` (339 lines)\n\n#### List Command Flow:\n1. Create `CommandContext` (handles store initialization)\n2. Build `IssueStore.ListFilters` struct from arguments\n3. Call `ctx.store.list(filters)` \n4. Format output based on mode (plain, rich, json, quiet)\n\n**Key Pattern** (lines 43-163):\n```zig\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n    \n    // Set filters from list_args\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    }\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {...};\n    }\n    // ... more filters\n    \n    const issues = try ctx.store.list(filters);\n    defer { /* cleanup */ }\n    \n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(ListResult{...});\n    } else {\n        try ctx.output.printIssueList(issues);\n    }\n}\n```\n\n#### Ready Command Filter Application (lines 215-269):\n```zig\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // Returns early if no filters\n    if (priority_min == null and priority_max == null and ...) {\n        return try allocator.dupe(Issue, issues);\n    }\n    \n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    \n    for (issues) |issue| {\n        // Skip with continue if doesn't match\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        try filtered.append(allocator, issue);\n    }\n    \n    return filtered.toOwnedSlice(allocator);\n}\n```\n\n---\n\n### 3. STORAGE LAYER & FILTERS\n\n**File**: `/home/hotschmoe/beads_zig/src/storage/store.zig`\n\n#### ListFilters Struct (lines 331-356):\n```zig\npub const ListFilters = struct {\n    status: ?Status = null,\n    priority: ?Priority = null,\n    priority_min: ?Priority = null,\n    priority_max: ?Priority = null,\n    issue_type: ?IssueType = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    include_tombstones: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    limit: ?u32 = null,\n    offset: ?u32 = null,\n    order_by: OrderBy = .created_at,\n    order_desc: bool = true,\n\n    pub const OrderBy = enum {\n        created_at,\n        updated_at,\n        priority,\n    };\n};\n```\n\n#### List Function (lines 359-493):\n- Iterates all issues and applies filters (continue pattern for exclusion)\n- Sorts results using custom comparator\n- Applies offset/limit\n- Returns owned slice to caller\n\n**Filter Pattern**:\n```zig\nfor (self.issues.items) |issue| {\n    // Skip tombstones\n    if (!filters.include_tombstones and statusEql(issue.status, .tombstone)) {\n        continue;\n    }\n    \n    // Apply all filters with early exit\n    if (filters.status) |s| { ... if (!match) continue; }\n    if (filters.priority) |p| { if (issue.priority.value != p.value) continue; }\n    if (filters.priority_min) |min_p| { \n        if (issue.priority.value < min_p.value) continue; \n    }\n    \n    try results.append(self.allocator, try issue.clone(self.allocator));\n}\n```\n\n---\n\n### 4. OUTPUT FORMATTING SYSTEM\n\n**File**: `/home/hotschmoe/beads_zig/src/output/mod.zig` (699 lines)\n\n#### OutputMode Enum (lines 19-24):\n```zig\npub const OutputMode = enum {\n    plain,   // No colors, basic formatting\n    rich,    // Colors and formatting (TTY)\n    json,    // Structured JSON output\n    quiet,   // Minimal output (IDs only)\n};\n```\n\n#### Output Interface:\n```zig\npub const Output = struct {\n    mode: OutputMode,\n    toon: bool,\n    silent: bool,\n    stdout: std.fs.File,\n    stderr: std.fs.File,\n    allocator: std.mem.Allocator,\n    \n    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueListJson(issues),\n            .quiet => try self.printIssueListQuiet(issues),\n            .rich => try self.printIssueListRich(issues),\n            .plain => try self.printIssueListPlain(issues),\n        }\n    }\n    \n    pub fn printJson(self: *Self, value: anytype) !void {\n        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n        defer self.allocator.free(json_bytes);\n        \n        if (self.toon) {\n            // Convert to TOON format (token-optimized)\n            const toon = @import(\"toon_zig\");\n            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |err| {...};\n            defer self.allocator.free(toon_bytes);\n            try self.stdout.writeAll(toon_bytes);\n        } else {\n            try self.stdout.writeAll(json_bytes);\n        }\n        try self.stdout.writeAll(\"\\n\");\n    }\n};\n```\n\n#### Format Methods (by mode):\n- **Plain** (lines 295-303): No colors, simple formatting\n- **Rich** (lines 345-364): ANSI colors, formatted output\n- **JSON** (lines 254-260): Structured JSON serialization\n- **Quiet** (lines 374-378): IDs only\n\n---\n\n### 5. DEPENDENCY GRAPH & HIERARCHY\n\n**File**: `/home/hotschmoe/beads_zig/src/storage/graph.zig` (665 lines)\n\n#### DependencyGraph Structure (lines 24-35):\n```zig\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n    \n    // Key methods:\n    pub fn addDependency(self: *Self, dep: Dependency) !void { ... }\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void { ... }\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency { ... }\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency { ... }\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool { ... }\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue { ... }\n    pub fn getBlockedIssues(self: *Self) ![]Issue { ... }\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue { ... }\n};\n```\n\n#### DependencyType Variants (src/models/dependency.zig, lines 10-22):\n```zig\npub const DependencyType = union(enum) {\n    blocks,\n    parent_child,           // <-- Hierarchy relationship!\n    conditional_blocks,\n    waits_for,\n    related,\n    discovered_from,\n    replies_to,\n    relates_to,\n    duplicates,\n    supersedes,\n    caused_by,\n    custom: []const u8,\n};\n```\n\n#### Dependency Structure (lines 98-106):\n```zig\npub const Dependency = struct {\n    issue_id: []const u8,       // Child/dependent issue\n    depends_on_id: []const u8,  // Parent/blocking issue\n    dep_type: DependencyType,\n    created_at: i64,\n    created_by: ?[]const u8,\n    metadata: ?[]const u8,\n    thread_id: ?[]const u8,\n};\n```\n\n---\n\n### 6. EPIC COMMAND HIERARCHY PATTERN\n\n**File**: `/home/hotschmoe/beads_zig/src/cli/epic.zig` (458 lines)\n\nShows real hierarchy usage pattern (lines 195-206):\n```zig\nvar graph = ctx.createGraph();\nconst now = std.time.timestamp();\nconst dep = Dependency{\n    .issue_id = add_args.issue_id,           // Child issue\n    .depends_on_id = add_args.epic_id,       // Parent epic\n    .dep_type = .parent_child,               // Hierarchy type!\n    .created_at = now,\n    .created_by = global.actor,\n    .metadata = null,\n    .thread_id = null,\n};\n\ngraph.addDependency(dep) catch |err| {\n    const msg = switch (err) {\n        DependencyGraphError.SelfDependency => \"cannot add epic to itself\",\n        DependencyGraphError.CycleDetected => \"adding to epic would create a cycle\",\n        DependencyGraphError.IssueNotFound => \"issue not found\",\n        else => \"failed to add issue to epic\",\n    };\n    // ... error handling\n};\n```\n\n**Key Pattern**: Parent-child hierarchies are implemented using `DependencyType.parent_child`, where:\n- `issue_id` = child/member\n- `depends_on_id` = parent/container\n\n---\n\n### 7. ISSUE MODEL & AVAILABLE FIELDS\n\n**File**: `/home/hotschmoe/beads_zig/src/models/issue.zig` (lines 106-156)\n\nAll available fields for CSV output:\n```zig\npub const Issue = struct {\n    // Identity\n    id: []const u8,\n    content_hash: ?[]const u8,\n    \n    // Content\n    title: []const u8,\n    description: ?[]const u8,\n    design: ?[]const u8,\n    acceptance_criteria: ?[]const u8,\n    notes: ?[]const u8,\n    \n    // Classification\n    status: Status,\n    priority: Priority,\n    issue_type: IssueType,\n    \n    // Assignment\n    assignee: ?[]const u8,\n    owner: ?[]const u8,\n    \n    // Timestamps (Unix epoch, serialized as RFC3339)\n    created_at: Rfc3339Timestamp,\n    created_by: ?[]const u8,\n    updated_at: Rfc3339Timestamp,\n    closed_at: OptionalRfc3339Timestamp,\n    close_reason: ?[]const u8,\n    closed_by_session: ?[]const u8,\n    \n    // Scheduling\n    due_at: OptionalRfc3339Timestamp,\n    defer_until: OptionalRfc3339Timestamp,\n    estimated_minutes: ?i32,\n    \n    // External references\n    external_ref: ?[]const u8,\n    source_system: ?[]const u8,\n    \n    // Flags\n    pinned: bool,\n    is_template: bool,\n    ephemeral: bool,\n    \n    // Metadata\n    version: u64,\n    \n    // Embedded relations (can be populated)\n    labels: []const []const u8,\n    dependencies: []const Dependency,\n    comments: []const Comment,\n};\n```\n\n---\n\n### SUMMARY: KEY FILES & PATTERNS\n\n| Task | File | Key Structures | Pattern |\n|------|------|----------------|---------|\n| **1. Add --parent/--recursive filters** | `src/cli/args.zig` (ListArgs, ReadyArgs) | Add fields to struct | Follow `overdue`, `include_deferred` pattern |\n| | `src/cli/list.zig`, `ready.zig` | Run function | Query graph for parent/child dependencies |\n| | `src/storage/graph.zig` | DependencyGraph | Use `getDependents()` to find children, `getDependencies()` for parents |\n| **2. Add CSV output format** | `src/cli/args.zig` (GlobalOptions) | Add `csv: bool` or create `OutputFormat` enum | Boolean flag or enum with json/toon/csv/plain |\n| | `src/output/mod.zig` (OutputMode) | Add `.csv` variant | Implement `printIssueListCsv()` method |\n| | Command files (list.zig, ready.zig) | Output routing | Call appropriate format method based on flag |\n\n---\n\n### IMPLEMENTATION STEPS SUMMARY\n\n**For --parent and --recursive filters:**\n1. Add `parent: ?[]const u8` and `recursive: bool` to `ListArgs` and `ReadyArgs`\n2. In `parseListArgs/parseReadyArgs`, consume flags similar to `--overdue`\n3. In list/ready command, after graph creation, filter using:\n   - `--parent <id>`: Get all issues with parent_child dep where depends_on_id = <id>\n   - `--recursive`: Recursively find all descendants\n4. Use `graph.getDependents(issue_id)` to find children (where dep.dep_type == parent_child)\n\n**For CSV output with --fields:**\n1. Add `csv: bool` to `GlobalOptions` (or use enum for output format)\n2. Add `--csv` flag parsing in `parseGlobalFlag`\n3. Add CSV output mode to `OutputMode` enum\n4. Add `--fields` argument to global options or command args\n5. Implement CSV formatter in `output/mod.zig` that:\n   - Accepts field list (id,title,status,priority,assignee,due_at, etc.)\n   - Escapes fields containing commas/quotes\n   - Writes CSV header + data rows\n\nBoth features follow established patterns in the codebase for maximum consistency!"}],"totalDurationMs":67313,"totalTokens":73503,"totalToolUseCount":24,"usage":{"input_tokens":3,"cache_creation_input_tokens":3655,"cache_read_input_tokens":69844,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3655},"output_tokens":1,"service_tier":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016TE2XJQHRKNigeZJwGXwiY","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding of the codebase. Let me start implementing the tasks."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4617,"cache_read_input_tokens":39214,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4617},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"6cd9ca33-50b2-405c-ab7b-325edeb52bed"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016TE2XJQHRKNigeZJwGXwiY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HHgBCbP94GujZq6dpuNNiN","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"in_progress","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"pending","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"pending","activeForm":"Creating single commit for all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":4617,"cache_read_input_tokens":39214,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4617},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4df1b797-c0f2-490e-9693-3b5359e63025"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HHgBCbP94GujZq6dpuNNiN","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"26f5f592-4c10-41b3-a76d-80dc4d349d91","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"in_progress","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"pending","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"pending","activeForm":"Creating single commit for all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ziSkrXM9c1sFEmvdUTfcZ","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the key files I need to modify."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":224,"cache_read_input_tokens":43831,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":224},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"dfd3f858-7be7-409b-8cef-fb72a7196a09"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ziSkrXM9c1sFEmvdUTfcZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LFXzqxuVJeZohYCQhi8JCV","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":224,"cache_read_input_tokens":43831,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":224},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d1d2013a-b154-4835-8978-23d22d48e4e6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ziSkrXM9c1sFEmvdUTfcZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mtvh8wY7NE79xDJk3C4L1C","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":224,"cache_read_input_tokens":43831,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":224},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"ed4f12cd-2c03-4895-bd55-db83051de4ae"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mtvh8wY7NE79xDJk3C4L1C","type":"tool_result","content":"     1→//! List command for beads_zig.\n     2→//!\n     3→//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n     4→//!\n     5→//! Lists issues with optional filters.\n     6→\n     7→const std = @import(\"std\");\n     8→const models = @import(\"../models/mod.zig\");\n     9→const common = @import(\"common.zig\");\n    10→const args = @import(\"args.zig\");\n    11→const test_util = @import(\"../test_util.zig\");\n    12→\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→const IssueStore = common.IssueStore;\n    18→const CommandContext = common.CommandContext;\n    19→\n    20→pub const ListError = error{\n    21→    WorkspaceNotInitialized,\n    22→    InvalidFilter,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→};\n    26→\n    27→pub const ListResult = struct {\n    28→    success: bool,\n    29→    issues: ?[]const IssueCompact = null,\n    30→    count: ?usize = null,\n    31→    message: ?[]const u8 = null,\n    32→\n    33→    const IssueCompact = struct {\n    34→        id: []const u8,\n    35→        title: []const u8,\n    36→        status: []const u8,\n    37→        priority: u3,\n    38→        issue_type: []const u8,\n    39→        assignee: ?[]const u8 = null,\n    40→    };\n    41→};\n    42→\n    43→pub fn run(\n    44→    list_args: args.ListArgs,\n    45→    global: args.GlobalOptions,\n    46→    allocator: std.mem.Allocator,\n    47→) !void {\n    48→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    49→        return ListError.WorkspaceNotInitialized;\n    50→    };\n    51→    defer ctx.deinit();\n    52→\n    53→    var filters = IssueStore.ListFilters{};\n    54→\n    55→    if (list_args.status) |s| {\n    56→        filters.status = Status.fromString(s);\n    57→    } else if (!list_args.all) {\n    58→        filters.status = .open;\n    59→    }\n    60→\n    61→    if (list_args.priority) |p| {\n    62→        filters.priority = Priority.fromString(p) catch {\n    63→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n    64→            return ListError.InvalidFilter;\n    65→        };\n    66→    }\n    67→\n    68→    if (list_args.priority_min) |p| {\n    69→        filters.priority_min = Priority.fromString(p) catch {\n    70→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n    71→            return ListError.InvalidFilter;\n    72→        };\n    73→    }\n    74→\n    75→    if (list_args.priority_max) |p| {\n    76→        filters.priority_max = Priority.fromString(p) catch {\n    77→            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n    78→            return ListError.InvalidFilter;\n    79→        };\n    80→    }\n    81→\n    82→    if (list_args.issue_type) |t| {\n    83→        filters.issue_type = IssueType.fromString(t);\n    84→    }\n    85→\n    86→    if (list_args.assignee) |a| {\n    87→        filters.assignee = a;\n    88→    }\n    89→\n    90→    if (list_args.label) |l| {\n    91→        filters.label = l;\n    92→    }\n    93→\n    94→    if (list_args.label_any.len > 0) {\n    95→        filters.label_any = list_args.label_any;\n    96→    }\n    97→\n    98→    if (list_args.title_contains) |t| {\n    99→        filters.title_contains = t;\n   100→    }\n   101→\n   102→    if (list_args.desc_contains) |d| {\n   103→        filters.desc_contains = d;\n   104→    }\n   105→\n   106→    if (list_args.notes_contains) |n| {\n   107→        filters.notes_contains = n;\n   108→    }\n   109→\n   110→    if (list_args.limit) |n| {\n   111→        filters.limit = n;\n   112→    }\n   113→\n   114→    // Apply overdue filter\n   115→    filters.overdue = list_args.overdue;\n   116→\n   117→    // Apply include_deferred filter\n   118→    filters.include_deferred = list_args.include_deferred;\n   119→\n   120→    // Apply sort options\n   121→    filters.order_by = switch (list_args.sort) {\n   122→        .created_at => .created_at,\n   123→        .updated_at => .updated_at,\n   124→        .priority => .priority,\n   125→    };\n   126→    filters.order_desc = list_args.sort_desc;\n   127→\n   128→    const issues = try ctx.store.list(filters);\n   129→    defer {\n   130→        for (issues) |*issue| {\n   131→            var i = issue.*;\n   132→            i.deinit(allocator);\n   133→        }\n   134→        allocator.free(issues);\n   135→    }\n   136→\n   137→    if (global.isStructuredOutput()) {\n   138→        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n   139→        defer allocator.free(compact_issues);\n   140→\n   141→        for (issues, 0..) |issue, i| {\n   142→            compact_issues[i] = .{\n   143→                .id = issue.id,\n   144→                .title = issue.title,\n   145→                .status = issue.status.toString(),\n   146→                .priority = issue.priority.value,\n   147→                .issue_type = issue.issue_type.toString(),\n   148→                .assignee = issue.assignee,\n   149→            };\n   150→        }\n   151→\n   152→        try ctx.output.printJson(ListResult{\n   153→            .success = true,\n   154→            .issues = compact_issues,\n   155→            .count = issues.len,\n   156→        });\n   157→    } else {\n   158→        try ctx.output.printIssueList(issues);\n   159→        if (!global.quiet and issues.len == 0) {\n   160→            try ctx.output.info(\"No issues found\", .{});\n   161→        }\n   162→    }\n   163→}\n   164→\n   165→fn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n   166→    if (structured_mode) {\n   167→        try output.printJson(ListResult{\n   168→            .success = false,\n   169→            .message = message,\n   170→        });\n   171→    } else {\n   172→        try output.err(\"{s}\", .{message});\n   173→    }\n   174→}\n   175→\n   176→// --- Tests ---\n   177→\n   178→test \"ListError enum exists\" {\n   179→    const err: ListError = ListError.WorkspaceNotInitialized;\n   180→    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n   181→}\n   182→\n   183→test \"ListResult struct works\" {\n   184→    const result = ListResult{\n   185→        .success = true,\n   186→        .count = 5,\n   187→    };\n   188→    try std.testing.expect(result.success);\n   189→    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n   190→}\n   191→\n   192→test \"run detects uninitialized workspace\" {\n   193→    const allocator = std.testing.allocator;\n   194→\n   195→    const list_args = args.ListArgs{};\n   196→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   197→\n   198→    const result = run(list_args, global, allocator);\n   199→    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n   200→}\n   201→\n   202→test \"run lists issues successfully\" {\n   203→    const allocator = std.testing.allocator;\n   204→\n   205→    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n   206→    defer allocator.free(tmp_dir_path);\n   207→    defer test_util.cleanupTestDir(tmp_dir_path);\n   208→\n   209→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   210→    defer allocator.free(data_path);\n   211→\n   212→    try std.fs.cwd().makeDir(data_path);\n   213→\n   214→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   215→    defer allocator.free(issues_path);\n   216→\n   217→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   218→    defer f.close();\n   219→\n   220→    const list_args = args.ListArgs{ .all = true };\n   221→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   222→\n   223→    try run(list_args, global, allocator);\n   224→}\n   225→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"cab2343e-2523-41ea-b0f0-ef0b5e7fad64","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/list.zig","content":"//! List command for beads_zig.\n//!\n//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n//!\n//! Lists issues with optional filters.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const ListError = error{\n    WorkspaceNotInitialized,\n    InvalidFilter,\n    StorageError,\n    OutOfMemory,\n};\n\npub const ListResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        status: []const u8,\n        priority: u3,\n        issue_type: []const u8,\n        assignee: ?[]const u8 = null,\n    };\n};\n\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    } else if (!list_args.all) {\n        filters.status = .open;\n    }\n\n    if (list_args.priority) |p| {\n        filters.priority = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_max) |p| {\n        filters.priority_max = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.issue_type) |t| {\n        filters.issue_type = IssueType.fromString(t);\n    }\n\n    if (list_args.assignee) |a| {\n        filters.assignee = a;\n    }\n\n    if (list_args.label) |l| {\n        filters.label = l;\n    }\n\n    if (list_args.label_any.len > 0) {\n        filters.label_any = list_args.label_any;\n    }\n\n    if (list_args.title_contains) |t| {\n        filters.title_contains = t;\n    }\n\n    if (list_args.desc_contains) |d| {\n        filters.desc_contains = d;\n    }\n\n    if (list_args.notes_contains) |n| {\n        filters.notes_contains = n;\n    }\n\n    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply overdue filter\n    filters.overdue = list_args.overdue;\n\n    // Apply include_deferred filter\n    filters.include_deferred = list_args.include_deferred;\n\n    // Apply sort options\n    filters.order_by = switch (list_args.sort) {\n        .created_at => .created_at,\n        .updated_at => .updated_at,\n        .priority => .priority,\n    };\n    filters.order_desc = list_args.sort_desc;\n\n    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n    if (structured_mode) {\n        try output.printJson(ListResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"ListError enum exists\" {\n    const err: ListError = ListError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n}\n\ntest \"ListResult struct works\" {\n    const result = ListResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const list_args = args.ListArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(list_args, global, allocator);\n    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const list_args = args.ListArgs{ .all = true };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(list_args, global, allocator);\n}\n","numLines":225,"startLine":1,"totalLines":225}}}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (27174 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01LFXzqxuVJeZohYCQhi8JCV"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a7d2d1aa-b01d-4769-ae76-15fe96a25803","tool_use_result":"Error: File content (27174 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ziSkrXM9c1sFEmvdUTfcZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011mVew5HRfjPdHGy8FoRVeV","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":224,"cache_read_input_tokens":43831,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":224},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"dcc3c32a-9cfe-4c9c-a650-6b6827a0fde5"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Sibling tool call errored</tool_use_error>","is_error":true,"tool_use_id":"toolu_011mVew5HRfjPdHGy8FoRVeV"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4c551c39-669c-4056-a5c2-22973d1ba777","tool_use_result":"Sibling tool call errored"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018MSp7PZQZsfUV8qyv55per","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XWnmoaVkYBq2XjQaW28S8T","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3142,"cache_read_input_tokens":44055,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3142},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"41322be3-4f69-482d-b6d5-893ebf5c5007"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XWnmoaVkYBq2XjQaW28S8T","type":"tool_result","content":"     1→//! Ready and blocked commands for beads_zig.\n     2→//!\n     3→//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n     4→//! `bz blocked [-n LIMIT]` - Show blocked issues\n     5→//!\n     6→//! Workflow queries for finding actionable work.\n     7→\n     8→const std = @import(\"std\");\n     9→const models = @import(\"../models/mod.zig\");\n    10→const store = @import(\"../storage/store.zig\");\n    11→const common = @import(\"common.zig\");\n    12→const args = @import(\"args.zig\");\n    13→const test_util = @import(\"../test_util.zig\");\n    14→\n    15→const Issue = models.Issue;\n    16→const Priority = models.Priority;\n    17→const CommandContext = common.CommandContext;\n    18→const DependencyGraph = common.DependencyGraph;\n    19→const containsIgnoreCase = store.containsIgnoreCase;\n    20→\n    21→pub const ReadyError = error{\n    22→    WorkspaceNotInitialized,\n    23→    StorageError,\n    24→    OutOfMemory,\n    25→    InvalidFilter,\n    26→};\n    27→\n    28→pub const ReadyResult = struct {\n    29→    success: bool,\n    30→    issues: ?[]const IssueCompact = null,\n    31→    count: ?usize = null,\n    32→    message: ?[]const u8 = null,\n    33→\n    34→    const IssueCompact = struct {\n    35→        id: []const u8,\n    36→        title: []const u8,\n    37→        priority: u3,\n    38→    };\n    39→};\n    40→\n    41→pub const BlockedResult = struct {\n    42→    success: bool,\n    43→    issues: ?[]const BlockedIssue = null,\n    44→    count: ?usize = null,\n    45→    message: ?[]const u8 = null,\n    46→\n    47→    const BlockedIssue = struct {\n    48→        id: []const u8,\n    49→        title: []const u8,\n    50→        priority: u3,\n    51→        blocked_by: []const []const u8,\n    52→    };\n    53→};\n    54→\n    55→pub fn run(\n    56→    ready_args: args.ReadyArgs,\n    57→    global: args.GlobalOptions,\n    58→    allocator: std.mem.Allocator,\n    59→) !void {\n    60→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    61→        return ReadyError.WorkspaceNotInitialized;\n    62→    };\n    63→    defer ctx.deinit();\n    64→\n    65→    // Parse priority filters\n    66→    var priority_min: ?Priority = null;\n    67→    var priority_max: ?Priority = null;\n    68→    if (ready_args.priority_min) |p| {\n    69→        priority_min = Priority.fromString(p) catch {\n    70→            try ctx.output.err(\"invalid priority-min value\", .{});\n    71→            return ReadyError.InvalidFilter;\n    72→        };\n    73→    }\n    74→    if (ready_args.priority_max) |p| {\n    75→        priority_max = Priority.fromString(p) catch {\n    76→            try ctx.output.err(\"invalid priority-max value\", .{});\n    77→            return ReadyError.InvalidFilter;\n    78→        };\n    79→    }\n    80→\n    81→    var graph = ctx.createGraph();\n    82→    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    83→    defer graph.freeIssues(issues);\n    84→\n    85→    // Apply filters\n    86→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    87→    defer allocator.free(filtered);\n    88→\n    89→    const display_issues = applyLimit(filtered, ready_args.limit);\n    90→\n    91→    if (global.isStructuredOutput()) {\n    92→        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n    93→        defer allocator.free(compact_issues);\n    94→\n    95→        for (display_issues, 0..) |issue, i| {\n    96→            compact_issues[i] = .{\n    97→                .id = issue.id,\n    98→                .title = issue.title,\n    99→                .priority = issue.priority.value,\n   100→            };\n   101→        }\n   102→\n   103→        try ctx.output.printJson(ReadyResult{\n   104→            .success = true,\n   105→            .issues = compact_issues,\n   106→            .count = display_issues.len,\n   107→        });\n   108→    } else {\n   109→        try ctx.output.printIssueList(display_issues);\n   110→        if (!global.quiet and display_issues.len == 0) {\n   111→            try ctx.output.info(\"No ready issues\", .{});\n   112→        }\n   113→    }\n   114→}\n   115→\n   116→pub fn runBlocked(\n   117→    blocked_args: args.BlockedArgs,\n   118→    global: args.GlobalOptions,\n   119→    allocator: std.mem.Allocator,\n   120→) !void {\n   121→    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   122→        return ReadyError.WorkspaceNotInitialized;\n   123→    };\n   124→    defer ctx.deinit();\n   125→\n   126→    // Parse priority filters\n   127→    var priority_min: ?Priority = null;\n   128→    var priority_max: ?Priority = null;\n   129→    if (blocked_args.priority_min) |p| {\n   130→        priority_min = Priority.fromString(p) catch {\n   131→            try ctx.output.err(\"invalid priority-min value\", .{});\n   132→            return ReadyError.InvalidFilter;\n   133→        };\n   134→    }\n   135→    if (blocked_args.priority_max) |p| {\n   136→        priority_max = Priority.fromString(p) catch {\n   137→            try ctx.output.err(\"invalid priority-max value\", .{});\n   138→            return ReadyError.InvalidFilter;\n   139→        };\n   140→    }\n   141→\n   142→    var graph = ctx.createGraph();\n   143→    const issues = try graph.getBlockedIssues();\n   144→    defer graph.freeIssues(issues);\n   145→\n   146→    // Apply filters (blocked command doesn't support overdue filter)\n   147→    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n   148→    defer allocator.free(filtered);\n   149→\n   150→    const display_issues = applyLimit(filtered, blocked_args.limit);\n   151→\n   152→    if (global.isStructuredOutput()) {\n   153→        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n   154→        defer {\n   155→            for (blocked_issues) |bi| {\n   156→                allocator.free(bi.blocked_by);\n   157→            }\n   158→            allocator.free(blocked_issues);\n   159→        }\n   160→\n   161→        for (display_issues, 0..) |issue, i| {\n   162→            const blockers = try graph.getBlockers(issue.id);\n   163→            defer graph.freeIssues(blockers);\n   164→\n   165→            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n   166→            for (blockers, 0..) |blocker, j| {\n   167→                blocker_ids[j] = blocker.id;\n   168→            }\n   169→\n   170→            blocked_issues[i] = .{\n   171→                .id = issue.id,\n   172→                .title = issue.title,\n   173→                .priority = issue.priority.value,\n   174→                .blocked_by = blocker_ids,\n   175→            };\n   176→        }\n   177→\n   178→        try ctx.output.printJson(BlockedResult{\n   179→            .success = true,\n   180→            .issues = blocked_issues,\n   181→            .count = display_issues.len,\n   182→        });\n   183→    } else {\n   184→        for (display_issues) |issue| {\n   185→            const blockers = try graph.getBlockers(issue.id);\n   186→            defer graph.freeIssues(blockers);\n   187→\n   188→            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n   189→\n   190→            if (blockers.len > 0) {\n   191→                try ctx.output.print(\"  blocked by: \", .{});\n   192→                for (blockers, 0..) |blocker, j| {\n   193→                    if (j > 0) try ctx.output.print(\", \", .{});\n   194→                    try ctx.output.print(\"{s}\", .{blocker.id});\n   195→                }\n   196→                try ctx.output.print(\"\\n\", .{});\n   197→            }\n   198→        }\n   199→\n   200→        if (!global.quiet and display_issues.len == 0) {\n   201→            try ctx.output.info(\"No blocked issues\", .{});\n   202→        }\n   203→    }\n   204→}\n   205→\n   206→fn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n   207→    if (limit) |n| {\n   208→        if (n < issues.len) {\n   209→            return issues[0..n];\n   210→        }\n   211→    }\n   212→    return issues;\n   213→}\n   214→\n   215→fn applyFilters(\n   216→    allocator: std.mem.Allocator,\n   217→    issues: []Issue,\n   218→    priority_min: ?Priority,\n   219→    priority_max: ?Priority,\n   220→    title_contains: ?[]const u8,\n   221→    desc_contains: ?[]const u8,\n   222→    notes_contains: ?[]const u8,\n   223→    overdue_only: bool,\n   224→) ![]Issue {\n   225→    // No filters - return original slice\n   226→    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n   227→        return try allocator.dupe(Issue, issues);\n   228→    }\n   229→\n   230→    const now = std.time.timestamp();\n   231→    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n   232→    errdefer filtered.deinit(allocator);\n   233→\n   234→    for (issues) |issue| {\n   235→        // Priority range filters (lower value = higher priority)\n   236→        if (priority_min) |min_p| {\n   237→            if (issue.priority.value < min_p.value) continue;\n   238→        }\n   239→        if (priority_max) |max_p| {\n   240→            if (issue.priority.value > max_p.value) continue;\n   241→        }\n   242→\n   243→        // Substring filters (case-insensitive)\n   244→        if (title_contains) |query| {\n   245→            if (!containsIgnoreCase(issue.title, query)) continue;\n   246→        }\n   247→        if (desc_contains) |query| {\n   248→            if (issue.description) |desc| {\n   249→                if (!containsIgnoreCase(desc, query)) continue;\n   250→            } else continue;\n   251→        }\n   252→        if (notes_contains) |query| {\n   253→            if (issue.notes) |notes| {\n   254→                if (!containsIgnoreCase(notes, query)) continue;\n   255→            } else continue;\n   256→        }\n   257→\n   258→        // Overdue filter: only include issues past their due date\n   259→        if (overdue_only) {\n   260→            if (issue.due_at.value) |due_time| {\n   261→                if (due_time >= now) continue;\n   262→            } else continue;\n   263→        }\n   264→\n   265→        try filtered.append(allocator, issue);\n   266→    }\n   267→\n   268→    return filtered.toOwnedSlice(allocator);\n   269→}\n   270→\n   271→// --- Tests ---\n   272→\n   273→test \"ReadyError enum exists\" {\n   274→    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n   275→    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n   276→}\n   277→\n   278→test \"ReadyResult struct works\" {\n   279→    const result = ReadyResult{\n   280→        .success = true,\n   281→        .count = 3,\n   282→    };\n   283→    try std.testing.expect(result.success);\n   284→    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n   285→}\n   286→\n   287→test \"BlockedResult struct works\" {\n   288→    const result = BlockedResult{\n   289→        .success = true,\n   290→        .count = 2,\n   291→    };\n   292→    try std.testing.expect(result.success);\n   293→    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n   294→}\n   295→\n   296→test \"run detects uninitialized workspace\" {\n   297→    const allocator = std.testing.allocator;\n   298→\n   299→    const ready_args = args.ReadyArgs{};\n   300→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   301→\n   302→    const result = run(ready_args, global, allocator);\n   303→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   304→}\n   305→\n   306→test \"runBlocked detects uninitialized workspace\" {\n   307→    const allocator = std.testing.allocator;\n   308→\n   309→    const blocked_args = args.BlockedArgs{};\n   310→    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   311→\n   312→    const result = runBlocked(blocked_args, global, allocator);\n   313→    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n   314→}\n   315→\n   316→test \"run returns empty list for empty workspace\" {\n   317→    const allocator = std.testing.allocator;\n   318→\n   319→    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n   320→    defer allocator.free(tmp_dir_path);\n   321→    defer test_util.cleanupTestDir(tmp_dir_path);\n   322→\n   323→    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   324→    defer allocator.free(data_path);\n   325→\n   326→    try std.fs.cwd().makeDir(data_path);\n   327→\n   328→    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   329→    defer allocator.free(issues_path);\n   330→\n   331→    const f = try std.fs.cwd().createFile(issues_path, .{});\n   332→    f.close();\n   333→\n   334→    const ready_args = args.ReadyArgs{};\n   335→    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   336→\n   337→    try run(ready_args, global, allocator);\n   338→}\n   339→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b0d8f27d-8399-4cc4-977d-2d7bd6ae78f3","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","content":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters (blocked command doesn't support overdue filter)\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","numLines":339,"startLine":1,"totalLines":339}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018MSp7PZQZsfUV8qyv55per","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HUTj3arZWBj54AzFRLen6T","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3142,"cache_read_input_tokens":44055,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3142},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"cb4fd1c1-5044-4fb1-a485-ffc5aeba38be"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HUTj3arZWBj54AzFRLen6T","type":"tool_result","content":"     1→//! CLI argument parsing for beads_zig.\n     2→//!\n     3→//! Parses command-line arguments into structured data for command dispatch.\n     4→//! Supports global flags, subcommands, and subcommand-specific arguments.\n     5→\n     6→const std = @import(\"std\");\n     7→\n     8→/// Global CLI options that apply to all commands.\n     9→pub const GlobalOptions = struct {\n    10→    json: bool = false,\n    11→    toon: bool = false,\n    12→    quiet: bool = false,\n    13→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    14→    verbose: u8 = 0,\n    15→    no_color: bool = false,\n    16→    data_path: ?[]const u8 = null,\n    17→    actor: ?[]const u8 = null,\n    18→    lock_timeout: u32 = 5000,\n    19→    no_auto_flush: bool = false,\n    20→    no_auto_import: bool = false,\n    21→\n    22→    /// Returns true if structured output (JSON or TOON) is enabled.\n    23→    pub fn isStructuredOutput(self: GlobalOptions) bool {\n    24→        return self.json or self.toon;\n    25→    }\n    26→};\n    27→\n    28→/// All available subcommands.\n    29→pub const Command = union(enum) {\n    30→    // Workspace\n    31→    init: InitArgs,\n    32→    info: void,\n    33→    stats: void,\n    34→    doctor: void,\n    35→    config: ConfigArgs,\n    36→    orphans: OrphansArgs,\n    37→    lint: LintArgs,\n    38→    where: void,\n    39→\n    40→    // Issue CRUD\n    41→    create: CreateArgs,\n    42→    q: QuickArgs,\n    43→    show: ShowArgs,\n    44→    update: UpdateArgs,\n    45→    close: CloseArgs,\n    46→    reopen: ReopenArgs,\n    47→    delete: DeleteArgs,\n    48→\n    49→    // Batch Operations\n    50→    add_batch: AddBatchArgs,\n    51→    import_cmd: ImportArgs,\n    52→\n    53→    // Query\n    54→    list: ListArgs,\n    55→    ready: ReadyArgs,\n    56→    blocked: BlockedArgs,\n    57→    search: SearchArgs,\n    58→    stale: StaleArgs,\n    59→    count: CountArgs,\n    60→    defer_cmd: DeferArgs,\n    61→    undefer: UndeferArgs,\n    62→\n    63→    // Dependencies\n    64→    dep: DepArgs,\n    65→    graph: GraphArgs,\n    66→\n    67→    // Epics\n    68→    epic: EpicArgs,\n    69→\n    70→    // Labels\n    71→    label: LabelArgs,\n    72→\n    73→    // Comments\n    74→    comments: CommentsArgs,\n    75→\n    76→    // Audit\n    77→    history: HistoryArgs,\n    78→    audit: AuditArgs,\n    79→\n    80→    // Changelog\n    81→    changelog: ChangelogArgs,\n    82→\n    83→    // Sync\n    84→    sync: SyncArgs,\n    85→\n    86→    // System\n    87→    version: void,\n    88→    schema: void,\n    89→    completions: CompletionsArgs,\n    90→    metrics: MetricsArgs,\n    91→\n    92→    // Saved Queries\n    93→    query: QueryArgs,\n    94→\n    95→    // Self-upgrade\n    96→    upgrade: UpgradeArgs,\n    97→\n    98→    // Help\n    99→    help: HelpArgs,\n   100→};\n   101→\n   102→/// Init command arguments.\n   103→pub const InitArgs = struct {\n   104→    prefix: []const u8 = \"bd\",\n   105→};\n   106→\n   107→/// Create command arguments.\n   108→pub const CreateArgs = struct {\n   109→    title: []const u8,\n   110→    description: ?[]const u8 = null,\n   111→    issue_type: ?[]const u8 = null,\n   112→    priority: ?[]const u8 = null,\n   113→    assignee: ?[]const u8 = null,\n   114→    owner: ?[]const u8 = null,\n   115→    design: ?[]const u8 = null,\n   116→    acceptance_criteria: ?[]const u8 = null,\n   117→    external_ref: ?[]const u8 = null,\n   118→    labels: []const []const u8 = &[_][]const u8{},\n   119→    deps: []const []const u8 = &[_][]const u8{},\n   120→    due: ?[]const u8 = null,\n   121→    estimate: ?i32 = null,\n   122→    ephemeral: bool = false, // Local-only, not written to JSONL\n   123→};\n   124→\n   125→/// Quick capture command arguments.\n   126→pub const QuickArgs = struct {\n   127→    title: []const u8,\n   128→    priority: ?[]const u8 = null,\n   129→};\n   130→\n   131→/// Show command arguments.\n   132→pub const ShowArgs = struct {\n   133→    id: []const u8,\n   134→    with_comments: bool = true,\n   135→    with_history: bool = false,\n   136→};\n   137→\n   138→/// Update command arguments.\n   139→pub const UpdateArgs = struct {\n   140→    id: []const u8,\n   141→    title: ?[]const u8 = null,\n   142→    description: ?[]const u8 = null,\n   143→    issue_type: ?[]const u8 = null,\n   144→    priority: ?[]const u8 = null,\n   145→    assignee: ?[]const u8 = null,\n   146→    owner: ?[]const u8 = null,\n   147→    design: ?[]const u8 = null,\n   148→    acceptance_criteria: ?[]const u8 = null,\n   149→    external_ref: ?[]const u8 = null,\n   150→    status: ?[]const u8 = null,\n   151→    /// Expected version for optimistic locking (compare-and-swap).\n   152→    expected_version: ?u64 = null,\n   153→    /// Claim: set assignee to actor AND status to in_progress atomically.\n   154→    claim: bool = false,\n   155→};\n   156→\n   157→/// Close command arguments.\n   158→pub const CloseArgs = struct {\n   159→    id: []const u8,\n   160→    reason: ?[]const u8 = null,\n   161→    session: ?[]const u8 = null,\n   162→};\n   163→\n   164→/// Reopen command arguments.\n   165→pub const ReopenArgs = struct {\n   166→    id: []const u8,\n   167→};\n   168→\n   169→/// Delete command arguments.\n   170→pub const DeleteArgs = struct {\n   171→    id: []const u8,\n   172→};\n   173→\n   174→/// Add-batch command arguments.\n   175→/// Creates multiple issues from stdin or a file with single lock acquisition.\n   176→pub const AddBatchArgs = struct {\n   177→    file: ?[]const u8 = null, // Read from file instead of stdin\n   178→    format: BatchFormat = .titles, // Input format\n   179→};\n   180→\n   181→/// Batch input format.\n   182→pub const BatchFormat = enum {\n   183→    titles, // One title per line\n   184→    jsonl, // Full JSONL format (one issue per line)\n   185→\n   186→    pub fn fromString(s: []const u8) ?BatchFormat {\n   187→        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n   188→        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n   189→        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n   190→        return null;\n   191→    }\n   192→};\n   193→\n   194→/// Import command arguments.\n   195→/// Imports issues from a JSONL file with single lock acquisition.\n   196→pub const ImportArgs = struct {\n   197→    file: []const u8, // Path to JSONL file (required)\n   198→    merge: bool = false, // Merge instead of replace\n   199→    dry_run: bool = false, // Show what would be imported without importing\n   200→};\n   201→\n   202→/// Sort field options for list command.\n   203→pub const SortField = enum {\n   204→    created_at,\n   205→    updated_at,\n   206→    priority,\n   207→\n   208→    pub fn fromString(s: []const u8) ?SortField {\n   209→        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n   210→        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n   211→        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n   212→        return null;\n   213→    }\n   214→};\n   215→\n   216→/// List command arguments.\n   217→pub const ListArgs = struct {\n   218→    status: ?[]const u8 = null,\n   219→    priority: ?[]const u8 = null,\n   220→    priority_min: ?[]const u8 = null,\n   221→    priority_max: ?[]const u8 = null,\n   222→    issue_type: ?[]const u8 = null,\n   223→    assignee: ?[]const u8 = null,\n   224→    label: ?[]const u8 = null,\n   225→    label_any: []const []const u8 = &[_][]const u8{},\n   226→    title_contains: ?[]const u8 = null,\n   227→    desc_contains: ?[]const u8 = null,\n   228→    notes_contains: ?[]const u8 = null,\n   229→    limit: ?u32 = null,\n   230→    all: bool = false,\n   231→    overdue: bool = false,\n   232→    include_deferred: bool = false,\n   233→    sort: SortField = .created_at,\n   234→    sort_desc: bool = true,\n   235→};\n   236→\n   237→/// Ready command arguments.\n   238→pub const ReadyArgs = struct {\n   239→    limit: ?u32 = null,\n   240→    priority_min: ?[]const u8 = null,\n   241→    priority_max: ?[]const u8 = null,\n   242→    title_contains: ?[]const u8 = null,\n   243→    desc_contains: ?[]const u8 = null,\n   244→    notes_contains: ?[]const u8 = null,\n   245→    overdue: bool = false,\n   246→    include_deferred: bool = false,\n   247→};\n   248→\n   249→/// Blocked command arguments.\n   250→pub const BlockedArgs = struct {\n   251→    limit: ?u32 = null,\n   252→    priority_min: ?[]const u8 = null,\n   253→    priority_max: ?[]const u8 = null,\n   254→    title_contains: ?[]const u8 = null,\n   255→    desc_contains: ?[]const u8 = null,\n   256→    notes_contains: ?[]const u8 = null,\n   257→};\n   258→\n   259→/// Search command arguments.\n   260→pub const SearchArgs = struct {\n   261→    query: []const u8,\n   262→    limit: ?u32 = null,\n   263→};\n   264→\n   265→/// Stale command arguments.\n   266→pub const StaleArgs = struct {\n   267→    days: u32 = 30,\n   268→    limit: ?u32 = null,\n   269→};\n   270→\n   271→/// Count command arguments.\n   272→pub const CountArgs = struct {\n   273→    group_by: ?[]const u8 = null,\n   274→};\n   275→\n   276→/// Defer command arguments.\n   277→pub const DeferArgs = struct {\n   278→    id: []const u8,\n   279→    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n   280→    reason: ?[]const u8 = null,\n   281→};\n   282→\n   283→/// Undefer command arguments.\n   284→pub const UndeferArgs = struct {\n   285→    id: []const u8,\n   286→};\n   287→\n   288→/// Epic subcommand variants.\n   289→pub const EpicSubcommand = union(enum) {\n   290→    create: struct {\n   291→        title: []const u8,\n   292→        description: ?[]const u8 = null,\n   293→        priority: ?[]const u8 = null,\n   294→    },\n   295→    add: struct {\n   296→        epic_id: []const u8,\n   297→        issue_id: []const u8,\n   298→    },\n   299→    remove: struct {\n   300→        epic_id: []const u8,\n   301→        issue_id: []const u8,\n   302→    },\n   303→    list: struct {\n   304→        epic_id: []const u8,\n   305→    },\n   306→};\n   307→\n   308→/// Epic command arguments.\n   309→pub const EpicArgs = struct {\n   310→    subcommand: EpicSubcommand,\n   311→};\n   312→\n   313→/// Dependency subcommand variants.\n   314→pub const DepSubcommand = union(enum) {\n   315→    add: struct {\n   316→        child: []const u8,\n   317→        parent: []const u8,\n   318→        dep_type: []const u8 = \"blocks\",\n   319→    },\n   320→    remove: struct {\n   321→        child: []const u8,\n   322→        parent: []const u8,\n   323→    },\n   324→    list: struct {\n   325→        id: []const u8,\n   326→    },\n   327→    tree: struct {\n   328→        id: []const u8,\n   329→    },\n   330→    cycles: void,\n   331→};\n   332→\n   333→/// Dependency command arguments.\n   334→pub const DepArgs = struct {\n   335→    subcommand: DepSubcommand,\n   336→};\n   337→\n   338→/// Graph command output formats.\n   339→pub const GraphFormat = enum {\n   340→    ascii,\n   341→    dot,\n   342→\n   343→    pub fn fromString(s: []const u8) ?GraphFormat {\n   344→        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n   345→        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n   346→        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n   347→        return null;\n   348→    }\n   349→};\n   350→\n   351→/// Graph command arguments.\n   352→pub const GraphArgs = struct {\n   353→    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n   354→    format: GraphFormat = .ascii,\n   355→    depth: ?u32 = null, // Max depth for tree traversal\n   356→};\n   357→\n   358→/// Label subcommand variants.\n   359→pub const LabelSubcommand = union(enum) {\n   360→    add: struct {\n   361→        id: []const u8,\n   362→        labels: []const []const u8,\n   363→    },\n   364→    remove: struct {\n   365→        id: []const u8,\n   366→        labels: []const []const u8,\n   367→    },\n   368→    list: struct {\n   369→        id: []const u8,\n   370→    },\n   371→    list_all: void,\n   372→};\n   373→\n   374→/// Label command arguments.\n   375→pub const LabelArgs = struct {\n   376→    subcommand: LabelSubcommand,\n   377→};\n   378→\n   379→/// Comments subcommand variants.\n   380→pub const CommentsSubcommand = union(enum) {\n   381→    add: struct {\n   382→        id: []const u8,\n   383→        text: []const u8,\n   384→    },\n   385→    list: struct {\n   386→        id: []const u8,\n   387→    },\n   388→};\n   389→\n   390→/// Comments command arguments.\n   391→pub const CommentsArgs = struct {\n   392→    subcommand: CommentsSubcommand,\n   393→};\n   394→\n   395→/// History command arguments.\n   396→pub const HistoryArgs = struct {\n   397→    id: []const u8,\n   398→};\n   399→\n   400→/// Audit command arguments.\n   401→pub const AuditArgs = struct {\n   402→    limit: ?u32 = null,\n   403→};\n   404→\n   405→/// Changelog command arguments.\n   406→pub const ChangelogArgs = struct {\n   407→    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n   408→    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n   409→    limit: ?u32 = null,\n   410→    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n   411→};\n   412→\n   413→/// Sync command arguments.\n   414→pub const SyncArgs = struct {\n   415→    flush_only: bool = false,\n   416→    import_only: bool = false,\n   417→};\n   418→\n   419→/// Shell completion types.\n   420→pub const Shell = enum {\n   421→    bash,\n   422→    zsh,\n   423→    fish,\n   424→    powershell,\n   425→\n   426→    pub fn fromString(s: []const u8) ?Shell {\n   427→        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n   428→        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n   429→        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n   430→        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n   431→        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n   432→        return null;\n   433→    }\n   434→};\n   435→\n   436→/// Completions command arguments.\n   437→pub const CompletionsArgs = struct {\n   438→    shell: Shell,\n   439→};\n   440→\n   441→/// Metrics command arguments.\n   442→pub const MetricsArgs = struct {\n   443→    reset: bool = false, // Reset metrics after displaying\n   444→};\n   445→\n   446→/// Help command arguments.\n   447→pub const HelpArgs = struct {\n   448→    topic: ?[]const u8 = null,\n   449→};\n   450→\n   451→/// Config subcommand variants.\n   452→pub const ConfigSubcommand = union(enum) {\n   453→    get: struct {\n   454→        key: []const u8,\n   455→    },\n   456→    set: struct {\n   457→        key: []const u8,\n   458→        value: []const u8,\n   459→    },\n   460→    list: void,\n   461→};\n   462→\n   463→/// Config command arguments.\n   464→pub const ConfigArgs = struct {\n   465→    subcommand: ConfigSubcommand,\n   466→};\n   467→\n   468→/// Query subcommand variants.\n   469→pub const QuerySubcommand = union(enum) {\n   470→    save: struct {\n   471→        name: []const u8,\n   472→        status: ?[]const u8 = null,\n   473→        priority: ?[]const u8 = null,\n   474→        issue_type: ?[]const u8 = null,\n   475→        assignee: ?[]const u8 = null,\n   476→        label: ?[]const u8 = null,\n   477→        limit: ?u32 = null,\n   478→    },\n   479→    run: struct {\n   480→        name: []const u8,\n   481→    },\n   482→    list: void,\n   483→    delete: struct {\n   484→        name: []const u8,\n   485→    },\n   486→};\n   487→\n   488→/// Query command arguments.\n   489→pub const QueryArgs = struct {\n   490→    subcommand: QuerySubcommand,\n   491→};\n   492→\n   493→/// Upgrade command arguments.\n   494→pub const UpgradeArgs = struct {\n   495→    check_only: bool = false,\n   496→    version: ?[]const u8 = null,\n   497→};\n   498→\n   499→/// Orphans command arguments.\n   500→pub const OrphansArgs = struct {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"e2f9c8bc-7d4b-4351-9f93-359e89e15205","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {","numLines":500,"startLine":1,"totalLines":2384}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GvKxJP3ScLy1vqxGg5w6aX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V6UVE4EajQXKV9vbi4NrS3","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":500,"limit":600}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10381,"cache_read_input_tokens":47197,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10381},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"de8cfffc-c449-4468-8da2-3005fd3a013c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V6UVE4EajQXKV9vbi4NrS3","type":"tool_result","content":"   500→pub const OrphansArgs = struct {\n   501→    limit: ?u32 = null,\n   502→    hierarchy_only: bool = false,\n   503→    deps_only: bool = false,\n   504→};\n   505→\n   506→/// Lint command arguments.\n   507→pub const LintArgs = struct {\n   508→    limit: ?u32 = null,\n   509→};\n   510→\n   511→/// Result of parsing command-line arguments.\n   512→pub const ParseResult = struct {\n   513→    global: GlobalOptions,\n   514→    command: Command,\n   515→\n   516→    /// Free any memory allocated during parsing (labels, deps slices).\n   517→    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n   518→        switch (self.command) {\n   519→            .create => |create| {\n   520→                if (create.labels.len > 0) allocator.free(create.labels);\n   521→                if (create.deps.len > 0) allocator.free(create.deps);\n   522→            },\n   523→            .list => |list_cmd| {\n   524→                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n   525→            },\n   526→            .label => |label_cmd| {\n   527→                switch (label_cmd.subcommand) {\n   528→                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n   529→                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n   530→                    else => {},\n   531→                }\n   532→            },\n   533→            else => {},\n   534→        }\n   535→    }\n   536→};\n   537→\n   538→/// Errors that can occur during argument parsing.\n   539→pub const ParseError = error{\n   540→    UnknownCommand,\n   541→    MissingRequiredArgument,\n   542→    InvalidArgument,\n   543→    UnknownFlag,\n   544→    MissingFlagValue,\n   545→    InvalidFlagValue,\n   546→    InvalidShell,\n   547→    UnknownSubcommand,\n   548→};\n   549→\n   550→/// Command-line argument parser.\n   551→pub const ArgParser = struct {\n   552→    allocator: std.mem.Allocator,\n   553→    args: []const []const u8,\n   554→    index: usize = 0,\n   555→\n   556→    const Self = @This();\n   557→\n   558→    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n   559→        return .{\n   560→            .allocator = allocator,\n   561→            .args = args,\n   562→        };\n   563→    }\n   564→\n   565→    /// Parse all arguments into a ParseResult.\n   566→    pub fn parse(self: *Self) ParseError!ParseResult {\n   567→        var global = GlobalOptions{};\n   568→\n   569→        // Parse global flags first\n   570→        while (self.hasNext()) {\n   571→            const arg = self.peek().?;\n   572→            if (std.mem.startsWith(u8, arg, \"-\")) {\n   573→                if (self.parseGlobalFlag(&global)) |consumed| {\n   574→                    if (!consumed) break;\n   575→                } else |_| {\n   576→                    break;\n   577→                }\n   578→            } else {\n   579→                break;\n   580→            }\n   581→        }\n   582→\n   583→        // Parse subcommand\n   584→        const cmd_str = self.next() orelse {\n   585→            return .{\n   586→                .global = global,\n   587→                .command = .{ .help = .{ .topic = null } },\n   588→            };\n   589→        };\n   590→\n   591→        const command = try self.parseCommand(cmd_str);\n   592→\n   593→        return .{\n   594→            .global = global,\n   595→            .command = command,\n   596→        };\n   597→    }\n   598→\n   599→    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n   600→        const arg = self.next().?;\n   601→\n   602→        if (std.mem.eql(u8, arg, \"--json\")) {\n   603→            global.json = true;\n   604→            return true;\n   605→        }\n   606→        if (std.mem.eql(u8, arg, \"--toon\")) {\n   607→            global.toon = true;\n   608→            return true;\n   609→        }\n   610→        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   611→            global.quiet = true;\n   612→            return true;\n   613→        }\n   614→        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   615→            global.verbose +|= 1;\n   616→            return true;\n   617→        }\n   618→        if (std.mem.eql(u8, arg, \"-vv\")) {\n   619→            global.verbose +|= 2;\n   620→            return true;\n   621→        }\n   622→        if (std.mem.eql(u8, arg, \"--no-color\")) {\n   623→            global.no_color = true;\n   624→            return true;\n   625→        }\n   626→        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n   627→            global.no_auto_flush = true;\n   628→            return true;\n   629→        }\n   630→        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n   631→            global.no_auto_import = true;\n   632→            return true;\n   633→        }\n   634→        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n   635→            global.data_path = self.next() orelse return error.MissingFlagValue;\n   636→            return true;\n   637→        }\n   638→        if (std.mem.eql(u8, arg, \"--actor\")) {\n   639→            global.actor = self.next() orelse return error.MissingFlagValue;\n   640→            return true;\n   641→        }\n   642→        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n   643→            const val = self.next() orelse return error.MissingFlagValue;\n   644→            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n   645→            return true;\n   646→        }\n   647→\n   648→        // Put back if not recognized\n   649→        self.index -= 1;\n   650→        return error.UnknownFlag;\n   651→    }\n   652→\n   653→    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n   654→        // Workspace\n   655→        if (std.mem.eql(u8, cmd, \"init\")) {\n   656→            return .{ .init = try self.parseInitArgs() };\n   657→        }\n   658→        if (std.mem.eql(u8, cmd, \"info\")) {\n   659→            return .{ .info = {} };\n   660→        }\n   661→        if (std.mem.eql(u8, cmd, \"stats\")) {\n   662→            return .{ .stats = {} };\n   663→        }\n   664→        if (std.mem.eql(u8, cmd, \"doctor\")) {\n   665→            return .{ .doctor = {} };\n   666→        }\n   667→        if (std.mem.eql(u8, cmd, \"config\")) {\n   668→            return .{ .config = try self.parseConfigArgs() };\n   669→        }\n   670→        if (std.mem.eql(u8, cmd, \"orphans\")) {\n   671→            return .{ .orphans = try self.parseOrphansArgs() };\n   672→        }\n   673→        if (std.mem.eql(u8, cmd, \"lint\")) {\n   674→            return .{ .lint = try self.parseLintArgs() };\n   675→        }\n   676→        if (std.mem.eql(u8, cmd, \"where\")) {\n   677→            return .{ .where = {} };\n   678→        }\n   679→\n   680→        // Issue CRUD\n   681→        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n   682→            return .{ .create = try self.parseCreateArgs() };\n   683→        }\n   684→        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n   685→            return .{ .q = try self.parseQuickArgs() };\n   686→        }\n   687→        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n   688→            return .{ .show = try self.parseShowArgs() };\n   689→        }\n   690→        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n   691→            return .{ .update = try self.parseUpdateArgs() };\n   692→        }\n   693→        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n   694→            return .{ .close = try self.parseCloseArgs() };\n   695→        }\n   696→        if (std.mem.eql(u8, cmd, \"reopen\")) {\n   697→            return .{ .reopen = try self.parseReopenArgs() };\n   698→        }\n   699→        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n   700→            return .{ .delete = try self.parseDeleteArgs() };\n   701→        }\n   702→\n   703→        // Batch Operations\n   704→        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n   705→            return .{ .add_batch = try self.parseAddBatchArgs() };\n   706→        }\n   707→        if (std.mem.eql(u8, cmd, \"import\")) {\n   708→            return .{ .import_cmd = try self.parseImportArgs() };\n   709→        }\n   710→\n   711→        // Query\n   712→        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n   713→            return .{ .list = try self.parseListArgs() };\n   714→        }\n   715→        if (std.mem.eql(u8, cmd, \"ready\")) {\n   716→            return .{ .ready = try self.parseReadyArgs() };\n   717→        }\n   718→        if (std.mem.eql(u8, cmd, \"blocked\")) {\n   719→            return .{ .blocked = try self.parseBlockedArgs() };\n   720→        }\n   721→        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n   722→            return .{ .search = try self.parseSearchArgs() };\n   723→        }\n   724→        if (std.mem.eql(u8, cmd, \"stale\")) {\n   725→            return .{ .stale = try self.parseStaleArgs() };\n   726→        }\n   727→        if (std.mem.eql(u8, cmd, \"count\")) {\n   728→            return .{ .count = try self.parseCountArgs() };\n   729→        }\n   730→        if (std.mem.eql(u8, cmd, \"defer\")) {\n   731→            return .{ .defer_cmd = try self.parseDeferArgs() };\n   732→        }\n   733→        if (std.mem.eql(u8, cmd, \"undefer\")) {\n   734→            return .{ .undefer = try self.parseUndeferArgs() };\n   735→        }\n   736→\n   737→        // Dependencies\n   738→        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n   739→            return .{ .dep = try self.parseDepArgs() };\n   740→        }\n   741→        if (std.mem.eql(u8, cmd, \"graph\")) {\n   742→            return .{ .graph = try self.parseGraphArgs() };\n   743→        }\n   744→\n   745→        // Epics\n   746→        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n   747→            return .{ .epic = try self.parseEpicArgs() };\n   748→        }\n   749→\n   750→        // Labels\n   751→        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n   752→            return .{ .label = try self.parseLabelArgs() };\n   753→        }\n   754→\n   755→        // Comments\n   756→        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n   757→            return .{ .comments = try self.parseCommentsArgs() };\n   758→        }\n   759→\n   760→        // Audit\n   761→        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n   762→            return .{ .history = try self.parseHistoryArgs() };\n   763→        }\n   764→        if (std.mem.eql(u8, cmd, \"audit\")) {\n   765→            return .{ .audit = try self.parseAuditArgs() };\n   766→        }\n   767→\n   768→        // Changelog\n   769→        if (std.mem.eql(u8, cmd, \"changelog\")) {\n   770→            return .{ .changelog = try self.parseChangelogArgs() };\n   771→        }\n   772→\n   773→        // Sync\n   774→        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n   775→            return .{ .sync = try self.parseSyncArgs() };\n   776→        }\n   777→\n   778→        // System\n   779→        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n   780→            return .{ .version = {} };\n   781→        }\n   782→        if (std.mem.eql(u8, cmd, \"schema\")) {\n   783→            return .{ .schema = {} };\n   784→        }\n   785→        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n   786→            return .{ .completions = try self.parseCompletionsArgs() };\n   787→        }\n   788→        if (std.mem.eql(u8, cmd, \"metrics\")) {\n   789→            return .{ .metrics = try self.parseMetricsArgs() };\n   790→        }\n   791→\n   792→        // Saved Queries\n   793→        if (std.mem.eql(u8, cmd, \"query\")) {\n   794→            return .{ .query = try self.parseQueryArgs() };\n   795→        }\n   796→\n   797→        // Self-upgrade\n   798→        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n   799→            return .{ .upgrade = try self.parseUpgradeArgs() };\n   800→        }\n   801→\n   802→        // Help\n   803→        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n   804→            return .{ .help = try self.parseHelpArgs() };\n   805→        }\n   806→\n   807→        return error.UnknownCommand;\n   808→    }\n   809→\n   810→    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n   811→        var result = InitArgs{};\n   812→        while (self.hasNext()) {\n   813→            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n   814→                result.prefix = self.next() orelse return error.MissingFlagValue;\n   815→            } else if (self.peekPositional()) |_| {\n   816→                result.prefix = self.next().?;\n   817→            } else break;\n   818→        }\n   819→        return result;\n   820→    }\n   821→\n   822→    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n   823→        var result = CreateArgs{ .title = undefined };\n   824→        var title_set = false;\n   825→        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n   826→        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n   827→\n   828→        while (self.hasNext()) {\n   829→            if (self.consumeFlag(\"-d\", \"--description\")) {\n   830→                result.description = self.next() orelse return error.MissingFlagValue;\n   831→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   832→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   833→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   834→                result.priority = self.next() orelse return error.MissingFlagValue;\n   835→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   836→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   837→            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n   838→                result.owner = self.next() orelse return error.MissingFlagValue;\n   839→            } else if (self.consumeFlag(null, \"--design\")) {\n   840→                result.design = self.next() orelse return error.MissingFlagValue;\n   841→            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n   842→                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n   843→            } else if (self.consumeFlag(null, \"--external-ref\")) {\n   844→                result.external_ref = self.next() orelse return error.MissingFlagValue;\n   845→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n   846→                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n   847→            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n   848→                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n   849→            } else if (self.consumeFlag(null, \"--due\")) {\n   850→                result.due = self.next() orelse return error.MissingFlagValue;\n   851→            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n   852→                const val = self.next() orelse return error.MissingFlagValue;\n   853→                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n   854→            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n   855→                result.ephemeral = true;\n   856→            } else if (self.peekPositional()) |_| {\n   857→                if (!title_set) {\n   858→                    result.title = self.next().?;\n   859→                    title_set = true;\n   860→                } else break;\n   861→            } else break;\n   862→        }\n   863→\n   864→        if (!title_set) return error.MissingRequiredArgument;\n   865→\n   866→        if (labels.items.len > 0) {\n   867→            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n   868→        }\n   869→        if (deps.items.len > 0) {\n   870→            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n   871→        }\n   872→\n   873→        return result;\n   874→    }\n   875→\n   876→    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n   877→        var result = QuickArgs{ .title = undefined };\n   878→        var title_set = false;\n   879→\n   880→        while (self.hasNext()) {\n   881→            if (self.consumeFlag(\"-p\", \"--priority\")) {\n   882→                result.priority = self.next() orelse return error.MissingFlagValue;\n   883→            } else if (self.peekPositional()) |_| {\n   884→                if (!title_set) {\n   885→                    result.title = self.next().?;\n   886→                    title_set = true;\n   887→                } else break;\n   888→            } else break;\n   889→        }\n   890→\n   891→        if (!title_set) return error.MissingRequiredArgument;\n   892→        return result;\n   893→    }\n   894→\n   895→    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n   896→        var result = ShowArgs{ .id = undefined };\n   897→        var id_set = false;\n   898→\n   899→        while (self.hasNext()) {\n   900→            if (self.consumeFlag(null, \"--no-comments\")) {\n   901→                result.with_comments = false;\n   902→            } else if (self.consumeFlag(null, \"--with-history\")) {\n   903→                result.with_history = true;\n   904→            } else if (self.peekPositional()) |_| {\n   905→                if (!id_set) {\n   906→                    result.id = self.next().?;\n   907→                    id_set = true;\n   908→                } else break;\n   909→            } else break;\n   910→        }\n   911→\n   912→        if (!id_set) return error.MissingRequiredArgument;\n   913→        return result;\n   914→    }\n   915→\n   916→    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n   917→        var result = UpdateArgs{ .id = undefined };\n   918→        var id_set = false;\n   919→\n   920→        while (self.hasNext()) {\n   921→            if (self.consumeFlag(null, \"--title\")) {\n   922→                result.title = self.next() orelse return error.MissingFlagValue;\n   923→            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n   924→                result.description = self.next() orelse return error.MissingFlagValue;\n   925→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n   926→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n   927→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n   928→                result.priority = self.next() orelse return error.MissingFlagValue;\n   929→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n   930→                result.assignee = self.next() orelse return error.MissingFlagValue;\n   931→            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n   932→                result.owner = self.next() orelse return error.MissingFlagValue;\n   933→            } else if (self.consumeFlag(null, \"--design\")) {\n   934→                result.design = self.next() orelse return error.MissingFlagValue;\n   935→            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n   936→                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n   937→            } else if (self.consumeFlag(null, \"--external-ref\")) {\n   938→                result.external_ref = self.next() orelse return error.MissingFlagValue;\n   939→            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n   940→                result.status = self.next() orelse return error.MissingFlagValue;\n   941→            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n   942→                const version_str = self.next() orelse return error.MissingFlagValue;\n   943→                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n   944→            } else if (self.consumeFlag(null, \"--claim\")) {\n   945→                result.claim = true;\n   946→            } else if (self.peekPositional()) |_| {\n   947→                if (!id_set) {\n   948→                    result.id = self.next().?;\n   949→                    id_set = true;\n   950→                } else break;\n   951→            } else break;\n   952→        }\n   953→\n   954→        if (!id_set) return error.MissingRequiredArgument;\n   955→        return result;\n   956→    }\n   957→\n   958→    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n   959→        var result = CloseArgs{ .id = undefined };\n   960→        var id_set = false;\n   961→\n   962→        while (self.hasNext()) {\n   963→            if (self.consumeFlag(\"-r\", \"--reason\")) {\n   964→                result.reason = self.next() orelse return error.MissingFlagValue;\n   965→            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n   966→                result.session = self.next() orelse return error.MissingFlagValue;\n   967→            } else if (self.peekPositional()) |_| {\n   968→                if (!id_set) {\n   969→                    result.id = self.next().?;\n   970→                    id_set = true;\n   971→                } else break;\n   972→            } else break;\n   973→        }\n   974→\n   975→        if (!id_set) return error.MissingRequiredArgument;\n   976→        return result;\n   977→    }\n   978→\n   979→    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n   980→        const id = self.next() orelse return error.MissingRequiredArgument;\n   981→        return .{ .id = id };\n   982→    }\n   983→\n   984→    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n   985→        const id = self.next() orelse return error.MissingRequiredArgument;\n   986→        return .{ .id = id };\n   987→    }\n   988→\n   989→    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n   990→        var result = AddBatchArgs{};\n   991→        while (self.hasNext()) {\n   992→            if (self.consumeFlag(\"-f\", \"--file\")) {\n   993→                result.file = self.next() orelse return error.MissingFlagValue;\n   994→            } else if (self.consumeFlag(null, \"--format\")) {\n   995→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n   996→                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n   997→            } else if (self.peekPositional()) |_| {\n   998→                // Positional argument is treated as file path\n   999→                if (result.file == null) {\n  1000→                    result.file = self.next().?;\n  1001→                } else break;\n  1002→            } else break;\n  1003→        }\n  1004→        return result;\n  1005→    }\n  1006→\n  1007→    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n  1008→        var result = ImportArgs{ .file = undefined };\n  1009→        var file_set = false;\n  1010→\n  1011→        while (self.hasNext()) {\n  1012→            if (self.consumeFlag(\"-m\", \"--merge\")) {\n  1013→                result.merge = true;\n  1014→            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n  1015→                result.dry_run = true;\n  1016→            } else if (self.peekPositional()) |_| {\n  1017→                if (!file_set) {\n  1018→                    result.file = self.next().?;\n  1019→                    file_set = true;\n  1020→                } else break;\n  1021→            } else break;\n  1022→        }\n  1023→\n  1024→        if (!file_set) return error.MissingRequiredArgument;\n  1025→        return result;\n  1026→    }\n  1027→\n  1028→    fn parseListArgs(self: *Self) ParseError!ListArgs {\n  1029→        var result = ListArgs{};\n  1030→        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n  1031→\n  1032→        while (self.hasNext()) {\n  1033→            if (self.consumeFlag(\"-s\", \"--status\")) {\n  1034→                result.status = self.next() orelse return error.MissingFlagValue;\n  1035→            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1036→                result.priority = self.next() orelse return error.MissingFlagValue;\n  1037→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1038→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1039→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1040→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1041→            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n  1042→                result.issue_type = self.next() orelse return error.MissingFlagValue;\n  1043→            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n  1044→                result.assignee = self.next() orelse return error.MissingFlagValue;\n  1045→            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n  1046→                result.label = self.next() orelse return error.MissingFlagValue;\n  1047→            } else if (self.consumeFlag(null, \"--label-any\")) {\n  1048→                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n  1049→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1050→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1051→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1052→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1053→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1054→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1055→            } else if (try self.parseLimitFlag()) |limit| {\n  1056→                result.limit = limit;\n  1057→            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n  1058→                result.all = true;\n  1059→            } else if (self.consumeFlag(null, \"--overdue\")) {\n  1060→                result.overdue = true;\n  1061→            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n  1062→                result.include_deferred = true;\n  1063→            } else if (self.consumeFlag(null, \"--sort\")) {\n  1064→                const sort_str = self.next() orelse return error.MissingFlagValue;\n  1065→                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n  1066→            } else if (self.consumeFlag(null, \"--asc\")) {\n  1067→                result.sort_desc = false;\n  1068→            } else if (self.consumeFlag(null, \"--desc\")) {\n  1069→                result.sort_desc = true;\n  1070→            } else break;\n  1071→        }\n  1072→\n  1073→        if (label_any_list.items.len > 0) {\n  1074→            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1075→        }\n  1076→\n  1077→        return result;\n  1078→    }\n  1079→\n  1080→    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n  1081→        var result = ReadyArgs{};\n  1082→        while (self.hasNext()) {\n  1083→            if (try self.parseLimitFlag()) |limit| {\n  1084→                result.limit = limit;\n  1085→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1086→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1087→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1088→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1089→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1090→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1091→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1092→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1093→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1094→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1095→            } else if (self.consumeFlag(null, \"--overdue\")) {\n  1096→                result.overdue = true;\n  1097→            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n  1098→                result.include_deferred = true;\n  1099→            } else break;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"42a3f7cd-23fd-4a6f-89b7-588401025045","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"pub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;","numLines":600,"startLine":500,"totalLines":2384}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MFmJysbWp1H8ats7Lxog9R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QR2HiEQPxQZwHWTuJwSxSt","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":1100,"limit":400}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":9724,"cache_read_input_tokens":57578,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9724},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"e95d6c51-90c1-4913-b43e-f4ff26162fc3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QR2HiEQPxQZwHWTuJwSxSt","type":"tool_result","content":"  1100→        }\n  1101→        return result;\n  1102→    }\n  1103→\n  1104→    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n  1105→        var result = BlockedArgs{};\n  1106→        while (self.hasNext()) {\n  1107→            if (try self.parseLimitFlag()) |limit| {\n  1108→                result.limit = limit;\n  1109→            } else if (self.consumeFlag(null, \"--priority-min\")) {\n  1110→                result.priority_min = self.next() orelse return error.MissingFlagValue;\n  1111→            } else if (self.consumeFlag(null, \"--priority-max\")) {\n  1112→                result.priority_max = self.next() orelse return error.MissingFlagValue;\n  1113→            } else if (self.consumeFlag(null, \"--title-contains\")) {\n  1114→                result.title_contains = self.next() orelse return error.MissingFlagValue;\n  1115→            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n  1116→                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n  1117→            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n  1118→                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n  1119→            } else break;\n  1120→        }\n  1121→        return result;\n  1122→    }\n  1123→\n  1124→    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n  1125→        var result = SearchArgs{ .query = undefined };\n  1126→        var query_set = false;\n  1127→\n  1128→        while (self.hasNext()) {\n  1129→            if (try self.parseLimitFlag()) |limit| {\n  1130→                result.limit = limit;\n  1131→            } else if (self.peekPositional()) |_| {\n  1132→                if (!query_set) {\n  1133→                    result.query = self.next().?;\n  1134→                    query_set = true;\n  1135→                } else break;\n  1136→            } else break;\n  1137→        }\n  1138→\n  1139→        if (!query_set) return error.MissingRequiredArgument;\n  1140→        return result;\n  1141→    }\n  1142→\n  1143→    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n  1144→        var result = StaleArgs{};\n  1145→        while (self.hasNext()) {\n  1146→            if (self.consumeFlag(\"-d\", \"--days\")) {\n  1147→                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n  1148→            } else if (try self.parseLimitFlag()) |limit| {\n  1149→                result.limit = limit;\n  1150→            } else break;\n  1151→        }\n  1152→        return result;\n  1153→    }\n  1154→\n  1155→    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n  1156→        var result = CountArgs{};\n  1157→        while (self.hasNext()) {\n  1158→            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1159→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1160→            } else break;\n  1161→        }\n  1162→        return result;\n  1163→    }\n  1164→\n  1165→    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n  1166→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1167→        var result = DeferArgs{ .id = id };\n  1168→        while (self.hasNext()) {\n  1169→            if (self.consumeFlag(\"-u\", \"--until\")) {\n  1170→                result.until = self.next() orelse return error.MissingFlagValue;\n  1171→            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n  1172→                result.reason = self.next() orelse return error.MissingFlagValue;\n  1173→            } else break;\n  1174→        }\n  1175→        return result;\n  1176→    }\n  1177→\n  1178→    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n  1179→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1180→        return UndeferArgs{ .id = id };\n  1181→    }\n  1182→\n  1183→    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n  1184→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1185→\n  1186→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1187→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1188→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1189→            var dep_type: []const u8 = \"blocks\";\n  1190→            while (self.hasNext()) {\n  1191→                if (self.consumeFlag(\"-t\", \"--type\")) {\n  1192→                    dep_type = self.next() orelse return error.MissingFlagValue;\n  1193→                } else break;\n  1194→            }\n  1195→            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n  1196→        }\n  1197→        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1198→            const child = self.next() orelse return error.MissingRequiredArgument;\n  1199→            const parent = self.next() orelse return error.MissingRequiredArgument;\n  1200→            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n  1201→        }\n  1202→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1203→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1204→        }\n  1205→        if (std.mem.eql(u8, subcmd, \"tree\")) {\n  1206→            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1207→        }\n  1208→        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n  1209→            return .{ .subcommand = .{ .cycles = {} } };\n  1210→        }\n  1211→        return error.UnknownSubcommand;\n  1212→    }\n  1213→\n  1214→    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n  1215→        var result = GraphArgs{};\n  1216→\n  1217→        while (self.hasNext()) {\n  1218→            if (self.consumeFlag(\"-f\", \"--format\")) {\n  1219→                const fmt_str = self.next() orelse return error.MissingFlagValue;\n  1220→                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n  1221→            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n  1222→                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n  1223→            } else if (self.peekPositional()) |_| {\n  1224→                if (result.id == null) {\n  1225→                    result.id = self.next().?;\n  1226→                } else break;\n  1227→            } else break;\n  1228→        }\n  1229→\n  1230→        return result;\n  1231→    }\n  1232→\n  1233→    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n  1234→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1235→\n  1236→        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n  1237→            var title: ?[]const u8 = null;\n  1238→            var description: ?[]const u8 = null;\n  1239→            var priority: ?[]const u8 = null;\n  1240→\n  1241→            while (self.hasNext()) {\n  1242→                if (self.consumeFlag(\"-d\", \"--description\")) {\n  1243→                    description = self.next() orelse return error.MissingFlagValue;\n  1244→                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1245→                    priority = self.next() orelse return error.MissingFlagValue;\n  1246→                } else if (self.peekPositional()) |_| {\n  1247→                    if (title == null) {\n  1248→                        title = self.next().?;\n  1249→                    } else break;\n  1250→                } else break;\n  1251→            }\n  1252→\n  1253→            if (title == null) return error.MissingRequiredArgument;\n  1254→            return .{ .subcommand = .{ .create = .{\n  1255→                .title = title.?,\n  1256→                .description = description,\n  1257→                .priority = priority,\n  1258→            } } };\n  1259→        }\n  1260→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1261→            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n  1262→            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n  1263→            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n  1264→        }\n  1265→        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1266→            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n  1267→            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n  1268→            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n  1269→        }\n  1270→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1271→            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n  1272→        }\n  1273→        return error.UnknownSubcommand;\n  1274→    }\n  1275→\n  1276→    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n  1277→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1278→\n  1279→        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1280→            const is_add = std.mem.eql(u8, subcmd, \"add\");\n  1281→            const id = self.next() orelse return error.MissingRequiredArgument;\n  1282→            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n  1283→\n  1284→            while (self.peekPositional()) |_| {\n  1285→                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n  1286→            }\n  1287→\n  1288→            if (labels.items.len == 0) return error.MissingRequiredArgument;\n  1289→\n  1290→            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n  1291→            if (is_add) {\n  1292→                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n  1293→            } else {\n  1294→                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n  1295→            }\n  1296→        }\n  1297→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1298→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1299→        }\n  1300→        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n  1301→            return .{ .subcommand = .{ .list_all = {} } };\n  1302→        }\n  1303→        return error.UnknownSubcommand;\n  1304→    }\n  1305→\n  1306→    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n  1307→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1308→\n  1309→        if (std.mem.eql(u8, subcmd, \"add\")) {\n  1310→            return .{ .subcommand = .{ .add = .{\n  1311→                .id = self.next() orelse return error.MissingRequiredArgument,\n  1312→                .text = self.next() orelse return error.MissingRequiredArgument,\n  1313→            } } };\n  1314→        }\n  1315→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1316→            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n  1317→        }\n  1318→        return error.UnknownSubcommand;\n  1319→    }\n  1320→\n  1321→    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n  1322→        const id = self.next() orelse return error.MissingRequiredArgument;\n  1323→        return .{ .id = id };\n  1324→    }\n  1325→\n  1326→    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n  1327→        var result = AuditArgs{};\n  1328→        while (self.hasNext()) {\n  1329→            if (try self.parseLimitFlag()) |limit| {\n  1330→                result.limit = limit;\n  1331→            } else break;\n  1332→        }\n  1333→        return result;\n  1334→    }\n  1335→\n  1336→    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n  1337→        var result = ChangelogArgs{};\n  1338→        while (self.hasNext()) {\n  1339→            if (self.consumeFlag(null, \"--since\")) {\n  1340→                result.since = self.next() orelse return error.MissingFlagValue;\n  1341→            } else if (self.consumeFlag(null, \"--until\")) {\n  1342→                result.until = self.next() orelse return error.MissingFlagValue;\n  1343→            } else if (try self.parseLimitFlag()) |limit| {\n  1344→                result.limit = limit;\n  1345→            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n  1346→                result.group_by = self.next() orelse return error.MissingFlagValue;\n  1347→            } else break;\n  1348→        }\n  1349→        return result;\n  1350→    }\n  1351→\n  1352→    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n  1353→        var result = SyncArgs{};\n  1354→        while (self.hasNext()) {\n  1355→            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n  1356→                result.flush_only = true;\n  1357→            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n  1358→                result.import_only = true;\n  1359→            } else break;\n  1360→        }\n  1361→        return result;\n  1362→    }\n  1363→\n  1364→    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n  1365→        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n  1366→        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n  1367→        return .{ .shell = shell };\n  1368→    }\n  1369→\n  1370→    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n  1371→        var result = MetricsArgs{};\n  1372→        while (self.hasNext()) {\n  1373→            if (self.consumeFlag(\"-r\", \"--reset\")) {\n  1374→                result.reset = true;\n  1375→            } else break;\n  1376→        }\n  1377→        return result;\n  1378→    }\n  1379→\n  1380→    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n  1381→        return .{ .topic = self.next() };\n  1382→    }\n  1383→\n  1384→    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n  1385→        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n  1386→\n  1387→        if (std.mem.eql(u8, subcmd, \"get\")) {\n  1388→            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n  1389→        }\n  1390→        if (std.mem.eql(u8, subcmd, \"set\")) {\n  1391→            return .{ .subcommand = .{ .set = .{\n  1392→                .key = self.next() orelse return error.MissingRequiredArgument,\n  1393→                .value = self.next() orelse return error.MissingRequiredArgument,\n  1394→            } } };\n  1395→        }\n  1396→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1397→            return .{ .subcommand = .{ .list = {} } };\n  1398→        }\n  1399→        return error.UnknownSubcommand;\n  1400→    }\n  1401→\n  1402→    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n  1403→        var result = OrphansArgs{};\n  1404→        while (self.hasNext()) {\n  1405→            if (try self.parseLimitFlag()) |limit| {\n  1406→                result.limit = limit;\n  1407→            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n  1408→                result.hierarchy_only = true;\n  1409→            } else if (self.consumeFlag(null, \"--deps-only\")) {\n  1410→                result.deps_only = true;\n  1411→            } else break;\n  1412→        }\n  1413→        return result;\n  1414→    }\n  1415→\n  1416→    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n  1417→        var result = LintArgs{};\n  1418→        while (self.hasNext()) {\n  1419→            if (try self.parseLimitFlag()) |limit| {\n  1420→                result.limit = limit;\n  1421→            } else break;\n  1422→        }\n  1423→        return result;\n  1424→    }\n  1425→\n  1426→    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n  1427→        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n  1428→\n  1429→        if (std.mem.eql(u8, subcmd, \"save\")) {\n  1430→            const name = self.next() orelse return error.MissingRequiredArgument;\n  1431→            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n  1432→\n  1433→            while (self.hasNext()) {\n  1434→                if (self.consumeFlag(\"-s\", \"--status\")) {\n  1435→                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n  1436→                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n  1437→                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n  1438→                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n  1439→                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n  1440→                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n  1441→                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n  1442→                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n  1443→                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n  1444→                } else if (try self.parseLimitFlag()) |limit| {\n  1445→                    save_args.save.limit = limit;\n  1446→                } else break;\n  1447→            }\n  1448→\n  1449→            return .{ .subcommand = save_args };\n  1450→        }\n  1451→        if (std.mem.eql(u8, subcmd, \"run\")) {\n  1452→            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n  1453→        }\n  1454→        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n  1455→            return .{ .subcommand = .{ .list = {} } };\n  1456→        }\n  1457→        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n  1458→            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n  1459→        }\n  1460→        return error.UnknownSubcommand;\n  1461→    }\n  1462→\n  1463→    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n  1464→        var result = UpgradeArgs{};\n  1465→        while (self.hasNext()) {\n  1466→            if (self.consumeFlag(\"-c\", \"--check\")) {\n  1467→                result.check_only = true;\n  1468→            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n  1469→                result.version = self.next() orelse return error.MissingFlagValue;\n  1470→            } else break;\n  1471→        }\n  1472→        return result;\n  1473→    }\n  1474→\n  1475→    fn hasNext(self: *Self) bool {\n  1476→        return self.index < self.args.len;\n  1477→    }\n  1478→\n  1479→    fn peek(self: *Self) ?[]const u8 {\n  1480→        if (self.index >= self.args.len) return null;\n  1481→        return self.args[self.index];\n  1482→    }\n  1483→\n  1484→    fn next(self: *Self) ?[]const u8 {\n  1485→        if (self.index >= self.args.len) return null;\n  1486→        const arg = self.args[self.index];\n  1487→        self.index += 1;\n  1488→        return arg;\n  1489→    }\n  1490→\n  1491→    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n  1492→    fn skip(self: *Self) void {\n  1493→        if (self.index < self.args.len) {\n  1494→            self.index += 1;\n  1495→        }\n  1496→    }\n  1497→\n  1498→    /// Check if current arg matches a flag, and if so consume it and return true.\n  1499→    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"68989546-80a5-44cb-ae5e-67fe450bf761","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {","numLines":400,"startLine":1100,"totalLines":2384}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MFmJysbWp1H8ats7Lxog9R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QwFsGdqvi5rhgExxPw8YB3","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","limit":400}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":9724,"cache_read_input_tokens":57578,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9724},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d5b2143f-f29b-48db-9afd-5e6ebb4c8e6e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QwFsGdqvi5rhgExxPw8YB3","type":"tool_result","content":"     1→//! Output formatting for beads_zig.\n     2→//!\n     3→//! Provides a unified interface for displaying output in different modes:\n     4→//! - plain: No colors, basic formatting (default for non-TTY)\n     5→//! - rich: Colors and formatting (default for TTY)\n     6→//! - json: Structured JSON output for machine consumption\n     7→//! - quiet: Minimal output (IDs only)\n     8→//!\n     9→//! Respects NO_COLOR environment variable and --no-color flag.\n    10→\n    11→const std = @import(\"std\");\n    12→const models = @import(\"../models/mod.zig\");\n    13→const Issue = models.Issue;\n    14→const Status = models.Status;\n    15→const Priority = models.Priority;\n    16→const IssueType = models.IssueType;\n    17→\n    18→/// Output mode determines formatting and verbosity.\n    19→pub const OutputMode = enum {\n    20→    plain, // No colors, basic formatting\n    21→    rich, // Colors and formatting (TTY)\n    22→    json, // Structured JSON output\n    23→    quiet, // Minimal output (IDs only)\n    24→};\n    25→\n    26→/// ANSI color escape codes.\n    27→pub const Color = struct {\n    28→    pub const reset = \"\\x1b[0m\";\n    29→    pub const bold = \"\\x1b[1m\";\n    30→    pub const dim = \"\\x1b[2m\";\n    31→    pub const italic = \"\\x1b[3m\";\n    32→    pub const underline = \"\\x1b[4m\";\n    33→\n    34→    pub const red = \"\\x1b[31m\";\n    35→    pub const green = \"\\x1b[32m\";\n    36→    pub const yellow = \"\\x1b[33m\";\n    37→    pub const blue = \"\\x1b[34m\";\n    38→    pub const magenta = \"\\x1b[35m\";\n    39→    pub const cyan = \"\\x1b[36m\";\n    40→    pub const white = \"\\x1b[37m\";\n    41→    pub const gray = \"\\x1b[90m\";\n    42→\n    43→    pub const bright_red = \"\\x1b[91m\";\n    44→    pub const bright_green = \"\\x1b[92m\";\n    45→    pub const bright_yellow = \"\\x1b[93m\";\n    46→    pub const bright_blue = \"\\x1b[94m\";\n    47→    pub const bright_magenta = \"\\x1b[95m\";\n    48→    pub const bright_cyan = \"\\x1b[96m\";\n    49→\n    50→    pub const bg_red = \"\\x1b[41m\";\n    51→    pub const bg_green = \"\\x1b[42m\";\n    52→    pub const bg_yellow = \"\\x1b[43m\";\n    53→    pub const bg_blue = \"\\x1b[44m\";\n    54→};\n    55→\n    56→/// Global options that affect output formatting.\n    57→/// This mirrors the relevant fields from cli.args.GlobalOptions.\n    58→pub const OutputOptions = struct {\n    59→    json: bool = false,\n    60→    toon: bool = false,\n    61→    quiet: bool = false,\n    62→    silent: bool = false, // Suppress ALL output including errors (for tests)\n    63→    no_color: bool = false,\n    64→};\n    65→\n    66→/// Output formatter for consistent CLI output across all modes.\n    67→pub const Output = struct {\n    68→    mode: OutputMode,\n    69→    toon: bool,\n    70→    silent: bool, // Suppress ALL output including errors (for tests)\n    71→    stdout: std.fs.File,\n    72→    stderr: std.fs.File,\n    73→    allocator: std.mem.Allocator,\n    74→\n    75→    const Self = @This();\n    76→\n    77→    /// Initialize output formatter based on global options and TTY detection.\n    78→    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n    79→        const stdout = std.fs.File.stdout();\n    80→        const stderr = std.fs.File.stderr();\n    81→\n    82→        var mode: OutputMode = .plain;\n    83→        if (opts.json or opts.toon) {\n    84→            mode = .json;\n    85→        } else if (opts.quiet or opts.silent) {\n    86→            mode = .quiet;\n    87→        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n    88→            mode = .rich;\n    89→        }\n    90→\n    91→        return .{\n    92→            .mode = mode,\n    93→            .toon = opts.toon,\n    94→            .silent = opts.silent,\n    95→            .stdout = stdout,\n    96→            .stderr = stderr,\n    97→            .allocator = allocator,\n    98→        };\n    99→    }\n   100→\n   101→    /// Initialize with explicit mode (useful for testing).\n   102→    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n   103→        return .{\n   104→            .mode = mode,\n   105→            .toon = false,\n   106→            .silent = false,\n   107→            .stdout = std.fs.File.stdout(),\n   108→            .stderr = std.fs.File.stderr(),\n   109→            .allocator = allocator,\n   110→        };\n   111→    }\n   112→\n   113→    /// Initialize for testing with custom file handles.\n   114→    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n   115→        return .{\n   116→            .mode = mode,\n   117→            .toon = false,\n   118→            .silent = false,\n   119→            .stdout = stdout,\n   120→            .stderr = stderr,\n   121→            .allocator = allocator,\n   122→        };\n   123→    }\n   124→\n   125→    /// Initialize with silent mode (suppresses ALL output including errors).\n   126→    pub fn initSilent(allocator: std.mem.Allocator) Self {\n   127→        return .{\n   128→            .mode = .quiet,\n   129→            .toon = false,\n   130→            .silent = true,\n   131→            .stdout = std.fs.File.stdout(),\n   132→            .stderr = std.fs.File.stderr(),\n   133→            .allocator = allocator,\n   134→        };\n   135→    }\n   136→\n   137→    // ========================================================================\n   138→    // Issue Display\n   139→    // ========================================================================\n   140→\n   141→    /// Print a single issue in the appropriate format.\n   142→    pub fn printIssue(self: *Self, issue: Issue) !void {\n   143→        switch (self.mode) {\n   144→            .json => try self.printIssueJson(issue),\n   145→            .quiet => try self.printIssueQuiet(issue),\n   146→            .rich => try self.printIssueRich(issue),\n   147→            .plain => try self.printIssuePlain(issue),\n   148→        }\n   149→    }\n   150→\n   151→    /// Print a list of issues in the appropriate format.\n   152→    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n   153→        switch (self.mode) {\n   154→            .json => try self.printIssueListJson(issues),\n   155→            .quiet => try self.printIssueListQuiet(issues),\n   156→            .rich => try self.printIssueListRich(issues),\n   157→            .plain => try self.printIssueListPlain(issues),\n   158→        }\n   159→    }\n   160→\n   161→    // ========================================================================\n   162→    // Generic Messages\n   163→    // ========================================================================\n   164→\n   165→    /// Print a formatted message to stdout.\n   166→    pub fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   167→        if (self.mode == .quiet) return;\n   168→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   169→        defer self.allocator.free(msg);\n   170→        try self.stdout.writeAll(msg);\n   171→    }\n   172→\n   173→    /// Print a formatted message to stdout with newline.\n   174→    pub fn println(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   175→        if (self.mode == .quiet) return;\n   176→        const msg = try std.fmt.allocPrint(self.allocator, fmt ++ \"\\n\", args);\n   177→        defer self.allocator.free(msg);\n   178→        try self.stdout.writeAll(msg);\n   179→    }\n   180→\n   181→    /// Print a success message (green in rich mode).\n   182→    pub fn success(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   183→        if (self.mode == .quiet) return;\n   184→        if (self.mode == .rich) try self.stdout.writeAll(Color.green);\n   185→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   186→        defer self.allocator.free(msg);\n   187→        try self.stdout.writeAll(msg);\n   188→        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n   189→        try self.stdout.writeAll(\"\\n\");\n   190→    }\n   191→\n   192→    /// Print an error message to stderr (red in rich mode).\n   193→    pub fn err(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   194→        if (self.silent) return;\n   195→        if (self.mode == .rich) try self.stderr.writeAll(Color.red);\n   196→        const msg = try std.fmt.allocPrint(self.allocator, \"error: \" ++ fmt, args);\n   197→        defer self.allocator.free(msg);\n   198→        try self.stderr.writeAll(msg);\n   199→        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n   200→        try self.stderr.writeAll(\"\\n\");\n   201→    }\n   202→\n   203→    /// Print a warning message to stderr (yellow in rich mode).\n   204→    pub fn warn(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   205→        if (self.silent or self.mode == .quiet) return;\n   206→        if (self.mode == .rich) try self.stderr.writeAll(Color.yellow);\n   207→        const msg = try std.fmt.allocPrint(self.allocator, \"warning: \" ++ fmt, args);\n   208→        defer self.allocator.free(msg);\n   209→        try self.stderr.writeAll(msg);\n   210→        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n   211→        try self.stderr.writeAll(\"\\n\");\n   212→    }\n   213→\n   214→    /// Print an info message (cyan in rich mode).\n   215→    pub fn info(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   216→        if (self.mode == .quiet) return;\n   217→        if (self.mode == .rich) try self.stdout.writeAll(Color.cyan);\n   218→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   219→        defer self.allocator.free(msg);\n   220→        try self.stdout.writeAll(msg);\n   221→        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n   222→        try self.stdout.writeAll(\"\\n\");\n   223→    }\n   224→\n   225→    /// Print raw bytes to stdout (bypasses mode checks).\n   226→    pub fn raw(self: *Self, bytes: []const u8) !void {\n   227→        try self.stdout.writeAll(bytes);\n   228→    }\n   229→\n   230→    /// Print raw JSON value to stdout (for JSON mode).\n   231→    /// If toon mode is enabled, converts JSON to TOON format for reduced token usage.\n   232→    pub fn printJson(self: *Self, value: anytype) !void {\n   233→        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n   234→        defer self.allocator.free(json_bytes);\n   235→\n   236→        if (self.toon) {\n   237→            const toon = @import(\"toon_zig\");\n   238→            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |convert_err| {\n   239→                try self.stderr.writeAll(\"error: failed to convert to TOON format\\n\");\n   240→                return convert_err;\n   241→            };\n   242→            defer self.allocator.free(toon_bytes);\n   243→            try self.stdout.writeAll(toon_bytes);\n   244→        } else {\n   245→            try self.stdout.writeAll(json_bytes);\n   246→        }\n   247→        try self.stdout.writeAll(\"\\n\");\n   248→    }\n   249→\n   250→    // ========================================================================\n   251→    // JSON Mode Helpers\n   252→    // ========================================================================\n   253→\n   254→    fn printIssueJson(self: *Self, issue: Issue) !void {\n   255→        try self.printJson(issue);\n   256→    }\n   257→\n   258→    fn printIssueListJson(self: *Self, issues: []const Issue) !void {\n   259→        try self.printJson(issues);\n   260→    }\n   261→\n   262→    // ========================================================================\n   263→    // Plain Mode Helpers\n   264→    // ========================================================================\n   265→\n   266→    fn printIssuePlain(self: *Self, issue: Issue) !void {\n   267→        try self.writeFormatted(\"ID: {s}\\n\", .{issue.id});\n   268→        try self.writeFormatted(\"Title: {s}\\n\", .{issue.title});\n   269→        try self.writeFormatted(\"Status: {s}\\n\", .{issue.status.toString()});\n   270→        try self.writeFormatted(\"Priority: {s}\\n\", .{issue.priority.toString()});\n   271→        try self.writeFormatted(\"Type: {s}\\n\", .{issue.issue_type.toString()});\n   272→\n   273→        if (issue.description) |desc| {\n   274→            try self.writeFormatted(\"Description: {s}\\n\", .{desc});\n   275→        }\n   276→        if (issue.assignee) |assignee| {\n   277→            try self.writeFormatted(\"Assignee: {s}\\n\", .{assignee});\n   278→        }\n   279→        if (issue.labels.len > 0) {\n   280→            try self.stdout.writeAll(\"Labels: \");\n   281→            for (issue.labels, 0..) |label, i| {\n   282→                if (i > 0) try self.stdout.writeAll(\", \");\n   283→                try self.stdout.writeAll(label);\n   284→            }\n   285→            try self.stdout.writeAll(\"\\n\");\n   286→        }\n   287→        if (issue.due_at.value) |due| {\n   288→            try self.writeFormatted(\"Due: {d}\\n\", .{due});\n   289→        }\n   290→\n   291→        try self.writeFormatted(\"Created: {d}\\n\", .{issue.created_at.value});\n   292→        try self.writeFormatted(\"Updated: {d}\\n\", .{issue.updated_at.value});\n   293→    }\n   294→\n   295→    fn printIssueListPlain(self: *Self, issues: []const Issue) !void {\n   296→        for (issues) |issue| {\n   297→            const status_abbrev = abbreviateStatus(issue.status);\n   298→            try self.writeFormatted(\"{s}  [{s}] {s}\\n\", .{\n   299→                issue.id,\n   300→                status_abbrev,\n   301→                issue.title,\n   302→            });\n   303→        }\n   304→    }\n   305→\n   306→    // ========================================================================\n   307→    // Rich Mode Helpers (ANSI colors)\n   308→    // ========================================================================\n   309→\n   310→    fn printIssueRich(self: *Self, issue: Issue) !void {\n   311→        // Bold ID\n   312→        try self.writeFormatted(\"{s}{s}{s}\\n\", .{ Color.bold, issue.id, Color.reset });\n   313→\n   314→        // Title\n   315→        try self.writeFormatted(\"  {s}\\n\", .{issue.title});\n   316→\n   317→        // Status with color\n   318→        const status_color = getStatusColor(issue.status);\n   319→        try self.writeFormatted(\"  Status: {s}{s}{s}\\n\", .{ status_color, issue.status.toString(), Color.reset });\n   320→\n   321→        // Priority with color\n   322→        const priority_color = getPriorityColor(issue.priority);\n   323→        try self.writeFormatted(\"  Priority: {s}{s}{s}\\n\", .{ priority_color, issue.priority.toString(), Color.reset });\n   324→\n   325→        // Type\n   326→        try self.writeFormatted(\"  Type: {s}\\n\", .{issue.issue_type.toString()});\n   327→\n   328→        // Optional fields\n   329→        if (issue.description) |desc| {\n   330→            try self.writeFormatted(\"  Description: {s}{s}{s}\\n\", .{ Color.dim, desc, Color.reset });\n   331→        }\n   332→        if (issue.assignee) |assignee| {\n   333→            try self.writeFormatted(\"  Assignee: {s}{s}{s}\\n\", .{ Color.cyan, assignee, Color.reset });\n   334→        }\n   335→        if (issue.labels.len > 0) {\n   336→            try self.stdout.writeAll(\"  Labels: \");\n   337→            for (issue.labels, 0..) |label, i| {\n   338→                if (i > 0) try self.stdout.writeAll(\", \");\n   339→                try self.writeFormatted(\"{s}{s}{s}\", .{ Color.magenta, label, Color.reset });\n   340→            }\n   341→            try self.stdout.writeAll(\"\\n\");\n   342→        }\n   343→    }\n   344→\n   345→    fn printIssueListRich(self: *Self, issues: []const Issue) !void {\n   346→        for (issues) |issue| {\n   347→            const status_color = getStatusColor(issue.status);\n   348→            const priority_color = getPriorityColor(issue.priority);\n   349→            const status_abbrev = abbreviateStatus(issue.status);\n   350→\n   351→            try self.writeFormatted(\"{s}{s}{s}  {s}[{s}]{s}  {s}{s}{s}  {s}\\n\", .{\n   352→                Color.bold,\n   353→                issue.id,\n   354→                Color.reset,\n   355→                status_color,\n   356→                status_abbrev,\n   357→                Color.reset,\n   358→                priority_color,\n   359→                priorityIndicator(issue.priority),\n   360→                Color.reset,\n   361→                issue.title,\n   362→            });\n   363→        }\n   364→    }\n   365→\n   366→    // ========================================================================\n   367→    // Quiet Mode Helpers\n   368→    // ========================================================================\n   369→\n   370→    fn printIssueQuiet(self: *Self, issue: Issue) !void {\n   371→        try self.writeFormatted(\"{s}\\n\", .{issue.id});\n   372→    }\n   373→\n   374→    fn printIssueListQuiet(self: *Self, issues: []const Issue) !void {\n   375→        for (issues) |issue| {\n   376→            try self.writeFormatted(\"{s}\\n\", .{issue.id});\n   377→        }\n   378→    }\n   379→\n   380→    // ========================================================================\n   381→    // Internal Helpers\n   382→    // ========================================================================\n   383→\n   384→    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n   385→        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n   386→        defer self.allocator.free(msg);\n   387→        try self.stdout.writeAll(msg);\n   388→    }\n   389→};\n   390→\n   391→// ============================================================================\n   392→// Helper Functions\n   393→// ============================================================================\n   394→\n   395→/// Check if NO_COLOR environment variable is set (cross-platform).\n   396→fn checkNoColorEnv() bool {\n   397→    // Per NO_COLOR spec, only existence matters, not the value\n   398→    return std.process.hasEnvVarConstant(\"NO_COLOR\");\n   399→}\n   400→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"98ae5783-ba92-4197-b001-9b062919b63a","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/output/mod.zig","content":"//! Output formatting for beads_zig.\n//!\n//! Provides a unified interface for displaying output in different modes:\n//! - plain: No colors, basic formatting (default for non-TTY)\n//! - rich: Colors and formatting (default for TTY)\n//! - json: Structured JSON output for machine consumption\n//! - quiet: Minimal output (IDs only)\n//!\n//! Respects NO_COLOR environment variable and --no-color flag.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\n\n/// Output mode determines formatting and verbosity.\npub const OutputMode = enum {\n    plain, // No colors, basic formatting\n    rich, // Colors and formatting (TTY)\n    json, // Structured JSON output\n    quiet, // Minimal output (IDs only)\n};\n\n/// ANSI color escape codes.\npub const Color = struct {\n    pub const reset = \"\\x1b[0m\";\n    pub const bold = \"\\x1b[1m\";\n    pub const dim = \"\\x1b[2m\";\n    pub const italic = \"\\x1b[3m\";\n    pub const underline = \"\\x1b[4m\";\n\n    pub const red = \"\\x1b[31m\";\n    pub const green = \"\\x1b[32m\";\n    pub const yellow = \"\\x1b[33m\";\n    pub const blue = \"\\x1b[34m\";\n    pub const magenta = \"\\x1b[35m\";\n    pub const cyan = \"\\x1b[36m\";\n    pub const white = \"\\x1b[37m\";\n    pub const gray = \"\\x1b[90m\";\n\n    pub const bright_red = \"\\x1b[91m\";\n    pub const bright_green = \"\\x1b[92m\";\n    pub const bright_yellow = \"\\x1b[93m\";\n    pub const bright_blue = \"\\x1b[94m\";\n    pub const bright_magenta = \"\\x1b[95m\";\n    pub const bright_cyan = \"\\x1b[96m\";\n\n    pub const bg_red = \"\\x1b[41m\";\n    pub const bg_green = \"\\x1b[42m\";\n    pub const bg_yellow = \"\\x1b[43m\";\n    pub const bg_blue = \"\\x1b[44m\";\n};\n\n/// Global options that affect output formatting.\n/// This mirrors the relevant fields from cli.args.GlobalOptions.\npub const OutputOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    no_color: bool = false,\n};\n\n/// Output formatter for consistent CLI output across all modes.\npub const Output = struct {\n    mode: OutputMode,\n    toon: bool,\n    silent: bool, // Suppress ALL output including errors (for tests)\n    stdout: std.fs.File,\n    stderr: std.fs.File,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    /// Initialize output formatter based on global options and TTY detection.\n    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n        const stdout = std.fs.File.stdout();\n        const stderr = std.fs.File.stderr();\n\n        var mode: OutputMode = .plain;\n        if (opts.json or opts.toon) {\n            mode = .json;\n        } else if (opts.quiet or opts.silent) {\n            mode = .quiet;\n        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n            mode = .rich;\n        }\n\n        return .{\n            .mode = mode,\n            .toon = opts.toon,\n            .silent = opts.silent,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize with explicit mode (useful for testing).\n    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize for testing with custom file handles.\n    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize with silent mode (suppresses ALL output including errors).\n    pub fn initSilent(allocator: std.mem.Allocator) Self {\n        return .{\n            .mode = .quiet,\n            .toon = false,\n            .silent = true,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n        };\n    }\n\n    // ========================================================================\n    // Issue Display\n    // ========================================================================\n\n    /// Print a single issue in the appropriate format.\n    pub fn printIssue(self: *Self, issue: Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueJson(issue),\n            .quiet => try self.printIssueQuiet(issue),\n            .rich => try self.printIssueRich(issue),\n            .plain => try self.printIssuePlain(issue),\n        }\n    }\n\n    /// Print a list of issues in the appropriate format.\n    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueListJson(issues),\n            .quiet => try self.printIssueListQuiet(issues),\n            .rich => try self.printIssueListRich(issues),\n            .plain => try self.printIssueListPlain(issues),\n        }\n    }\n\n    // ========================================================================\n    // Generic Messages\n    // ========================================================================\n\n    /// Print a formatted message to stdout.\n    pub fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    /// Print a formatted message to stdout with newline.\n    pub fn println(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        const msg = try std.fmt.allocPrint(self.allocator, fmt ++ \"\\n\", args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    /// Print a success message (green in rich mode).\n    pub fn success(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stdout.writeAll(Color.green);\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    /// Print an error message to stderr (red in rich mode).\n    pub fn err(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.silent) return;\n        if (self.mode == .rich) try self.stderr.writeAll(Color.red);\n        const msg = try std.fmt.allocPrint(self.allocator, \"error: \" ++ fmt, args);\n        defer self.allocator.free(msg);\n        try self.stderr.writeAll(msg);\n        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n        try self.stderr.writeAll(\"\\n\");\n    }\n\n    /// Print a warning message to stderr (yellow in rich mode).\n    pub fn warn(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.silent or self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stderr.writeAll(Color.yellow);\n        const msg = try std.fmt.allocPrint(self.allocator, \"warning: \" ++ fmt, args);\n        defer self.allocator.free(msg);\n        try self.stderr.writeAll(msg);\n        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n        try self.stderr.writeAll(\"\\n\");\n    }\n\n    /// Print an info message (cyan in rich mode).\n    pub fn info(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stdout.writeAll(Color.cyan);\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    /// Print raw bytes to stdout (bypasses mode checks).\n    pub fn raw(self: *Self, bytes: []const u8) !void {\n        try self.stdout.writeAll(bytes);\n    }\n\n    /// Print raw JSON value to stdout (for JSON mode).\n    /// If toon mode is enabled, converts JSON to TOON format for reduced token usage.\n    pub fn printJson(self: *Self, value: anytype) !void {\n        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n        defer self.allocator.free(json_bytes);\n\n        if (self.toon) {\n            const toon = @import(\"toon_zig\");\n            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |convert_err| {\n                try self.stderr.writeAll(\"error: failed to convert to TOON format\\n\");\n                return convert_err;\n            };\n            defer self.allocator.free(toon_bytes);\n            try self.stdout.writeAll(toon_bytes);\n        } else {\n            try self.stdout.writeAll(json_bytes);\n        }\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    // ========================================================================\n    // JSON Mode Helpers\n    // ========================================================================\n\n    fn printIssueJson(self: *Self, issue: Issue) !void {\n        try self.printJson(issue);\n    }\n\n    fn printIssueListJson(self: *Self, issues: []const Issue) !void {\n        try self.printJson(issues);\n    }\n\n    // ========================================================================\n    // Plain Mode Helpers\n    // ========================================================================\n\n    fn printIssuePlain(self: *Self, issue: Issue) !void {\n        try self.writeFormatted(\"ID: {s}\\n\", .{issue.id});\n        try self.writeFormatted(\"Title: {s}\\n\", .{issue.title});\n        try self.writeFormatted(\"Status: {s}\\n\", .{issue.status.toString()});\n        try self.writeFormatted(\"Priority: {s}\\n\", .{issue.priority.toString()});\n        try self.writeFormatted(\"Type: {s}\\n\", .{issue.issue_type.toString()});\n\n        if (issue.description) |desc| {\n            try self.writeFormatted(\"Description: {s}\\n\", .{desc});\n        }\n        if (issue.assignee) |assignee| {\n            try self.writeFormatted(\"Assignee: {s}\\n\", .{assignee});\n        }\n        if (issue.labels.len > 0) {\n            try self.stdout.writeAll(\"Labels: \");\n            for (issue.labels, 0..) |label, i| {\n                if (i > 0) try self.stdout.writeAll(\", \");\n                try self.stdout.writeAll(label);\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n        if (issue.due_at.value) |due| {\n            try self.writeFormatted(\"Due: {d}\\n\", .{due});\n        }\n\n        try self.writeFormatted(\"Created: {d}\\n\", .{issue.created_at.value});\n        try self.writeFormatted(\"Updated: {d}\\n\", .{issue.updated_at.value});\n    }\n\n    fn printIssueListPlain(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            const status_abbrev = abbreviateStatus(issue.status);\n            try self.writeFormatted(\"{s}  [{s}] {s}\\n\", .{\n                issue.id,\n                status_abbrev,\n                issue.title,\n            });\n        }\n    }\n\n    // ========================================================================\n    // Rich Mode Helpers (ANSI colors)\n    // ========================================================================\n\n    fn printIssueRich(self: *Self, issue: Issue) !void {\n        // Bold ID\n        try self.writeFormatted(\"{s}{s}{s}\\n\", .{ Color.bold, issue.id, Color.reset });\n\n        // Title\n        try self.writeFormatted(\"  {s}\\n\", .{issue.title});\n\n        // Status with color\n        const status_color = getStatusColor(issue.status);\n        try self.writeFormatted(\"  Status: {s}{s}{s}\\n\", .{ status_color, issue.status.toString(), Color.reset });\n\n        // Priority with color\n        const priority_color = getPriorityColor(issue.priority);\n        try self.writeFormatted(\"  Priority: {s}{s}{s}\\n\", .{ priority_color, issue.priority.toString(), Color.reset });\n\n        // Type\n        try self.writeFormatted(\"  Type: {s}\\n\", .{issue.issue_type.toString()});\n\n        // Optional fields\n        if (issue.description) |desc| {\n            try self.writeFormatted(\"  Description: {s}{s}{s}\\n\", .{ Color.dim, desc, Color.reset });\n        }\n        if (issue.assignee) |assignee| {\n            try self.writeFormatted(\"  Assignee: {s}{s}{s}\\n\", .{ Color.cyan, assignee, Color.reset });\n        }\n        if (issue.labels.len > 0) {\n            try self.stdout.writeAll(\"  Labels: \");\n            for (issue.labels, 0..) |label, i| {\n                if (i > 0) try self.stdout.writeAll(\", \");\n                try self.writeFormatted(\"{s}{s}{s}\", .{ Color.magenta, label, Color.reset });\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n    }\n\n    fn printIssueListRich(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            const status_color = getStatusColor(issue.status);\n            const priority_color = getPriorityColor(issue.priority);\n            const status_abbrev = abbreviateStatus(issue.status);\n\n            try self.writeFormatted(\"{s}{s}{s}  {s}[{s}]{s}  {s}{s}{s}  {s}\\n\", .{\n                Color.bold,\n                issue.id,\n                Color.reset,\n                status_color,\n                status_abbrev,\n                Color.reset,\n                priority_color,\n                priorityIndicator(issue.priority),\n                Color.reset,\n                issue.title,\n            });\n        }\n    }\n\n    // ========================================================================\n    // Quiet Mode Helpers\n    // ========================================================================\n\n    fn printIssueQuiet(self: *Self, issue: Issue) !void {\n        try self.writeFormatted(\"{s}\\n\", .{issue.id});\n    }\n\n    fn printIssueListQuiet(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            try self.writeFormatted(\"{s}\\n\", .{issue.id});\n        }\n    }\n\n    // ========================================================================\n    // Internal Helpers\n    // ========================================================================\n\n    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n};\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/// Check if NO_COLOR environment variable is set (cross-platform).\nfn checkNoColorEnv() bool {\n    // Per NO_COLOR spec, only existence matters, not the value\n    return std.process.hasEnvVarConstant(\"NO_COLOR\");\n}\n","numLines":400,"startLine":1,"totalLines":703}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVQNanMugQia2R83U2rmto","type":"message","role":"assistant","content":[{"type":"text","text":"Let me continue reading the output module and the storage graph file to understand the parent-child relationship handling."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":12903,"cache_read_input_tokens":67302,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":12903},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2e48681b-1dc7-4c47-ae2c-f34b38b727b9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVQNanMugQia2R83U2rmto","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NpoTCUwTyibLcHi47UirCX","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","offset":400,"limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":12903,"cache_read_input_tokens":67302,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":12903},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2b30e746-b541-49aa-ad7e-6d2dc3b02b5b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NpoTCUwTyibLcHi47UirCX","type":"tool_result","content":"   400→\n   401→/// Get ANSI color for a status.\n   402→fn getStatusColor(status: Status) []const u8 {\n   403→    return switch (status) {\n   404→        .open => Color.green,\n   405→        .in_progress => Color.yellow,\n   406→        .blocked => Color.red,\n   407→        .deferred => Color.gray,\n   408→        .closed => Color.gray,\n   409→        .tombstone => Color.dim,\n   410→        .pinned => Color.bright_cyan,\n   411→        .custom => Color.blue,\n   412→    };\n   413→}\n   414→\n   415→/// Get ANSI color for a priority.\n   416→fn getPriorityColor(priority: Priority) []const u8 {\n   417→    return switch (priority.value) {\n   418→        0 => Color.bright_red, // critical\n   419→        1 => Color.red, // high\n   420→        2 => Color.yellow, // medium\n   421→        3 => Color.green, // low\n   422→        4 => Color.gray, // backlog\n   423→        else => Color.reset,\n   424→    };\n   425→}\n   426→\n   427→/// Get short status abbreviation.\n   428→fn abbreviateStatus(status: Status) []const u8 {\n   429→    return switch (status) {\n   430→        .open => \"OPEN\",\n   431→        .in_progress => \"PROG\",\n   432→        .blocked => \"BLKD\",\n   433→        .deferred => \"DEFR\",\n   434→        .closed => \"DONE\",\n   435→        .tombstone => \"DEL \",\n   436→        .pinned => \"PIN \",\n   437→        .custom => \"CUST\",\n   438→    };\n   439→}\n   440→\n   441→/// Get priority indicator symbol.\n   442→fn priorityIndicator(priority: Priority) []const u8 {\n   443→    return switch (priority.value) {\n   444→        0 => \"!!!\",\n   445→        1 => \"!! \",\n   446→        2 => \"!  \",\n   447→        3 => \".  \",\n   448→        4 => \"   \",\n   449→        else => \"   \",\n   450→    };\n   451→}\n   452→\n   453→// ============================================================================\n   454→// Tests\n   455→// ============================================================================\n   456→\n   457→test \"OutputMode enum values\" {\n   458→    try std.testing.expectEqual(OutputMode.plain, OutputMode.plain);\n   459→    try std.testing.expectEqual(OutputMode.rich, OutputMode.rich);\n   460→    try std.testing.expectEqual(OutputMode.json, OutputMode.json);\n   461→    try std.testing.expectEqual(OutputMode.quiet, OutputMode.quiet);\n   462→}\n   463→\n   464→test \"Output.init with json option\" {\n   465→    const allocator = std.testing.allocator;\n   466→    const opts = OutputOptions{ .json = true };\n   467→    const output = Output.init(allocator, opts);\n   468→    try std.testing.expectEqual(OutputMode.json, output.mode);\n   469→    try std.testing.expect(!output.toon);\n   470→}\n   471→\n   472→test \"Output.init with toon option\" {\n   473→    const allocator = std.testing.allocator;\n   474→    const opts = OutputOptions{ .toon = true };\n   475→    const output = Output.init(allocator, opts);\n   476→    try std.testing.expectEqual(OutputMode.json, output.mode);\n   477→    try std.testing.expect(output.toon);\n   478→}\n   479→\n   480→test \"Output.init with quiet option\" {\n   481→    const allocator = std.testing.allocator;\n   482→    const opts = OutputOptions{ .quiet = true };\n   483→    const output = Output.init(allocator, opts);\n   484→    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n   485→}\n   486→\n   487→test \"Output.init with no_color option forces plain mode\" {\n   488→    const allocator = std.testing.allocator;\n   489→    const opts = OutputOptions{ .no_color = true };\n   490→    const output = Output.init(allocator, opts);\n   491→    try std.testing.expectEqual(OutputMode.plain, output.mode);\n   492→}\n   493→\n   494→test \"Output.init json overrides quiet\" {\n   495→    const allocator = std.testing.allocator;\n   496→    const opts = OutputOptions{ .json = true, .quiet = true };\n   497→    const output = Output.init(allocator, opts);\n   498→    try std.testing.expectEqual(OutputMode.json, output.mode);\n   499→}\n   500→\n   501→test \"Output.initWithMode sets explicit mode\" {\n   502→    const allocator = std.testing.allocator;\n   503→    const output = Output.initWithMode(allocator, .rich);\n   504→    try std.testing.expectEqual(OutputMode.rich, output.mode);\n   505→}\n   506→\n   507→test \"abbreviateStatus returns 4-char strings\" {\n   508→    const statuses = [_]Status{\n   509→        .open,\n   510→        .in_progress,\n   511→        .blocked,\n   512→        .deferred,\n   513→        .closed,\n   514→        .tombstone,\n   515→        .pinned,\n   516→        .{ .custom = \"test\" },\n   517→    };\n   518→    for (statuses) |status| {\n   519→        const abbrev = abbreviateStatus(status);\n   520→        try std.testing.expectEqual(@as(usize, 4), abbrev.len);\n   521→    }\n   522→}\n   523→\n   524→test \"priorityIndicator returns 3-char strings\" {\n   525→    var p: u3 = 0;\n   526→    while (p <= 4) : (p += 1) {\n   527→        const priority = Priority{ .value = p };\n   528→        const indicator = priorityIndicator(priority);\n   529→        try std.testing.expectEqual(@as(usize, 3), indicator.len);\n   530→    }\n   531→}\n   532→\n   533→test \"getStatusColor returns valid ANSI codes\" {\n   534→    const statuses = [_]Status{\n   535→        .open,\n   536→        .in_progress,\n   537→        .blocked,\n   538→        .deferred,\n   539→        .closed,\n   540→        .tombstone,\n   541→        .pinned,\n   542→        .{ .custom = \"test\" },\n   543→    };\n   544→    for (statuses) |status| {\n   545→        const color = getStatusColor(status);\n   546→        try std.testing.expect(color.len > 0);\n   547→        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n   548→    }\n   549→}\n   550→\n   551→test \"getPriorityColor returns valid ANSI codes\" {\n   552→    var p: u3 = 0;\n   553→    while (p <= 4) : (p += 1) {\n   554→        const priority = Priority{ .value = p };\n   555→        const color = getPriorityColor(priority);\n   556→        try std.testing.expect(color.len > 0);\n   557→        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n   558→    }\n   559→}\n   560→\n   561→test \"Color constants are valid ANSI escape sequences\" {\n   562→    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n   563→    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n   564→    try std.testing.expect(std.mem.startsWith(u8, Color.red, \"\\x1b[\"));\n   565→    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n   566→    try std.testing.expect(std.mem.startsWith(u8, Color.yellow, \"\\x1b[\"));\n   567→    try std.testing.expect(std.mem.startsWith(u8, Color.blue, \"\\x1b[\"));\n   568→    try std.testing.expect(std.mem.startsWith(u8, Color.gray, \"\\x1b[\"));\n   569→}\n   570→\n   571→test \"Output printIssueListQuiet writes IDs only\" {\n   572→    // Test the quiet formatting logic directly\n   573→    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n   574→    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n   575→    const issues = [_]Issue{ issue1, issue2 };\n   576→\n   577→    // In quiet mode, printIssueListQuiet outputs \"{id}\\n\" for each issue\n   578→    // Verify the expected output format\n   579→    try std.testing.expectEqualStrings(\"bd-abc123\", issue1.id);\n   580→    try std.testing.expectEqualStrings(\"bd-def456\", issue2.id);\n   581→    try std.testing.expectEqual(@as(usize, 2), issues.len);\n   582→}\n   583→\n   584→test \"Output printIssueListPlain writes formatted lines\" {\n   585→    // Test the plain formatting logic via abbreviateStatus and Issue fields\n   586→    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n   587→\n   588→    // Verify issue fields are correct\n   589→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   590→    try std.testing.expectEqualStrings(\"Test issue\", issue.title);\n   591→    try std.testing.expectEqual(Status.open, issue.status);\n   592→\n   593→    // Verify status abbreviation\n   594→    const status_abbrev = abbreviateStatus(issue.status);\n   595→    try std.testing.expectEqualStrings(\"OPEN\", status_abbrev);\n   596→}\n   597→\n   598→test \"Output printIssueListRich includes ANSI codes\" {\n   599→    // Test that rich mode formatting uses ANSI codes\n   600→    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n   601→\n   602→    // Verify issue fields\n   603→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   604→\n   605→    // Verify rich mode uses color codes\n   606→    const status_color = getStatusColor(issue.status);\n   607→    try std.testing.expect(std.mem.startsWith(u8, status_color, \"\\x1b[\"));\n   608→\n   609→    const priority_color = getPriorityColor(issue.priority);\n   610→    try std.testing.expect(std.mem.startsWith(u8, priority_color, \"\\x1b[\"));\n   611→\n   612→    // Verify Color.bold is used\n   613→    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n   614→}\n   615→\n   616→test \"Output printIssueListJson produces valid JSON array\" {\n   617→    const allocator = std.testing.allocator;\n   618→\n   619→    // Test JSON serialization directly\n   620→    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n   621→    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n   622→    const issues = [_]Issue{ issue1, issue2 };\n   623→\n   624→    // Serialize to JSON\n   625→    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n   626→    defer allocator.free(json_bytes);\n   627→\n   628→    // Verify it starts with [ and contains expected data\n   629→    try std.testing.expect(std.mem.startsWith(u8, json_bytes, \"[\"));\n   630→    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-abc123\") != null);\n   631→    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-def456\") != null);\n   632→\n   633→    // Verify it can be parsed back\n   634→    const parsed = try std.json.parseFromSlice([]const Issue, allocator, json_bytes, .{});\n   635→    defer parsed.deinit();\n   636→    try std.testing.expectEqual(@as(usize, 2), parsed.value.len);\n   637→}\n   638→\n   639→test \"Output.err formats error messages correctly\" {\n   640→    const allocator = std.testing.allocator;\n   641→\n   642→    // Test the error message formatting\n   643→    const msg = try std.fmt.allocPrint(allocator, \"error: \" ++ \"something went wrong: {s}\", .{\"test error\"});\n   644→    defer allocator.free(msg);\n   645→\n   646→    try std.testing.expect(std.mem.indexOf(u8, msg, \"error:\") != null);\n   647→    try std.testing.expect(std.mem.indexOf(u8, msg, \"test error\") != null);\n   648→}\n   649→\n   650→test \"Output.warn formats warning messages correctly\" {\n   651→    const allocator = std.testing.allocator;\n   652→\n   653→    // Test the warning message formatting\n   654→    const msg = try std.fmt.allocPrint(allocator, \"warning: \" ++ \"this is a warning: {s}\", .{\"be careful\"});\n   655→    defer allocator.free(msg);\n   656→\n   657→    try std.testing.expect(std.mem.indexOf(u8, msg, \"warning:\") != null);\n   658→    try std.testing.expect(std.mem.indexOf(u8, msg, \"be careful\") != null);\n   659→}\n   660→\n   661→test \"Output quiet mode suppresses print but not err\" {\n   662→    const allocator = std.testing.allocator;\n   663→\n   664→    // Test quiet mode behavior through Output struct logic\n   665→    const output = Output.initWithMode(allocator, .quiet);\n   666→\n   667→    // Verify quiet mode is set\n   668→    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n   669→\n   670→    // The print/println/success/warn methods check mode == .quiet and return early\n   671→    // The err method does NOT check for quiet mode (always prints)\n   672→    // This is the documented behavior we're testing\n   673→}\n   674→\n   675→test \"Output.success uses green color in rich mode\" {\n   676→    const allocator = std.testing.allocator;\n   677→\n   678→    // Test that success would use green color in rich mode\n   679→    const output = Output.initWithMode(allocator, .rich);\n   680→    try std.testing.expectEqual(OutputMode.rich, output.mode);\n   681→\n   682→    // Verify Color.green is a valid ANSI escape\n   683→    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n   684→    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n   685→}\n   686→\n   687→test \"Output.printIssue in plain mode shows all fields\" {\n   688→    // Test issue field access and formatting\n   689→    var issue = Issue.init(\"bd-abc123\", \"Test issue title\", 1706540000);\n   690→    issue.description = \"A test description\";\n   691→    issue.assignee = \"alice@example.com\";\n   692→\n   693→    // Verify all fields that would be printed\n   694→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   695→    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n   696→    try std.testing.expectEqual(Status.open, issue.status);\n   697→    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n   698→    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n   699→    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"153ee355-ad42-4b43-bb3f-bae81721bc73","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/output/mod.zig","content":"\n/// Get ANSI color for a status.\nfn getStatusColor(status: Status) []const u8 {\n    return switch (status) {\n        .open => Color.green,\n        .in_progress => Color.yellow,\n        .blocked => Color.red,\n        .deferred => Color.gray,\n        .closed => Color.gray,\n        .tombstone => Color.dim,\n        .pinned => Color.bright_cyan,\n        .custom => Color.blue,\n    };\n}\n\n/// Get ANSI color for a priority.\nfn getPriorityColor(priority: Priority) []const u8 {\n    return switch (priority.value) {\n        0 => Color.bright_red, // critical\n        1 => Color.red, // high\n        2 => Color.yellow, // medium\n        3 => Color.green, // low\n        4 => Color.gray, // backlog\n        else => Color.reset,\n    };\n}\n\n/// Get short status abbreviation.\nfn abbreviateStatus(status: Status) []const u8 {\n    return switch (status) {\n        .open => \"OPEN\",\n        .in_progress => \"PROG\",\n        .blocked => \"BLKD\",\n        .deferred => \"DEFR\",\n        .closed => \"DONE\",\n        .tombstone => \"DEL \",\n        .pinned => \"PIN \",\n        .custom => \"CUST\",\n    };\n}\n\n/// Get priority indicator symbol.\nfn priorityIndicator(priority: Priority) []const u8 {\n    return switch (priority.value) {\n        0 => \"!!!\",\n        1 => \"!! \",\n        2 => \"!  \",\n        3 => \".  \",\n        4 => \"   \",\n        else => \"   \",\n    };\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\ntest \"OutputMode enum values\" {\n    try std.testing.expectEqual(OutputMode.plain, OutputMode.plain);\n    try std.testing.expectEqual(OutputMode.rich, OutputMode.rich);\n    try std.testing.expectEqual(OutputMode.json, OutputMode.json);\n    try std.testing.expectEqual(OutputMode.quiet, OutputMode.quiet);\n}\n\ntest \"Output.init with json option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .json = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n    try std.testing.expect(!output.toon);\n}\n\ntest \"Output.init with toon option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .toon = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n    try std.testing.expect(output.toon);\n}\n\ntest \"Output.init with quiet option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .quiet = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n}\n\ntest \"Output.init with no_color option forces plain mode\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .no_color = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.plain, output.mode);\n}\n\ntest \"Output.init json overrides quiet\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .json = true, .quiet = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n}\n\ntest \"Output.initWithMode sets explicit mode\" {\n    const allocator = std.testing.allocator;\n    const output = Output.initWithMode(allocator, .rich);\n    try std.testing.expectEqual(OutputMode.rich, output.mode);\n}\n\ntest \"abbreviateStatus returns 4-char strings\" {\n    const statuses = [_]Status{\n        .open,\n        .in_progress,\n        .blocked,\n        .deferred,\n        .closed,\n        .tombstone,\n        .pinned,\n        .{ .custom = \"test\" },\n    };\n    for (statuses) |status| {\n        const abbrev = abbreviateStatus(status);\n        try std.testing.expectEqual(@as(usize, 4), abbrev.len);\n    }\n}\n\ntest \"priorityIndicator returns 3-char strings\" {\n    var p: u3 = 0;\n    while (p <= 4) : (p += 1) {\n        const priority = Priority{ .value = p };\n        const indicator = priorityIndicator(priority);\n        try std.testing.expectEqual(@as(usize, 3), indicator.len);\n    }\n}\n\ntest \"getStatusColor returns valid ANSI codes\" {\n    const statuses = [_]Status{\n        .open,\n        .in_progress,\n        .blocked,\n        .deferred,\n        .closed,\n        .tombstone,\n        .pinned,\n        .{ .custom = \"test\" },\n    };\n    for (statuses) |status| {\n        const color = getStatusColor(status);\n        try std.testing.expect(color.len > 0);\n        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n    }\n}\n\ntest \"getPriorityColor returns valid ANSI codes\" {\n    var p: u3 = 0;\n    while (p <= 4) : (p += 1) {\n        const priority = Priority{ .value = p };\n        const color = getPriorityColor(priority);\n        try std.testing.expect(color.len > 0);\n        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n    }\n}\n\ntest \"Color constants are valid ANSI escape sequences\" {\n    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.red, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.yellow, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.blue, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.gray, \"\\x1b[\"));\n}\n\ntest \"Output printIssueListQuiet writes IDs only\" {\n    // Test the quiet formatting logic directly\n    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n    const issues = [_]Issue{ issue1, issue2 };\n\n    // In quiet mode, printIssueListQuiet outputs \"{id}\\n\" for each issue\n    // Verify the expected output format\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue1.id);\n    try std.testing.expectEqualStrings(\"bd-def456\", issue2.id);\n    try std.testing.expectEqual(@as(usize, 2), issues.len);\n}\n\ntest \"Output printIssueListPlain writes formatted lines\" {\n    // Test the plain formatting logic via abbreviateStatus and Issue fields\n    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n\n    // Verify issue fields are correct\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n\n    // Verify status abbreviation\n    const status_abbrev = abbreviateStatus(issue.status);\n    try std.testing.expectEqualStrings(\"OPEN\", status_abbrev);\n}\n\ntest \"Output printIssueListRich includes ANSI codes\" {\n    // Test that rich mode formatting uses ANSI codes\n    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n\n    // Verify issue fields\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n\n    // Verify rich mode uses color codes\n    const status_color = getStatusColor(issue.status);\n    try std.testing.expect(std.mem.startsWith(u8, status_color, \"\\x1b[\"));\n\n    const priority_color = getPriorityColor(issue.priority);\n    try std.testing.expect(std.mem.startsWith(u8, priority_color, \"\\x1b[\"));\n\n    // Verify Color.bold is used\n    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n}\n\ntest \"Output printIssueListJson produces valid JSON array\" {\n    const allocator = std.testing.allocator;\n\n    // Test JSON serialization directly\n    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n    const issues = [_]Issue{ issue1, issue2 };\n\n    // Serialize to JSON\n    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n    defer allocator.free(json_bytes);\n\n    // Verify it starts with [ and contains expected data\n    try std.testing.expect(std.mem.startsWith(u8, json_bytes, \"[\"));\n    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-abc123\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-def456\") != null);\n\n    // Verify it can be parsed back\n    const parsed = try std.json.parseFromSlice([]const Issue, allocator, json_bytes, .{});\n    defer parsed.deinit();\n    try std.testing.expectEqual(@as(usize, 2), parsed.value.len);\n}\n\ntest \"Output.err formats error messages correctly\" {\n    const allocator = std.testing.allocator;\n\n    // Test the error message formatting\n    const msg = try std.fmt.allocPrint(allocator, \"error: \" ++ \"something went wrong: {s}\", .{\"test error\"});\n    defer allocator.free(msg);\n\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"error:\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"test error\") != null);\n}\n\ntest \"Output.warn formats warning messages correctly\" {\n    const allocator = std.testing.allocator;\n\n    // Test the warning message formatting\n    const msg = try std.fmt.allocPrint(allocator, \"warning: \" ++ \"this is a warning: {s}\", .{\"be careful\"});\n    defer allocator.free(msg);\n\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"warning:\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"be careful\") != null);\n}\n\ntest \"Output quiet mode suppresses print but not err\" {\n    const allocator = std.testing.allocator;\n\n    // Test quiet mode behavior through Output struct logic\n    const output = Output.initWithMode(allocator, .quiet);\n\n    // Verify quiet mode is set\n    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n\n    // The print/println/success/warn methods check mode == .quiet and return early\n    // The err method does NOT check for quiet mode (always prints)\n    // This is the documented behavior we're testing\n}\n\ntest \"Output.success uses green color in rich mode\" {\n    const allocator = std.testing.allocator;\n\n    // Test that success would use green color in rich mode\n    const output = Output.initWithMode(allocator, .rich);\n    try std.testing.expectEqual(OutputMode.rich, output.mode);\n\n    // Verify Color.green is a valid ANSI escape\n    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n}\n\ntest \"Output.printIssue in plain mode shows all fields\" {\n    // Test issue field access and formatting\n    var issue = Issue.init(\"bd-abc123\", \"Test issue title\", 1706540000);\n    issue.description = \"A test description\";\n    issue.assignee = \"alice@example.com\";\n\n    // Verify all fields that would be printed\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());","numLines":300,"startLine":400,"totalLines":703}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVQNanMugQia2R83U2rmto","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BpFRPfxfXtUqsNCoYDC2js","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":12903,"cache_read_input_tokens":67302,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":12903},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8e08b086-7667-46ac-8ed0-698c98b6a74e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BpFRPfxfXtUqsNCoYDC2js","type":"tool_result","content":"     1→//! Dependency graph operations for beads_zig.\n     2→//!\n     3→//! Provides dependency management including:\n     4→//! - Add/remove dependencies\n     5→//! - Cycle detection (DFS algorithm)\n     6→//! - Query dependencies and dependents\n     7→//! - Ready/blocked issue queries\n     8→\n     9→const std = @import(\"std\");\n    10→const store_mod = @import(\"store.zig\");\n    11→const IssueStore = store_mod.IssueStore;\n    12→const Issue = @import(\"../models/issue.zig\").Issue;\n    13→const Dependency = @import(\"../models/dependency.zig\").Dependency;\n    14→const DependencyType = @import(\"../models/dependency.zig\").DependencyType;\n    15→const Status = @import(\"../models/status.zig\").Status;\n    16→\n    17→pub const DependencyGraphError = error{\n    18→    SelfDependency,\n    19→    CycleDetected,\n    20→    DependencyNotFound,\n    21→    IssueNotFound,\n    22→};\n    23→\n    24→pub const DependencyGraph = struct {\n    25→    store: *IssueStore,\n    26→    allocator: std.mem.Allocator,\n    27→\n    28→    const Self = @This();\n    29→\n    30→    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n    31→        return .{\n    32→            .store = store,\n    33→            .allocator = allocator,\n    34→        };\n    35→    }\n    36→\n    37→    /// Add a dependency (issue_id depends on depends_on_id).\n    38→    /// Returns error.SelfDependency if trying to depend on self.\n    39→    /// Returns error.CycleDetected if adding would create a cycle.\n    40→    pub fn addDependency(self: *Self, dep: Dependency) !void {\n    41→        // Check for self-dependency\n    42→        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n    43→            return DependencyGraphError.SelfDependency;\n    44→        }\n    45→\n    46→        // Check if issue exists\n    47→        const issue = self.store.getRef(dep.issue_id) orelse\n    48→            return DependencyGraphError.IssueNotFound;\n    49→\n    50→        // Check for cycles before inserting\n    51→        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n    52→            return DependencyGraphError.CycleDetected;\n    53→        }\n    54→\n    55→        // Check if dependency already exists\n    56→        for (issue.dependencies) |existing| {\n    57→            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n    58→                return; // Already exists, no-op\n    59→            }\n    60→        }\n    61→\n    62→        // Clone and add the dependency\n    63→        const cloned = try cloneDependency(dep, self.allocator);\n    64→        errdefer freeDependency(@constCast(&cloned), self.allocator);\n    65→\n    66→        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n    67→        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n    68→        new_deps[issue.dependencies.len] = cloned;\n    69→\n    70→        // Only free the old array, not the dependency contents (they're now in new_deps)\n    71→        if (issue.dependencies.len > 0) {\n    72→            self.allocator.free(issue.dependencies);\n    73→        }\n    74→        issue.dependencies = new_deps;\n    75→\n    76→        try self.store.markDirty(dep.issue_id);\n    77→    }\n    78→\n    79→    /// Remove a dependency.\n    80→    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n    81→        const issue = self.store.getRef(issue_id) orelse\n    82→            return DependencyGraphError.IssueNotFound;\n    83→\n    84→        var found_idx: ?usize = null;\n    85→        for (issue.dependencies, 0..) |dep, i| {\n    86→            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n    87→                found_idx = i;\n    88→                break;\n    89→            }\n    90→        }\n    91→\n    92→        if (found_idx) |fi| {\n    93→            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n    94→\n    95→            if (issue.dependencies.len == 1) {\n    96→                self.allocator.free(issue.dependencies);\n    97→                issue.dependencies = &[_]Dependency{};\n    98→            } else {\n    99→                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n   100→                var j: usize = 0;\n   101→                for (issue.dependencies, 0..) |dep, i| {\n   102→                    if (i != fi) {\n   103→                        new_deps[j] = dep;\n   104→                        j += 1;\n   105→                    }\n   106→                }\n   107→                self.allocator.free(issue.dependencies);\n   108→                issue.dependencies = new_deps;\n   109→            }\n   110→\n   111→            try self.store.markDirty(issue_id);\n   112→        }\n   113→    }\n   114→\n   115→    /// Get dependencies for an issue (what it depends on).\n   116→    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n   117→        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n   118→\n   119→        if (issue.dependencies.len == 0) return &[_]Dependency{};\n   120→\n   121→        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n   122→        errdefer self.allocator.free(deps);\n   123→\n   124→        for (issue.dependencies, 0..) |dep, i| {\n   125→            deps[i] = try cloneDependency(dep, self.allocator);\n   126→        }\n   127→\n   128→        return deps;\n   129→    }\n   130→\n   131→    /// Get dependents of an issue (what depends on it).\n   132→    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n   133→        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n   134→        errdefer {\n   135→            for (deps.items) |*dep| {\n   136→                freeDependency(dep, self.allocator);\n   137→            }\n   138→            deps.deinit(self.allocator);\n   139→        }\n   140→\n   141→        for (self.store.getAllRef()) |issue| {\n   142→            for (issue.dependencies) |dep| {\n   143→                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n   144→                    const cloned = try cloneDependency(dep, self.allocator);\n   145→                    try deps.append(self.allocator, cloned);\n   146→                }\n   147→            }\n   148→        }\n   149→\n   150→        return deps.toOwnedSlice(self.allocator);\n   151→    }\n   152→\n   153→    /// Check if adding a dependency would create a cycle.\n   154→    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n   155→    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n   156→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   157→        defer {\n   158→            var key_it = visited.keyIterator();\n   159→            while (key_it.next()) |key| {\n   160→                self.allocator.free(key.*);\n   161→            }\n   162→            visited.deinit(self.allocator);\n   163→        }\n   164→\n   165→        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n   166→    }\n   167→\n   168→    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n   169→        if (std.mem.eql(u8, from, target)) return true;\n   170→        if (visited.contains(from)) return false;\n   171→\n   172→        const from_copy = try self.allocator.dupe(u8, from);\n   173→        errdefer self.allocator.free(from_copy);\n   174→        try visited.put(self.allocator, from_copy, {});\n   175→\n   176→        const issue = self.store.getRef(from) orelse return false;\n   177→\n   178→        for (issue.dependencies) |dep| {\n   179→            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n   180→                return true;\n   181→            }\n   182→        }\n   183→        return false;\n   184→    }\n   185→\n   186→    /// Detect all cycles in the dependency graph.\n   187→    /// Returns array of cycle paths, or null if no cycles.\n   188→    pub fn detectCycles(self: *Self) !?[][]const u8 {\n   189→        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n   190→        defer {\n   191→            var it = all_issues.keyIterator();\n   192→            while (it.next()) |key| {\n   193→                self.allocator.free(key.*);\n   194→            }\n   195→            all_issues.deinit(self.allocator);\n   196→        }\n   197→\n   198→        // Collect all issue IDs involved in dependencies\n   199→        for (self.store.getAllRef()) |issue| {\n   200→            if (issue.dependencies.len > 0) {\n   201→                if (!all_issues.contains(issue.id)) {\n   202→                    const id_copy = try self.allocator.dupe(u8, issue.id);\n   203→                    try all_issues.put(self.allocator, id_copy, {});\n   204→                }\n   205→                for (issue.dependencies) |dep| {\n   206→                    if (!all_issues.contains(dep.depends_on_id)) {\n   207→                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n   208→                        try all_issues.put(self.allocator, id_copy, {});\n   209→                    }\n   210→                }\n   211→            }\n   212→        }\n   213→\n   214→        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n   215→        errdefer {\n   216→            for (cycles.items) |c| {\n   217→                self.allocator.free(c);\n   218→            }\n   219→            cycles.deinit(self.allocator);\n   220→        }\n   221→\n   222→        var visited: std.StringHashMapUnmanaged(void) = .{};\n   223→        defer visited.deinit(self.allocator);\n   224→\n   225→        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n   226→        defer rec_stack.deinit(self.allocator);\n   227→\n   228→        var it = all_issues.keyIterator();\n   229→        while (it.next()) |key| {\n   230→            if (!visited.contains(key.*)) {\n   231→                var path: std.ArrayListUnmanaged([]const u8) = .{};\n   232→                defer path.deinit(self.allocator);\n   233→\n   234→                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n   235→                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n   236→                    try cycles.append(self.allocator, cycle_str);\n   237→                }\n   238→            }\n   239→        }\n   240→\n   241→        if (cycles.items.len == 0) {\n   242→            return null;\n   243→        }\n   244→\n   245→        return try cycles.toOwnedSlice(self.allocator);\n   246→    }\n   247→\n   248→    fn detectCycleDfs(\n   249→        self: *Self,\n   250→        node: []const u8,\n   251→        visited: *std.StringHashMapUnmanaged(void),\n   252→        rec_stack: *std.StringHashMapUnmanaged(void),\n   253→        path: *std.ArrayListUnmanaged([]const u8),\n   254→    ) !bool {\n   255→        try visited.put(self.allocator, node, {});\n   256→        try rec_stack.put(self.allocator, node, {});\n   257→        try path.append(self.allocator, node);\n   258→\n   259→        const issue = self.store.getRef(node) orelse {\n   260→            _ = path.pop();\n   261→            _ = rec_stack.remove(node);\n   262→            return false;\n   263→        };\n   264→\n   265→        for (issue.dependencies) |dep| {\n   266→            if (!visited.contains(dep.depends_on_id)) {\n   267→                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n   268→                    return true;\n   269→                }\n   270→            } else if (rec_stack.contains(dep.depends_on_id)) {\n   271→                try path.append(self.allocator, dep.depends_on_id);\n   272→                return true;\n   273→            }\n   274→        }\n   275→\n   276→        _ = rec_stack.remove(node);\n   277→        _ = path.pop();\n   278→        return false;\n   279→    }\n   280→\n   281→    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n   282→    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n   283→        const now = std.time.timestamp();\n   284→\n   285→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   286→        errdefer {\n   287→            for (results.items) |*issue| {\n   288→                issue.deinit(self.allocator);\n   289→            }\n   290→            results.deinit(self.allocator);\n   291→        }\n   292→\n   293→        for (self.store.getAllRef()) |issue| {\n   294→            // Must be open (or deferred if include_deferred is set)\n   295→            if (statusEql(issue.status, .deferred)) {\n   296→                if (!include_deferred) continue;\n   297→            } else if (!statusEql(issue.status, .open)) {\n   298→                continue;\n   299→            }\n   300→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"442d4dcc-0576-4665-b3a8-888fb1129132","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","content":"//! Dependency graph operations for beads_zig.\n//!\n//! Provides dependency management including:\n//! - Add/remove dependencies\n//! - Cycle detection (DFS algorithm)\n//! - Query dependencies and dependents\n//! - Ready/blocked issue queries\n\nconst std = @import(\"std\");\nconst store_mod = @import(\"store.zig\");\nconst IssueStore = store_mod.IssueStore;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Status = @import(\"../models/status.zig\").Status;\n\npub const DependencyGraphError = error{\n    SelfDependency,\n    CycleDetected,\n    DependencyNotFound,\n    IssueNotFound,\n};\n\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n        return .{\n            .store = store,\n            .allocator = allocator,\n        };\n    }\n\n    /// Add a dependency (issue_id depends on depends_on_id).\n    /// Returns error.SelfDependency if trying to depend on self.\n    /// Returns error.CycleDetected if adding would create a cycle.\n    pub fn addDependency(self: *Self, dep: Dependency) !void {\n        // Check for self-dependency\n        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.SelfDependency;\n        }\n\n        // Check if issue exists\n        const issue = self.store.getRef(dep.issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        // Check for cycles before inserting\n        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.CycleDetected;\n        }\n\n        // Check if dependency already exists\n        for (issue.dependencies) |existing| {\n            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n                return; // Already exists, no-op\n            }\n        }\n\n        // Clone and add the dependency\n        const cloned = try cloneDependency(dep, self.allocator);\n        errdefer freeDependency(@constCast(&cloned), self.allocator);\n\n        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n        new_deps[issue.dependencies.len] = cloned;\n\n        // Only free the old array, not the dependency contents (they're now in new_deps)\n        if (issue.dependencies.len > 0) {\n            self.allocator.free(issue.dependencies);\n        }\n        issue.dependencies = new_deps;\n\n        try self.store.markDirty(dep.issue_id);\n    }\n\n    /// Remove a dependency.\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n        const issue = self.store.getRef(issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        var found_idx: ?usize = null;\n        for (issue.dependencies, 0..) |dep, i| {\n            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n\n            if (issue.dependencies.len == 1) {\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = &[_]Dependency{};\n            } else {\n                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n                var j: usize = 0;\n                for (issue.dependencies, 0..) |dep, i| {\n                    if (i != fi) {\n                        new_deps[j] = dep;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = new_deps;\n            }\n\n            try self.store.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue (what it depends on).\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n\n        return deps;\n    }\n\n    /// Get dependents of an issue (what depends on it).\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n        errdefer {\n            for (deps.items) |*dep| {\n                freeDependency(dep, self.allocator);\n            }\n            deps.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n                    const cloned = try cloneDependency(dep, self.allocator);\n                    try deps.append(self.allocator, cloned);\n                }\n            }\n        }\n\n        return deps.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if adding a dependency would create a cycle.\n    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var key_it = visited.keyIterator();\n            while (key_it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            visited.deinit(self.allocator);\n        }\n\n        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n    }\n\n    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n        if (std.mem.eql(u8, from, target)) return true;\n        if (visited.contains(from)) return false;\n\n        const from_copy = try self.allocator.dupe(u8, from);\n        errdefer self.allocator.free(from_copy);\n        try visited.put(self.allocator, from_copy, {});\n\n        const issue = self.store.getRef(from) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// Detect all cycles in the dependency graph.\n    /// Returns array of cycle paths, or null if no cycles.\n    pub fn detectCycles(self: *Self) !?[][]const u8 {\n        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var it = all_issues.keyIterator();\n            while (it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            all_issues.deinit(self.allocator);\n        }\n\n        // Collect all issue IDs involved in dependencies\n        for (self.store.getAllRef()) |issue| {\n            if (issue.dependencies.len > 0) {\n                if (!all_issues.contains(issue.id)) {\n                    const id_copy = try self.allocator.dupe(u8, issue.id);\n                    try all_issues.put(self.allocator, id_copy, {});\n                }\n                for (issue.dependencies) |dep| {\n                    if (!all_issues.contains(dep.depends_on_id)) {\n                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n                        try all_issues.put(self.allocator, id_copy, {});\n                    }\n                }\n            }\n        }\n\n        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (cycles.items) |c| {\n                self.allocator.free(c);\n            }\n            cycles.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n        defer rec_stack.deinit(self.allocator);\n\n        var it = all_issues.keyIterator();\n        while (it.next()) |key| {\n            if (!visited.contains(key.*)) {\n                var path: std.ArrayListUnmanaged([]const u8) = .{};\n                defer path.deinit(self.allocator);\n\n                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n                    try cycles.append(self.allocator, cycle_str);\n                }\n            }\n        }\n\n        if (cycles.items.len == 0) {\n            return null;\n        }\n\n        return try cycles.toOwnedSlice(self.allocator);\n    }\n\n    fn detectCycleDfs(\n        self: *Self,\n        node: []const u8,\n        visited: *std.StringHashMapUnmanaged(void),\n        rec_stack: *std.StringHashMapUnmanaged(void),\n        path: *std.ArrayListUnmanaged([]const u8),\n    ) !bool {\n        try visited.put(self.allocator, node, {});\n        try rec_stack.put(self.allocator, node, {});\n        try path.append(self.allocator, node);\n\n        const issue = self.store.getRef(node) orelse {\n            _ = path.pop();\n            _ = rec_stack.remove(node);\n            return false;\n        };\n\n        for (issue.dependencies) |dep| {\n            if (!visited.contains(dep.depends_on_id)) {\n                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n                    return true;\n                }\n            } else if (rec_stack.contains(dep.depends_on_id)) {\n                try path.append(self.allocator, dep.depends_on_id);\n                return true;\n            }\n        }\n\n        _ = rec_stack.remove(node);\n        _ = path.pop();\n        return false;\n    }\n\n    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open (or deferred if include_deferred is set)\n            if (statusEql(issue.status, .deferred)) {\n                if (!include_deferred) continue;\n            } else if (!statusEql(issue.status, .open)) {\n                continue;\n            }\n","numLines":300,"startLine":1,"totalLines":665}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RY2knd8tovYWH1JgE4ebJM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PrR2KLYETadYLfWvmzwCSp","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","offset":300,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":9101,"cache_read_input_tokens":80205,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9101},"output_tokens":18,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b976da2a-d362-4819-9eb2-db5d9a620249"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PrR2KLYETadYLfWvmzwCSp","type":"tool_result","content":"   300→\n   301→            // Must not be deferred to future (unless including deferred)\n   302→            if (!include_deferred) {\n   303→                if (issue.defer_until.value) |defer_time| {\n   304→                    if (defer_time > now) continue;\n   305→                }\n   306→            }\n   307→\n   308→            // Must not have any open blockers\n   309→            var has_open_blocker = false;\n   310→            for (issue.dependencies) |dep| {\n   311→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   312→                    if (!statusEql(blocker.status, .closed) and\n   313→                        !statusEql(blocker.status, .tombstone))\n   314→                    {\n   315→                        has_open_blocker = true;\n   316→                        break;\n   317→                    }\n   318→                }\n   319→            }\n   320→            if (has_open_blocker) continue;\n   321→\n   322→            try results.append(self.allocator, try issue.clone(self.allocator));\n   323→        }\n   324→\n   325→        // Sort by priority then created_at\n   326→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   327→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   328→                if (a.priority.value != b.priority.value) {\n   329→                    return a.priority.value < b.priority.value;\n   330→                }\n   331→                return a.created_at.value < b.created_at.value;\n   332→            }\n   333→        }.lessThan);\n   334→\n   335→        return results.toOwnedSlice(self.allocator);\n   336→    }\n   337→\n   338→    /// Get all blocked issues (open issues with unresolved dependencies).\n   339→    pub fn getBlockedIssues(self: *Self) ![]Issue {\n   340→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   341→        errdefer {\n   342→            for (results.items) |*issue| {\n   343→                issue.deinit(self.allocator);\n   344→            }\n   345→            results.deinit(self.allocator);\n   346→        }\n   347→\n   348→        for (self.store.getAllRef()) |issue| {\n   349→            // Must be open\n   350→            if (!statusEql(issue.status, .open)) continue;\n   351→\n   352→            // Must have at least one open blocker\n   353→            var has_open_blocker = false;\n   354→            for (issue.dependencies) |dep| {\n   355→                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   356→                    if (!statusEql(blocker.status, .closed) and\n   357→                        !statusEql(blocker.status, .tombstone))\n   358→                    {\n   359→                        has_open_blocker = true;\n   360→                        break;\n   361→                    }\n   362→                }\n   363→            }\n   364→            if (!has_open_blocker) continue;\n   365→\n   366→            try results.append(self.allocator, try issue.clone(self.allocator));\n   367→        }\n   368→\n   369→        // Sort by priority then created_at\n   370→        std.mem.sortUnstable(Issue, results.items, {}, struct {\n   371→            fn lessThan(_: void, a: Issue, b: Issue) bool {\n   372→                if (a.priority.value != b.priority.value) {\n   373→                    return a.priority.value < b.priority.value;\n   374→                }\n   375→                return a.created_at.value < b.created_at.value;\n   376→            }\n   377→        }.lessThan);\n   378→\n   379→        return results.toOwnedSlice(self.allocator);\n   380→    }\n   381→\n   382→    /// Get blockers for an issue (open issues that this issue depends on).\n   383→    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n   384→        var results: std.ArrayListUnmanaged(Issue) = .{};\n   385→        errdefer {\n   386→            for (results.items) |*issue| {\n   387→                issue.deinit(self.allocator);\n   388→            }\n   389→            results.deinit(self.allocator);\n   390→        }\n   391→\n   392→        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n   393→\n   394→        for (issue.dependencies) |dep| {\n   395→            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n   396→                if (!statusEql(blocker.status, .closed) and\n   397→                    !statusEql(blocker.status, .tombstone))\n   398→                {\n   399→                    try results.append(self.allocator, try blocker.clone(self.allocator));\n   400→                }\n   401→            }\n   402→        }\n   403→\n   404→        return results.toOwnedSlice(self.allocator);\n   405→    }\n   406→\n   407→    /// Free an array of dependencies.\n   408→    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n   409→        for (deps) |*dep| {\n   410→            freeDependency(dep, self.allocator);\n   411→        }\n   412→        self.allocator.free(deps);\n   413→    }\n   414→\n   415→    /// Free an array of issues.\n   416→    pub fn freeIssues(self: *Self, issues: []Issue) void {\n   417→        for (issues) |*issue| {\n   418→            issue.deinit(self.allocator);\n   419→        }\n   420→        self.allocator.free(issues);\n   421→    }\n   422→\n   423→    /// Free an array of cycle strings.\n   424→    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n   425→        for (cycles) |c| {\n   426→            self.allocator.free(c);\n   427→        }\n   428→        self.allocator.free(cycles);\n   429→    }\n   430→};\n   431→\n   432→// Helper functions\n   433→fn statusEql(a: Status, b: Status) bool {\n   434→    const Tag = std.meta.Tag(Status);\n   435→    const tag_a: Tag = a;\n   436→    const tag_b: Tag = b;\n   437→    if (tag_a != tag_b) return false;\n   438→    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n   439→}\n   440→\n   441→fn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n   442→    var result: Dependency = undefined;\n   443→\n   444→    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n   445→    errdefer allocator.free(result.issue_id);\n   446→\n   447→    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n   448→    errdefer allocator.free(result.depends_on_id);\n   449→\n   450→    result.dep_type = switch (dep.dep_type) {\n   451→        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n   452→        else => dep.dep_type,\n   453→    };\n   454→\n   455→    result.created_at = dep.created_at;\n   456→    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n   457→    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n   458→    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n   459→\n   460→    return result;\n   461→}\n   462→\n   463→fn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n   464→    allocator.free(dep.issue_id);\n   465→    allocator.free(dep.depends_on_id);\n   466→    switch (dep.dep_type) {\n   467→        .custom => |s| allocator.free(s),\n   468→        else => {},\n   469→    }\n   470→    if (dep.created_by) |c| allocator.free(c);\n   471→    if (dep.metadata) |m| allocator.free(m);\n   472→    if (dep.thread_id) |t| allocator.free(t);\n   473→}\n   474→\n   475→// --- Tests ---\n   476→\n   477→test \"DependencyGraph rejects self-dependency\" {\n   478→    const allocator = std.testing.allocator;\n   479→    var store = IssueStore.init(allocator, \"test.jsonl\");\n   480→    defer store.deinit();\n   481→\n   482→    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n   483→\n   484→    var graph = DependencyGraph.init(&store, allocator);\n   485→\n   486→    const dep = Dependency{\n   487→        .issue_id = \"bd-self\",\n   488→        .depends_on_id = \"bd-self\",\n   489→        .dep_type = .blocks,\n   490→        .created_at = 1706540000,\n   491→        .created_by = null,\n   492→        .metadata = null,\n   493→        .thread_id = null,\n   494→    };\n   495→\n   496→    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n   497→}\n   498→\n   499→test \"DependencyGraph rejects direct cycle\" {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c5d8fa27-c868-4dd4-b510-9e6fa32ddb18","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","content":"\n            // Must not be deferred to future (unless including deferred)\n            if (!include_deferred) {\n                if (issue.defer_until.value) |defer_time| {\n                    if (defer_time > now) continue;\n                }\n            }\n\n            // Must not have any open blockers\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all blocked issues (open issues with unresolved dependencies).\n    pub fn getBlockedIssues(self: *Self) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must have at least one open blocker\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get blockers for an issue (open issues that this issue depends on).\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n\n        for (issue.dependencies) |dep| {\n            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                if (!statusEql(blocker.status, .closed) and\n                    !statusEql(blocker.status, .tombstone))\n                {\n                    try results.append(self.allocator, try blocker.clone(self.allocator));\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Free an array of dependencies.\n    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n        for (deps) |*dep| {\n            freeDependency(dep, self.allocator);\n        }\n        self.allocator.free(deps);\n    }\n\n    /// Free an array of issues.\n    pub fn freeIssues(self: *Self, issues: []Issue) void {\n        for (issues) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.allocator.free(issues);\n    }\n\n    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n};\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n    allocator.free(dep.issue_id);\n    allocator.free(dep.depends_on_id);\n    switch (dep.dep_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n    if (dep.created_by) |c| allocator.free(c);\n    if (dep.metadata) |m| allocator.free(m);\n    if (dep.thread_id) |t| allocator.free(t);\n}\n\n// --- Tests ---\n\ntest \"DependencyGraph rejects self-dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-self\",\n        .depends_on_id = \"bd-self\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n}\n\ntest \"DependencyGraph rejects direct cycle\" {","numLines":200,"startLine":300,"totalLines":665}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDatpyXsxRtLUWnFfCS813","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase. Let me implement Task 1 first - adding `--parent` and `--recursive` filters. I need to:\n\n1. Add `parent` and `recursive` fields to `ListArgs` and `ReadyArgs` in `args.zig`\n2. Add parsing for these flags in `parseListArgs` and `parseReadyArgs`\n3. Add a helper function in `graph.zig` to get children of a parent issue\n4. Apply the filter in `list.zig` and `ready.zig`\n\nLet me start implementing:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2913,"cache_read_input_tokens":89306,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2913},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c96348fb-803e-4ef8-93ef-a3f4923d777c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDatpyXsxRtLUWnFfCS813","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JMKrdzMS1zstmUxUdJVVYE","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};","new_string":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2913,"cache_read_input_tokens":89306,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2913},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"808100cf-53e3-421d-9eb5-ff38fa565209"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JMKrdzMS1zstmUxUdJVVYE","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"f6bf1270-14f9-4cb2-b597-f724fc930834","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};","newString":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":232,"oldLines":6,"newStart":232,"newLines":8,"lines":["     include_deferred: bool = false,","     sort: SortField = .created_at,","     sort_desc: bool = true,","+    parent: ?[]const u8 = null,","+    recursive: bool = false,"," };"," "," /// Ready command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DhvQe2SqXiukFt6sELCynF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019UKYvrHTXR7We6L1L2Cym2","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};","new_string":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":814,"cache_read_input_tokens":92219,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":814},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"003749de-01d4-4060-991d-c231fba8e7a9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019UKYvrHTXR7We6L1L2Cym2","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1a8923bf-07c8-4f40-9fea-ca4dffa3f89e","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};","newString":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":246,"oldLines":6,"newStart":246,"newLines":8,"lines":["     notes_contains: ?[]const u8 = null,","     overdue: bool = false,","     include_deferred: bool = false,","+    parent: ?[]const u8 = null,","+    recursive: bool = false,"," };"," "," /// Blocked command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014LCgHM8sUbCJbPR39tKaob","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the parsing functions. First the `parseListArgs`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":434,"cache_read_input_tokens":93033,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":434},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"962c6c3a-f478-42dd-8f61-71abac49067c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014LCgHM8sUbCJbPR39tKaob","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SKzjDTbWb8uV7kcEYt2Ww4","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs","new_string":"            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":434,"cache_read_input_tokens":93033,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":434},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4a2e91d5-0dc4-4f0f-bd80-d918fedb7c51"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SKzjDTbWb8uV7kcEYt2Ww4","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"0cf3ab0c-f5c0-419b-8428-d7185f446566","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs","newString":"            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1071,"oldLines":6,"newStart":1071,"newLines":10,"lines":["                 result.sort_desc = false;","             } else if (self.consumeFlag(null, \"--desc\")) {","                 result.sort_desc = true;","+            } else if (self.consumeFlag(null, \"--parent\")) {","+                result.parent = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {","+                result.recursive = true;","             } else break;","         }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GoMa1KtMfmieai2WGbagy4","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `parseReadyArgs`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":521,"cache_read_input_tokens":93467,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":521},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"ed03a186-7cf0-4d6c-87e5-982b0464ad60"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GoMa1KtMfmieai2WGbagy4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019apJvn9ZEEQHEinqC9zFkr","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs","new_string":"            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":521,"cache_read_input_tokens":93467,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":521},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"68765350-f7a3-4df6-9792-053d903d4e7d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019apJvn9ZEEQHEinqC9zFkr","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7666687d-9d59-4546-947e-5082acba2b87","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs","newString":"            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1104,"oldLines":6,"newStart":1104,"newLines":10,"lines":["                 result.overdue = true;","             } else if (self.consumeFlag(null, \"--include-deferred\")) {","                 result.include_deferred = true;","+            } else if (self.consumeFlag(null, \"--parent\")) {","+                result.parent = self.next() orelse return error.MissingFlagValue;","+            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {","+                result.recursive = true;","             } else break;","         }","         return result;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017RSfqLSyYxjRES9ivPQMNp","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add a function to `graph.zig` to get children (and descendants) of a parent issue. Let me add this function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":410,"cache_read_input_tokens":93988,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":410},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a2a61a1a-4f8b-49fc-80c3-2dd8459ccddf"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017RSfqLSyYxjRES9ivPQMNp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QUqGgoVoPG9zmfF3gcR8RE","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","old_string":"    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n};","new_string":"    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n\n    /// Get direct children of a parent issue (issues with parent_child dependency).\n    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (depTypeEql(dep.dep_type, .parent_child) and\n                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n                {\n                    try results.append(self.allocator, try issue.clone(self.allocator));\n                    break;\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all descendants of a parent issue recursively.\n    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        try self.collectDescendants(parent_id, &results, &visited);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    fn collectDescendants(\n        self: *Self,\n        parent_id: []const u8,\n        results: *std.ArrayListUnmanaged(Issue),\n        visited: *std.StringHashMapUnmanaged(void),\n    ) !void {\n        for (self.store.getAllRef()) |issue| {\n            if (visited.contains(issue.id)) continue;\n\n            for (issue.dependencies) |dep| {\n                if (depTypeEql(dep.dep_type, .parent_child) and\n                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n                {\n                    try visited.put(self.allocator, issue.id, {});\n                    try results.append(self.allocator, try issue.clone(self.allocator));\n                    try self.collectDescendants(issue.id, results, visited);\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Check if an issue is a child (direct or descendant) of a given parent.\n    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {\n        const issue = self.store.getRef(issue_id) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (depTypeEql(dep.dep_type, .parent_child)) {\n                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {\n                    return true;\n                }\n                if (recursive) {\n                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":410,"cache_read_input_tokens":93988,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":410},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d8106287-da0c-4a32-a5ff-c5f33c9527b9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QUqGgoVoPG9zmfF3gcR8RE","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/graph.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b93112f4-2fe8-4a0c-b54f-f212540e424f","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","oldString":"    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n};","newString":"    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n\n    /// Get direct children of a parent issue (issues with parent_child dependency).\n    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (depTypeEql(dep.dep_type, .parent_child) and\n                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n                {\n                    try results.append(self.allocator, try issue.clone(self.allocator));\n                    break;\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all descendants of a parent issue recursively.\n    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        try self.collectDescendants(parent_id, &results, &visited);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    fn collectDescendants(\n        self: *Self,\n        parent_id: []const u8,\n        results: *std.ArrayListUnmanaged(Issue),\n        visited: *std.StringHashMapUnmanaged(void),\n    ) !void {\n        for (self.store.getAllRef()) |issue| {\n            if (visited.contains(issue.id)) continue;\n\n            for (issue.dependencies) |dep| {\n                if (depTypeEql(dep.dep_type, .parent_child) and\n                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n                {\n                    try visited.put(self.allocator, issue.id, {});\n                    try results.append(self.allocator, try issue.clone(self.allocator));\n                    try self.collectDescendants(issue.id, results, visited);\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Check if an issue is a child (direct or descendant) of a given parent.\n    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {\n        const issue = self.store.getRef(issue_id) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (depTypeEql(dep.dep_type, .parent_child)) {\n                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {\n                    return true;\n                }\n                if (recursive) {\n                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};","originalFile":"//! Dependency graph operations for beads_zig.\n//!\n//! Provides dependency management including:\n//! - Add/remove dependencies\n//! - Cycle detection (DFS algorithm)\n//! - Query dependencies and dependents\n//! - Ready/blocked issue queries\n\nconst std = @import(\"std\");\nconst store_mod = @import(\"store.zig\");\nconst IssueStore = store_mod.IssueStore;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Status = @import(\"../models/status.zig\").Status;\n\npub const DependencyGraphError = error{\n    SelfDependency,\n    CycleDetected,\n    DependencyNotFound,\n    IssueNotFound,\n};\n\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n        return .{\n            .store = store,\n            .allocator = allocator,\n        };\n    }\n\n    /// Add a dependency (issue_id depends on depends_on_id).\n    /// Returns error.SelfDependency if trying to depend on self.\n    /// Returns error.CycleDetected if adding would create a cycle.\n    pub fn addDependency(self: *Self, dep: Dependency) !void {\n        // Check for self-dependency\n        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.SelfDependency;\n        }\n\n        // Check if issue exists\n        const issue = self.store.getRef(dep.issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        // Check for cycles before inserting\n        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.CycleDetected;\n        }\n\n        // Check if dependency already exists\n        for (issue.dependencies) |existing| {\n            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n                return; // Already exists, no-op\n            }\n        }\n\n        // Clone and add the dependency\n        const cloned = try cloneDependency(dep, self.allocator);\n        errdefer freeDependency(@constCast(&cloned), self.allocator);\n\n        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n        new_deps[issue.dependencies.len] = cloned;\n\n        // Only free the old array, not the dependency contents (they're now in new_deps)\n        if (issue.dependencies.len > 0) {\n            self.allocator.free(issue.dependencies);\n        }\n        issue.dependencies = new_deps;\n\n        try self.store.markDirty(dep.issue_id);\n    }\n\n    /// Remove a dependency.\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n        const issue = self.store.getRef(issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        var found_idx: ?usize = null;\n        for (issue.dependencies, 0..) |dep, i| {\n            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n\n            if (issue.dependencies.len == 1) {\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = &[_]Dependency{};\n            } else {\n                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n                var j: usize = 0;\n                for (issue.dependencies, 0..) |dep, i| {\n                    if (i != fi) {\n                        new_deps[j] = dep;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = new_deps;\n            }\n\n            try self.store.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue (what it depends on).\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n\n        return deps;\n    }\n\n    /// Get dependents of an issue (what depends on it).\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n        errdefer {\n            for (deps.items) |*dep| {\n                freeDependency(dep, self.allocator);\n            }\n            deps.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n                    const cloned = try cloneDependency(dep, self.allocator);\n                    try deps.append(self.allocator, cloned);\n                }\n            }\n        }\n\n        return deps.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if adding a dependency would create a cycle.\n    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var key_it = visited.keyIterator();\n            while (key_it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            visited.deinit(self.allocator);\n        }\n\n        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n    }\n\n    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n        if (std.mem.eql(u8, from, target)) return true;\n        if (visited.contains(from)) return false;\n\n        const from_copy = try self.allocator.dupe(u8, from);\n        errdefer self.allocator.free(from_copy);\n        try visited.put(self.allocator, from_copy, {});\n\n        const issue = self.store.getRef(from) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// Detect all cycles in the dependency graph.\n    /// Returns array of cycle paths, or null if no cycles.\n    pub fn detectCycles(self: *Self) !?[][]const u8 {\n        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var it = all_issues.keyIterator();\n            while (it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            all_issues.deinit(self.allocator);\n        }\n\n        // Collect all issue IDs involved in dependencies\n        for (self.store.getAllRef()) |issue| {\n            if (issue.dependencies.len > 0) {\n                if (!all_issues.contains(issue.id)) {\n                    const id_copy = try self.allocator.dupe(u8, issue.id);\n                    try all_issues.put(self.allocator, id_copy, {});\n                }\n                for (issue.dependencies) |dep| {\n                    if (!all_issues.contains(dep.depends_on_id)) {\n                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n                        try all_issues.put(self.allocator, id_copy, {});\n                    }\n                }\n            }\n        }\n\n        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (cycles.items) |c| {\n                self.allocator.free(c);\n            }\n            cycles.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n        defer rec_stack.deinit(self.allocator);\n\n        var it = all_issues.keyIterator();\n        while (it.next()) |key| {\n            if (!visited.contains(key.*)) {\n                var path: std.ArrayListUnmanaged([]const u8) = .{};\n                defer path.deinit(self.allocator);\n\n                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n                    try cycles.append(self.allocator, cycle_str);\n                }\n            }\n        }\n\n        if (cycles.items.len == 0) {\n            return null;\n        }\n\n        return try cycles.toOwnedSlice(self.allocator);\n    }\n\n    fn detectCycleDfs(\n        self: *Self,\n        node: []const u8,\n        visited: *std.StringHashMapUnmanaged(void),\n        rec_stack: *std.StringHashMapUnmanaged(void),\n        path: *std.ArrayListUnmanaged([]const u8),\n    ) !bool {\n        try visited.put(self.allocator, node, {});\n        try rec_stack.put(self.allocator, node, {});\n        try path.append(self.allocator, node);\n\n        const issue = self.store.getRef(node) orelse {\n            _ = path.pop();\n            _ = rec_stack.remove(node);\n            return false;\n        };\n\n        for (issue.dependencies) |dep| {\n            if (!visited.contains(dep.depends_on_id)) {\n                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n                    return true;\n                }\n            } else if (rec_stack.contains(dep.depends_on_id)) {\n                try path.append(self.allocator, dep.depends_on_id);\n                return true;\n            }\n        }\n\n        _ = rec_stack.remove(node);\n        _ = path.pop();\n        return false;\n    }\n\n    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open (or deferred if include_deferred is set)\n            if (statusEql(issue.status, .deferred)) {\n                if (!include_deferred) continue;\n            } else if (!statusEql(issue.status, .open)) {\n                continue;\n            }\n\n            // Must not be deferred to future (unless including deferred)\n            if (!include_deferred) {\n                if (issue.defer_until.value) |defer_time| {\n                    if (defer_time > now) continue;\n                }\n            }\n\n            // Must not have any open blockers\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all blocked issues (open issues with unresolved dependencies).\n    pub fn getBlockedIssues(self: *Self) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must have at least one open blocker\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get blockers for an issue (open issues that this issue depends on).\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n\n        for (issue.dependencies) |dep| {\n            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                if (!statusEql(blocker.status, .closed) and\n                    !statusEql(blocker.status, .tombstone))\n                {\n                    try results.append(self.allocator, try blocker.clone(self.allocator));\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Free an array of dependencies.\n    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n        for (deps) |*dep| {\n            freeDependency(dep, self.allocator);\n        }\n        self.allocator.free(deps);\n    }\n\n    /// Free an array of issues.\n    pub fn freeIssues(self: *Self, issues: []Issue) void {\n        for (issues) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.allocator.free(issues);\n    }\n\n    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n};\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n    allocator.free(dep.issue_id);\n    allocator.free(dep.depends_on_id);\n    switch (dep.dep_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n    if (dep.created_by) |c| allocator.free(c);\n    if (dep.metadata) |m| allocator.free(m);\n    if (dep.thread_id) |t| allocator.free(t);\n}\n\n// --- Tests ---\n\ntest \"DependencyGraph rejects self-dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-self\",\n        .depends_on_id = \"bd-self\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n}\n\ntest \"DependencyGraph rejects direct cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph rejects indirect cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on C\n    try graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-c\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // C depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-c\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph getReadyIssues excludes blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues(false);\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyGraph getReadyIssues includes when blocker closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues(false);\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyGraph getBlockedIssues returns only blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const blocked = try graph.getBlockedIssues();\n    defer graph.freeIssues(blocked);\n\n    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n}\n","structuredPatch":[{"oldStart":427,"oldLines":6,"newStart":427,"newLines":89,"lines":["         }","         self.allocator.free(cycles);","     }","+","+    /// Get direct children of a parent issue (issues with parent_child dependency).","+    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {","+        var results: std.ArrayListUnmanaged(Issue) = .{};","+        errdefer {","+            for (results.items) |*issue| {","+                issue.deinit(self.allocator);","+            }","+            results.deinit(self.allocator);","+        }","+","+        for (self.store.getAllRef()) |issue| {","+            for (issue.dependencies) |dep| {","+                if (depTypeEql(dep.dep_type, .parent_child) and","+                    std.mem.eql(u8, dep.depends_on_id, parent_id))","+                {","+                    try results.append(self.allocator, try issue.clone(self.allocator));","+                    break;","+                }","+            }","+        }","+","+        return results.toOwnedSlice(self.allocator);","+    }","+","+    /// Get all descendants of a parent issue recursively.","+    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {","+        var results: std.ArrayListUnmanaged(Issue) = .{};","+        errdefer {","+            for (results.items) |*issue| {","+                issue.deinit(self.allocator);","+            }","+            results.deinit(self.allocator);","+        }","+","+        var visited: std.StringHashMapUnmanaged(void) = .{};","+        defer visited.deinit(self.allocator);","+","+        try self.collectDescendants(parent_id, &results, &visited);","+","+        return results.toOwnedSlice(self.allocator);","+    }","+","+    fn collectDescendants(","+        self: *Self,","+        parent_id: []const u8,","+        results: *std.ArrayListUnmanaged(Issue),","+        visited: *std.StringHashMapUnmanaged(void),","+    ) !void {","+        for (self.store.getAllRef()) |issue| {","+            if (visited.contains(issue.id)) continue;","+","+            for (issue.dependencies) |dep| {","+                if (depTypeEql(dep.dep_type, .parent_child) and","+                    std.mem.eql(u8, dep.depends_on_id, parent_id))","+                {","+                    try visited.put(self.allocator, issue.id, {});","+                    try results.append(self.allocator, try issue.clone(self.allocator));","+                    try self.collectDescendants(issue.id, results, visited);","+                    break;","+                }","+            }","+        }","+    }","+","+    /// Check if an issue is a child (direct or descendant) of a given parent.","+    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {","+        const issue = self.store.getRef(issue_id) orelse return false;","+","+        for (issue.dependencies) |dep| {","+            if (depTypeEql(dep.dep_type, .parent_child)) {","+                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {","+                    return true;","+                }","+                if (recursive) {","+                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {","+                        return true;","+                    }","+                }","+            }","+        }","+        return false;","+    }"," };"," "," // Helper functions"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DehD6mHJDkZr5ciEceadvb","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the helper function `depTypeEql` and the tests. Let me add that:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1383,"cache_read_input_tokens":94398,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1383},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"db3e921c-de9c-42f9-b0ac-9cbedb945ac2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DehD6mHJDkZr5ciEceadvb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GR14w4mS18g9uDbZvkveyP","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/storage/graph.zig","old_string":"fn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}","new_string":"fn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn depTypeEql(a: DependencyType, b: DependencyType) bool {\n    const Tag = std.meta.Tag(DependencyType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1383,"cache_read_input_tokens":94398,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1383},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b4deb39e-bc1f-4e6f-88d4-8a37b93a28ac"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GR14w4mS18g9uDbZvkveyP","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/storage/graph.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2b43b693-7704-43c7-8ba2-6e954afbf9cc","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/storage/graph.zig","oldString":"fn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}","newString":"fn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn depTypeEql(a: DependencyType, b: DependencyType) bool {\n    const Tag = std.meta.Tag(DependencyType);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}","originalFile":"//! Dependency graph operations for beads_zig.\n//!\n//! Provides dependency management including:\n//! - Add/remove dependencies\n//! - Cycle detection (DFS algorithm)\n//! - Query dependencies and dependents\n//! - Ready/blocked issue queries\n\nconst std = @import(\"std\");\nconst store_mod = @import(\"store.zig\");\nconst IssueStore = store_mod.IssueStore;\nconst Issue = @import(\"../models/issue.zig\").Issue;\nconst Dependency = @import(\"../models/dependency.zig\").Dependency;\nconst DependencyType = @import(\"../models/dependency.zig\").DependencyType;\nconst Status = @import(\"../models/status.zig\").Status;\n\npub const DependencyGraphError = error{\n    SelfDependency,\n    CycleDetected,\n    DependencyNotFound,\n    IssueNotFound,\n};\n\npub const DependencyGraph = struct {\n    store: *IssueStore,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    pub fn init(store: *IssueStore, allocator: std.mem.Allocator) Self {\n        return .{\n            .store = store,\n            .allocator = allocator,\n        };\n    }\n\n    /// Add a dependency (issue_id depends on depends_on_id).\n    /// Returns error.SelfDependency if trying to depend on self.\n    /// Returns error.CycleDetected if adding would create a cycle.\n    pub fn addDependency(self: *Self, dep: Dependency) !void {\n        // Check for self-dependency\n        if (std.mem.eql(u8, dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.SelfDependency;\n        }\n\n        // Check if issue exists\n        const issue = self.store.getRef(dep.issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        // Check for cycles before inserting\n        if (try self.wouldCreateCycle(dep.issue_id, dep.depends_on_id)) {\n            return DependencyGraphError.CycleDetected;\n        }\n\n        // Check if dependency already exists\n        for (issue.dependencies) |existing| {\n            if (std.mem.eql(u8, existing.depends_on_id, dep.depends_on_id)) {\n                return; // Already exists, no-op\n            }\n        }\n\n        // Clone and add the dependency\n        const cloned = try cloneDependency(dep, self.allocator);\n        errdefer freeDependency(@constCast(&cloned), self.allocator);\n\n        const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len + 1);\n        @memcpy(new_deps[0..issue.dependencies.len], issue.dependencies);\n        new_deps[issue.dependencies.len] = cloned;\n\n        // Only free the old array, not the dependency contents (they're now in new_deps)\n        if (issue.dependencies.len > 0) {\n            self.allocator.free(issue.dependencies);\n        }\n        issue.dependencies = new_deps;\n\n        try self.store.markDirty(dep.issue_id);\n    }\n\n    /// Remove a dependency.\n    pub fn removeDependency(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !void {\n        const issue = self.store.getRef(issue_id) orelse\n            return DependencyGraphError.IssueNotFound;\n\n        var found_idx: ?usize = null;\n        for (issue.dependencies, 0..) |dep, i| {\n            if (std.mem.eql(u8, dep.depends_on_id, depends_on_id)) {\n                found_idx = i;\n                break;\n            }\n        }\n\n        if (found_idx) |fi| {\n            freeDependency(@constCast(&issue.dependencies[fi]), self.allocator);\n\n            if (issue.dependencies.len == 1) {\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = &[_]Dependency{};\n            } else {\n                const new_deps = try self.allocator.alloc(Dependency, issue.dependencies.len - 1);\n                var j: usize = 0;\n                for (issue.dependencies, 0..) |dep, i| {\n                    if (i != fi) {\n                        new_deps[j] = dep;\n                        j += 1;\n                    }\n                }\n                self.allocator.free(issue.dependencies);\n                issue.dependencies = new_deps;\n            }\n\n            try self.store.markDirty(issue_id);\n        }\n    }\n\n    /// Get dependencies for an issue (what it depends on).\n    pub fn getDependencies(self: *Self, issue_id: []const u8) ![]Dependency {\n        const issue = self.store.getRef(issue_id) orelse return &[_]Dependency{};\n\n        if (issue.dependencies.len == 0) return &[_]Dependency{};\n\n        const deps = try self.allocator.alloc(Dependency, issue.dependencies.len);\n        errdefer self.allocator.free(deps);\n\n        for (issue.dependencies, 0..) |dep, i| {\n            deps[i] = try cloneDependency(dep, self.allocator);\n        }\n\n        return deps;\n    }\n\n    /// Get dependents of an issue (what depends on it).\n    pub fn getDependents(self: *Self, issue_id: []const u8) ![]Dependency {\n        var deps: std.ArrayListUnmanaged(Dependency) = .{};\n        errdefer {\n            for (deps.items) |*dep| {\n                freeDependency(dep, self.allocator);\n            }\n            deps.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n                    const cloned = try cloneDependency(dep, self.allocator);\n                    try deps.append(self.allocator, cloned);\n                }\n            }\n        }\n\n        return deps.toOwnedSlice(self.allocator);\n    }\n\n    /// Check if adding a dependency would create a cycle.\n    /// Uses DFS from depends_on_id to see if it can reach issue_id.\n    pub fn wouldCreateCycle(self: *Self, issue_id: []const u8, depends_on_id: []const u8) !bool {\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var key_it = visited.keyIterator();\n            while (key_it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            visited.deinit(self.allocator);\n        }\n\n        return try self.dfsReachable(depends_on_id, issue_id, &visited);\n    }\n\n    fn dfsReachable(self: *Self, from: []const u8, target: []const u8, visited: *std.StringHashMapUnmanaged(void)) !bool {\n        if (std.mem.eql(u8, from, target)) return true;\n        if (visited.contains(from)) return false;\n\n        const from_copy = try self.allocator.dupe(u8, from);\n        errdefer self.allocator.free(from_copy);\n        try visited.put(self.allocator, from_copy, {});\n\n        const issue = self.store.getRef(from) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (try self.dfsReachable(dep.depends_on_id, target, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// Detect all cycles in the dependency graph.\n    /// Returns array of cycle paths, or null if no cycles.\n    pub fn detectCycles(self: *Self) !?[][]const u8 {\n        var all_issues: std.StringHashMapUnmanaged(void) = .{};\n        defer {\n            var it = all_issues.keyIterator();\n            while (it.next()) |key| {\n                self.allocator.free(key.*);\n            }\n            all_issues.deinit(self.allocator);\n        }\n\n        // Collect all issue IDs involved in dependencies\n        for (self.store.getAllRef()) |issue| {\n            if (issue.dependencies.len > 0) {\n                if (!all_issues.contains(issue.id)) {\n                    const id_copy = try self.allocator.dupe(u8, issue.id);\n                    try all_issues.put(self.allocator, id_copy, {});\n                }\n                for (issue.dependencies) |dep| {\n                    if (!all_issues.contains(dep.depends_on_id)) {\n                        const id_copy = try self.allocator.dupe(u8, dep.depends_on_id);\n                        try all_issues.put(self.allocator, id_copy, {});\n                    }\n                }\n            }\n        }\n\n        var cycles: std.ArrayListUnmanaged([]const u8) = .{};\n        errdefer {\n            for (cycles.items) |c| {\n                self.allocator.free(c);\n            }\n            cycles.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        var rec_stack: std.StringHashMapUnmanaged(void) = .{};\n        defer rec_stack.deinit(self.allocator);\n\n        var it = all_issues.keyIterator();\n        while (it.next()) |key| {\n            if (!visited.contains(key.*)) {\n                var path: std.ArrayListUnmanaged([]const u8) = .{};\n                defer path.deinit(self.allocator);\n\n                if (try self.detectCycleDfs(key.*, &visited, &rec_stack, &path)) {\n                    const cycle_str = try std.mem.join(self.allocator, \" -> \", path.items);\n                    try cycles.append(self.allocator, cycle_str);\n                }\n            }\n        }\n\n        if (cycles.items.len == 0) {\n            return null;\n        }\n\n        return try cycles.toOwnedSlice(self.allocator);\n    }\n\n    fn detectCycleDfs(\n        self: *Self,\n        node: []const u8,\n        visited: *std.StringHashMapUnmanaged(void),\n        rec_stack: *std.StringHashMapUnmanaged(void),\n        path: *std.ArrayListUnmanaged([]const u8),\n    ) !bool {\n        try visited.put(self.allocator, node, {});\n        try rec_stack.put(self.allocator, node, {});\n        try path.append(self.allocator, node);\n\n        const issue = self.store.getRef(node) orelse {\n            _ = path.pop();\n            _ = rec_stack.remove(node);\n            return false;\n        };\n\n        for (issue.dependencies) |dep| {\n            if (!visited.contains(dep.depends_on_id)) {\n                if (try self.detectCycleDfs(dep.depends_on_id, visited, rec_stack, path)) {\n                    return true;\n                }\n            } else if (rec_stack.contains(dep.depends_on_id)) {\n                try path.append(self.allocator, dep.depends_on_id);\n                return true;\n            }\n        }\n\n        _ = rec_stack.remove(node);\n        _ = path.pop();\n        return false;\n    }\n\n    /// Get all issues that are ready (open, not blocked by open issues, optionally not deferred).\n    pub fn getReadyIssues(self: *Self, include_deferred: bool) ![]Issue {\n        const now = std.time.timestamp();\n\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open (or deferred if include_deferred is set)\n            if (statusEql(issue.status, .deferred)) {\n                if (!include_deferred) continue;\n            } else if (!statusEql(issue.status, .open)) {\n                continue;\n            }\n\n            // Must not be deferred to future (unless including deferred)\n            if (!include_deferred) {\n                if (issue.defer_until.value) |defer_time| {\n                    if (defer_time > now) continue;\n                }\n            }\n\n            // Must not have any open blockers\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all blocked issues (open issues with unresolved dependencies).\n    pub fn getBlockedIssues(self: *Self) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            // Must be open\n            if (!statusEql(issue.status, .open)) continue;\n\n            // Must have at least one open blocker\n            var has_open_blocker = false;\n            for (issue.dependencies) |dep| {\n                if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                    if (!statusEql(blocker.status, .closed) and\n                        !statusEql(blocker.status, .tombstone))\n                    {\n                        has_open_blocker = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_open_blocker) continue;\n\n            try results.append(self.allocator, try issue.clone(self.allocator));\n        }\n\n        // Sort by priority then created_at\n        std.mem.sortUnstable(Issue, results.items, {}, struct {\n            fn lessThan(_: void, a: Issue, b: Issue) bool {\n                if (a.priority.value != b.priority.value) {\n                    return a.priority.value < b.priority.value;\n                }\n                return a.created_at.value < b.created_at.value;\n            }\n        }.lessThan);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get blockers for an issue (open issues that this issue depends on).\n    pub fn getBlockers(self: *Self, issue_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        const issue = self.store.getRef(issue_id) orelse return results.toOwnedSlice(self.allocator);\n\n        for (issue.dependencies) |dep| {\n            if (self.store.getRef(dep.depends_on_id)) |blocker| {\n                if (!statusEql(blocker.status, .closed) and\n                    !statusEql(blocker.status, .tombstone))\n                {\n                    try results.append(self.allocator, try blocker.clone(self.allocator));\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Free an array of dependencies.\n    pub fn freeDependencies(self: *Self, deps: []Dependency) void {\n        for (deps) |*dep| {\n            freeDependency(dep, self.allocator);\n        }\n        self.allocator.free(deps);\n    }\n\n    /// Free an array of issues.\n    pub fn freeIssues(self: *Self, issues: []Issue) void {\n        for (issues) |*issue| {\n            issue.deinit(self.allocator);\n        }\n        self.allocator.free(issues);\n    }\n\n    /// Free an array of cycle strings.\n    pub fn freeCycles(self: *Self, cycles: [][]const u8) void {\n        for (cycles) |c| {\n            self.allocator.free(c);\n        }\n        self.allocator.free(cycles);\n    }\n\n    /// Get direct children of a parent issue (issues with parent_child dependency).\n    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        for (self.store.getAllRef()) |issue| {\n            for (issue.dependencies) |dep| {\n                if (depTypeEql(dep.dep_type, .parent_child) and\n                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n                {\n                    try results.append(self.allocator, try issue.clone(self.allocator));\n                    break;\n                }\n            }\n        }\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    /// Get all descendants of a parent issue recursively.\n    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {\n        var results: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer {\n            for (results.items) |*issue| {\n                issue.deinit(self.allocator);\n            }\n            results.deinit(self.allocator);\n        }\n\n        var visited: std.StringHashMapUnmanaged(void) = .{};\n        defer visited.deinit(self.allocator);\n\n        try self.collectDescendants(parent_id, &results, &visited);\n\n        return results.toOwnedSlice(self.allocator);\n    }\n\n    fn collectDescendants(\n        self: *Self,\n        parent_id: []const u8,\n        results: *std.ArrayListUnmanaged(Issue),\n        visited: *std.StringHashMapUnmanaged(void),\n    ) !void {\n        for (self.store.getAllRef()) |issue| {\n            if (visited.contains(issue.id)) continue;\n\n            for (issue.dependencies) |dep| {\n                if (depTypeEql(dep.dep_type, .parent_child) and\n                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n                {\n                    try visited.put(self.allocator, issue.id, {});\n                    try results.append(self.allocator, try issue.clone(self.allocator));\n                    try self.collectDescendants(issue.id, results, visited);\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Check if an issue is a child (direct or descendant) of a given parent.\n    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {\n        const issue = self.store.getRef(issue_id) orelse return false;\n\n        for (issue.dependencies) |dep| {\n            if (depTypeEql(dep.dep_type, .parent_child)) {\n                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {\n                    return true;\n                }\n                if (recursive) {\n                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n\n// Helper functions\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n    var result: Dependency = undefined;\n\n    result.issue_id = try allocator.dupe(u8, dep.issue_id);\n    errdefer allocator.free(result.issue_id);\n\n    result.depends_on_id = try allocator.dupe(u8, dep.depends_on_id);\n    errdefer allocator.free(result.depends_on_id);\n\n    result.dep_type = switch (dep.dep_type) {\n        .custom => |s| .{ .custom = try allocator.dupe(u8, s) },\n        else => dep.dep_type,\n    };\n\n    result.created_at = dep.created_at;\n    result.created_by = if (dep.created_by) |c| try allocator.dupe(u8, c) else null;\n    result.metadata = if (dep.metadata) |m| try allocator.dupe(u8, m) else null;\n    result.thread_id = if (dep.thread_id) |t| try allocator.dupe(u8, t) else null;\n\n    return result;\n}\n\nfn freeDependency(dep: *Dependency, allocator: std.mem.Allocator) void {\n    allocator.free(dep.issue_id);\n    allocator.free(dep.depends_on_id);\n    switch (dep.dep_type) {\n        .custom => |s| allocator.free(s),\n        else => {},\n    }\n    if (dep.created_by) |c| allocator.free(c);\n    if (dep.metadata) |m| allocator.free(m);\n    if (dep.thread_id) |t| allocator.free(t);\n}\n\n// --- Tests ---\n\ntest \"DependencyGraph rejects self-dependency\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-self\", \"Self\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    const dep = Dependency{\n        .issue_id = \"bd-self\",\n        .depends_on_id = \"bd-self\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    };\n\n    try std.testing.expectError(DependencyGraphError.SelfDependency, graph.addDependency(dep));\n}\n\ntest \"DependencyGraph rejects direct cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph rejects indirect cycle\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-a\", \"A\", 1706540000));\n    try store.insert(Issue.init(\"bd-b\", \"B\", 1706540000));\n    try store.insert(Issue.init(\"bd-c\", \"C\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    // A depends on B\n    try graph.addDependency(.{\n        .issue_id = \"bd-a\",\n        .depends_on_id = \"bd-b\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // B depends on C\n    try graph.addDependency(.{\n        .issue_id = \"bd-b\",\n        .depends_on_id = \"bd-c\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    // C depends on A would create a cycle\n    try std.testing.expectError(DependencyGraphError.CycleDetected, graph.addDependency(.{\n        .issue_id = \"bd-c\",\n        .depends_on_id = \"bd-a\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    }));\n}\n\ntest \"DependencyGraph getReadyIssues excludes blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues(false);\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 2), ready.len);\n\n    // Verify blocked is not in the list\n    for (ready) |issue| {\n        try std.testing.expect(!std.mem.eql(u8, issue.id, \"bd-blocked\"));\n    }\n}\n\ntest \"DependencyGraph getReadyIssues includes when blocker closed\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    var blocker = Issue.init(\"bd-blocker\", \"Blocker\", 1706540000);\n    blocker.status = .closed;\n    try store.insert(blocker);\n    try store.insert(Issue.init(\"bd-child\", \"Child\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-child\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const ready = try graph.getReadyIssues(false);\n    defer graph.freeIssues(ready);\n\n    try std.testing.expectEqual(@as(usize, 1), ready.len);\n    try std.testing.expectEqualStrings(\"bd-child\", ready[0].id);\n}\n\ntest \"DependencyGraph getBlockedIssues returns only blocked\" {\n    const allocator = std.testing.allocator;\n    var store = IssueStore.init(allocator, \"test.jsonl\");\n    defer store.deinit();\n\n    try store.insert(Issue.init(\"bd-blocker\", \"Blocker\", 1706540000));\n    try store.insert(Issue.init(\"bd-blocked\", \"Blocked\", 1706540000));\n    try store.insert(Issue.init(\"bd-ready\", \"Ready\", 1706540000));\n\n    var graph = DependencyGraph.init(&store, allocator);\n\n    try graph.addDependency(.{\n        .issue_id = \"bd-blocked\",\n        .depends_on_id = \"bd-blocker\",\n        .dep_type = .blocks,\n        .created_at = 1706540000,\n        .created_by = null,\n        .metadata = null,\n        .thread_id = null,\n    });\n\n    const blocked = try graph.getBlockedIssues();\n    defer graph.freeIssues(blocked);\n\n    try std.testing.expectEqual(@as(usize, 1), blocked.len);\n    try std.testing.expectEqualStrings(\"bd-blocked\", blocked[0].id);\n}\n","structuredPatch":[{"oldStart":521,"oldLines":6,"newStart":521,"newLines":14,"lines":["     return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;"," }"," ","+fn depTypeEql(a: DependencyType, b: DependencyType) bool {","+    const Tag = std.meta.Tag(DependencyType);","+    const tag_a: Tag = a;","+    const tag_b: Tag = b;","+    if (tag_a != tag_b) return false;","+    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;","+}","+"," fn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {","     var result: Dependency = undefined;"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HUxRvpwAH5sEavCXGyXLvt","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the `list.zig` file to apply the parent filter. I need to read more to understand how it works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":502,"cache_read_input_tokens":95781,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":502},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"eefb7229-b173-45be-a587-2c9782b5ac31"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HUxRvpwAH5sEavCXGyXLvt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013PhbmL4VqVcmHfb1MSLpTA","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/common.zig","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":502,"cache_read_input_tokens":95781,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":502},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"f48ca950-e90d-433d-ba86-7c6e9fdf8b7b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013PhbmL4VqVcmHfb1MSLpTA","type":"tool_result","content":"     1→//! Common CLI utilities shared across commands.\n     2→//!\n     3→//! Provides workspace loading, error handling, and shared result types\n     4→//! to reduce duplication across command implementations.\n     5→\n     6→const std = @import(\"std\");\n     7→const storage = @import(\"../storage/mod.zig\");\n     8→const output_mod = @import(\"../output/mod.zig\");\n     9→const args = @import(\"args.zig\");\n    10→\n    11→pub const Output = output_mod.Output;\n    12→pub const OutputOptions = output_mod.OutputOptions;\n    13→pub const IssueStore = storage.IssueStore;\n    14→pub const IssueStoreError = storage.IssueStoreError;\n    15→pub const DependencyGraph = storage.DependencyGraph;\n    16→pub const EventStore = storage.EventStore;\n    17→pub const StoreLoadResult = storage.StoreLoadResult;\n    18→\n    19→/// Common errors shared across CLI commands.\n    20→pub const CommandError = error{\n    21→    WorkspaceNotInitialized,\n    22→    StorageError,\n    23→    OutOfMemory,\n    24→};\n    25→\n    26→/// Context for executing a CLI command with an initialized workspace.\n    27→pub const CommandContext = struct {\n    28→    allocator: std.mem.Allocator,\n    29→    output: Output,\n    30→    store: IssueStore,\n    31→    event_store: EventStore,\n    32→    beads_dir: []const u8,\n    33→    issues_path: []const u8,\n    34→    events_path: []const u8,\n    35→    global: args.GlobalOptions,\n    36→    /// Number of corrupt entries skipped during load.\n    37→    corruption_count: usize = 0,\n    38→    /// Line numbers of corrupt JSONL entries (owned memory).\n    39→    corrupt_lines: []const usize = &.{},\n    40→    /// Number of WAL entries replayed during load.\n    41→    wal_entries_replayed: usize = 0,\n    42→\n    43→    /// Initialize a command context by loading the workspace.\n    44→    /// Returns null and outputs an error if workspace is not initialized.\n    45→    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    46→    /// Replays WAL entries after loading main file for consistency.\n    47→    pub fn init(\n    48→        allocator: std.mem.Allocator,\n    49→        global: args.GlobalOptions,\n    50→    ) CommandError!?CommandContext {\n    51→        var output = Output.init(allocator, .{\n    52→            .json = global.json,\n    53→            .toon = global.toon,\n    54→            .quiet = global.quiet,\n    55→            .silent = global.silent,\n    56→            .no_color = global.no_color,\n    57→        });\n    58→\n    59→        const beads_dir_str = global.data_path orelse \".beads\";\n    60→        const beads_dir = allocator.dupe(u8, beads_dir_str) catch {\n    61→            return CommandError.OutOfMemory;\n    62→        };\n    63→        const issues_path = std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" }) catch {\n    64→            allocator.free(beads_dir);\n    65→            return CommandError.OutOfMemory;\n    66→        };\n    67→        const events_path = std.fs.path.join(allocator, &.{ beads_dir, \"events.jsonl\" }) catch {\n    68→            allocator.free(issues_path);\n    69→            allocator.free(beads_dir);\n    70→            return CommandError.OutOfMemory;\n    71→        };\n    72→\n    73→        std.fs.cwd().access(issues_path, .{}) catch |err| {\n    74→            if (err == error.FileNotFound) {\n    75→                outputErrorGeneric(&output, global.isStructuredOutput(), \"workspace not initialized. Run 'bz init' first.\") catch {};\n    76→                allocator.free(issues_path);\n    77→                allocator.free(events_path);\n    78→                allocator.free(beads_dir);\n    79→                return null;\n    80→            }\n    81→            outputErrorGeneric(&output, global.isStructuredOutput(), \"cannot access workspace\") catch {};\n    82→            allocator.free(issues_path);\n    83→            allocator.free(events_path);\n    84→            allocator.free(beads_dir);\n    85→            return CommandError.StorageError;\n    86→        };\n    87→\n    88→        var store = IssueStore.init(allocator, issues_path);\n    89→        var corruption_count: usize = 0;\n    90→        var corrupt_lines: []const usize = &.{};\n    91→\n    92→        // Use recovery mode: log and skip corrupt entries instead of failing\n    93→        const load_result = store.loadFromFileWithRecovery() catch |err| {\n    94→            if (err != error.FileNotFound) {\n    95→                outputErrorGeneric(&output, global.isStructuredOutput(), \"failed to load issues\") catch {};\n    96→                store.deinit();\n    97→                allocator.free(issues_path);\n    98→                allocator.free(events_path);\n    99→                allocator.free(beads_dir);\n   100→                return CommandError.StorageError;\n   101→            }\n   102→            // File not found is OK - empty workspace\n   103→            var event_store_empty = EventStore.init(allocator, events_path);\n   104→            event_store_empty.loadNextId() catch {};\n   105→            return CommandContext{\n   106→                .allocator = allocator,\n   107→                .output = output,\n   108→                .store = store,\n   109→                .event_store = event_store_empty,\n   110→                .beads_dir = beads_dir,\n   111→                .issues_path = issues_path,\n   112→                .events_path = events_path,\n   113→                .global = global,\n   114→                .corruption_count = 0,\n   115→                .corrupt_lines = &.{},\n   116→                .wal_entries_replayed = 0,\n   117→            };\n   118→        };\n   119→\n   120→        corruption_count = load_result.jsonl_corruption_count;\n   121→        corrupt_lines = load_result.jsonl_corrupt_lines;\n   122→\n   123→        // Replay WAL entries onto the store for consistency\n   124→        var wal_entries_replayed: usize = 0;\n   125→        wal_replay: {\n   126→            var wal_obj = storage.Wal.init(beads_dir, allocator) catch {\n   127→                break :wal_replay;\n   128→            };\n   129→            defer wal_obj.deinit();\n   130→\n   131→            var replay_stats = wal_obj.replay(&store) catch {\n   132→                break :wal_replay;\n   133→            };\n   134→            defer replay_stats.deinit(allocator);\n   135→            wal_entries_replayed = replay_stats.applied;\n   136→        }\n   137→\n   138→        // Warn user about corruption (unless quiet/silent mode)\n   139→        if (corruption_count > 0 and !global.quiet and !global.silent and !global.isStructuredOutput()) {\n   140→            output.print(\"warning: {d} corrupt entries skipped during load\\n\", .{corruption_count}) catch {};\n   141→            output.print(\"         Run 'bz doctor' for details, 'bz compact' to rebuild.\\n\", .{}) catch {};\n   142→        }\n   143→\n   144→        // Initialize event store and load next ID\n   145→        var event_store = EventStore.init(allocator, events_path);\n   146→        event_store.loadNextId() catch {}; // OK if events file doesn't exist\n   147→\n   148→        return CommandContext{\n   149→            .allocator = allocator,\n   150→            .output = output,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1b84faab-a814-4471-932c-77e5b65863ab","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/common.zig","content":"//! Common CLI utilities shared across commands.\n//!\n//! Provides workspace loading, error handling, and shared result types\n//! to reduce duplication across command implementations.\n\nconst std = @import(\"std\");\nconst storage = @import(\"../storage/mod.zig\");\nconst output_mod = @import(\"../output/mod.zig\");\nconst args = @import(\"args.zig\");\n\npub const Output = output_mod.Output;\npub const OutputOptions = output_mod.OutputOptions;\npub const IssueStore = storage.IssueStore;\npub const IssueStoreError = storage.IssueStoreError;\npub const DependencyGraph = storage.DependencyGraph;\npub const EventStore = storage.EventStore;\npub const StoreLoadResult = storage.StoreLoadResult;\n\n/// Common errors shared across CLI commands.\npub const CommandError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n};\n\n/// Context for executing a CLI command with an initialized workspace.\npub const CommandContext = struct {\n    allocator: std.mem.Allocator,\n    output: Output,\n    store: IssueStore,\n    event_store: EventStore,\n    beads_dir: []const u8,\n    issues_path: []const u8,\n    events_path: []const u8,\n    global: args.GlobalOptions,\n    /// Number of corrupt entries skipped during load.\n    corruption_count: usize = 0,\n    /// Line numbers of corrupt JSONL entries (owned memory).\n    corrupt_lines: []const usize = &.{},\n    /// Number of WAL entries replayed during load.\n    wal_entries_replayed: usize = 0,\n\n    /// Initialize a command context by loading the workspace.\n    /// Returns null and outputs an error if workspace is not initialized.\n    /// Uses graceful corruption recovery: logs and skips corrupt entries.\n    /// Replays WAL entries after loading main file for consistency.\n    pub fn init(\n        allocator: std.mem.Allocator,\n        global: args.GlobalOptions,\n    ) CommandError!?CommandContext {\n        var output = Output.init(allocator, .{\n            .json = global.json,\n            .toon = global.toon,\n            .quiet = global.quiet,\n            .silent = global.silent,\n            .no_color = global.no_color,\n        });\n\n        const beads_dir_str = global.data_path orelse \".beads\";\n        const beads_dir = allocator.dupe(u8, beads_dir_str) catch {\n            return CommandError.OutOfMemory;\n        };\n        const issues_path = std.fs.path.join(allocator, &.{ beads_dir, \"issues.jsonl\" }) catch {\n            allocator.free(beads_dir);\n            return CommandError.OutOfMemory;\n        };\n        const events_path = std.fs.path.join(allocator, &.{ beads_dir, \"events.jsonl\" }) catch {\n            allocator.free(issues_path);\n            allocator.free(beads_dir);\n            return CommandError.OutOfMemory;\n        };\n\n        std.fs.cwd().access(issues_path, .{}) catch |err| {\n            if (err == error.FileNotFound) {\n                outputErrorGeneric(&output, global.isStructuredOutput(), \"workspace not initialized. Run 'bz init' first.\") catch {};\n                allocator.free(issues_path);\n                allocator.free(events_path);\n                allocator.free(beads_dir);\n                return null;\n            }\n            outputErrorGeneric(&output, global.isStructuredOutput(), \"cannot access workspace\") catch {};\n            allocator.free(issues_path);\n            allocator.free(events_path);\n            allocator.free(beads_dir);\n            return CommandError.StorageError;\n        };\n\n        var store = IssueStore.init(allocator, issues_path);\n        var corruption_count: usize = 0;\n        var corrupt_lines: []const usize = &.{};\n\n        // Use recovery mode: log and skip corrupt entries instead of failing\n        const load_result = store.loadFromFileWithRecovery() catch |err| {\n            if (err != error.FileNotFound) {\n                outputErrorGeneric(&output, global.isStructuredOutput(), \"failed to load issues\") catch {};\n                store.deinit();\n                allocator.free(issues_path);\n                allocator.free(events_path);\n                allocator.free(beads_dir);\n                return CommandError.StorageError;\n            }\n            // File not found is OK - empty workspace\n            var event_store_empty = EventStore.init(allocator, events_path);\n            event_store_empty.loadNextId() catch {};\n            return CommandContext{\n                .allocator = allocator,\n                .output = output,\n                .store = store,\n                .event_store = event_store_empty,\n                .beads_dir = beads_dir,\n                .issues_path = issues_path,\n                .events_path = events_path,\n                .global = global,\n                .corruption_count = 0,\n                .corrupt_lines = &.{},\n                .wal_entries_replayed = 0,\n            };\n        };\n\n        corruption_count = load_result.jsonl_corruption_count;\n        corrupt_lines = load_result.jsonl_corrupt_lines;\n\n        // Replay WAL entries onto the store for consistency\n        var wal_entries_replayed: usize = 0;\n        wal_replay: {\n            var wal_obj = storage.Wal.init(beads_dir, allocator) catch {\n                break :wal_replay;\n            };\n            defer wal_obj.deinit();\n\n            var replay_stats = wal_obj.replay(&store) catch {\n                break :wal_replay;\n            };\n            defer replay_stats.deinit(allocator);\n            wal_entries_replayed = replay_stats.applied;\n        }\n\n        // Warn user about corruption (unless quiet/silent mode)\n        if (corruption_count > 0 and !global.quiet and !global.silent and !global.isStructuredOutput()) {\n            output.print(\"warning: {d} corrupt entries skipped during load\\n\", .{corruption_count}) catch {};\n            output.print(\"         Run 'bz doctor' for details, 'bz compact' to rebuild.\\n\", .{}) catch {};\n        }\n\n        // Initialize event store and load next ID\n        var event_store = EventStore.init(allocator, events_path);\n        event_store.loadNextId() catch {}; // OK if events file doesn't exist\n\n        return CommandContext{\n            .allocator = allocator,\n            .output = output,","numLines":150,"startLine":1,"totalLines":338}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ABDuz1nEWJEyaFzgDJW13y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MMyhcN18e3HjjnPpDBYFVF","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/common.zig","offset":150,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2349,"cache_read_input_tokens":96283,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2349},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"34fffa05-c662-4e7d-bb09-2d5ba0a62a56"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MMyhcN18e3HjjnPpDBYFVF","type":"tool_result","content":"   150→            .output = output,\n   151→            .store = store,\n   152→            .event_store = event_store,\n   153→            .beads_dir = beads_dir,\n   154→            .issues_path = issues_path,\n   155→            .events_path = events_path,\n   156→            .global = global,\n   157→            .corruption_count = corruption_count,\n   158→            .corrupt_lines = corrupt_lines,\n   159→            .wal_entries_replayed = wal_entries_replayed,\n   160→        };\n   161→    }\n   162→\n   163→    /// Clean up resources.\n   164→    pub fn deinit(self: *CommandContext) void {\n   165→        self.store.deinit();\n   166→        self.allocator.free(self.beads_dir);\n   167→        self.allocator.free(self.issues_path);\n   168→        self.allocator.free(self.events_path);\n   169→        if (self.corrupt_lines.len > 0) {\n   170→            self.allocator.free(self.corrupt_lines);\n   171→        }\n   172→    }\n   173→\n   174→    /// Check if corruption was detected during load.\n   175→    pub fn hasCorruption(self: *const CommandContext) bool {\n   176→        return self.corruption_count > 0;\n   177→    }\n   178→\n   179→    /// Save the store to file if auto-flush is enabled.\n   180→    /// Note: For single-issue writes, prefer appendToWal() for better performance.\n   181→    pub fn saveIfAutoFlush(self: *CommandContext) CommandError!void {\n   182→        if (!self.global.no_auto_flush) {\n   183→            self.store.saveToFile() catch {\n   184→                outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to save issues\") catch {};\n   185→                return CommandError.StorageError;\n   186→            };\n   187→        }\n   188→    }\n   189→\n   190→    /// Append an issue to the WAL for fast persistence.\n   191→    /// Use this for single-issue creates/updates instead of saveToFile().\n   192→    pub fn appendToWal(self: *CommandContext, issue: @import(\"../models/issue.zig\").Issue, op: storage.WalOp) CommandError!void {\n   193→        if (self.global.no_auto_flush) return;\n   194→\n   195→        var wal_obj = storage.Wal.init(self.beads_dir, self.allocator) catch {\n   196→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to initialize WAL\") catch {};\n   197→            return CommandError.StorageError;\n   198→        };\n   199→        defer wal_obj.deinit();\n   200→\n   201→        wal_obj.appendEntry(.{\n   202→            .op = op,\n   203→            .ts = std.time.timestamp(),\n   204→            .id = issue.id,\n   205→            .data = issue,\n   206→        }) catch {\n   207→            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to write to WAL\") catch {};\n   208→            return CommandError.StorageError;\n   209→        };\n   210→    }\n   211→\n   212→    /// Create a dependency graph from the store.\n   213→    pub fn createGraph(self: *CommandContext) DependencyGraph {\n   214→        return DependencyGraph.init(&self.store, self.allocator);\n   215→    }\n   216→\n   217→    /// Record an audit event. Silently ignores errors (audit is best-effort).\n   218→    pub fn recordEvent(self: *CommandContext, event: @import(\"../models/event.zig\").Event) void {\n   219→        _ = self.event_store.append(event) catch {};\n   220→    }\n   221→};\n   222→\n   223→/// Output a generic error message in the appropriate format.\n   224→pub fn outputErrorGeneric(output: *Output, json_mode: bool, message: []const u8) !void {\n   225→    if (json_mode) {\n   226→        try output.printJson(.{\n   227→            .success = false,\n   228→            .message = message,\n   229→        });\n   230→    } else {\n   231→        try output.err(\"{s}\", .{message});\n   232→    }\n   233→}\n   234→\n   235→/// Output an error with a specific result type for JSON mode.\n   236→pub fn outputErrorTyped(\n   237→    comptime T: type,\n   238→    output: *Output,\n   239→    json_mode: bool,\n   240→    message: []const u8,\n   241→) !void {\n   242→    if (json_mode) {\n   243→        const result = T{ .success = false, .message = message };\n   244→        try output.printJson(result);\n   245→    } else {\n   246→        try output.err(\"{s}\", .{message});\n   247→    }\n   248→}\n   249→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"f583523a-1f08-4f88-84d5-ddaf395054d7","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/common.zig","content":"            .output = output,\n            .store = store,\n            .event_store = event_store,\n            .beads_dir = beads_dir,\n            .issues_path = issues_path,\n            .events_path = events_path,\n            .global = global,\n            .corruption_count = corruption_count,\n            .corrupt_lines = corrupt_lines,\n            .wal_entries_replayed = wal_entries_replayed,\n        };\n    }\n\n    /// Clean up resources.\n    pub fn deinit(self: *CommandContext) void {\n        self.store.deinit();\n        self.allocator.free(self.beads_dir);\n        self.allocator.free(self.issues_path);\n        self.allocator.free(self.events_path);\n        if (self.corrupt_lines.len > 0) {\n            self.allocator.free(self.corrupt_lines);\n        }\n    }\n\n    /// Check if corruption was detected during load.\n    pub fn hasCorruption(self: *const CommandContext) bool {\n        return self.corruption_count > 0;\n    }\n\n    /// Save the store to file if auto-flush is enabled.\n    /// Note: For single-issue writes, prefer appendToWal() for better performance.\n    pub fn saveIfAutoFlush(self: *CommandContext) CommandError!void {\n        if (!self.global.no_auto_flush) {\n            self.store.saveToFile() catch {\n                outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to save issues\") catch {};\n                return CommandError.StorageError;\n            };\n        }\n    }\n\n    /// Append an issue to the WAL for fast persistence.\n    /// Use this for single-issue creates/updates instead of saveToFile().\n    pub fn appendToWal(self: *CommandContext, issue: @import(\"../models/issue.zig\").Issue, op: storage.WalOp) CommandError!void {\n        if (self.global.no_auto_flush) return;\n\n        var wal_obj = storage.Wal.init(self.beads_dir, self.allocator) catch {\n            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to initialize WAL\") catch {};\n            return CommandError.StorageError;\n        };\n        defer wal_obj.deinit();\n\n        wal_obj.appendEntry(.{\n            .op = op,\n            .ts = std.time.timestamp(),\n            .id = issue.id,\n            .data = issue,\n        }) catch {\n            outputErrorGeneric(&self.output, self.global.isStructuredOutput(), \"failed to write to WAL\") catch {};\n            return CommandError.StorageError;\n        };\n    }\n\n    /// Create a dependency graph from the store.\n    pub fn createGraph(self: *CommandContext) DependencyGraph {\n        return DependencyGraph.init(&self.store, self.allocator);\n    }\n\n    /// Record an audit event. Silently ignores errors (audit is best-effort).\n    pub fn recordEvent(self: *CommandContext, event: @import(\"../models/event.zig\").Event) void {\n        _ = self.event_store.append(event) catch {};\n    }\n};\n\n/// Output a generic error message in the appropriate format.\npub fn outputErrorGeneric(output: *Output, json_mode: bool, message: []const u8) !void {\n    if (json_mode) {\n        try output.printJson(.{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n/// Output an error with a specific result type for JSON mode.\npub fn outputErrorTyped(\n    comptime T: type,\n    output: *Output,\n    json_mode: bool,\n    message: []const u8,\n) !void {\n    if (json_mode) {\n        const result = T{ .success = false, .message = message };\n        try output.printJson(result);\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n","numLines":100,"startLine":150,"totalLines":338}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FxczAbNbNRDpNZoJJAjaZt","type":"message","role":"assistant","content":[{"type":"text","text":"Good, I can see that `CommandContext` has a `createGraph()` method. Now I need to update `list.zig` to apply the parent filter. Let me edit `list.zig`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1528,"cache_read_input_tokens":98632,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1528},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"267136db-dc8d-4b3b-ac49-2f88047ecb4e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FxczAbNbNRDpNZoJJAjaZt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0183JsRVCiX6pyP4q4bfRosj","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig","old_string":"    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    if (global.isStructuredOutput()) {","new_string":"    var issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    // Apply parent filter if specified\n    if (list_args.parent) |parent_id| {\n        var graph = ctx.createGraph();\n        var filtered: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer filtered.deinit(allocator);\n\n        for (issues) |issue| {\n            if (graph.isChildOf(issue.id, parent_id, list_args.recursive)) {\n                try filtered.append(allocator, issue);\n            } else {\n                var i = issue;\n                i.deinit(allocator);\n            }\n        }\n        allocator.free(issues);\n        issues = try filtered.toOwnedSlice(allocator);\n    }\n\n    if (global.isStructuredOutput()) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1528,"cache_read_input_tokens":98632,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1528},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"9f79ef01-fde2-442f-9ad8-826b639f196e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0183JsRVCiX6pyP4q4bfRosj","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/list.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c1c4eaec-754d-4cc6-ac10-746daeeb6149","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/list.zig","oldString":"    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    if (global.isStructuredOutput()) {","newString":"    var issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    // Apply parent filter if specified\n    if (list_args.parent) |parent_id| {\n        var graph = ctx.createGraph();\n        var filtered: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer filtered.deinit(allocator);\n\n        for (issues) |issue| {\n            if (graph.isChildOf(issue.id, parent_id, list_args.recursive)) {\n                try filtered.append(allocator, issue);\n            } else {\n                var i = issue;\n                i.deinit(allocator);\n            }\n        }\n        allocator.free(issues);\n        issues = try filtered.toOwnedSlice(allocator);\n    }\n\n    if (global.isStructuredOutput()) {","originalFile":"//! List command for beads_zig.\n//!\n//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n//!\n//! Lists issues with optional filters.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const ListError = error{\n    WorkspaceNotInitialized,\n    InvalidFilter,\n    StorageError,\n    OutOfMemory,\n};\n\npub const ListResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        status: []const u8,\n        priority: u3,\n        issue_type: []const u8,\n        assignee: ?[]const u8 = null,\n    };\n};\n\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    } else if (!list_args.all) {\n        filters.status = .open;\n    }\n\n    if (list_args.priority) |p| {\n        filters.priority = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_max) |p| {\n        filters.priority_max = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.issue_type) |t| {\n        filters.issue_type = IssueType.fromString(t);\n    }\n\n    if (list_args.assignee) |a| {\n        filters.assignee = a;\n    }\n\n    if (list_args.label) |l| {\n        filters.label = l;\n    }\n\n    if (list_args.label_any.len > 0) {\n        filters.label_any = list_args.label_any;\n    }\n\n    if (list_args.title_contains) |t| {\n        filters.title_contains = t;\n    }\n\n    if (list_args.desc_contains) |d| {\n        filters.desc_contains = d;\n    }\n\n    if (list_args.notes_contains) |n| {\n        filters.notes_contains = n;\n    }\n\n    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply overdue filter\n    filters.overdue = list_args.overdue;\n\n    // Apply include_deferred filter\n    filters.include_deferred = list_args.include_deferred;\n\n    // Apply sort options\n    filters.order_by = switch (list_args.sort) {\n        .created_at => .created_at,\n        .updated_at => .updated_at,\n        .priority => .priority,\n    };\n    filters.order_desc = list_args.sort_desc;\n\n    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n    if (structured_mode) {\n        try output.printJson(ListResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"ListError enum exists\" {\n    const err: ListError = ListError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n}\n\ntest \"ListResult struct works\" {\n    const result = ListResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const list_args = args.ListArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(list_args, global, allocator);\n    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const list_args = args.ListArgs{ .all = true };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(list_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":125,"oldLines":7,"newStart":125,"newLines":7,"lines":["     };","     filters.order_desc = list_args.sort_desc;"," ","-    const issues = try ctx.store.list(filters);","+    var issues = try ctx.store.list(filters);","     defer {","         for (issues) |*issue| {","             var i = issue.*;"]},{"oldStart":134,"oldLines":6,"newStart":134,"newLines":24,"lines":["         allocator.free(issues);","     }"," ","+    // Apply parent filter if specified","+    if (list_args.parent) |parent_id| {","+        var graph = ctx.createGraph();","+        var filtered: std.ArrayListUnmanaged(Issue) = .{};","+        errdefer filtered.deinit(allocator);","+","+        for (issues) |issue| {","+            if (graph.isChildOf(issue.id, parent_id, list_args.recursive)) {","+                try filtered.append(allocator, issue);","+            } else {","+                var i = issue;","+                i.deinit(allocator);","+            }","+        }","+        allocator.free(issues);","+        issues = try filtered.toOwnedSlice(allocator);","+    }","+","     if (global.isStructuredOutput()) {","         var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);","         defer allocator.free(compact_issues);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HGXS9BGeC442mxSgnpxr41","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `ready.zig` similarly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":533,"cache_read_input_tokens":100160,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":533},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7cb85ac3-6129-4da4-83f6-6c84504e55e2"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HGXS9BGeC442mxSgnpxr41","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PUqjo9DxjXHxT9uKE4gsBM","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig","old_string":"    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);","new_string":"    var graph = ctx.createGraph();\n    var issues = try graph.getReadyIssues(ready_args.include_deferred);\n\n    // Apply parent filter if specified (before other filters for efficiency)\n    if (ready_args.parent) |parent_id| {\n        var parent_filtered: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer parent_filtered.deinit(allocator);\n\n        for (issues) |issue| {\n            if (graph.isChildOf(issue.id, parent_id, ready_args.recursive)) {\n                try parent_filtered.append(allocator, issue);\n            } else {\n                var i = issue;\n                i.deinit(allocator);\n            }\n        }\n        allocator.free(issues);\n        issues = try parent_filtered.toOwnedSlice(allocator);\n    }\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":533,"cache_read_input_tokens":100160,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":533},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"db1fc1ca-d5e2-4386-b986-1914df494a5c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PUqjo9DxjXHxT9uKE4gsBM","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/ready.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"bf7d9fd1-c93b-409f-b2c8-98c6e39d4da2","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","oldString":"    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);","newString":"    var graph = ctx.createGraph();\n    var issues = try graph.getReadyIssues(ready_args.include_deferred);\n\n    // Apply parent filter if specified (before other filters for efficiency)\n    if (ready_args.parent) |parent_id| {\n        var parent_filtered: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer parent_filtered.deinit(allocator);\n\n        for (issues) |issue| {\n            if (graph.isChildOf(issue.id, parent_id, ready_args.recursive)) {\n                try parent_filtered.append(allocator, issue);\n            } else {\n                var i = issue;\n                i.deinit(allocator);\n            }\n        }\n        allocator.free(issues);\n        issues = try parent_filtered.toOwnedSlice(allocator);\n    }\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);","originalFile":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getReadyIssues(ready_args.include_deferred);\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters (blocked command doesn't support overdue filter)\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":79,"oldLines":7,"newStart":79,"newLines":24,"lines":["     }"," ","     var graph = ctx.createGraph();","-    const issues = try graph.getReadyIssues(ready_args.include_deferred);","+    var issues = try graph.getReadyIssues(ready_args.include_deferred);","+","+    // Apply parent filter if specified (before other filters for efficiency)","+    if (ready_args.parent) |parent_id| {","+        var parent_filtered: std.ArrayListUnmanaged(Issue) = .{};","+        errdefer parent_filtered.deinit(allocator);","+","+        for (issues) |issue| {","+            if (graph.isChildOf(issue.id, parent_id, ready_args.recursive)) {","+                try parent_filtered.append(allocator, issue);","+            } else {","+                var i = issue;","+                i.deinit(allocator);","+            }","+        }","+        allocator.free(issues);","+        issues = try parent_filtered.toOwnedSlice(allocator);","+    }","     defer graph.freeIssues(issues);"," ","     // Apply filters"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016rjSFJDYMNTbUYFXheVzx7","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify the code compiles by running the build:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":589,"cache_read_input_tokens":100693,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":589},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d327b92b-ab24-44a4-b710-3a196a45854d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016rjSFJDYMNTbUYFXheVzx7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DYG9UhfwHqfvbC2dfWjsFA","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build to check for compilation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":589,"cache_read_input_tokens":100693,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":589},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"93bcb5fb-84b5-48e0-af91-9a053c280af5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DYG9UhfwHqfvbC2dfWjsFA","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"51d24bc3-a136-4d50-bc8e-7c7a3b9e44b0","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wv6sqNqKeaVWp5kfMxg9Jg","type":"message","role":"assistant","content":[{"type":"text","text":"Build succeeded. Let me run the tests to make sure everything works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":276,"cache_read_input_tokens":101282,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":276},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a9d0b909-f912-4d44-9fff-bd62495bdaf3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wv6sqNqKeaVWp5kfMxg9Jg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S1LS8r3G7bKq4nG4EiGaPP","name":"Bash","input":{"command":"zig build test 2>&1 | tail -50","description":"Run tests to verify implementation","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":276,"cache_read_input_tokens":101282,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":276},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"9ba4774d-a3f8-419b-857f-001cbfca3f5b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S1LS8r3G7bKq4nG4EiGaPP","type":"tool_result","content":"620/661 id.hash.test.contentHash different for different flags...OK\n621/661 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n622/661 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n623/661 id.hash.test.contentHash ignores id field...OK\n624/661 id.hash.test.contentHash ignores timestamps...OK\n625/661 id.hash.test.contentHash with custom status...OK\n626/661 id.hash.test.contentHash with custom issue_type...OK\n627/661 config.yaml.test.parse simple key-value...OK\n628/661 config.yaml.test.parse with comments...OK\n629/661 config.yaml.test.parse nested structure...OK\n630/661 config.yaml.test.parse quoted values...OK\n631/661 config.yaml.test.parse empty value...OK\n632/661 config.yaml.test.get returns null for missing key...OK\n633/661 config.yaml.test.parse handles Windows line endings...OK\n634/661 config.yaml.test.parse ignores blank lines...OK\n635/661 tests.cli_test.test.bz version shows version info...OK\n636/661 tests.cli_test.test.bz help shows usage...OK\n637/661 tests.cli_test.test.bz --help shows usage...OK\n638/661 tests.cli_test.test.bz init creates workspace...OK\n639/661 tests.cli_test.test.bz init fails when already initialized...OK\n640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 74 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c96a4154-14cd-4644-a017-63b899e7e13c","tool_use_result":{"stdout":"620/661 id.hash.test.contentHash different for different flags...OK\n621/661 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n622/661 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n623/661 id.hash.test.contentHash ignores id field...OK\n624/661 id.hash.test.contentHash ignores timestamps...OK\n625/661 id.hash.test.contentHash with custom status...OK\n626/661 id.hash.test.contentHash with custom issue_type...OK\n627/661 config.yaml.test.parse simple key-value...OK\n628/661 config.yaml.test.parse with comments...OK\n629/661 config.yaml.test.parse nested structure...OK\n630/661 config.yaml.test.parse quoted values...OK\n631/661 config.yaml.test.parse empty value...OK\n632/661 config.yaml.test.get returns null for missing key...OK\n633/661 config.yaml.test.parse handles Windows line endings...OK\n634/661 config.yaml.test.parse ignores blank lines...OK\n635/661 tests.cli_test.test.bz version shows version info...OK\n636/661 tests.cli_test.test.bz help shows usage...OK\n637/661 tests.cli_test.test.bz --help shows usage...OK\n638/661 tests.cli_test.test.bz init creates workspace...OK\n639/661 tests.cli_test.test.bz init fails when already initialized...OK\n640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 74 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LcnSBD3MgEMceZVswAUsgG","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Now let me mark Task 1 as complete and move to Task 2:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1050,"cache_read_input_tokens":101558,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1050},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"fd5eac61-9713-4daa-90fb-1365bfd335af"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LcnSBD3MgEMceZVswAUsgG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S4fNauahPRYKNSTdRLojEK","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"in_progress","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"pending","activeForm":"Creating single commit for all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1050,"cache_read_input_tokens":101558,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1050},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"01263085-ebb4-45ad-a81f-ddac14899055"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S4fNauahPRYKNSTdRLojEK","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b0f03a6c-97be-48fa-95ff-edf21ffa0f29","tool_use_result":{"oldTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"in_progress","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"pending","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"pending","activeForm":"Creating single commit for all changes"}],"newTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"in_progress","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"pending","activeForm":"Creating single commit for all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Tg7YcS3QtJMzbr8KwJLafX","type":"message","role":"assistant","content":[{"type":"text","text":"Now for Task 2: Add CSV output format with --fields option. I need to:\n\n1. Add `--format` flag to GlobalOptions (or as a command-level option)\n2. Add `--fields` flag to specify which fields to output\n3. Create a CSV formatter in the output module\n4. Apply it to list and ready commands\n\nLooking at the spec, the format should be:\n```bash\nbz list --format csv\nbz list --format csv --fields id,title,status,priority\n```\n\nLet me add the CSV output support. I'll add it as a command-level option for list/ready since it's specific to those:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":226,"cache_read_input_tokens":102608,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":226},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"5c44b270-b8db-43a2-a0d3-206db6f47e4a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Tg7YcS3QtJMzbr8KwJLafX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XZXVYKZniqMQfw9oZ5aCHu","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Sort field options for list command.\npub const SortField = enum {","new_string":"/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":226,"cache_read_input_tokens":102608,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":226},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"9b803079-9406-42e6-af1a-74d019ae1fc0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XZXVYKZniqMQfw9oZ5aCHu","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"20586660-1080-498d-92cb-61ff23a5af36","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Sort field options for list command.\npub const SortField = enum {","newString":"/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":199,"oldLines":6,"newStart":199,"newLines":18,"lines":["     dry_run: bool = false, // Show what would be imported without importing"," };"," ","+/// Output format for list/ready commands.","+pub const OutputFormat = enum {","+    default,","+    csv,","+","+    pub fn fromString(s: []const u8) ?OutputFormat {","+        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;","+        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;","+        return null;","+    }","+};","+"," /// Sort field options for list command."," pub const SortField = enum {","     created_at,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014YTmTszZDjVJH4ZRMGvNEH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017kpMQDTuB33ccrNbXJLjao","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};","new_string":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":465,"cache_read_input_tokens":102834,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":465},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"8255009b-0d3a-4ad3-9c73-46a5c4e2a5b5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017kpMQDTuB33ccrNbXJLjao","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"f58f99dd-18ad-4e3e-9d2d-a87a5983cfed","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};","newString":"/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":246,"oldLines":6,"newStart":246,"newLines":8,"lines":["     sort_desc: bool = true,","     parent: ?[]const u8 = null,","     recursive: bool = false,","+    format: OutputFormat = .default,","+    fields: ?[]const u8 = null,"," };"," "," /// Ready command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NAL8DB8HiUTKDiCanJzDX1","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the parsing for `parseListArgs`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":722,"cache_read_input_tokens":103299,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":722},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"3127dd0f-d563-42cd-a95d-c6116b06fc75"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NAL8DB8HiUTKDiCanJzDX1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VW7dDy6zmPoaGmbAiEYkoV","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs","new_string":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":722,"cache_read_input_tokens":103299,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":722},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"a7a7507d-e71d-4ae6-9f9a-0e8ce45d5d65"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VW7dDy6zmPoaGmbAiEYkoV","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"3808801b-f144-4d9f-8ea5-9c5786aad468","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs","newString":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1089,"oldLines":6,"newStart":1089,"newLines":11,"lines":["                 result.parent = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-r\", \"--recursive\")) {","                 result.recursive = true;","+            } else if (self.consumeFlag(\"-f\", \"--format\")) {","+                const fmt_str = self.next() orelse return error.MissingFlagValue;","+                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;","+            } else if (self.consumeFlag(null, \"--fields\")) {","+                result.fields = self.next() orelse return error.MissingFlagValue;","             } else break;","         }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014wq6WKAwZ1BsiRbogocD6h","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the CSV output functionality to the output module. Let me add a CSV writer function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":574,"cache_read_input_tokens":104021,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":574},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"58d0ee2f-d198-455b-aa82-7e6dee4a4c9e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014wq6WKAwZ1BsiRbogocD6h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DBL8ge9VnLQY3uE9fnJfUc","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","offset":690,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":574,"cache_read_input_tokens":104021,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":574},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"52e012c1-5d11-45d0-accc-f0cca4164c22"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DBL8ge9VnLQY3uE9fnJfUc","type":"tool_result","content":"   690→    issue.description = \"A test description\";\n   691→    issue.assignee = \"alice@example.com\";\n   692→\n   693→    // Verify all fields that would be printed\n   694→    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n   695→    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n   696→    try std.testing.expectEqual(Status.open, issue.status);\n   697→    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n   698→    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n   699→    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());\n   700→    try std.testing.expectEqualStrings(\"A test description\", issue.description.?);\n   701→    try std.testing.expectEqualStrings(\"alice@example.com\", issue.assignee.?);\n   702→}\n   703→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"cbeb19f3-d935-4dab-92b6-e56110a764e1","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/output/mod.zig","content":"    issue.description = \"A test description\";\n    issue.assignee = \"alice@example.com\";\n\n    // Verify all fields that would be printed\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());\n    try std.testing.expectEqualStrings(\"A test description\", issue.description.?);\n    try std.testing.expectEqualStrings(\"alice@example.com\", issue.assignee.?);\n}\n","numLines":14,"startLine":690,"totalLines":703}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01964miMkFruhjuDqRafuDZh","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add CSV output functionality. Let me add this after the existing formatters in the Output struct:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":479,"cache_read_input_tokens":104595,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":479},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"439478d3-29d5-4fbf-ba26-effc07489158"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01964miMkFruhjuDqRafuDZh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QBD2qfryJCGPT3LNVqaGNr","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","old_string":"    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n};","new_string":"    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    // ========================================================================\n    // CSV Mode Helpers\n    // ========================================================================\n\n    /// Available fields for CSV output.\n    pub const CsvField = enum {\n        id,\n        title,\n        status,\n        priority,\n        issue_type,\n        assignee,\n        owner,\n        description,\n        created_at,\n        updated_at,\n        due_at,\n        labels,\n\n        pub fn fromString(s: []const u8) ?CsvField {\n            if (std.mem.eql(u8, s, \"id\")) return .id;\n            if (std.mem.eql(u8, s, \"title\")) return .title;\n            if (std.mem.eql(u8, s, \"status\")) return .status;\n            if (std.mem.eql(u8, s, \"priority\")) return .priority;\n            if (std.mem.eql(u8, s, \"type\") or std.mem.eql(u8, s, \"issue_type\")) return .issue_type;\n            if (std.mem.eql(u8, s, \"assignee\")) return .assignee;\n            if (std.mem.eql(u8, s, \"owner\")) return .owner;\n            if (std.mem.eql(u8, s, \"description\") or std.mem.eql(u8, s, \"desc\")) return .description;\n            if (std.mem.eql(u8, s, \"created_at\") or std.mem.eql(u8, s, \"created\")) return .created_at;\n            if (std.mem.eql(u8, s, \"updated_at\") or std.mem.eql(u8, s, \"updated\")) return .updated_at;\n            if (std.mem.eql(u8, s, \"due_at\") or std.mem.eql(u8, s, \"due\")) return .due_at;\n            if (std.mem.eql(u8, s, \"labels\")) return .labels;\n            return null;\n        }\n\n        pub fn toString(self: CsvField) []const u8 {\n            return switch (self) {\n                .id => \"id\",\n                .title => \"title\",\n                .status => \"status\",\n                .priority => \"priority\",\n                .issue_type => \"type\",\n                .assignee => \"assignee\",\n                .owner => \"owner\",\n                .description => \"description\",\n                .created_at => \"created_at\",\n                .updated_at => \"updated_at\",\n                .due_at => \"due_at\",\n                .labels => \"labels\",\n            };\n        }\n    };\n\n    /// Default fields for CSV output.\n    pub const default_csv_fields = [_]CsvField{ .id, .title, .status, .priority };\n\n    /// Parse a comma-separated field list into CsvField array.\n    pub fn parseCsvFields(allocator: std.mem.Allocator, fields_str: ?[]const u8) ![]const CsvField {\n        if (fields_str) |str| {\n            var fields: std.ArrayListUnmanaged(CsvField) = .{};\n            errdefer fields.deinit(allocator);\n\n            var it = std.mem.splitSequence(u8, str, \",\");\n            while (it.next()) |field_name| {\n                const trimmed = std.mem.trim(u8, field_name, \" \");\n                if (CsvField.fromString(trimmed)) |field| {\n                    try fields.append(allocator, field);\n                }\n            }\n\n            if (fields.items.len == 0) {\n                return &default_csv_fields;\n            }\n            return fields.toOwnedSlice(allocator);\n        }\n        return &default_csv_fields;\n    }\n\n    /// Print a list of issues in CSV format.\n    pub fn printIssueListCsv(self: *Self, issues: []const Issue, fields: []const CsvField) !void {\n        // Write header\n        for (fields, 0..) |field, i| {\n            if (i > 0) try self.stdout.writeAll(\",\");\n            try self.stdout.writeAll(field.toString());\n        }\n        try self.stdout.writeAll(\"\\n\");\n\n        // Write data rows\n        for (issues) |issue| {\n            for (fields, 0..) |field, i| {\n                if (i > 0) try self.stdout.writeAll(\",\");\n                try self.writeCsvField(issue, field);\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n    }\n\n    fn writeCsvField(self: *Self, issue: Issue, field: CsvField) !void {\n        switch (field) {\n            .id => try self.writeCsvValue(issue.id),\n            .title => try self.writeCsvValue(issue.title),\n            .status => try self.writeCsvValue(issue.status.toString()),\n            .priority => try self.writeCsvValue(issue.priority.toString()),\n            .issue_type => try self.writeCsvValue(issue.issue_type.toString()),\n            .assignee => try self.writeCsvValue(issue.assignee orelse \"\"),\n            .owner => try self.writeCsvValue(issue.owner orelse \"\"),\n            .description => try self.writeCsvValue(issue.description orelse \"\"),\n            .created_at => {\n                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.created_at.value});\n                defer self.allocator.free(ts);\n                try self.writeCsvValue(ts);\n            },\n            .updated_at => {\n                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.updated_at.value});\n                defer self.allocator.free(ts);\n                try self.writeCsvValue(ts);\n            },\n            .due_at => {\n                if (issue.due_at.value) |due| {\n                    const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{due});\n                    defer self.allocator.free(ts);\n                    try self.writeCsvValue(ts);\n                } else {\n                    try self.stdout.writeAll(\"\");\n                }\n            },\n            .labels => {\n                if (issue.labels.len > 0) {\n                    const joined = try std.mem.join(self.allocator, \";\", issue.labels);\n                    defer self.allocator.free(joined);\n                    try self.writeCsvValue(joined);\n                } else {\n                    try self.stdout.writeAll(\"\");\n                }\n            },\n        }\n    }\n\n    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeByte(c);\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":479,"cache_read_input_tokens":104595,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":479},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1edd1880-c14d-4dbb-b75d-ffe7e9f6ef2b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QBD2qfryJCGPT3LNVqaGNr","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/output/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"0428e8a9-4ef1-4056-82d7-23b0b280f4d4","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/output/mod.zig","oldString":"    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n};","newString":"    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    // ========================================================================\n    // CSV Mode Helpers\n    // ========================================================================\n\n    /// Available fields for CSV output.\n    pub const CsvField = enum {\n        id,\n        title,\n        status,\n        priority,\n        issue_type,\n        assignee,\n        owner,\n        description,\n        created_at,\n        updated_at,\n        due_at,\n        labels,\n\n        pub fn fromString(s: []const u8) ?CsvField {\n            if (std.mem.eql(u8, s, \"id\")) return .id;\n            if (std.mem.eql(u8, s, \"title\")) return .title;\n            if (std.mem.eql(u8, s, \"status\")) return .status;\n            if (std.mem.eql(u8, s, \"priority\")) return .priority;\n            if (std.mem.eql(u8, s, \"type\") or std.mem.eql(u8, s, \"issue_type\")) return .issue_type;\n            if (std.mem.eql(u8, s, \"assignee\")) return .assignee;\n            if (std.mem.eql(u8, s, \"owner\")) return .owner;\n            if (std.mem.eql(u8, s, \"description\") or std.mem.eql(u8, s, \"desc\")) return .description;\n            if (std.mem.eql(u8, s, \"created_at\") or std.mem.eql(u8, s, \"created\")) return .created_at;\n            if (std.mem.eql(u8, s, \"updated_at\") or std.mem.eql(u8, s, \"updated\")) return .updated_at;\n            if (std.mem.eql(u8, s, \"due_at\") or std.mem.eql(u8, s, \"due\")) return .due_at;\n            if (std.mem.eql(u8, s, \"labels\")) return .labels;\n            return null;\n        }\n\n        pub fn toString(self: CsvField) []const u8 {\n            return switch (self) {\n                .id => \"id\",\n                .title => \"title\",\n                .status => \"status\",\n                .priority => \"priority\",\n                .issue_type => \"type\",\n                .assignee => \"assignee\",\n                .owner => \"owner\",\n                .description => \"description\",\n                .created_at => \"created_at\",\n                .updated_at => \"updated_at\",\n                .due_at => \"due_at\",\n                .labels => \"labels\",\n            };\n        }\n    };\n\n    /// Default fields for CSV output.\n    pub const default_csv_fields = [_]CsvField{ .id, .title, .status, .priority };\n\n    /// Parse a comma-separated field list into CsvField array.\n    pub fn parseCsvFields(allocator: std.mem.Allocator, fields_str: ?[]const u8) ![]const CsvField {\n        if (fields_str) |str| {\n            var fields: std.ArrayListUnmanaged(CsvField) = .{};\n            errdefer fields.deinit(allocator);\n\n            var it = std.mem.splitSequence(u8, str, \",\");\n            while (it.next()) |field_name| {\n                const trimmed = std.mem.trim(u8, field_name, \" \");\n                if (CsvField.fromString(trimmed)) |field| {\n                    try fields.append(allocator, field);\n                }\n            }\n\n            if (fields.items.len == 0) {\n                return &default_csv_fields;\n            }\n            return fields.toOwnedSlice(allocator);\n        }\n        return &default_csv_fields;\n    }\n\n    /// Print a list of issues in CSV format.\n    pub fn printIssueListCsv(self: *Self, issues: []const Issue, fields: []const CsvField) !void {\n        // Write header\n        for (fields, 0..) |field, i| {\n            if (i > 0) try self.stdout.writeAll(\",\");\n            try self.stdout.writeAll(field.toString());\n        }\n        try self.stdout.writeAll(\"\\n\");\n\n        // Write data rows\n        for (issues) |issue| {\n            for (fields, 0..) |field, i| {\n                if (i > 0) try self.stdout.writeAll(\",\");\n                try self.writeCsvField(issue, field);\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n    }\n\n    fn writeCsvField(self: *Self, issue: Issue, field: CsvField) !void {\n        switch (field) {\n            .id => try self.writeCsvValue(issue.id),\n            .title => try self.writeCsvValue(issue.title),\n            .status => try self.writeCsvValue(issue.status.toString()),\n            .priority => try self.writeCsvValue(issue.priority.toString()),\n            .issue_type => try self.writeCsvValue(issue.issue_type.toString()),\n            .assignee => try self.writeCsvValue(issue.assignee orelse \"\"),\n            .owner => try self.writeCsvValue(issue.owner orelse \"\"),\n            .description => try self.writeCsvValue(issue.description orelse \"\"),\n            .created_at => {\n                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.created_at.value});\n                defer self.allocator.free(ts);\n                try self.writeCsvValue(ts);\n            },\n            .updated_at => {\n                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.updated_at.value});\n                defer self.allocator.free(ts);\n                try self.writeCsvValue(ts);\n            },\n            .due_at => {\n                if (issue.due_at.value) |due| {\n                    const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{due});\n                    defer self.allocator.free(ts);\n                    try self.writeCsvValue(ts);\n                } else {\n                    try self.stdout.writeAll(\"\");\n                }\n            },\n            .labels => {\n                if (issue.labels.len > 0) {\n                    const joined = try std.mem.join(self.allocator, \";\", issue.labels);\n                    defer self.allocator.free(joined);\n                    try self.writeCsvValue(joined);\n                } else {\n                    try self.stdout.writeAll(\"\");\n                }\n            },\n        }\n    }\n\n    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeByte(c);\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};","originalFile":"//! Output formatting for beads_zig.\n//!\n//! Provides a unified interface for displaying output in different modes:\n//! - plain: No colors, basic formatting (default for non-TTY)\n//! - rich: Colors and formatting (default for TTY)\n//! - json: Structured JSON output for machine consumption\n//! - quiet: Minimal output (IDs only)\n//!\n//! Respects NO_COLOR environment variable and --no-color flag.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\n\n/// Output mode determines formatting and verbosity.\npub const OutputMode = enum {\n    plain, // No colors, basic formatting\n    rich, // Colors and formatting (TTY)\n    json, // Structured JSON output\n    quiet, // Minimal output (IDs only)\n};\n\n/// ANSI color escape codes.\npub const Color = struct {\n    pub const reset = \"\\x1b[0m\";\n    pub const bold = \"\\x1b[1m\";\n    pub const dim = \"\\x1b[2m\";\n    pub const italic = \"\\x1b[3m\";\n    pub const underline = \"\\x1b[4m\";\n\n    pub const red = \"\\x1b[31m\";\n    pub const green = \"\\x1b[32m\";\n    pub const yellow = \"\\x1b[33m\";\n    pub const blue = \"\\x1b[34m\";\n    pub const magenta = \"\\x1b[35m\";\n    pub const cyan = \"\\x1b[36m\";\n    pub const white = \"\\x1b[37m\";\n    pub const gray = \"\\x1b[90m\";\n\n    pub const bright_red = \"\\x1b[91m\";\n    pub const bright_green = \"\\x1b[92m\";\n    pub const bright_yellow = \"\\x1b[93m\";\n    pub const bright_blue = \"\\x1b[94m\";\n    pub const bright_magenta = \"\\x1b[95m\";\n    pub const bright_cyan = \"\\x1b[96m\";\n\n    pub const bg_red = \"\\x1b[41m\";\n    pub const bg_green = \"\\x1b[42m\";\n    pub const bg_yellow = \"\\x1b[43m\";\n    pub const bg_blue = \"\\x1b[44m\";\n};\n\n/// Global options that affect output formatting.\n/// This mirrors the relevant fields from cli.args.GlobalOptions.\npub const OutputOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    no_color: bool = false,\n};\n\n/// Output formatter for consistent CLI output across all modes.\npub const Output = struct {\n    mode: OutputMode,\n    toon: bool,\n    silent: bool, // Suppress ALL output including errors (for tests)\n    stdout: std.fs.File,\n    stderr: std.fs.File,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    /// Initialize output formatter based on global options and TTY detection.\n    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n        const stdout = std.fs.File.stdout();\n        const stderr = std.fs.File.stderr();\n\n        var mode: OutputMode = .plain;\n        if (opts.json or opts.toon) {\n            mode = .json;\n        } else if (opts.quiet or opts.silent) {\n            mode = .quiet;\n        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n            mode = .rich;\n        }\n\n        return .{\n            .mode = mode,\n            .toon = opts.toon,\n            .silent = opts.silent,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize with explicit mode (useful for testing).\n    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize for testing with custom file handles.\n    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize with silent mode (suppresses ALL output including errors).\n    pub fn initSilent(allocator: std.mem.Allocator) Self {\n        return .{\n            .mode = .quiet,\n            .toon = false,\n            .silent = true,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n        };\n    }\n\n    // ========================================================================\n    // Issue Display\n    // ========================================================================\n\n    /// Print a single issue in the appropriate format.\n    pub fn printIssue(self: *Self, issue: Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueJson(issue),\n            .quiet => try self.printIssueQuiet(issue),\n            .rich => try self.printIssueRich(issue),\n            .plain => try self.printIssuePlain(issue),\n        }\n    }\n\n    /// Print a list of issues in the appropriate format.\n    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueListJson(issues),\n            .quiet => try self.printIssueListQuiet(issues),\n            .rich => try self.printIssueListRich(issues),\n            .plain => try self.printIssueListPlain(issues),\n        }\n    }\n\n    // ========================================================================\n    // Generic Messages\n    // ========================================================================\n\n    /// Print a formatted message to stdout.\n    pub fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    /// Print a formatted message to stdout with newline.\n    pub fn println(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        const msg = try std.fmt.allocPrint(self.allocator, fmt ++ \"\\n\", args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    /// Print a success message (green in rich mode).\n    pub fn success(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stdout.writeAll(Color.green);\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    /// Print an error message to stderr (red in rich mode).\n    pub fn err(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.silent) return;\n        if (self.mode == .rich) try self.stderr.writeAll(Color.red);\n        const msg = try std.fmt.allocPrint(self.allocator, \"error: \" ++ fmt, args);\n        defer self.allocator.free(msg);\n        try self.stderr.writeAll(msg);\n        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n        try self.stderr.writeAll(\"\\n\");\n    }\n\n    /// Print a warning message to stderr (yellow in rich mode).\n    pub fn warn(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.silent or self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stderr.writeAll(Color.yellow);\n        const msg = try std.fmt.allocPrint(self.allocator, \"warning: \" ++ fmt, args);\n        defer self.allocator.free(msg);\n        try self.stderr.writeAll(msg);\n        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n        try self.stderr.writeAll(\"\\n\");\n    }\n\n    /// Print an info message (cyan in rich mode).\n    pub fn info(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stdout.writeAll(Color.cyan);\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    /// Print raw bytes to stdout (bypasses mode checks).\n    pub fn raw(self: *Self, bytes: []const u8) !void {\n        try self.stdout.writeAll(bytes);\n    }\n\n    /// Print raw JSON value to stdout (for JSON mode).\n    /// If toon mode is enabled, converts JSON to TOON format for reduced token usage.\n    pub fn printJson(self: *Self, value: anytype) !void {\n        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n        defer self.allocator.free(json_bytes);\n\n        if (self.toon) {\n            const toon = @import(\"toon_zig\");\n            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |convert_err| {\n                try self.stderr.writeAll(\"error: failed to convert to TOON format\\n\");\n                return convert_err;\n            };\n            defer self.allocator.free(toon_bytes);\n            try self.stdout.writeAll(toon_bytes);\n        } else {\n            try self.stdout.writeAll(json_bytes);\n        }\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    // ========================================================================\n    // JSON Mode Helpers\n    // ========================================================================\n\n    fn printIssueJson(self: *Self, issue: Issue) !void {\n        try self.printJson(issue);\n    }\n\n    fn printIssueListJson(self: *Self, issues: []const Issue) !void {\n        try self.printJson(issues);\n    }\n\n    // ========================================================================\n    // Plain Mode Helpers\n    // ========================================================================\n\n    fn printIssuePlain(self: *Self, issue: Issue) !void {\n        try self.writeFormatted(\"ID: {s}\\n\", .{issue.id});\n        try self.writeFormatted(\"Title: {s}\\n\", .{issue.title});\n        try self.writeFormatted(\"Status: {s}\\n\", .{issue.status.toString()});\n        try self.writeFormatted(\"Priority: {s}\\n\", .{issue.priority.toString()});\n        try self.writeFormatted(\"Type: {s}\\n\", .{issue.issue_type.toString()});\n\n        if (issue.description) |desc| {\n            try self.writeFormatted(\"Description: {s}\\n\", .{desc});\n        }\n        if (issue.assignee) |assignee| {\n            try self.writeFormatted(\"Assignee: {s}\\n\", .{assignee});\n        }\n        if (issue.labels.len > 0) {\n            try self.stdout.writeAll(\"Labels: \");\n            for (issue.labels, 0..) |label, i| {\n                if (i > 0) try self.stdout.writeAll(\", \");\n                try self.stdout.writeAll(label);\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n        if (issue.due_at.value) |due| {\n            try self.writeFormatted(\"Due: {d}\\n\", .{due});\n        }\n\n        try self.writeFormatted(\"Created: {d}\\n\", .{issue.created_at.value});\n        try self.writeFormatted(\"Updated: {d}\\n\", .{issue.updated_at.value});\n    }\n\n    fn printIssueListPlain(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            const status_abbrev = abbreviateStatus(issue.status);\n            try self.writeFormatted(\"{s}  [{s}] {s}\\n\", .{\n                issue.id,\n                status_abbrev,\n                issue.title,\n            });\n        }\n    }\n\n    // ========================================================================\n    // Rich Mode Helpers (ANSI colors)\n    // ========================================================================\n\n    fn printIssueRich(self: *Self, issue: Issue) !void {\n        // Bold ID\n        try self.writeFormatted(\"{s}{s}{s}\\n\", .{ Color.bold, issue.id, Color.reset });\n\n        // Title\n        try self.writeFormatted(\"  {s}\\n\", .{issue.title});\n\n        // Status with color\n        const status_color = getStatusColor(issue.status);\n        try self.writeFormatted(\"  Status: {s}{s}{s}\\n\", .{ status_color, issue.status.toString(), Color.reset });\n\n        // Priority with color\n        const priority_color = getPriorityColor(issue.priority);\n        try self.writeFormatted(\"  Priority: {s}{s}{s}\\n\", .{ priority_color, issue.priority.toString(), Color.reset });\n\n        // Type\n        try self.writeFormatted(\"  Type: {s}\\n\", .{issue.issue_type.toString()});\n\n        // Optional fields\n        if (issue.description) |desc| {\n            try self.writeFormatted(\"  Description: {s}{s}{s}\\n\", .{ Color.dim, desc, Color.reset });\n        }\n        if (issue.assignee) |assignee| {\n            try self.writeFormatted(\"  Assignee: {s}{s}{s}\\n\", .{ Color.cyan, assignee, Color.reset });\n        }\n        if (issue.labels.len > 0) {\n            try self.stdout.writeAll(\"  Labels: \");\n            for (issue.labels, 0..) |label, i| {\n                if (i > 0) try self.stdout.writeAll(\", \");\n                try self.writeFormatted(\"{s}{s}{s}\", .{ Color.magenta, label, Color.reset });\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n    }\n\n    fn printIssueListRich(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            const status_color = getStatusColor(issue.status);\n            const priority_color = getPriorityColor(issue.priority);\n            const status_abbrev = abbreviateStatus(issue.status);\n\n            try self.writeFormatted(\"{s}{s}{s}  {s}[{s}]{s}  {s}{s}{s}  {s}\\n\", .{\n                Color.bold,\n                issue.id,\n                Color.reset,\n                status_color,\n                status_abbrev,\n                Color.reset,\n                priority_color,\n                priorityIndicator(issue.priority),\n                Color.reset,\n                issue.title,\n            });\n        }\n    }\n\n    // ========================================================================\n    // Quiet Mode Helpers\n    // ========================================================================\n\n    fn printIssueQuiet(self: *Self, issue: Issue) !void {\n        try self.writeFormatted(\"{s}\\n\", .{issue.id});\n    }\n\n    fn printIssueListQuiet(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            try self.writeFormatted(\"{s}\\n\", .{issue.id});\n        }\n    }\n\n    // ========================================================================\n    // Internal Helpers\n    // ========================================================================\n\n    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n};\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/// Check if NO_COLOR environment variable is set (cross-platform).\nfn checkNoColorEnv() bool {\n    // Per NO_COLOR spec, only existence matters, not the value\n    return std.process.hasEnvVarConstant(\"NO_COLOR\");\n}\n\n/// Get ANSI color for a status.\nfn getStatusColor(status: Status) []const u8 {\n    return switch (status) {\n        .open => Color.green,\n        .in_progress => Color.yellow,\n        .blocked => Color.red,\n        .deferred => Color.gray,\n        .closed => Color.gray,\n        .tombstone => Color.dim,\n        .pinned => Color.bright_cyan,\n        .custom => Color.blue,\n    };\n}\n\n/// Get ANSI color for a priority.\nfn getPriorityColor(priority: Priority) []const u8 {\n    return switch (priority.value) {\n        0 => Color.bright_red, // critical\n        1 => Color.red, // high\n        2 => Color.yellow, // medium\n        3 => Color.green, // low\n        4 => Color.gray, // backlog\n        else => Color.reset,\n    };\n}\n\n/// Get short status abbreviation.\nfn abbreviateStatus(status: Status) []const u8 {\n    return switch (status) {\n        .open => \"OPEN\",\n        .in_progress => \"PROG\",\n        .blocked => \"BLKD\",\n        .deferred => \"DEFR\",\n        .closed => \"DONE\",\n        .tombstone => \"DEL \",\n        .pinned => \"PIN \",\n        .custom => \"CUST\",\n    };\n}\n\n/// Get priority indicator symbol.\nfn priorityIndicator(priority: Priority) []const u8 {\n    return switch (priority.value) {\n        0 => \"!!!\",\n        1 => \"!! \",\n        2 => \"!  \",\n        3 => \".  \",\n        4 => \"   \",\n        else => \"   \",\n    };\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\ntest \"OutputMode enum values\" {\n    try std.testing.expectEqual(OutputMode.plain, OutputMode.plain);\n    try std.testing.expectEqual(OutputMode.rich, OutputMode.rich);\n    try std.testing.expectEqual(OutputMode.json, OutputMode.json);\n    try std.testing.expectEqual(OutputMode.quiet, OutputMode.quiet);\n}\n\ntest \"Output.init with json option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .json = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n    try std.testing.expect(!output.toon);\n}\n\ntest \"Output.init with toon option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .toon = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n    try std.testing.expect(output.toon);\n}\n\ntest \"Output.init with quiet option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .quiet = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n}\n\ntest \"Output.init with no_color option forces plain mode\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .no_color = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.plain, output.mode);\n}\n\ntest \"Output.init json overrides quiet\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .json = true, .quiet = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n}\n\ntest \"Output.initWithMode sets explicit mode\" {\n    const allocator = std.testing.allocator;\n    const output = Output.initWithMode(allocator, .rich);\n    try std.testing.expectEqual(OutputMode.rich, output.mode);\n}\n\ntest \"abbreviateStatus returns 4-char strings\" {\n    const statuses = [_]Status{\n        .open,\n        .in_progress,\n        .blocked,\n        .deferred,\n        .closed,\n        .tombstone,\n        .pinned,\n        .{ .custom = \"test\" },\n    };\n    for (statuses) |status| {\n        const abbrev = abbreviateStatus(status);\n        try std.testing.expectEqual(@as(usize, 4), abbrev.len);\n    }\n}\n\ntest \"priorityIndicator returns 3-char strings\" {\n    var p: u3 = 0;\n    while (p <= 4) : (p += 1) {\n        const priority = Priority{ .value = p };\n        const indicator = priorityIndicator(priority);\n        try std.testing.expectEqual(@as(usize, 3), indicator.len);\n    }\n}\n\ntest \"getStatusColor returns valid ANSI codes\" {\n    const statuses = [_]Status{\n        .open,\n        .in_progress,\n        .blocked,\n        .deferred,\n        .closed,\n        .tombstone,\n        .pinned,\n        .{ .custom = \"test\" },\n    };\n    for (statuses) |status| {\n        const color = getStatusColor(status);\n        try std.testing.expect(color.len > 0);\n        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n    }\n}\n\ntest \"getPriorityColor returns valid ANSI codes\" {\n    var p: u3 = 0;\n    while (p <= 4) : (p += 1) {\n        const priority = Priority{ .value = p };\n        const color = getPriorityColor(priority);\n        try std.testing.expect(color.len > 0);\n        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n    }\n}\n\ntest \"Color constants are valid ANSI escape sequences\" {\n    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.red, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.yellow, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.blue, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.gray, \"\\x1b[\"));\n}\n\ntest \"Output printIssueListQuiet writes IDs only\" {\n    // Test the quiet formatting logic directly\n    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n    const issues = [_]Issue{ issue1, issue2 };\n\n    // In quiet mode, printIssueListQuiet outputs \"{id}\\n\" for each issue\n    // Verify the expected output format\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue1.id);\n    try std.testing.expectEqualStrings(\"bd-def456\", issue2.id);\n    try std.testing.expectEqual(@as(usize, 2), issues.len);\n}\n\ntest \"Output printIssueListPlain writes formatted lines\" {\n    // Test the plain formatting logic via abbreviateStatus and Issue fields\n    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n\n    // Verify issue fields are correct\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n\n    // Verify status abbreviation\n    const status_abbrev = abbreviateStatus(issue.status);\n    try std.testing.expectEqualStrings(\"OPEN\", status_abbrev);\n}\n\ntest \"Output printIssueListRich includes ANSI codes\" {\n    // Test that rich mode formatting uses ANSI codes\n    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n\n    // Verify issue fields\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n\n    // Verify rich mode uses color codes\n    const status_color = getStatusColor(issue.status);\n    try std.testing.expect(std.mem.startsWith(u8, status_color, \"\\x1b[\"));\n\n    const priority_color = getPriorityColor(issue.priority);\n    try std.testing.expect(std.mem.startsWith(u8, priority_color, \"\\x1b[\"));\n\n    // Verify Color.bold is used\n    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n}\n\ntest \"Output printIssueListJson produces valid JSON array\" {\n    const allocator = std.testing.allocator;\n\n    // Test JSON serialization directly\n    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n    const issues = [_]Issue{ issue1, issue2 };\n\n    // Serialize to JSON\n    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n    defer allocator.free(json_bytes);\n\n    // Verify it starts with [ and contains expected data\n    try std.testing.expect(std.mem.startsWith(u8, json_bytes, \"[\"));\n    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-abc123\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-def456\") != null);\n\n    // Verify it can be parsed back\n    const parsed = try std.json.parseFromSlice([]const Issue, allocator, json_bytes, .{});\n    defer parsed.deinit();\n    try std.testing.expectEqual(@as(usize, 2), parsed.value.len);\n}\n\ntest \"Output.err formats error messages correctly\" {\n    const allocator = std.testing.allocator;\n\n    // Test the error message formatting\n    const msg = try std.fmt.allocPrint(allocator, \"error: \" ++ \"something went wrong: {s}\", .{\"test error\"});\n    defer allocator.free(msg);\n\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"error:\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"test error\") != null);\n}\n\ntest \"Output.warn formats warning messages correctly\" {\n    const allocator = std.testing.allocator;\n\n    // Test the warning message formatting\n    const msg = try std.fmt.allocPrint(allocator, \"warning: \" ++ \"this is a warning: {s}\", .{\"be careful\"});\n    defer allocator.free(msg);\n\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"warning:\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"be careful\") != null);\n}\n\ntest \"Output quiet mode suppresses print but not err\" {\n    const allocator = std.testing.allocator;\n\n    // Test quiet mode behavior through Output struct logic\n    const output = Output.initWithMode(allocator, .quiet);\n\n    // Verify quiet mode is set\n    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n\n    // The print/println/success/warn methods check mode == .quiet and return early\n    // The err method does NOT check for quiet mode (always prints)\n    // This is the documented behavior we're testing\n}\n\ntest \"Output.success uses green color in rich mode\" {\n    const allocator = std.testing.allocator;\n\n    // Test that success would use green color in rich mode\n    const output = Output.initWithMode(allocator, .rich);\n    try std.testing.expectEqual(OutputMode.rich, output.mode);\n\n    // Verify Color.green is a valid ANSI escape\n    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n}\n\ntest \"Output.printIssue in plain mode shows all fields\" {\n    // Test issue field access and formatting\n    var issue = Issue.init(\"bd-abc123\", \"Test issue title\", 1706540000);\n    issue.description = \"A test description\";\n    issue.assignee = \"alice@example.com\";\n\n    // Verify all fields that would be printed\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());\n    try std.testing.expectEqualStrings(\"A test description\", issue.description.?);\n    try std.testing.expectEqualStrings(\"alice@example.com\", issue.assignee.?);\n}\n","structuredPatch":[{"oldStart":386,"oldLines":6,"newStart":386,"newLines":164,"lines":["         defer self.allocator.free(msg);","         try self.stdout.writeAll(msg);","     }","+","+    // ========================================================================","+    // CSV Mode Helpers","+    // ========================================================================","+","+    /// Available fields for CSV output.","+    pub const CsvField = enum {","+        id,","+        title,","+        status,","+        priority,","+        issue_type,","+        assignee,","+        owner,","+        description,","+        created_at,","+        updated_at,","+        due_at,","+        labels,","+","+        pub fn fromString(s: []const u8) ?CsvField {","+            if (std.mem.eql(u8, s, \"id\")) return .id;","+            if (std.mem.eql(u8, s, \"title\")) return .title;","+            if (std.mem.eql(u8, s, \"status\")) return .status;","+            if (std.mem.eql(u8, s, \"priority\")) return .priority;","+            if (std.mem.eql(u8, s, \"type\") or std.mem.eql(u8, s, \"issue_type\")) return .issue_type;","+            if (std.mem.eql(u8, s, \"assignee\")) return .assignee;","+            if (std.mem.eql(u8, s, \"owner\")) return .owner;","+            if (std.mem.eql(u8, s, \"description\") or std.mem.eql(u8, s, \"desc\")) return .description;","+            if (std.mem.eql(u8, s, \"created_at\") or std.mem.eql(u8, s, \"created\")) return .created_at;","+            if (std.mem.eql(u8, s, \"updated_at\") or std.mem.eql(u8, s, \"updated\")) return .updated_at;","+            if (std.mem.eql(u8, s, \"due_at\") or std.mem.eql(u8, s, \"due\")) return .due_at;","+            if (std.mem.eql(u8, s, \"labels\")) return .labels;","+            return null;","+        }","+","+        pub fn toString(self: CsvField) []const u8 {","+            return switch (self) {","+                .id => \"id\",","+                .title => \"title\",","+                .status => \"status\",","+                .priority => \"priority\",","+                .issue_type => \"type\",","+                .assignee => \"assignee\",","+                .owner => \"owner\",","+                .description => \"description\",","+                .created_at => \"created_at\",","+                .updated_at => \"updated_at\",","+                .due_at => \"due_at\",","+                .labels => \"labels\",","+            };","+        }","+    };","+","+    /// Default fields for CSV output.","+    pub const default_csv_fields = [_]CsvField{ .id, .title, .status, .priority };","+","+    /// Parse a comma-separated field list into CsvField array.","+    pub fn parseCsvFields(allocator: std.mem.Allocator, fields_str: ?[]const u8) ![]const CsvField {","+        if (fields_str) |str| {","+            var fields: std.ArrayListUnmanaged(CsvField) = .{};","+            errdefer fields.deinit(allocator);","+","+            var it = std.mem.splitSequence(u8, str, \",\");","+            while (it.next()) |field_name| {","+                const trimmed = std.mem.trim(u8, field_name, \" \");","+                if (CsvField.fromString(trimmed)) |field| {","+                    try fields.append(allocator, field);","+                }","+            }","+","+            if (fields.items.len == 0) {","+                return &default_csv_fields;","+            }","+            return fields.toOwnedSlice(allocator);","+        }","+        return &default_csv_fields;","+    }","+","+    /// Print a list of issues in CSV format.","+    pub fn printIssueListCsv(self: *Self, issues: []const Issue, fields: []const CsvField) !void {","+        // Write header","+        for (fields, 0..) |field, i| {","+            if (i > 0) try self.stdout.writeAll(\",\");","+            try self.stdout.writeAll(field.toString());","+        }","+        try self.stdout.writeAll(\"\\n\");","+","+        // Write data rows","+        for (issues) |issue| {","+            for (fields, 0..) |field, i| {","+                if (i > 0) try self.stdout.writeAll(\",\");","+                try self.writeCsvField(issue, field);","+            }","+            try self.stdout.writeAll(\"\\n\");","+        }","+    }","+","+    fn writeCsvField(self: *Self, issue: Issue, field: CsvField) !void {","+        switch (field) {","+            .id => try self.writeCsvValue(issue.id),","+            .title => try self.writeCsvValue(issue.title),","+            .status => try self.writeCsvValue(issue.status.toString()),","+            .priority => try self.writeCsvValue(issue.priority.toString()),","+            .issue_type => try self.writeCsvValue(issue.issue_type.toString()),","+            .assignee => try self.writeCsvValue(issue.assignee orelse \"\"),","+            .owner => try self.writeCsvValue(issue.owner orelse \"\"),","+            .description => try self.writeCsvValue(issue.description orelse \"\"),","+            .created_at => {","+                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.created_at.value});","+                defer self.allocator.free(ts);","+                try self.writeCsvValue(ts);","+            },","+            .updated_at => {","+                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.updated_at.value});","+                defer self.allocator.free(ts);","+                try self.writeCsvValue(ts);","+            },","+            .due_at => {","+                if (issue.due_at.value) |due| {","+                    const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{due});","+                    defer self.allocator.free(ts);","+                    try self.writeCsvValue(ts);","+                } else {","+                    try self.stdout.writeAll(\"\");","+                }","+            },","+            .labels => {","+                if (issue.labels.len > 0) {","+                    const joined = try std.mem.join(self.allocator, \";\", issue.labels);","+                    defer self.allocator.free(joined);","+                    try self.writeCsvValue(joined);","+                } else {","+                    try self.stdout.writeAll(\"\");","+                }","+            },","+        }","+    }","+","+    /// Write a CSV value with proper escaping.","+    fn writeCsvValue(self: *Self, value: []const u8) !void {","+        // Check if escaping is needed (contains comma, quote, or newline)","+        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;","+","+        if (needs_quoting) {","+            try self.stdout.writeAll(\"\\\"\");","+            for (value) |c| {","+                if (c == '\"') {","+                    try self.stdout.writeAll(\"\\\"\\\"\");","+                } else {","+                    try self.stdout.writeByte(c);","+                }","+            }","+            try self.stdout.writeAll(\"\\\"\");","+        } else {","+            try self.stdout.writeAll(value);","+        }","+    }"," };"," "," // ============================================================================"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HbNuxnqAomwjGhhH41yo9X","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the list.zig to use the CSV output format:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2208,"cache_read_input_tokens":105074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2208},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"164ce813-0cc2-4f30-8634-5cc7c091ca51"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HbNuxnqAomwjGhhH41yo9X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XaNyzz4iKAsWTSVkxcvYA7","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/list.zig","old_string":"    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}","new_string":"    // Handle CSV output format\n    if (list_args.format == .csv) {\n        const Output = common.Output;\n        const fields = try Output.parseCsvFields(allocator, list_args.fields);\n        defer if (list_args.fields != null) allocator.free(fields);\n        try ctx.output.printIssueListCsv(issues, fields);\n        return;\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2208,"cache_read_input_tokens":105074,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2208},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"533d2277-3b9f-47da-a4d1-1a22130e9eee"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XaNyzz4iKAsWTSVkxcvYA7","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/list.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"cd2d34c5-efab-4446-99b7-48a0656a59ff","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/list.zig","oldString":"    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}","newString":"    // Handle CSV output format\n    if (list_args.format == .csv) {\n        const Output = common.Output;\n        const fields = try Output.parseCsvFields(allocator, list_args.fields);\n        defer if (list_args.fields != null) allocator.free(fields);\n        try ctx.output.printIssueListCsv(issues, fields);\n        return;\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}","originalFile":"//! List command for beads_zig.\n//!\n//! `bz list [--status X] [--priority X] [--type X] [--assignee X] [--label X] [-n LIMIT] [--all]`\n//!\n//! Lists issues with optional filters.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\n\npub const ListError = error{\n    WorkspaceNotInitialized,\n    InvalidFilter,\n    StorageError,\n    OutOfMemory,\n};\n\npub const ListResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        status: []const u8,\n        priority: u3,\n        issue_type: []const u8,\n        assignee: ?[]const u8 = null,\n    };\n};\n\npub fn run(\n    list_args: args.ListArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ListError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n\n    if (list_args.status) |s| {\n        filters.status = Status.fromString(s);\n    } else if (!list_args.all) {\n        filters.status = .open;\n    }\n\n    if (list_args.priority) |p| {\n        filters.priority = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_min) |p| {\n        filters.priority_min = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-min value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.priority_max) |p| {\n        filters.priority_max = Priority.fromString(p) catch {\n            try outputError(&ctx.output, global.isStructuredOutput(), \"invalid priority-max value\");\n            return ListError.InvalidFilter;\n        };\n    }\n\n    if (list_args.issue_type) |t| {\n        filters.issue_type = IssueType.fromString(t);\n    }\n\n    if (list_args.assignee) |a| {\n        filters.assignee = a;\n    }\n\n    if (list_args.label) |l| {\n        filters.label = l;\n    }\n\n    if (list_args.label_any.len > 0) {\n        filters.label_any = list_args.label_any;\n    }\n\n    if (list_args.title_contains) |t| {\n        filters.title_contains = t;\n    }\n\n    if (list_args.desc_contains) |d| {\n        filters.desc_contains = d;\n    }\n\n    if (list_args.notes_contains) |n| {\n        filters.notes_contains = n;\n    }\n\n    if (list_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    // Apply overdue filter\n    filters.overdue = list_args.overdue;\n\n    // Apply include_deferred filter\n    filters.include_deferred = list_args.include_deferred;\n\n    // Apply sort options\n    filters.order_by = switch (list_args.sort) {\n        .created_at => .created_at,\n        .updated_at => .updated_at,\n        .priority => .priority,\n    };\n    filters.order_desc = list_args.sort_desc;\n\n    var issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    // Apply parent filter if specified\n    if (list_args.parent) |parent_id| {\n        var graph = ctx.createGraph();\n        var filtered: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer filtered.deinit(allocator);\n\n        for (issues) |issue| {\n            if (graph.isChildOf(issue.id, parent_id, list_args.recursive)) {\n                try filtered.append(allocator, issue);\n            } else {\n                var i = issue;\n                i.deinit(allocator);\n            }\n        }\n        allocator.free(issues);\n        issues = try filtered.toOwnedSlice(allocator);\n    }\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);\n        defer allocator.free(compact_issues);\n\n        for (issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .status = issue.status.toString(),\n                .priority = issue.priority.value,\n                .issue_type = issue.issue_type.toString(),\n                .assignee = issue.assignee,\n            };\n        }\n\n        try ctx.output.printJson(ListResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(issues);\n        if (!global.quiet and issues.len == 0) {\n            try ctx.output.info(\"No issues found\", .{});\n        }\n    }\n}\n\nfn outputError(output: *common.Output, structured_mode: bool, message: []const u8) !void {\n    if (structured_mode) {\n        try output.printJson(ListResult{\n            .success = false,\n            .message = message,\n        });\n    } else {\n        try output.err(\"{s}\", .{message});\n    }\n}\n\n// --- Tests ---\n\ntest \"ListError enum exists\" {\n    const err: ListError = ListError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ListError.WorkspaceNotInitialized);\n}\n\ntest \"ListResult struct works\" {\n    const result = ListResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const list_args = args.ListArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(list_args, global, allocator);\n    try std.testing.expectError(ListError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"list_success\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const list_args = args.ListArgs{ .all = true };\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(list_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":152,"oldLines":6,"newStart":152,"newLines":15,"lines":["         issues = try filtered.toOwnedSlice(allocator);","     }"," ","+    // Handle CSV output format","+    if (list_args.format == .csv) {","+        const Output = common.Output;","+        const fields = try Output.parseCsvFields(allocator, list_args.fields);","+        defer if (list_args.fields != null) allocator.free(fields);","+        try ctx.output.printIssueListCsv(issues, fields);","+        return;","+    }","+","     if (global.isStructuredOutput()) {","         var compact_issues = try allocator.alloc(ListResult.IssueCompact, issues.len);","         defer allocator.free(compact_issues);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Hqooi4LdyfJQPz6B3G8uEE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also add this to the `ready.zig` command. First, let me add format and fields to ReadyArgs:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":952,"cache_read_input_tokens":107282,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":952},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"fa0ca920-462a-4bd3-8f8c-7671a53e60aa"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Hqooi4LdyfJQPz6B3G8uEE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FKvDJJ78Y4FCM8X66RzB6o","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};","new_string":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":952,"cache_read_input_tokens":107282,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":952},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"74b699ab-439d-4ae4-9ebe-2027c26f1d0c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FKvDJJ78Y4FCM8X66RzB6o","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2e4626a7-2b49-4b40-be63-78a542820fed","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};","newString":"/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":262,"oldLines":6,"newStart":262,"newLines":8,"lines":["     include_deferred: bool = false,","     parent: ?[]const u8 = null,","     recursive: bool = false,","+    format: OutputFormat = .default,","+    fields: ?[]const u8 = null,"," };"," "," /// Blocked command arguments."]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015ZH6yadGUJFYtnRqsXgyrw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016pAEbte4BqR18NMeY6vzZw","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs","new_string":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":508,"cache_read_input_tokens":108234,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":508},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b3b58d18-4753-494c-afc6-c9780759aa0d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016pAEbte4BqR18NMeY6vzZw","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c82db3d4-e894-433d-802a-74af94e4f981","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs","newString":"            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: void,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    id: []const u8,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    tree: struct {\n        id: []const u8,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    version: ?[]const u8 = null,\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // Parse global flags first\n        while (self.hasNext()) {\n            const arg = self.peek().?;\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (self.parseGlobalFlag(&global)) |consumed| {\n                    if (!consumed) break;\n                } else |_| {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Parse subcommand\n        const cmd_str = self.next() orelse {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        };\n\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            return .{ .subcommand = .{ .tree = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        var result = AuditArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":1129,"oldLines":6,"newStart":1129,"newLines":11,"lines":["                 result.parent = self.next() orelse return error.MissingFlagValue;","             } else if (self.consumeFlag(\"-r\", \"--recursive\")) {","                 result.recursive = true;","+            } else if (self.consumeFlag(\"-f\", \"--format\")) {","+                const fmt_str = self.next() orelse return error.MissingFlagValue;","+                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;","+            } else if (self.consumeFlag(null, \"--fields\")) {","+                result.fields = self.next() orelse return error.MissingFlagValue;","             } else break;","         }","         return result;"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XknqxEVMMAi8jWqTMfQVg5","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update ready.zig to support CSV output:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":453,"cache_read_input_tokens":108742,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":453},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"add096f1-c870-46d9-b821-cc69bd26598f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XknqxEVMMAi8jWqTMfQVg5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016xkZJynQDMdeQQ9AMeMK8N","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/ready.zig","old_string":"    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {","new_string":"    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    // Handle CSV output format\n    if (ready_args.format == .csv) {\n        const Output = common.Output;\n        const fields = try Output.parseCsvFields(allocator, ready_args.fields);\n        defer if (ready_args.fields != null) allocator.free(fields);\n        try ctx.output.printIssueListCsv(display_issues, fields);\n        return;\n    }\n\n    if (global.isStructuredOutput()) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":453,"cache_read_input_tokens":108742,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":453},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"fe8fa596-76c9-427d-b217-d6da1f288193"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016xkZJynQDMdeQQ9AMeMK8N","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/ready.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"58769847-ef1e-4ce7-a28f-2ea12ed798b9","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/ready.zig","oldString":"    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {","newString":"    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    // Handle CSV output format\n    if (ready_args.format == .csv) {\n        const Output = common.Output;\n        const fields = try Output.parseCsvFields(allocator, ready_args.fields);\n        defer if (ready_args.fields != null) allocator.free(fields);\n        try ctx.output.printIssueListCsv(display_issues, fields);\n        return;\n    }\n\n    if (global.isStructuredOutput()) {","originalFile":"//! Ready and blocked commands for beads_zig.\n//!\n//! `bz ready [-n LIMIT]` - Show issues ready to work on (no blockers)\n//! `bz blocked [-n LIMIT]` - Show blocked issues\n//!\n//! Workflow queries for finding actionable work.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst store = @import(\"../storage/store.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst Priority = models.Priority;\nconst CommandContext = common.CommandContext;\nconst DependencyGraph = common.DependencyGraph;\nconst containsIgnoreCase = store.containsIgnoreCase;\n\npub const ReadyError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidFilter,\n};\n\npub const ReadyResult = struct {\n    success: bool,\n    issues: ?[]const IssueCompact = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const IssueCompact = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n    };\n};\n\npub const BlockedResult = struct {\n    success: bool,\n    issues: ?[]const BlockedIssue = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    const BlockedIssue = struct {\n        id: []const u8,\n        title: []const u8,\n        priority: u3,\n        blocked_by: []const []const u8,\n    };\n};\n\npub fn run(\n    ready_args: args.ReadyArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (ready_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (ready_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    var issues = try graph.getReadyIssues(ready_args.include_deferred);\n\n    // Apply parent filter if specified (before other filters for efficiency)\n    if (ready_args.parent) |parent_id| {\n        var parent_filtered: std.ArrayListUnmanaged(Issue) = .{};\n        errdefer parent_filtered.deinit(allocator);\n\n        for (issues) |issue| {\n            if (graph.isChildOf(issue.id, parent_id, ready_args.recursive)) {\n                try parent_filtered.append(allocator, issue);\n            } else {\n                var i = issue;\n                i.deinit(allocator);\n            }\n        }\n        allocator.free(issues);\n        issues = try parent_filtered.toOwnedSlice(allocator);\n    }\n    defer graph.freeIssues(issues);\n\n    // Apply filters\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, ready_args.title_contains, ready_args.desc_contains, ready_args.notes_contains, ready_args.overdue);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, ready_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);\n        defer allocator.free(compact_issues);\n\n        for (display_issues, 0..) |issue, i| {\n            compact_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n            };\n        }\n\n        try ctx.output.printJson(ReadyResult{\n            .success = true,\n            .issues = compact_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        try ctx.output.printIssueList(display_issues);\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No ready issues\", .{});\n        }\n    }\n}\n\npub fn runBlocked(\n    blocked_args: args.BlockedArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ReadyError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Parse priority filters\n    var priority_min: ?Priority = null;\n    var priority_max: ?Priority = null;\n    if (blocked_args.priority_min) |p| {\n        priority_min = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-min value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n    if (blocked_args.priority_max) |p| {\n        priority_max = Priority.fromString(p) catch {\n            try ctx.output.err(\"invalid priority-max value\", .{});\n            return ReadyError.InvalidFilter;\n        };\n    }\n\n    var graph = ctx.createGraph();\n    const issues = try graph.getBlockedIssues();\n    defer graph.freeIssues(issues);\n\n    // Apply filters (blocked command doesn't support overdue filter)\n    const filtered = try applyFilters(allocator, issues, priority_min, priority_max, blocked_args.title_contains, blocked_args.desc_contains, blocked_args.notes_contains, false);\n    defer allocator.free(filtered);\n\n    const display_issues = applyLimit(filtered, blocked_args.limit);\n\n    if (global.isStructuredOutput()) {\n        var blocked_issues = try allocator.alloc(BlockedResult.BlockedIssue, display_issues.len);\n        defer {\n            for (blocked_issues) |bi| {\n                allocator.free(bi.blocked_by);\n            }\n            allocator.free(blocked_issues);\n        }\n\n        for (display_issues, 0..) |issue, i| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            var blocker_ids = try allocator.alloc([]const u8, blockers.len);\n            for (blockers, 0..) |blocker, j| {\n                blocker_ids[j] = blocker.id;\n            }\n\n            blocked_issues[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .priority = issue.priority.value,\n                .blocked_by = blocker_ids,\n            };\n        }\n\n        try ctx.output.printJson(BlockedResult{\n            .success = true,\n            .issues = blocked_issues,\n            .count = display_issues.len,\n        });\n    } else {\n        for (display_issues) |issue| {\n            const blockers = try graph.getBlockers(issue.id);\n            defer graph.freeIssues(blockers);\n\n            try ctx.output.print(\"{s}  {s}\\n\", .{ issue.id, issue.title });\n\n            if (blockers.len > 0) {\n                try ctx.output.print(\"  blocked by: \", .{});\n                for (blockers, 0..) |blocker, j| {\n                    if (j > 0) try ctx.output.print(\", \", .{});\n                    try ctx.output.print(\"{s}\", .{blocker.id});\n                }\n                try ctx.output.print(\"\\n\", .{});\n            }\n        }\n\n        if (!global.quiet and display_issues.len == 0) {\n            try ctx.output.info(\"No blocked issues\", .{});\n        }\n    }\n}\n\nfn applyLimit(issues: []Issue, limit: ?u32) []Issue {\n    if (limit) |n| {\n        if (n < issues.len) {\n            return issues[0..n];\n        }\n    }\n    return issues;\n}\n\nfn applyFilters(\n    allocator: std.mem.Allocator,\n    issues: []Issue,\n    priority_min: ?Priority,\n    priority_max: ?Priority,\n    title_contains: ?[]const u8,\n    desc_contains: ?[]const u8,\n    notes_contains: ?[]const u8,\n    overdue_only: bool,\n) ![]Issue {\n    // No filters - return original slice\n    if (priority_min == null and priority_max == null and title_contains == null and desc_contains == null and notes_contains == null and !overdue_only) {\n        return try allocator.dupe(Issue, issues);\n    }\n\n    const now = std.time.timestamp();\n    var filtered: std.ArrayListUnmanaged(Issue) = .{};\n    errdefer filtered.deinit(allocator);\n\n    for (issues) |issue| {\n        // Priority range filters (lower value = higher priority)\n        if (priority_min) |min_p| {\n            if (issue.priority.value < min_p.value) continue;\n        }\n        if (priority_max) |max_p| {\n            if (issue.priority.value > max_p.value) continue;\n        }\n\n        // Substring filters (case-insensitive)\n        if (title_contains) |query| {\n            if (!containsIgnoreCase(issue.title, query)) continue;\n        }\n        if (desc_contains) |query| {\n            if (issue.description) |desc| {\n                if (!containsIgnoreCase(desc, query)) continue;\n            } else continue;\n        }\n        if (notes_contains) |query| {\n            if (issue.notes) |notes| {\n                if (!containsIgnoreCase(notes, query)) continue;\n            } else continue;\n        }\n\n        // Overdue filter: only include issues past their due date\n        if (overdue_only) {\n            if (issue.due_at.value) |due_time| {\n                if (due_time >= now) continue;\n            } else continue;\n        }\n\n        try filtered.append(allocator, issue);\n    }\n\n    return filtered.toOwnedSlice(allocator);\n}\n\n// --- Tests ---\n\ntest \"ReadyError enum exists\" {\n    const err: ReadyError = ReadyError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ReadyError.WorkspaceNotInitialized);\n}\n\ntest \"ReadyResult struct works\" {\n    const result = ReadyResult{\n        .success = true,\n        .count = 3,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 3), result.count.?);\n}\n\ntest \"BlockedResult struct works\" {\n    const result = BlockedResult{\n        .success = true,\n        .count = 2,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 2), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(ready_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"runBlocked detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const blocked_args = args.BlockedArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = runBlocked(blocked_args, global, allocator);\n    try std.testing.expectError(ReadyError.WorkspaceNotInitialized, result);\n}\n\ntest \"run returns empty list for empty workspace\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"ready_empty\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    f.close();\n\n    const ready_args = args.ReadyArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(ready_args, global, allocator);\n}\n","structuredPatch":[{"oldStart":105,"oldLines":6,"newStart":105,"newLines":15,"lines":[" ","     const display_issues = applyLimit(filtered, ready_args.limit);"," ","+    // Handle CSV output format","+    if (ready_args.format == .csv) {","+        const Output = common.Output;","+        const fields = try Output.parseCsvFields(allocator, ready_args.fields);","+        defer if (ready_args.fields != null) allocator.free(fields);","+        try ctx.output.printIssueListCsv(display_issues, fields);","+        return;","+    }","+","     if (global.isStructuredOutput()) {","         var compact_issues = try allocator.alloc(ReadyResult.IssueCompact, display_issues.len);","         defer allocator.free(compact_issues);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GKWJZSjB2SmJb3KF3AJd17","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me build and test:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":344,"cache_read_input_tokens":109195,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":344},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7ea5dc4d-bbc4-4393-baa3-fc2b84ee50e7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GKWJZSjB2SmJb3KF3AJd17","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014gPnxnqo42zBy4UNBin1JC","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build to check for compilation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":344,"cache_read_input_tokens":109195,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":344},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"62f10372-8108-4640-ae48-885087db77e8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014gPnxnqo42zBy4UNBin1JC","type":"tool_result","content":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/output/mod.zig:539:36: \u001b[31merror: \u001b[0m\u001b[1mno field or member function named 'writeByte' in 'fs.File'\n\u001b[0m                    try self.stdout.writeByte(c);\n                        \u001b[32m~~~~~~~~~~~^~~~~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/fs/File.zig:1:1: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0mconst builtin = @import(\"builtin\");\n\u001b[32m^~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    writeCsvField: src/output/mod.zig:489:42\n    printIssueListCsv: src/output/mod.zig:481:39\n    9 reference(s) hidden; use '-freference-trace=11' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x2ae06fb7 -Ze143ee97a1001030","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"cc715798-aaba-42c0-9426-0c05929a1356","tool_use_result":{"stdout":"\u001b[2minstall\n\u001b(0mq\u001b(B install bz\n   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\u001b[0m\u001b[1msrc/output/mod.zig:539:36: \u001b[31merror: \u001b[0m\u001b[1mno field or member function named 'writeByte' in 'fs.File'\n\u001b[0m                    try self.stdout.writeByte(c);\n                        \u001b[32m~~~~~~~~~~~^~~~~~~~~~\n\u001b[0m\u001b[1m/opt/zig/lib/std/fs/File.zig:1:1: \u001b[36mnote: \u001b[0m\u001b[1mstruct declared here\n\u001b[0mconst builtin = @import(\"builtin\");\n\u001b[32m^~~~~\n\u001b[0m\u001b[0m\u001b[2mreferenced by:\n    writeCsvField: src/output/mod.zig:489:42\n    printIssueListCsv: src/output/mod.zig:481:39\n    9 reference(s) hidden; use '-freference-trace=11' to see all references\n\u001b[0m\u001b[31merror: \u001b[0mthe following command failed with 1 compilation errors:\n/opt/zig/zig build-exe -ODebug --dep beads_zig -Mroot=/home/hotschmoe/beads_zig/src/main.zig --dep toon_zig -Mbeads_zig=/home/hotschmoe/beads_zig/src/root.zig -Mtoon_zig=/home/hotschmoe/.cache/zig/p/toon_zig-0.1.5-k_hmCPp2BQDaa0LBM1gdu8BTNzIdBqW8y7eH6dM99BcU/src/root.zig --cache-dir .zig-cache --global-cache-dir /home/hotschmoe/.cache/zig --name bz --zig-lib-dir /opt/zig/lib/ --listen=-\n\u001b[36m\nBuild Summary:\u001b[0m 4/7 steps succeeded; 1 failed\ninstall\u001b[2m transitive failure\n\u001b[0m\u001b(0mq\u001b(B install bz\u001b[2m transitive failure\n\u001b[0m   \u001b(0mq\u001b(B compile exe bz Debug native\u001b[31m 1 errors\n\u001b[0m\nerror: the following build command failed with exit code 1:\n.zig-cache/o/de909db1625d20466f1db85ea251d07c/build /opt/zig/zig /opt/zig/lib /home/hotschmoe/beads_zig .zig-cache /home/hotschmoe/.cache/zig --seed 0x2ae06fb7 -Ze143ee97a1001030","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AUFU9jnVZzEmW3d6jTHobh","type":"message","role":"assistant","content":[{"type":"text","text":"I need to fix the file writing method. Let me fix it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":781,"cache_read_input_tokens":109539,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":781},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"10486ca2-c01e-4e51-af00-773e283cd1b4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AUFU9jnVZzEmW3d6jTHobh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012XbmyzCGPTGz1rPNV24jsF","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/output/mod.zig","old_string":"    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeByte(c);\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};","new_string":"    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeAll(&[_]u8{c});\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":781,"cache_read_input_tokens":109539,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":781},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1cea7446-2244-41f3-85f4-1be6cf0f35a8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012XbmyzCGPTGz1rPNV24jsF","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/output/mod.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"b4294d5e-7caf-4c8f-8720-d8d19f0f03ae","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/output/mod.zig","oldString":"    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeByte(c);\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};","newString":"    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeAll(&[_]u8{c});\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};","originalFile":"//! Output formatting for beads_zig.\n//!\n//! Provides a unified interface for displaying output in different modes:\n//! - plain: No colors, basic formatting (default for non-TTY)\n//! - rich: Colors and formatting (default for TTY)\n//! - json: Structured JSON output for machine consumption\n//! - quiet: Minimal output (IDs only)\n//!\n//! Respects NO_COLOR environment variable and --no-color flag.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst Issue = models.Issue;\nconst Status = models.Status;\nconst Priority = models.Priority;\nconst IssueType = models.IssueType;\n\n/// Output mode determines formatting and verbosity.\npub const OutputMode = enum {\n    plain, // No colors, basic formatting\n    rich, // Colors and formatting (TTY)\n    json, // Structured JSON output\n    quiet, // Minimal output (IDs only)\n};\n\n/// ANSI color escape codes.\npub const Color = struct {\n    pub const reset = \"\\x1b[0m\";\n    pub const bold = \"\\x1b[1m\";\n    pub const dim = \"\\x1b[2m\";\n    pub const italic = \"\\x1b[3m\";\n    pub const underline = \"\\x1b[4m\";\n\n    pub const red = \"\\x1b[31m\";\n    pub const green = \"\\x1b[32m\";\n    pub const yellow = \"\\x1b[33m\";\n    pub const blue = \"\\x1b[34m\";\n    pub const magenta = \"\\x1b[35m\";\n    pub const cyan = \"\\x1b[36m\";\n    pub const white = \"\\x1b[37m\";\n    pub const gray = \"\\x1b[90m\";\n\n    pub const bright_red = \"\\x1b[91m\";\n    pub const bright_green = \"\\x1b[92m\";\n    pub const bright_yellow = \"\\x1b[93m\";\n    pub const bright_blue = \"\\x1b[94m\";\n    pub const bright_magenta = \"\\x1b[95m\";\n    pub const bright_cyan = \"\\x1b[96m\";\n\n    pub const bg_red = \"\\x1b[41m\";\n    pub const bg_green = \"\\x1b[42m\";\n    pub const bg_yellow = \"\\x1b[43m\";\n    pub const bg_blue = \"\\x1b[44m\";\n};\n\n/// Global options that affect output formatting.\n/// This mirrors the relevant fields from cli.args.GlobalOptions.\npub const OutputOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    no_color: bool = false,\n};\n\n/// Output formatter for consistent CLI output across all modes.\npub const Output = struct {\n    mode: OutputMode,\n    toon: bool,\n    silent: bool, // Suppress ALL output including errors (for tests)\n    stdout: std.fs.File,\n    stderr: std.fs.File,\n    allocator: std.mem.Allocator,\n\n    const Self = @This();\n\n    /// Initialize output formatter based on global options and TTY detection.\n    pub fn init(allocator: std.mem.Allocator, opts: OutputOptions) Self {\n        const stdout = std.fs.File.stdout();\n        const stderr = std.fs.File.stderr();\n\n        var mode: OutputMode = .plain;\n        if (opts.json or opts.toon) {\n            mode = .json;\n        } else if (opts.quiet or opts.silent) {\n            mode = .quiet;\n        } else if (!opts.no_color and !checkNoColorEnv() and stdout.isTty()) {\n            mode = .rich;\n        }\n\n        return .{\n            .mode = mode,\n            .toon = opts.toon,\n            .silent = opts.silent,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize with explicit mode (useful for testing).\n    pub fn initWithMode(allocator: std.mem.Allocator, mode: OutputMode) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize for testing with custom file handles.\n    pub fn initForTesting(allocator: std.mem.Allocator, mode: OutputMode, stdout: std.fs.File, stderr: std.fs.File) Self {\n        return .{\n            .mode = mode,\n            .toon = false,\n            .silent = false,\n            .stdout = stdout,\n            .stderr = stderr,\n            .allocator = allocator,\n        };\n    }\n\n    /// Initialize with silent mode (suppresses ALL output including errors).\n    pub fn initSilent(allocator: std.mem.Allocator) Self {\n        return .{\n            .mode = .quiet,\n            .toon = false,\n            .silent = true,\n            .stdout = std.fs.File.stdout(),\n            .stderr = std.fs.File.stderr(),\n            .allocator = allocator,\n        };\n    }\n\n    // ========================================================================\n    // Issue Display\n    // ========================================================================\n\n    /// Print a single issue in the appropriate format.\n    pub fn printIssue(self: *Self, issue: Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueJson(issue),\n            .quiet => try self.printIssueQuiet(issue),\n            .rich => try self.printIssueRich(issue),\n            .plain => try self.printIssuePlain(issue),\n        }\n    }\n\n    /// Print a list of issues in the appropriate format.\n    pub fn printIssueList(self: *Self, issues: []const Issue) !void {\n        switch (self.mode) {\n            .json => try self.printIssueListJson(issues),\n            .quiet => try self.printIssueListQuiet(issues),\n            .rich => try self.printIssueListRich(issues),\n            .plain => try self.printIssueListPlain(issues),\n        }\n    }\n\n    // ========================================================================\n    // Generic Messages\n    // ========================================================================\n\n    /// Print a formatted message to stdout.\n    pub fn print(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    /// Print a formatted message to stdout with newline.\n    pub fn println(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        const msg = try std.fmt.allocPrint(self.allocator, fmt ++ \"\\n\", args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    /// Print a success message (green in rich mode).\n    pub fn success(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stdout.writeAll(Color.green);\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    /// Print an error message to stderr (red in rich mode).\n    pub fn err(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.silent) return;\n        if (self.mode == .rich) try self.stderr.writeAll(Color.red);\n        const msg = try std.fmt.allocPrint(self.allocator, \"error: \" ++ fmt, args);\n        defer self.allocator.free(msg);\n        try self.stderr.writeAll(msg);\n        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n        try self.stderr.writeAll(\"\\n\");\n    }\n\n    /// Print a warning message to stderr (yellow in rich mode).\n    pub fn warn(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.silent or self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stderr.writeAll(Color.yellow);\n        const msg = try std.fmt.allocPrint(self.allocator, \"warning: \" ++ fmt, args);\n        defer self.allocator.free(msg);\n        try self.stderr.writeAll(msg);\n        if (self.mode == .rich) try self.stderr.writeAll(Color.reset);\n        try self.stderr.writeAll(\"\\n\");\n    }\n\n    /// Print an info message (cyan in rich mode).\n    pub fn info(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        if (self.mode == .quiet) return;\n        if (self.mode == .rich) try self.stdout.writeAll(Color.cyan);\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n        if (self.mode == .rich) try self.stdout.writeAll(Color.reset);\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    /// Print raw bytes to stdout (bypasses mode checks).\n    pub fn raw(self: *Self, bytes: []const u8) !void {\n        try self.stdout.writeAll(bytes);\n    }\n\n    /// Print raw JSON value to stdout (for JSON mode).\n    /// If toon mode is enabled, converts JSON to TOON format for reduced token usage.\n    pub fn printJson(self: *Self, value: anytype) !void {\n        const json_bytes = try std.json.Stringify.valueAlloc(self.allocator, value, .{});\n        defer self.allocator.free(json_bytes);\n\n        if (self.toon) {\n            const toon = @import(\"toon_zig\");\n            const toon_bytes = toon.jsonToToon(self.allocator, json_bytes) catch |convert_err| {\n                try self.stderr.writeAll(\"error: failed to convert to TOON format\\n\");\n                return convert_err;\n            };\n            defer self.allocator.free(toon_bytes);\n            try self.stdout.writeAll(toon_bytes);\n        } else {\n            try self.stdout.writeAll(json_bytes);\n        }\n        try self.stdout.writeAll(\"\\n\");\n    }\n\n    // ========================================================================\n    // JSON Mode Helpers\n    // ========================================================================\n\n    fn printIssueJson(self: *Self, issue: Issue) !void {\n        try self.printJson(issue);\n    }\n\n    fn printIssueListJson(self: *Self, issues: []const Issue) !void {\n        try self.printJson(issues);\n    }\n\n    // ========================================================================\n    // Plain Mode Helpers\n    // ========================================================================\n\n    fn printIssuePlain(self: *Self, issue: Issue) !void {\n        try self.writeFormatted(\"ID: {s}\\n\", .{issue.id});\n        try self.writeFormatted(\"Title: {s}\\n\", .{issue.title});\n        try self.writeFormatted(\"Status: {s}\\n\", .{issue.status.toString()});\n        try self.writeFormatted(\"Priority: {s}\\n\", .{issue.priority.toString()});\n        try self.writeFormatted(\"Type: {s}\\n\", .{issue.issue_type.toString()});\n\n        if (issue.description) |desc| {\n            try self.writeFormatted(\"Description: {s}\\n\", .{desc});\n        }\n        if (issue.assignee) |assignee| {\n            try self.writeFormatted(\"Assignee: {s}\\n\", .{assignee});\n        }\n        if (issue.labels.len > 0) {\n            try self.stdout.writeAll(\"Labels: \");\n            for (issue.labels, 0..) |label, i| {\n                if (i > 0) try self.stdout.writeAll(\", \");\n                try self.stdout.writeAll(label);\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n        if (issue.due_at.value) |due| {\n            try self.writeFormatted(\"Due: {d}\\n\", .{due});\n        }\n\n        try self.writeFormatted(\"Created: {d}\\n\", .{issue.created_at.value});\n        try self.writeFormatted(\"Updated: {d}\\n\", .{issue.updated_at.value});\n    }\n\n    fn printIssueListPlain(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            const status_abbrev = abbreviateStatus(issue.status);\n            try self.writeFormatted(\"{s}  [{s}] {s}\\n\", .{\n                issue.id,\n                status_abbrev,\n                issue.title,\n            });\n        }\n    }\n\n    // ========================================================================\n    // Rich Mode Helpers (ANSI colors)\n    // ========================================================================\n\n    fn printIssueRich(self: *Self, issue: Issue) !void {\n        // Bold ID\n        try self.writeFormatted(\"{s}{s}{s}\\n\", .{ Color.bold, issue.id, Color.reset });\n\n        // Title\n        try self.writeFormatted(\"  {s}\\n\", .{issue.title});\n\n        // Status with color\n        const status_color = getStatusColor(issue.status);\n        try self.writeFormatted(\"  Status: {s}{s}{s}\\n\", .{ status_color, issue.status.toString(), Color.reset });\n\n        // Priority with color\n        const priority_color = getPriorityColor(issue.priority);\n        try self.writeFormatted(\"  Priority: {s}{s}{s}\\n\", .{ priority_color, issue.priority.toString(), Color.reset });\n\n        // Type\n        try self.writeFormatted(\"  Type: {s}\\n\", .{issue.issue_type.toString()});\n\n        // Optional fields\n        if (issue.description) |desc| {\n            try self.writeFormatted(\"  Description: {s}{s}{s}\\n\", .{ Color.dim, desc, Color.reset });\n        }\n        if (issue.assignee) |assignee| {\n            try self.writeFormatted(\"  Assignee: {s}{s}{s}\\n\", .{ Color.cyan, assignee, Color.reset });\n        }\n        if (issue.labels.len > 0) {\n            try self.stdout.writeAll(\"  Labels: \");\n            for (issue.labels, 0..) |label, i| {\n                if (i > 0) try self.stdout.writeAll(\", \");\n                try self.writeFormatted(\"{s}{s}{s}\", .{ Color.magenta, label, Color.reset });\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n    }\n\n    fn printIssueListRich(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            const status_color = getStatusColor(issue.status);\n            const priority_color = getPriorityColor(issue.priority);\n            const status_abbrev = abbreviateStatus(issue.status);\n\n            try self.writeFormatted(\"{s}{s}{s}  {s}[{s}]{s}  {s}{s}{s}  {s}\\n\", .{\n                Color.bold,\n                issue.id,\n                Color.reset,\n                status_color,\n                status_abbrev,\n                Color.reset,\n                priority_color,\n                priorityIndicator(issue.priority),\n                Color.reset,\n                issue.title,\n            });\n        }\n    }\n\n    // ========================================================================\n    // Quiet Mode Helpers\n    // ========================================================================\n\n    fn printIssueQuiet(self: *Self, issue: Issue) !void {\n        try self.writeFormatted(\"{s}\\n\", .{issue.id});\n    }\n\n    fn printIssueListQuiet(self: *Self, issues: []const Issue) !void {\n        for (issues) |issue| {\n            try self.writeFormatted(\"{s}\\n\", .{issue.id});\n        }\n    }\n\n    // ========================================================================\n    // Internal Helpers\n    // ========================================================================\n\n    fn writeFormatted(self: *Self, comptime fmt: []const u8, args: anytype) !void {\n        const msg = try std.fmt.allocPrint(self.allocator, fmt, args);\n        defer self.allocator.free(msg);\n        try self.stdout.writeAll(msg);\n    }\n\n    // ========================================================================\n    // CSV Mode Helpers\n    // ========================================================================\n\n    /// Available fields for CSV output.\n    pub const CsvField = enum {\n        id,\n        title,\n        status,\n        priority,\n        issue_type,\n        assignee,\n        owner,\n        description,\n        created_at,\n        updated_at,\n        due_at,\n        labels,\n\n        pub fn fromString(s: []const u8) ?CsvField {\n            if (std.mem.eql(u8, s, \"id\")) return .id;\n            if (std.mem.eql(u8, s, \"title\")) return .title;\n            if (std.mem.eql(u8, s, \"status\")) return .status;\n            if (std.mem.eql(u8, s, \"priority\")) return .priority;\n            if (std.mem.eql(u8, s, \"type\") or std.mem.eql(u8, s, \"issue_type\")) return .issue_type;\n            if (std.mem.eql(u8, s, \"assignee\")) return .assignee;\n            if (std.mem.eql(u8, s, \"owner\")) return .owner;\n            if (std.mem.eql(u8, s, \"description\") or std.mem.eql(u8, s, \"desc\")) return .description;\n            if (std.mem.eql(u8, s, \"created_at\") or std.mem.eql(u8, s, \"created\")) return .created_at;\n            if (std.mem.eql(u8, s, \"updated_at\") or std.mem.eql(u8, s, \"updated\")) return .updated_at;\n            if (std.mem.eql(u8, s, \"due_at\") or std.mem.eql(u8, s, \"due\")) return .due_at;\n            if (std.mem.eql(u8, s, \"labels\")) return .labels;\n            return null;\n        }\n\n        pub fn toString(self: CsvField) []const u8 {\n            return switch (self) {\n                .id => \"id\",\n                .title => \"title\",\n                .status => \"status\",\n                .priority => \"priority\",\n                .issue_type => \"type\",\n                .assignee => \"assignee\",\n                .owner => \"owner\",\n                .description => \"description\",\n                .created_at => \"created_at\",\n                .updated_at => \"updated_at\",\n                .due_at => \"due_at\",\n                .labels => \"labels\",\n            };\n        }\n    };\n\n    /// Default fields for CSV output.\n    pub const default_csv_fields = [_]CsvField{ .id, .title, .status, .priority };\n\n    /// Parse a comma-separated field list into CsvField array.\n    pub fn parseCsvFields(allocator: std.mem.Allocator, fields_str: ?[]const u8) ![]const CsvField {\n        if (fields_str) |str| {\n            var fields: std.ArrayListUnmanaged(CsvField) = .{};\n            errdefer fields.deinit(allocator);\n\n            var it = std.mem.splitSequence(u8, str, \",\");\n            while (it.next()) |field_name| {\n                const trimmed = std.mem.trim(u8, field_name, \" \");\n                if (CsvField.fromString(trimmed)) |field| {\n                    try fields.append(allocator, field);\n                }\n            }\n\n            if (fields.items.len == 0) {\n                return &default_csv_fields;\n            }\n            return fields.toOwnedSlice(allocator);\n        }\n        return &default_csv_fields;\n    }\n\n    /// Print a list of issues in CSV format.\n    pub fn printIssueListCsv(self: *Self, issues: []const Issue, fields: []const CsvField) !void {\n        // Write header\n        for (fields, 0..) |field, i| {\n            if (i > 0) try self.stdout.writeAll(\",\");\n            try self.stdout.writeAll(field.toString());\n        }\n        try self.stdout.writeAll(\"\\n\");\n\n        // Write data rows\n        for (issues) |issue| {\n            for (fields, 0..) |field, i| {\n                if (i > 0) try self.stdout.writeAll(\",\");\n                try self.writeCsvField(issue, field);\n            }\n            try self.stdout.writeAll(\"\\n\");\n        }\n    }\n\n    fn writeCsvField(self: *Self, issue: Issue, field: CsvField) !void {\n        switch (field) {\n            .id => try self.writeCsvValue(issue.id),\n            .title => try self.writeCsvValue(issue.title),\n            .status => try self.writeCsvValue(issue.status.toString()),\n            .priority => try self.writeCsvValue(issue.priority.toString()),\n            .issue_type => try self.writeCsvValue(issue.issue_type.toString()),\n            .assignee => try self.writeCsvValue(issue.assignee orelse \"\"),\n            .owner => try self.writeCsvValue(issue.owner orelse \"\"),\n            .description => try self.writeCsvValue(issue.description orelse \"\"),\n            .created_at => {\n                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.created_at.value});\n                defer self.allocator.free(ts);\n                try self.writeCsvValue(ts);\n            },\n            .updated_at => {\n                const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{issue.updated_at.value});\n                defer self.allocator.free(ts);\n                try self.writeCsvValue(ts);\n            },\n            .due_at => {\n                if (issue.due_at.value) |due| {\n                    const ts = try std.fmt.allocPrint(self.allocator, \"{d}\", .{due});\n                    defer self.allocator.free(ts);\n                    try self.writeCsvValue(ts);\n                } else {\n                    try self.stdout.writeAll(\"\");\n                }\n            },\n            .labels => {\n                if (issue.labels.len > 0) {\n                    const joined = try std.mem.join(self.allocator, \";\", issue.labels);\n                    defer self.allocator.free(joined);\n                    try self.writeCsvValue(joined);\n                } else {\n                    try self.stdout.writeAll(\"\");\n                }\n            },\n        }\n    }\n\n    /// Write a CSV value with proper escaping.\n    fn writeCsvValue(self: *Self, value: []const u8) !void {\n        // Check if escaping is needed (contains comma, quote, or newline)\n        const needs_quoting = std.mem.indexOfAny(u8, value, \",\\\"\\n\\r\") != null;\n\n        if (needs_quoting) {\n            try self.stdout.writeAll(\"\\\"\");\n            for (value) |c| {\n                if (c == '\"') {\n                    try self.stdout.writeAll(\"\\\"\\\"\");\n                } else {\n                    try self.stdout.writeByte(c);\n                }\n            }\n            try self.stdout.writeAll(\"\\\"\");\n        } else {\n            try self.stdout.writeAll(value);\n        }\n    }\n};\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/// Check if NO_COLOR environment variable is set (cross-platform).\nfn checkNoColorEnv() bool {\n    // Per NO_COLOR spec, only existence matters, not the value\n    return std.process.hasEnvVarConstant(\"NO_COLOR\");\n}\n\n/// Get ANSI color for a status.\nfn getStatusColor(status: Status) []const u8 {\n    return switch (status) {\n        .open => Color.green,\n        .in_progress => Color.yellow,\n        .blocked => Color.red,\n        .deferred => Color.gray,\n        .closed => Color.gray,\n        .tombstone => Color.dim,\n        .pinned => Color.bright_cyan,\n        .custom => Color.blue,\n    };\n}\n\n/// Get ANSI color for a priority.\nfn getPriorityColor(priority: Priority) []const u8 {\n    return switch (priority.value) {\n        0 => Color.bright_red, // critical\n        1 => Color.red, // high\n        2 => Color.yellow, // medium\n        3 => Color.green, // low\n        4 => Color.gray, // backlog\n        else => Color.reset,\n    };\n}\n\n/// Get short status abbreviation.\nfn abbreviateStatus(status: Status) []const u8 {\n    return switch (status) {\n        .open => \"OPEN\",\n        .in_progress => \"PROG\",\n        .blocked => \"BLKD\",\n        .deferred => \"DEFR\",\n        .closed => \"DONE\",\n        .tombstone => \"DEL \",\n        .pinned => \"PIN \",\n        .custom => \"CUST\",\n    };\n}\n\n/// Get priority indicator symbol.\nfn priorityIndicator(priority: Priority) []const u8 {\n    return switch (priority.value) {\n        0 => \"!!!\",\n        1 => \"!! \",\n        2 => \"!  \",\n        3 => \".  \",\n        4 => \"   \",\n        else => \"   \",\n    };\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\ntest \"OutputMode enum values\" {\n    try std.testing.expectEqual(OutputMode.plain, OutputMode.plain);\n    try std.testing.expectEqual(OutputMode.rich, OutputMode.rich);\n    try std.testing.expectEqual(OutputMode.json, OutputMode.json);\n    try std.testing.expectEqual(OutputMode.quiet, OutputMode.quiet);\n}\n\ntest \"Output.init with json option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .json = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n    try std.testing.expect(!output.toon);\n}\n\ntest \"Output.init with toon option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .toon = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n    try std.testing.expect(output.toon);\n}\n\ntest \"Output.init with quiet option\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .quiet = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n}\n\ntest \"Output.init with no_color option forces plain mode\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .no_color = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.plain, output.mode);\n}\n\ntest \"Output.init json overrides quiet\" {\n    const allocator = std.testing.allocator;\n    const opts = OutputOptions{ .json = true, .quiet = true };\n    const output = Output.init(allocator, opts);\n    try std.testing.expectEqual(OutputMode.json, output.mode);\n}\n\ntest \"Output.initWithMode sets explicit mode\" {\n    const allocator = std.testing.allocator;\n    const output = Output.initWithMode(allocator, .rich);\n    try std.testing.expectEqual(OutputMode.rich, output.mode);\n}\n\ntest \"abbreviateStatus returns 4-char strings\" {\n    const statuses = [_]Status{\n        .open,\n        .in_progress,\n        .blocked,\n        .deferred,\n        .closed,\n        .tombstone,\n        .pinned,\n        .{ .custom = \"test\" },\n    };\n    for (statuses) |status| {\n        const abbrev = abbreviateStatus(status);\n        try std.testing.expectEqual(@as(usize, 4), abbrev.len);\n    }\n}\n\ntest \"priorityIndicator returns 3-char strings\" {\n    var p: u3 = 0;\n    while (p <= 4) : (p += 1) {\n        const priority = Priority{ .value = p };\n        const indicator = priorityIndicator(priority);\n        try std.testing.expectEqual(@as(usize, 3), indicator.len);\n    }\n}\n\ntest \"getStatusColor returns valid ANSI codes\" {\n    const statuses = [_]Status{\n        .open,\n        .in_progress,\n        .blocked,\n        .deferred,\n        .closed,\n        .tombstone,\n        .pinned,\n        .{ .custom = \"test\" },\n    };\n    for (statuses) |status| {\n        const color = getStatusColor(status);\n        try std.testing.expect(color.len > 0);\n        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n    }\n}\n\ntest \"getPriorityColor returns valid ANSI codes\" {\n    var p: u3 = 0;\n    while (p <= 4) : (p += 1) {\n        const priority = Priority{ .value = p };\n        const color = getPriorityColor(priority);\n        try std.testing.expect(color.len > 0);\n        try std.testing.expect(std.mem.startsWith(u8, color, \"\\x1b[\"));\n    }\n}\n\ntest \"Color constants are valid ANSI escape sequences\" {\n    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.red, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.yellow, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.blue, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.gray, \"\\x1b[\"));\n}\n\ntest \"Output printIssueListQuiet writes IDs only\" {\n    // Test the quiet formatting logic directly\n    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n    const issues = [_]Issue{ issue1, issue2 };\n\n    // In quiet mode, printIssueListQuiet outputs \"{id}\\n\" for each issue\n    // Verify the expected output format\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue1.id);\n    try std.testing.expectEqualStrings(\"bd-def456\", issue2.id);\n    try std.testing.expectEqual(@as(usize, 2), issues.len);\n}\n\ntest \"Output printIssueListPlain writes formatted lines\" {\n    // Test the plain formatting logic via abbreviateStatus and Issue fields\n    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n\n    // Verify issue fields are correct\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n\n    // Verify status abbreviation\n    const status_abbrev = abbreviateStatus(issue.status);\n    try std.testing.expectEqualStrings(\"OPEN\", status_abbrev);\n}\n\ntest \"Output printIssueListRich includes ANSI codes\" {\n    // Test that rich mode formatting uses ANSI codes\n    const issue = Issue.init(\"bd-abc123\", \"Test issue\", 1706540000);\n\n    // Verify issue fields\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n\n    // Verify rich mode uses color codes\n    const status_color = getStatusColor(issue.status);\n    try std.testing.expect(std.mem.startsWith(u8, status_color, \"\\x1b[\"));\n\n    const priority_color = getPriorityColor(issue.priority);\n    try std.testing.expect(std.mem.startsWith(u8, priority_color, \"\\x1b[\"));\n\n    // Verify Color.bold is used\n    try std.testing.expect(std.mem.startsWith(u8, Color.bold, \"\\x1b[\"));\n}\n\ntest \"Output printIssueListJson produces valid JSON array\" {\n    const allocator = std.testing.allocator;\n\n    // Test JSON serialization directly\n    const issue1 = Issue.init(\"bd-abc123\", \"Test issue 1\", 1706540000);\n    const issue2 = Issue.init(\"bd-def456\", \"Test issue 2\", 1706540000);\n    const issues = [_]Issue{ issue1, issue2 };\n\n    // Serialize to JSON\n    const json_bytes = try std.json.Stringify.valueAlloc(allocator, issues, .{});\n    defer allocator.free(json_bytes);\n\n    // Verify it starts with [ and contains expected data\n    try std.testing.expect(std.mem.startsWith(u8, json_bytes, \"[\"));\n    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-abc123\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, json_bytes, \"bd-def456\") != null);\n\n    // Verify it can be parsed back\n    const parsed = try std.json.parseFromSlice([]const Issue, allocator, json_bytes, .{});\n    defer parsed.deinit();\n    try std.testing.expectEqual(@as(usize, 2), parsed.value.len);\n}\n\ntest \"Output.err formats error messages correctly\" {\n    const allocator = std.testing.allocator;\n\n    // Test the error message formatting\n    const msg = try std.fmt.allocPrint(allocator, \"error: \" ++ \"something went wrong: {s}\", .{\"test error\"});\n    defer allocator.free(msg);\n\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"error:\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"test error\") != null);\n}\n\ntest \"Output.warn formats warning messages correctly\" {\n    const allocator = std.testing.allocator;\n\n    // Test the warning message formatting\n    const msg = try std.fmt.allocPrint(allocator, \"warning: \" ++ \"this is a warning: {s}\", .{\"be careful\"});\n    defer allocator.free(msg);\n\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"warning:\") != null);\n    try std.testing.expect(std.mem.indexOf(u8, msg, \"be careful\") != null);\n}\n\ntest \"Output quiet mode suppresses print but not err\" {\n    const allocator = std.testing.allocator;\n\n    // Test quiet mode behavior through Output struct logic\n    const output = Output.initWithMode(allocator, .quiet);\n\n    // Verify quiet mode is set\n    try std.testing.expectEqual(OutputMode.quiet, output.mode);\n\n    // The print/println/success/warn methods check mode == .quiet and return early\n    // The err method does NOT check for quiet mode (always prints)\n    // This is the documented behavior we're testing\n}\n\ntest \"Output.success uses green color in rich mode\" {\n    const allocator = std.testing.allocator;\n\n    // Test that success would use green color in rich mode\n    const output = Output.initWithMode(allocator, .rich);\n    try std.testing.expectEqual(OutputMode.rich, output.mode);\n\n    // Verify Color.green is a valid ANSI escape\n    try std.testing.expect(std.mem.startsWith(u8, Color.green, \"\\x1b[\"));\n    try std.testing.expect(std.mem.startsWith(u8, Color.reset, \"\\x1b[\"));\n}\n\ntest \"Output.printIssue in plain mode shows all fields\" {\n    // Test issue field access and formatting\n    var issue = Issue.init(\"bd-abc123\", \"Test issue title\", 1706540000);\n    issue.description = \"A test description\";\n    issue.assignee = \"alice@example.com\";\n\n    // Verify all fields that would be printed\n    try std.testing.expectEqualStrings(\"bd-abc123\", issue.id);\n    try std.testing.expectEqualStrings(\"Test issue title\", issue.title);\n    try std.testing.expectEqual(Status.open, issue.status);\n    try std.testing.expectEqualStrings(\"open\", issue.status.toString());\n    try std.testing.expectEqualStrings(\"medium\", issue.priority.toString());\n    try std.testing.expectEqualStrings(\"task\", issue.issue_type.toString());\n    try std.testing.expectEqualStrings(\"A test description\", issue.description.?);\n    try std.testing.expectEqualStrings(\"alice@example.com\", issue.assignee.?);\n}\n","structuredPatch":[{"oldStart":536,"oldLines":7,"newStart":536,"newLines":7,"lines":["                 if (c == '\"') {","                     try self.stdout.writeAll(\"\\\"\\\"\");","                 } else {","-                    try self.stdout.writeByte(c);","+                    try self.stdout.writeAll(&[_]u8{c});","                 }","             }","             try self.stdout.writeAll(\"\\\"\");"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0135GMns4qa4fPvriQqeR9B1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RkKLaBKCnxnUXHjedxxD9K","name":"Bash","input":{"command":"zig build 2>&1 | head -50","description":"Build to check for compilation errors"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":593,"cache_read_input_tokens":110320,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":593},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"6859dd96-235c-4728-b105-b786c326c137"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RkKLaBKCnxnUXHjedxxD9K","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7bbd18bf-d5fc-4137-be0d-62c97da97f1e","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EUipUVQqhbCGL4F1jcG1cP","type":"message","role":"assistant","content":[{"type":"text","text":"Build succeeded. Now let me run tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":262,"cache_read_input_tokens":110913,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c8223a6f-3adf-4e04-83c0-4a4398e5d12b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EUipUVQqhbCGL4F1jcG1cP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X2YCwaJ8pLstVRrQoSuzYx","name":"Bash","input":{"command":"zig build test 2>&1 | tail -30","description":"Run tests to verify implementation","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":262,"cache_read_input_tokens":110913,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c14134d6-8a97-4154-8656-65b2e9f39aaf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X2YCwaJ8pLstVRrQoSuzYx","type":"tool_result","content":"640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"17cec210-4f23-4404-9235-a4e1c25c393c","tool_use_result":{"stdout":"640/661 tests.cli_test.test.bz create returns ID...OK\n641/661 tests.cli_test.test.bz q returns ID...OK\n642/661 tests.cli_test.test.bz list returns issues...OK\n643/661 tests.cli_test.test.bz list --json returns output...OK\n644/661 tests.cli_test.test.bz show displays issue...OK\n645/661 tests.cli_test.test.bz show not-found returns error...OK\n646/661 tests.cli_test.test.bz close marks issue as closed...OK\n647/661 tests.cli_test.test.bz reopen reopens closed issue...OK\n648/661 tests.cli_test.test.bz delete soft deletes issue...OK\n649/661 tests.cli_test.test.bz search finds matching issues...OK\n650/661 tests.cli_test.test.bz dep add creates dependency...OK\n651/661 tests.cli_test.test.bz dep add rejects cycles...OK\n652/661 tests.cli_test.test.bz ready shows unblocked issues...OK\n653/661 tests.cli_test.test.bz blocked shows blocked issues...OK\n654/661 tests.cli_test.test.bz unknown command returns error...OK\n655/661 tests.cli_test.test.bz without workspace shows error...OK\n656/661 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n657/661 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n658/661 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n659/661 tests.stress_test.test.sequential writes: single thread baseline...OK\n660/661 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n661/661 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 661 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RbY1JJYmpvzy1oSYzuv5jB","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Let me do a quick manual test to verify the functionality works correctly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":666,"cache_read_input_tokens":111175,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":666},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"509d9ee9-f4dd-494f-9d82-5d6ce57f6e6d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RbY1JJYmpvzy1oSYzuv5jB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Jwh7b1BYPmpwM665tYY3aW","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig/sandbox && rm -rf .beads && ../zig-out/bin/bz init && ../zig-out/bin/bz create \"Test issue 1\" && ../zig-out/bin/bz create \"Test issue 2\" && ../zig-out/bin/bz create \"Test \\\"with\\\" comma, issue\"","description":"Create test issues in sandbox"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":666,"cache_read_input_tokens":111175,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":666},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"fbf49c53-3336-4da8-a9fb-d99e1e70c040"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Jwh7b1BYPmpwM665tYY3aW","type":"tool_result","content":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-2vs\nCreated issue bd-1vu\nCreated issue bd-qus","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d489d596-f966-4825-a1c4-6a2ac2bdd1f6","tool_use_result":{"stdout":"Initialized beads workspace in .beads/\n  Issue prefix: bd\n  Issues file: .beads/issues.jsonl\nCreated issue bd-2vs\nCreated issue bd-1vu\nCreated issue bd-qus","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EmXAhSL1gp4f1emgjfySZK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PuVVQcDjtznybquUVrnNFt","name":"Bash","input":{"command":"../zig-out/bin/bz list --format csv","description":"Test CSV output"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":246,"cache_read_input_tokens":111841,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":246},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"46bdbfd3-855e-41bd-98e5-bc04e984c71b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PuVVQcDjtznybquUVrnNFt","type":"tool_result","content":"id,title,status,priority\nbd-2vs,Test issue 1,open,medium\nbd-1vu,Test issue 2,open,medium\nbd-qus,\"Test \"\"with\"\" comma, issue\",open,medium","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4125dda1-fd23-4472-a9ae-8206c50db1d5","tool_use_result":{"stdout":"id,title,status,priority\nbd-2vs,Test issue 1,open,medium\nbd-1vu,Test issue 2,open,medium\nbd-qus,\"Test \"\"with\"\" comma, issue\",open,medium","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EVg2UYr1P2jEBNnPRbutna","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017nBWCSHGco7Dks7epPaue5","name":"Bash","input":{"command":"../zig-out/bin/bz list --format csv --fields id,title,status,assignee,labels","description":"Test CSV output with custom fields"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":150,"cache_read_input_tokens":112087,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":150},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"153046c9-8806-46ec-a1c0-38fa2765631e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017nBWCSHGco7Dks7epPaue5","type":"tool_result","content":"id,title,status,assignee,labels\nbd-2vs,Test issue 1,open,,\nbd-1vu,Test issue 2,open,,\nbd-qus,\"Test \"\"with\"\" comma, issue\",open,,","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"e0a1c8e9-b893-4069-9b43-7b5d24e18638","tool_use_result":{"stdout":"id,title,status,assignee,labels\nbd-2vs,Test issue 1,open,,\nbd-1vu,Test issue 2,open,,\nbd-qus,\"Test \"\"with\"\" comma, issue\",open,,","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011axMhJTntdZqbHY4WVjbti","type":"message","role":"assistant","content":[{"type":"text","text":"CSV output is working correctly with proper escaping. Now let me test the parent/recursive filters. First I need to create an epic and add children:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":165,"cache_read_input_tokens":112237,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":165},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"adaf5f0a-0b16-416c-bd92-bdfe7d77503b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011axMhJTntdZqbHY4WVjbti","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019ydkAE2cQAzB8YhEBu881N","name":"Bash","input":{"command":"../zig-out/bin/bz epic create \"Parent Epic\" && ../zig-out/bin/bz create \"Child 1\" && ../zig-out/bin/bz create \"Child 2\"","description":"Create epic and child issues"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":165,"cache_read_input_tokens":112237,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":165},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2c31b40c-ab50-4b43-b771-e0a8874cb2b3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019ydkAE2cQAzB8YhEBu881N","type":"tool_result","content":"Created epic bd-10i\nCreated issue bd-37h\nCreated issue bd-38s","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1a2c9e36-a905-4445-9e5f-45fe85c4807a","tool_use_result":{"stdout":"Created epic bd-10i\nCreated issue bd-37h\nCreated issue bd-38s","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01V6yyMCNhTt8hPzUuxYzVLM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H8odoJNYn7DspTRYbXYvt8","name":"Bash","input":{"command":"../zig-out/bin/bz epic add bd-10i bd-37h && ../zig-out/bin/bz epic add bd-10i bd-38s","description":"Add children to epic"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":186,"cache_read_input_tokens":112402,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":186},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"bc667c3d-f7d0-4f3f-aba5-5e4272751ab8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H8odoJNYn7DspTRYbXYvt8","type":"tool_result","content":"Added bd-37h to epic bd-10i\nAdded bd-38s to epic bd-10i","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"40f22c22-2f31-4cd2-8e17-3b5094eb2a4b","tool_use_result":{"stdout":"Added bd-37h to epic bd-10i\nAdded bd-38s to epic bd-10i","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R8gG3c4h8VmZ1ok3Yeh1dT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015Rjw3Rcwevzgqcrocw7qPm","name":"Bash","input":{"command":"../zig-out/bin/bz list --parent bd-10i","description":"Test parent filter"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":147,"cache_read_input_tokens":112588,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":147},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"3426ab06-4477-49ff-8d55-a55c3c1da9e5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015Rjw3Rcwevzgqcrocw7qPm","type":"tool_result","content":"bd-37h  [OPEN] Child 1\nbd-38s  [OPEN] Child 2","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"3fcdbf2c-9d85-42fb-9b4c-84205262b4d2","tool_use_result":{"stdout":"bd-37h  [OPEN] Child 1\nbd-38s  [OPEN] Child 2","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SHMPULizDrKBUAcxSR8APB","type":"message","role":"assistant","content":[{"type":"text","text":"The parent filter is working. Let me test recursive by adding a grandchild:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":291,"cache_read_input_tokens":112735,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":291},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"94055d28-818d-4eb6-8d10-9ffdcbb2ec5d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SHMPULizDrKBUAcxSR8APB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KkEpSohtmfcSBvbZbjEUhu","name":"Bash","input":{"command":"../zig-out/bin/bz create \"Grandchild 1\" && ../zig-out/bin/bz dep add bd-m6m bd-37h -t parent_child","description":"Create grandchild issue"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":291,"cache_read_input_tokens":112735,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":291},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"74353a2f-60a3-4dea-96ab-4cf983868b49"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\nerror: issue not found: bd-m6m\n\nCreated issue bd-1t8","is_error":true,"tool_use_id":"toolu_01KkEpSohtmfcSBvbZbjEUhu"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"31019c8b-9b2b-4847-8691-30c37f019d1e","tool_use_result":"Error: Exit code 1\nerror: issue not found: bd-m6m\n\nCreated issue bd-1t8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DGr98Y67mJ6sFd6dBh8GMX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GuoMrCrmn8cxD3myQ3y235","name":"Bash","input":{"command":"../zig-out/bin/bz dep add bd-1t8 bd-37h -t parent_child","description":"Add grandchild dependency"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":180,"cache_read_input_tokens":113026,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":180},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"ccc9cbfe-15c3-47c2-8a7c-9d22e86f9fe1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GuoMrCrmn8cxD3myQ3y235","type":"tool_result","content":"Added dependency: bd-1t8 depends on bd-37h","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"fc00b203-b0f1-4405-ab80-455bb28ffb3c","tool_use_result":{"stdout":"Added dependency: bd-1t8 depends on bd-37h","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014DTTk7R45YYQLuikoJKddK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MC4nBmTgkSakxVywfHHYV5","name":"Bash","input":{"command":"../zig-out/bin/bz list --parent bd-10i","description":"Test parent filter without recursive"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":126,"cache_read_input_tokens":113206,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":126},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"ef3a74ab-f8c5-436f-9a95-434c54e3d654"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MC4nBmTgkSakxVywfHHYV5","type":"tool_result","content":"bd-37h  [OPEN] Child 1\nbd-38s  [OPEN] Child 2","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"4fb0463a-c2ef-438a-9a2a-642a76700171","tool_use_result":{"stdout":"bd-37h  [OPEN] Child 1\nbd-38s  [OPEN] Child 2","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WhG1kVb82Wtzgff2nfdEoV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LPL7A7vSRexWNuZ8ityB2u","name":"Bash","input":{"command":"../zig-out/bin/bz list --parent bd-10i --recursive","description":"Test parent filter with recursive"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":126,"cache_read_input_tokens":113332,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":126},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"89e531db-c9d4-4099-931e-35a58f374c6d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LPL7A7vSRexWNuZ8ityB2u","type":"tool_result","content":"bd-1t8  [OPEN] Grandchild 1\nbd-37h  [OPEN] Child 1\nbd-38s  [OPEN] Child 2","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"5808f489-48b0-4fa6-8f13-4b6eb925fcfb","tool_use_result":{"stdout":"bd-1t8  [OPEN] Grandchild 1\nbd-37h  [OPEN] Child 1\nbd-38s  [OPEN] Child 2","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Ex7Uz8FbsbA7AwPgQz9Hmv","type":"message","role":"assistant","content":[{"type":"text","text":"Both tasks are working correctly. Now let me update the todo and create the commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":145,"cache_read_input_tokens":113458,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":145},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"cdd100a4-c0fd-477d-be6d-f9700efe0cde"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Ex7Uz8FbsbA7AwPgQz9Hmv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017xVpjdomPreypRiY5ucx46","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"completed","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"in_progress","activeForm":"Creating single commit for all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":145,"cache_read_input_tokens":113458,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":145},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"0b2e66c8-57e7-43f7-a220-e87ad820d06c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017xVpjdomPreypRiY5ucx46","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"7e953c44-ff1b-474b-8e21-bf2e6aadcd14","tool_use_result":{"oldTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"in_progress","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"pending","activeForm":"Creating single commit for all changes"}],"newTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"completed","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"in_progress","activeForm":"Creating single commit for all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EVW1qu4bnkSRZYgAXwJuuR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KzLPm3Hh1AhVNbDXUQ83vV","name":"Bash","input":{"command":"cd /home/hotschmoe/beads_zig && git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":222,"cache_read_input_tokens":113603,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":222},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"bbaa382e-2d59-44cc-94dc-4c4401280ad3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KzLPm3Hh1AhVNbDXUQ83vV","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 16 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/list.zig\n\tmodified:   src/cli/ready.zig\n\tmodified:   src/output/mod.zig\n\tmodified:   src/storage/graph.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"bac2a513-ff90-478b-87bf-317e000a5c8f","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 16 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\tmodified:   src/cli/args.zig\n\tmodified:   src/cli/list.zig\n\tmodified:   src/cli/ready.zig\n\tmodified:   src/output/mod.zig\n\tmodified:   src/storage/graph.zig\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MCyc5dWjZ2NKTUmhL2wJxU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XDj1PJpCYqdmh7csiYsjjy","name":"Bash","input":{"command":"git diff src/cli/args.zig","description":"Show changes to args.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":300,"cache_read_input_tokens":113825,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":300},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"68cf139a-1f12-42a8-a342-e54accab1408"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XDj1PJpCYqdmh7csiYsjjy","type":"tool_result","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex fe002b8..c9786b6 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -199,6 +199,18 @@ pub const ImportArgs = struct {\n     dry_run: bool = false, // Show what would be imported without importing\n };\n \n+/// Output format for list/ready commands.\n+pub const OutputFormat = enum {\n+    default,\n+    csv,\n+\n+    pub fn fromString(s: []const u8) ?OutputFormat {\n+        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n+        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n+        return null;\n+    }\n+};\n+\n /// Sort field options for list command.\n pub const SortField = enum {\n     created_at,\n@@ -232,6 +244,10 @@ pub const ListArgs = struct {\n     include_deferred: bool = false,\n     sort: SortField = .created_at,\n     sort_desc: bool = true,\n+    parent: ?[]const u8 = null,\n+    recursive: bool = false,\n+    format: OutputFormat = .default,\n+    fields: ?[]const u8 = null,\n };\n \n /// Ready command arguments.\n@@ -244,6 +260,10 @@ pub const ReadyArgs = struct {\n     notes_contains: ?[]const u8 = null,\n     overdue: bool = false,\n     include_deferred: bool = false,\n+    parent: ?[]const u8 = null,\n+    recursive: bool = false,\n+    format: OutputFormat = .default,\n+    fields: ?[]const u8 = null,\n };\n \n /// Blocked command arguments.\n@@ -1067,6 +1087,15 @@ pub const ArgParser = struct {\n                 result.sort_desc = false;\n             } else if (self.consumeFlag(null, \"--desc\")) {\n                 result.sort_desc = true;\n+            } else if (self.consumeFlag(null, \"--parent\")) {\n+                result.parent = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n+                result.recursive = true;\n+            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n+                const fmt_str = self.next() orelse return error.MissingFlagValue;\n+                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n+            } else if (self.consumeFlag(null, \"--fields\")) {\n+                result.fields = self.next() orelse return error.MissingFlagValue;\n             } else break;\n         }\n \n@@ -1096,6 +1125,15 @@ pub const ArgParser = struct {\n                 result.overdue = true;\n             } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                 result.include_deferred = true;\n+            } else if (self.consumeFlag(null, \"--parent\")) {\n+                result.parent = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n+                result.recursive = true;\n+            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n+                const fmt_str = self.next() orelse return error.MissingFlagValue;\n+                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n+            } else if (self.consumeFlag(null, \"--fields\")) {\n+                result.fields = self.next() orelse return error.MissingFlagValue;\n             } else break;\n         }\n         return result;","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"ab64539e-bd01-4bfa-a1be-7ecd69e9ed61","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex fe002b8..c9786b6 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -199,6 +199,18 @@ pub const ImportArgs = struct {\n     dry_run: bool = false, // Show what would be imported without importing\n };\n \n+/// Output format for list/ready commands.\n+pub const OutputFormat = enum {\n+    default,\n+    csv,\n+\n+    pub fn fromString(s: []const u8) ?OutputFormat {\n+        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n+        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n+        return null;\n+    }\n+};\n+\n /// Sort field options for list command.\n pub const SortField = enum {\n     created_at,\n@@ -232,6 +244,10 @@ pub const ListArgs = struct {\n     include_deferred: bool = false,\n     sort: SortField = .created_at,\n     sort_desc: bool = true,\n+    parent: ?[]const u8 = null,\n+    recursive: bool = false,\n+    format: OutputFormat = .default,\n+    fields: ?[]const u8 = null,\n };\n \n /// Ready command arguments.\n@@ -244,6 +260,10 @@ pub const ReadyArgs = struct {\n     notes_contains: ?[]const u8 = null,\n     overdue: bool = false,\n     include_deferred: bool = false,\n+    parent: ?[]const u8 = null,\n+    recursive: bool = false,\n+    format: OutputFormat = .default,\n+    fields: ?[]const u8 = null,\n };\n \n /// Blocked command arguments.\n@@ -1067,6 +1087,15 @@ pub const ArgParser = struct {\n                 result.sort_desc = false;\n             } else if (self.consumeFlag(null, \"--desc\")) {\n                 result.sort_desc = true;\n+            } else if (self.consumeFlag(null, \"--parent\")) {\n+                result.parent = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n+                result.recursive = true;\n+            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n+                const fmt_str = self.next() orelse return error.MissingFlagValue;\n+                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n+            } else if (self.consumeFlag(null, \"--fields\")) {\n+                result.fields = self.next() orelse return error.MissingFlagValue;\n             } else break;\n         }\n \n@@ -1096,6 +1125,15 @@ pub const ArgParser = struct {\n                 result.overdue = true;\n             } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                 result.include_deferred = true;\n+            } else if (self.consumeFlag(null, \"--parent\")) {\n+                result.parent = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n+                result.recursive = true;\n+            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n+                const fmt_str = self.next() orelse return error.MissingFlagValue;\n+                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n+            } else if (self.consumeFlag(null, \"--fields\")) {\n+                result.fields = self.next() orelse return error.MissingFlagValue;\n             } else break;\n         }\n         return result;","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011h8CwD8HxcZnB7r2oKGSnh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S57YoaFdZomchVZUGzyVip","name":"Bash","input":{"command":"git diff src/storage/graph.zig","description":"Show changes to graph.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1112,"cache_read_input_tokens":114125,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1112},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"d192c01a-4a23-4189-aa83-55aa9802f559"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S57YoaFdZomchVZUGzyVip","type":"tool_result","content":"diff --git a/src/storage/graph.zig b/src/storage/graph.zig\nindex ee8fd14..077b00e 100644\n--- a/src/storage/graph.zig\n+++ b/src/storage/graph.zig\n@@ -427,6 +427,89 @@ pub const DependencyGraph = struct {\n         }\n         self.allocator.free(cycles);\n     }\n+\n+    /// Get direct children of a parent issue (issues with parent_child dependency).\n+    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {\n+        var results: std.ArrayListUnmanaged(Issue) = .{};\n+        errdefer {\n+            for (results.items) |*issue| {\n+                issue.deinit(self.allocator);\n+            }\n+            results.deinit(self.allocator);\n+        }\n+\n+        for (self.store.getAllRef()) |issue| {\n+            for (issue.dependencies) |dep| {\n+                if (depTypeEql(dep.dep_type, .parent_child) and\n+                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n+                {\n+                    try results.append(self.allocator, try issue.clone(self.allocator));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return results.toOwnedSlice(self.allocator);\n+    }\n+\n+    /// Get all descendants of a parent issue recursively.\n+    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {\n+        var results: std.ArrayListUnmanaged(Issue) = .{};\n+        errdefer {\n+            for (results.items) |*issue| {\n+                issue.deinit(self.allocator);\n+            }\n+            results.deinit(self.allocator);\n+        }\n+\n+        var visited: std.StringHashMapUnmanaged(void) = .{};\n+        defer visited.deinit(self.allocator);\n+\n+        try self.collectDescendants(parent_id, &results, &visited);\n+\n+        return results.toOwnedSlice(self.allocator);\n+    }\n+\n+    fn collectDescendants(\n+        self: *Self,\n+        parent_id: []const u8,\n+        results: *std.ArrayListUnmanaged(Issue),\n+        visited: *std.StringHashMapUnmanaged(void),\n+    ) !void {\n+        for (self.store.getAllRef()) |issue| {\n+            if (visited.contains(issue.id)) continue;\n+\n+            for (issue.dependencies) |dep| {\n+                if (depTypeEql(dep.dep_type, .parent_child) and\n+                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n+                {\n+                    try visited.put(self.allocator, issue.id, {});\n+                    try results.append(self.allocator, try issue.clone(self.allocator));\n+                    try self.collectDescendants(issue.id, results, visited);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Check if an issue is a child (direct or descendant) of a given parent.\n+    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {\n+        const issue = self.store.getRef(issue_id) orelse return false;\n+\n+        for (issue.dependencies) |dep| {\n+            if (depTypeEql(dep.dep_type, .parent_child)) {\n+                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {\n+                    return true;\n+                }\n+                if (recursive) {\n+                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n };\n \n // Helper functions\n@@ -438,6 +521,14 @@ fn statusEql(a: Status, b: Status) bool {\n     return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n }\n \n+fn depTypeEql(a: DependencyType, b: DependencyType) bool {\n+    const Tag = std.meta.Tag(DependencyType);\n+    const tag_a: Tag = a;\n+    const tag_b: Tag = b;\n+    if (tag_a != tag_b) return false;\n+    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n+}\n+\n fn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n     var result: Dependency = undefined;","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"6388fc9e-b4cc-4dda-b0ca-313368b2fefc","tool_use_result":{"stdout":"diff --git a/src/storage/graph.zig b/src/storage/graph.zig\nindex ee8fd14..077b00e 100644\n--- a/src/storage/graph.zig\n+++ b/src/storage/graph.zig\n@@ -427,6 +427,89 @@ pub const DependencyGraph = struct {\n         }\n         self.allocator.free(cycles);\n     }\n+\n+    /// Get direct children of a parent issue (issues with parent_child dependency).\n+    pub fn getChildren(self: *Self, parent_id: []const u8) ![]Issue {\n+        var results: std.ArrayListUnmanaged(Issue) = .{};\n+        errdefer {\n+            for (results.items) |*issue| {\n+                issue.deinit(self.allocator);\n+            }\n+            results.deinit(self.allocator);\n+        }\n+\n+        for (self.store.getAllRef()) |issue| {\n+            for (issue.dependencies) |dep| {\n+                if (depTypeEql(dep.dep_type, .parent_child) and\n+                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n+                {\n+                    try results.append(self.allocator, try issue.clone(self.allocator));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return results.toOwnedSlice(self.allocator);\n+    }\n+\n+    /// Get all descendants of a parent issue recursively.\n+    pub fn getDescendants(self: *Self, parent_id: []const u8) ![]Issue {\n+        var results: std.ArrayListUnmanaged(Issue) = .{};\n+        errdefer {\n+            for (results.items) |*issue| {\n+                issue.deinit(self.allocator);\n+            }\n+            results.deinit(self.allocator);\n+        }\n+\n+        var visited: std.StringHashMapUnmanaged(void) = .{};\n+        defer visited.deinit(self.allocator);\n+\n+        try self.collectDescendants(parent_id, &results, &visited);\n+\n+        return results.toOwnedSlice(self.allocator);\n+    }\n+\n+    fn collectDescendants(\n+        self: *Self,\n+        parent_id: []const u8,\n+        results: *std.ArrayListUnmanaged(Issue),\n+        visited: *std.StringHashMapUnmanaged(void),\n+    ) !void {\n+        for (self.store.getAllRef()) |issue| {\n+            if (visited.contains(issue.id)) continue;\n+\n+            for (issue.dependencies) |dep| {\n+                if (depTypeEql(dep.dep_type, .parent_child) and\n+                    std.mem.eql(u8, dep.depends_on_id, parent_id))\n+                {\n+                    try visited.put(self.allocator, issue.id, {});\n+                    try results.append(self.allocator, try issue.clone(self.allocator));\n+                    try self.collectDescendants(issue.id, results, visited);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Check if an issue is a child (direct or descendant) of a given parent.\n+    pub fn isChildOf(self: *Self, issue_id: []const u8, parent_id: []const u8, recursive: bool) bool {\n+        const issue = self.store.getRef(issue_id) orelse return false;\n+\n+        for (issue.dependencies) |dep| {\n+            if (depTypeEql(dep.dep_type, .parent_child)) {\n+                if (std.mem.eql(u8, dep.depends_on_id, parent_id)) {\n+                    return true;\n+                }\n+                if (recursive) {\n+                    if (self.isChildOf(dep.depends_on_id, parent_id, true)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n };\n \n // Helper functions\n@@ -438,6 +521,14 @@ fn statusEql(a: Status, b: Status) bool {\n     return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n }\n \n+fn depTypeEql(a: DependencyType, b: DependencyType) bool {\n+    const Tag = std.meta.Tag(DependencyType);\n+    const tag_a: Tag = a;\n+    const tag_b: Tag = b;\n+    if (tag_a != tag_b) return false;\n+    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n+}\n+\n fn cloneDependency(dep: Dependency, allocator: std.mem.Allocator) !Dependency {\n     var result: Dependency = undefined;","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ARyb8htPT41yk28asG8be9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PZ8pJrCAoGokR9d3sdE1Gx","name":"Bash","input":{"command":"git log -3 --oneline","description":"Show recent commits for style"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1398,"cache_read_input_tokens":115237,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1398},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"927ef251-173d-49e3-9cc7-798b5a1d3f01"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PZ8pJrCAoGokR9d3sdE1Gx","type":"tool_result","content":"487c67f Plan mode: complete 2 tasks\n0996d4b refactor(store): simplify list filter logic\n9016d44 feat(cli): add --overdue and --deferred filters for list and ready","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"0e763a69-50ea-4ae3-aceb-e7254438002a","tool_use_result":{"stdout":"487c67f Plan mode: complete 2 tasks\n0996d4b refactor(store): simplify list filter logic\n9016d44 feat(cli): add --overdue and --deferred filters for list and ready","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011q1XLG56pBcovqfa8JXWJV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GVM3FKDk3ESo1eBNQ12pAY","name":"Bash","input":{"command":"git add src/cli/args.zig src/cli/list.zig src/cli/ready.zig src/output/mod.zig src/storage/graph.zig","description":"Stage relevant source files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":143,"cache_read_input_tokens":116635,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":143},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"2438254b-27f8-4514-a52e-389b944acd64"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GVM3FKDk3ESo1eBNQ12pAY","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"5fef940c-34c9-4335-8b47-ef9e4bdfbb94","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EGWefD2Nm9dU2o1R3TfaBY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V2EsbgpNkJvYZVtg8cP7DZ","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nfeat(cli): add hierarchy filters and CSV output format\n\nAdd --parent and --recursive filters for list and ready commands:\n- --parent <id>: Filter to direct children of a parent issue\n- --recursive: Include all descendants when used with --parent\n\nAdd CSV output format with customizable fields:\n- --format csv: Output issues in CSV format\n- --fields id,title,status,...: Specify which columns to include\n\nImplementation:\n- DependencyGraph: Add getChildren(), getDescendants(), isChildOf()\n- Output: Add CSV formatter with proper escaping for quotes/commas\n- Args: Add OutputFormat enum and new command options\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit all changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":139,"cache_read_input_tokens":116778,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":139},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"585a714e-1dbd-44a7-a12a-1254a00ca686"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V2EsbgpNkJvYZVtg8cP7DZ","type":"tool_result","content":"[dev-hotschmoe 7ab8985] feat(cli): add hierarchy filters and CSV output format\n 5 files changed, 342 insertions(+), 2 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"c8682348-303f-465b-99df-4bfd6b01b917","tool_use_result":{"stdout":"[dev-hotschmoe 7ab8985] feat(cli): add hierarchy filters and CSV output format\n 5 files changed, 342 insertions(+), 2 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AAhjTbFE2f8s4QgtETXqpj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012hauGmqdibtGxgJb1Si3Nm","name":"TodoWrite","input":{"todos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"completed","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"completed","activeForm":"Creating single commit for all changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":312,"cache_read_input_tokens":116917,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":312},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"1866519e-3267-471d-b2a6-8dce0f5379b6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012hauGmqdibtGxgJb1Si3Nm","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"256a72fc-c940-4879-a779-098ba6d474c7","tool_use_result":{"oldTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"completed","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"in_progress","activeForm":"Creating single commit for all changes"}],"newTodos":[{"content":"Task 1: Add --parent and --recursive filters for hierarchy","status":"completed","activeForm":"Adding --parent and --recursive filters for hierarchy"},{"content":"Task 2: Add CSV output format with --fields option","status":"completed","activeForm":"Adding CSV output format with --fields option"},{"content":"Create single commit for all changes","status":"completed","activeForm":"Creating single commit for all changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ALqBS8Zpimke3WsCUs4NPf","type":"message","role":"assistant","content":[{"type":"text","text":"Both tasks have been completed successfully. Here's a summary:\n\n## Task Status\n\n### Task 1: Add --parent and --recursive filters for hierarchy - SUCCESS\n\n**Implementation:**\n- Added `--parent <id>` and `--recursive` flags to both `list` and `ready` commands in `args.zig`\n- Added `getChildren()`, `getDescendants()`, and `isChildOf()` functions to `DependencyGraph` in `graph.zig`\n- Applied filters in `list.zig` and `ready.zig` to filter issues by parent-child relationships\n\n**Usage:**\n```bash\nbz list --parent BD-1           # Direct children only\nbz list --parent BD-1 --recursive  # All descendants\nbz ready --parent BD-1          # Ready children of parent\n```\n\n### Task 2: Add CSV output format with --fields option - SUCCESS\n\n**Implementation:**\n- Added `OutputFormat` enum with `default` and `csv` options in `args.zig`\n- Added `--format csv` and `--fields` flags to both `list` and `ready` commands\n- Added CSV formatter (`printIssueListCsv`) to `Output` in `output/mod.zig` with proper escaping for commas, quotes, and newlines\n\n**Usage:**\n```bash\nbz list --format csv\nbz list --format csv --fields id,title,status,priority,assignee\nbz ready --format csv --fields id,title\n```\n\n**Available CSV fields:** id, title, status, priority, type, assignee, owner, description, created_at, updated_at, due_at, labels\n\n### Commit Created\nAll changes have been committed in a single commit: `7ab8985 feat(cli): add hierarchy filters and CSV output format`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":202,"cache_read_input_tokens":117229,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":202},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","uuid":"93413f0c-0427-4da6-8a60-a72076890003"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":397956,"duration_api_ms":420217,"num_turns":59,"result":"Both tasks have been completed successfully. Here's a summary:\n\n## Task Status\n\n### Task 1: Add --parent and --recursive filters for hierarchy - SUCCESS\n\n**Implementation:**\n- Added `--parent <id>` and `--recursive` flags to both `list` and `ready` commands in `args.zig`\n- Added `getChildren()`, `getDescendants()`, and `isChildOf()` functions to `DependencyGraph` in `graph.zig`\n- Applied filters in `list.zig` and `ready.zig` to filter issues by parent-child relationships\n\n**Usage:**\n```bash\nbz list --parent BD-1           # Direct children only\nbz list --parent BD-1 --recursive  # All descendants\nbz ready --parent BD-1          # Ready children of parent\n```\n\n### Task 2: Add CSV output format with --fields option - SUCCESS\n\n**Implementation:**\n- Added `OutputFormat` enum with `default` and `csv` options in `args.zig`\n- Added `--format csv` and `--fields` flags to both `list` and `ready` commands\n- Added CSV formatter (`printIssueListCsv`) to `Output` in `output/mod.zig` with proper escaping for commas, quotes, and newlines\n\n**Usage:**\n```bash\nbz list --format csv\nbz list --format csv --fields id,title,status,priority,assignee\nbz ready --format csv --fields id,title\n```\n\n**Available CSV fields:** id, title, status, priority, type, assignee, owner, description, created_at, updated_at, due_at, labels\n\n### Commit Created\nAll changes have been committed in a single commit: `7ab8985 feat(cli): add hierarchy filters and CSV output format`","session_id":"8b43dc9f-baf5-4ebd-87b4-c44da69f5dec","total_cost_usd":3.861854399999999,"usage":{"input_tokens":2,"cache_creation_input_tokens":99455,"cache_read_input_tokens":5236159,"output_tokens":16328,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":99455,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":16328,"cacheReadInputTokens":5236159,"cacheCreationInputTokens":99455,"webSearchRequests":0,"costUSD":3.6478832499999982,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":36637,"outputTokens":7850,"cacheReadInputTokens":577304,"cacheCreationInputTokens":64283,"webSearchRequests":0,"costUSD":0.21397115000000003,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"9501c07d-60d4-4493-9aa8-f309ecd9a0cd"}
