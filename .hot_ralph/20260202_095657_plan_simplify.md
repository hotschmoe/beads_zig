{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"3427775d-9f02-439a-891d-b9ec8986d232","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"9b425744-33df-4ca6-892e-b61bb3293e97"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wiwe3kCzHsgaKr4wLz8W1s","type":"message","role":"assistant","content":[{"type":"text","text":"I'll review the recently modified code and simplify where appropriate. Let me start by checking what was changed."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3681,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3681},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"74c098e3-e196-403c-a8be-cead3d2fe132"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wiwe3kCzHsgaKr4wLz8W1s","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FizqMkGfnp5dcc4bCZc1Yf","name":"Bash","input":{"command":"git status","description":"Check git status for modified files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3681,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3681},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"b55ebc55-f6e5-4c1a-b099-000afb1df16e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FizqMkGfnp5dcc4bCZc1Yf","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 40 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260202_095524_plan_mode.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"9cfb27b9-fed9-4a85-b4b3-e9327a62f565","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 40 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260202_095524_plan_mode.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wiwe3kCzHsgaKr4wLz8W1s","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JYYdkxusUtgeLq7iN8Nn5g","name":"Bash","input":{"command":"git diff --name-only HEAD~5","description":"List files changed in recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3681,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3681},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"6610bfe4-48a3-4992-bab7-f2bd63c502b6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JYYdkxusUtgeLq7iN8Nn5g","type":"tool_result","content":".beads/issues.jsonl\n.hot_ralph/20260202_093030_plan_mode.md\n.hot_ralph/20260202_093243_plan_simplify.md\n.hot_ralph/20260202_094323_plan_mode.md\n.hot_ralph/20260202_094624_plan_simplify.md\n.hot_ralph/state.json\nbuild.zig\nsrc/cli/args.zig\nsrc/cli/audit.zig\nsrc/cli/backup.zig\nsrc/cli/changelog.zig\nsrc/cli/graph.zig\nsrc/cli/help.zig\nsrc/cli/mod.zig\nsrc/cli/stats.zig\nsrc/main.zig\nsrc/models/event.zig","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"ade64f47-d0d2-40f1-b4f5-4e52ef29c7c1","tool_use_result":{"stdout":".beads/issues.jsonl\n.hot_ralph/20260202_093030_plan_mode.md\n.hot_ralph/20260202_093243_plan_simplify.md\n.hot_ralph/20260202_094323_plan_mode.md\n.hot_ralph/20260202_094624_plan_simplify.md\n.hot_ralph/state.json\nbuild.zig\nsrc/cli/args.zig\nsrc/cli/audit.zig\nsrc/cli/backup.zig\nsrc/cli/changelog.zig\nsrc/cli/graph.zig\nsrc/cli/help.zig\nsrc/cli/mod.zig\nsrc/cli/stats.zig\nsrc/main.zig\nsrc/models/event.zig","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CvcC6HcctJRwNaoi5wQi3u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Pm8XPMYzPZkPyyDKCjXCJf","name":"Bash","input":{"command":"git diff HEAD~5 -- src/","description":"Show diff of src/ files from recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":590,"cache_read_input_tokens":21657,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":590},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"1ccdf1b2-898a-45ca-8472-b7c901e3cc23"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Pm8XPMYzPZkPyyDKCjXCJf","type":"tool_result","content":"<persisted-output>\nOutput too large (68.5KB). Full output saved to: /home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/3427775d-9f02-439a-891d-b9ec8986d232/tool-results/toolu_01Pm8XPMYzPZkPyyDKCjXCJf.txt\n\nPreview (first 2KB):\ndiff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 1a80844..ee9431d 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -38,7 +38,7 @@ pub const Command = union(enum) {\n     // Workspace\n     init: InitArgs,\n     info: void,\n-    stats: void,\n+    stats: StatsArgs,\n     doctor: void,\n     config: ConfigArgs,\n     orphans: OrphansArgs,\n@@ -115,6 +115,12 @@ pub const InitArgs = struct {\n     prefix: []const u8 = \"bd\",\n };\n \n+/// Stats command arguments.\n+pub const StatsArgs = struct {\n+    activity: bool = false, // Show git-based activity statistics\n+    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n+};\n+\n /// Create command arguments.\n pub const CreateArgs = struct {\n     title: []const u8,\n@@ -426,6 +432,8 @@ pub const GraphArgs = struct {\n     id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n     format: GraphFormat = .ascii,\n     depth: ?u32 = null, // Max depth for tree traversal\n+    all: bool = false, // Show dependency graph for all open issues\n+    compact: bool = false, // Compact one-line-per-issue output\n };\n \n /// Label subcommand variants.\n@@ -474,15 +482,51 @@ pub const HistoryArgs = struct {\n     id: []const u8,\n };\n \n+/// Audit subcommand variants.\n+pub const AuditSubcommand = union(enum) {\n+    /// Record an LLM/tool interaction for training data.\n+    record: struct {\n+        kind: []const u8, // \"llm_call\" or \"tool_call\"\n+        issue_id: ?[]const u8 = null, // Optional issue context\n+        model: ?[]const u8 = null, // Model name (for llm_call)\n+        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n+        response: ?[]const u8 = null, // Output response (for llm_call)\n+        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n+        exit_code: ?i32 = null, // Exit code (for tool_call)\n+        metadata: ?[]const u8 = null, // Additional JSON metadata\n+    },\n+    /// Label an audit entry for quality tracking.\n+    label: struct {\n...\n</persisted-output>","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"e5890496-fa80-43ae-a2b9-4a1d7b7cf906","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 1a80844..ee9431d 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -38,7 +38,7 @@ pub const Command = union(enum) {\n     // Workspace\n     init: InitArgs,\n     info: void,\n-    stats: void,\n+    stats: StatsArgs,\n     doctor: void,\n     config: ConfigArgs,\n     orphans: OrphansArgs,\n@@ -115,6 +115,12 @@ pub const InitArgs = struct {\n     prefix: []const u8 = \"bd\",\n };\n \n+/// Stats command arguments.\n+pub const StatsArgs = struct {\n+    activity: bool = false, // Show git-based activity statistics\n+    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n+};\n+\n /// Create command arguments.\n pub const CreateArgs = struct {\n     title: []const u8,\n@@ -426,6 +432,8 @@ pub const GraphArgs = struct {\n     id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n     format: GraphFormat = .ascii,\n     depth: ?u32 = null, // Max depth for tree traversal\n+    all: bool = false, // Show dependency graph for all open issues\n+    compact: bool = false, // Compact one-line-per-issue output\n };\n \n /// Label subcommand variants.\n@@ -474,15 +482,51 @@ pub const HistoryArgs = struct {\n     id: []const u8,\n };\n \n+/// Audit subcommand variants.\n+pub const AuditSubcommand = union(enum) {\n+    /// Record an LLM/tool interaction for training data.\n+    record: struct {\n+        kind: []const u8, // \"llm_call\" or \"tool_call\"\n+        issue_id: ?[]const u8 = null, // Optional issue context\n+        model: ?[]const u8 = null, // Model name (for llm_call)\n+        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n+        response: ?[]const u8 = null, // Output response (for llm_call)\n+        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n+        exit_code: ?i32 = null, // Exit code (for tool_call)\n+        metadata: ?[]const u8 = null, // Additional JSON metadata\n+    },\n+    /// Label an audit entry for quality tracking.\n+    label: struct {\n+        entry_id: i64, // Event ID to label\n+        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n+        reason: ?[]const u8 = null, // Explanation for the label\n+    },\n+    /// View audit log for a specific issue.\n+    log: struct {\n+        issue_id: []const u8,\n+        limit: ?u32 = null,\n+    },\n+    /// Summary of audit data over time period.\n+    summary: struct {\n+        days: u32 = 7, // Number of days to summarize\n+    },\n+    /// Legacy: show project-wide audit log (default behavior).\n+    list: struct {\n+        limit: ?u32 = null,\n+    },\n+};\n+\n /// Audit command arguments.\n pub const AuditArgs = struct {\n-    limit: ?u32 = null,\n+    subcommand: AuditSubcommand,\n };\n \n /// Changelog command arguments.\n pub const ChangelogArgs = struct {\n     since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n     until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n+    since_tag: ?[]const u8 = null, // Git tag for start date (e.g., \"v1.0.0\")\n+    since_commit: ?[]const u8 = null, // Git commit for start date (e.g., \"abc123\")\n     limit: ?u32 = null,\n     group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n };\n@@ -804,7 +848,7 @@ pub const ArgParser = struct {\n             return .{ .info = {} };\n         }\n         if (std.mem.eql(u8, cmd, \"stats\")) {\n-            return .{ .stats = {} };\n+            return .{ .stats = try self.parseStatsArgs() };\n         }\n         if (std.mem.eql(u8, cmd, \"doctor\")) {\n             return .{ .doctor = {} };\n@@ -969,6 +1013,18 @@ pub const ArgParser = struct {\n         return result;\n     }\n \n+    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n+        var result = StatsArgs{};\n+        while (self.hasNext()) {\n+            if (self.consumeFlag(\"-a\", \"--activity\")) {\n+                result.activity = true;\n+            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n+                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n+            } else break;\n+        }\n+        return result;\n+    }\n+\n     fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n         var result = CreateArgs{ .title = undefined };\n         var title_set = false;\n@@ -1429,6 +1485,10 @@ pub const ArgParser = struct {\n                 result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n             } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                 result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-a\", \"--all\")) {\n+                result.all = true;\n+            } else if (self.consumeFlag(\"-c\", \"--compact\")) {\n+                result.compact = true;\n             } else if (self.peekPositional()) |_| {\n                 if (result.id == null) {\n                     result.id = self.next().?;\n@@ -1550,13 +1610,108 @@ pub const ArgParser = struct {\n     }\n \n     fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n-        var result = AuditArgs{};\n-        while (self.hasNext()) {\n-            if (try self.parseLimitFlag()) |limit| {\n-                result.limit = limit;\n-            } else break;\n+        // Check for subcommand\n+        const subcmd = self.next() orelse {\n+            // Default: list with no limit\n+            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n+        };\n+\n+        // Handle --limit flag at top level (legacy support)\n+        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n+            // Put it back and parse as list subcommand with limit\n+            self.index -= 1;\n+            var limit: ?u32 = null;\n+            while (self.hasNext()) {\n+                if (try self.parseLimitFlag()) |l| {\n+                    limit = l;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n         }\n-        return result;\n+\n+        if (std.mem.eql(u8, subcmd, \"record\")) {\n+            const kind = self.next() orelse return error.MissingRequiredArgument;\n+            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n+\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-i\", \"--issue\")) {\n+                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n+                    result.record.model = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n+                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n+                    result.record.response = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n+                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n+                    const exit_str = self.next() orelse return error.MissingFlagValue;\n+                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n+                } else if (self.consumeFlag(null, \"--metadata\")) {\n+                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n+                } else break;\n+            }\n+            return .{ .subcommand = result };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"label\")) {\n+            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n+            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n+            var label_value: ?[]const u8 = null;\n+            var reason: ?[]const u8 = null;\n+\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-l\", \"--label\")) {\n+                    label_value = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n+                    reason = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.peekPositional()) |_| {\n+                    if (label_value == null) {\n+                        label_value = self.next().?;\n+                    } else break;\n+                } else break;\n+            }\n+\n+            if (label_value == null) return error.MissingRequiredArgument;\n+            return .{ .subcommand = .{ .label = .{\n+                .entry_id = entry_id,\n+                .label_value = label_value.?,\n+                .reason = reason,\n+            } } };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"log\")) {\n+            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n+            var limit: ?u32 = null;\n+            while (self.hasNext()) {\n+                if (try self.parseLimitFlag()) |l| {\n+                    limit = l;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"summary\")) {\n+            var days: u32 = 7;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-d\", \"--days\")) {\n+                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n+            var limit: ?u32 = null;\n+            while (self.hasNext()) {\n+                if (try self.parseLimitFlag()) |l| {\n+                    limit = l;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n+        }\n+\n+        return error.UnknownSubcommand;\n     }\n \n     fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n@@ -1566,6 +1721,10 @@ pub const ArgParser = struct {\n                 result.since = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(null, \"--until\")) {\n                 result.until = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--since-tag\")) {\n+                result.since_tag = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--since-commit\")) {\n+                result.since_commit = self.next() orelse return error.MissingFlagValue;\n             } else if (try self.parseLimitFlag()) |limit| {\n                 result.limit = limit;\n             } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n@@ -2482,9 +2641,13 @@ test \"parse audit command\" {\n test \"parse audit command with limit\" {\n     const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\n-    const result = try parser.parse();\n+    var result = try parser.parse();\n+    defer result.deinit(std.testing.allocator);\n \n-    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n+    switch (result.command.audit.subcommand) {\n+        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n+        else => try std.testing.expect(false),\n+    }\n }\n \n test \"parse sync command\" {\ndiff --git a/src/cli/audit.zig b/src/cli/audit.zig\nindex 50d3d6b..6860d8d 100644\n--- a/src/cli/audit.zig\n+++ b/src/cli/audit.zig\n@@ -1,10 +1,16 @@\n //! Audit command for beads_zig.\n //!\n-//! `bz audit [--limit N]` - Show project-wide audit log\n+//! `bz audit` - Show project-wide audit log (default)\n+//! `bz audit record <kind>` - Record LLM/tool interaction\n+//! `bz audit label <entry-id> <label>` - Label audit entry\n+//! `bz audit log <issue-id>` - View audit log for specific issue\n+//! `bz audit summary` - Summary of audit data over time period\n \n const std = @import(\"std\");\n const common = @import(\"common.zig\");\n const args = @import(\"args.zig\");\n+const Event = @import(\"../models/event.zig\").Event;\n+const EventType = @import(\"../models/event.zig\").EventType;\n \n const CommandContext = common.CommandContext;\n \n@@ -12,19 +18,42 @@ pub const AuditError = error{\n     WorkspaceNotInitialized,\n     StorageError,\n     OutOfMemory,\n+    InvalidKind,\n+    EntryNotFound,\n };\n \n pub const AuditResult = struct {\n     success: bool,\n     events: ?[]const AuditEvent = null,\n     total: ?usize = null,\n+    event_id: ?i64 = null,\n+    summary: ?AuditSummary = null,\n     message: ?[]const u8 = null,\n \n     pub const AuditEvent = struct {\n+        id: i64,\n         issue_id: []const u8,\n         event_type: []const u8,\n         actor: []const u8,\n         created_at: i64,\n+        old_value: ?[]const u8 = null,\n+        new_value: ?[]const u8 = null,\n+    };\n+\n+    pub const AuditSummary = struct {\n+        period_days: u32,\n+        total_events: usize,\n+        llm_calls: usize,\n+        tool_calls: usize,\n+        issue_creates: usize,\n+        issue_closes: usize,\n+        other_events: usize,\n+        by_actor: ?[]const ActorCount = null,\n+\n+        pub const ActorCount = struct {\n+            actor: []const u8,\n+            count: usize,\n+        };\n     };\n };\n \n@@ -32,13 +61,364 @@ pub fn run(\n     audit_args: args.AuditArgs,\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n+) !void {\n+    switch (audit_args.subcommand) {\n+        .record => |record_args| try runRecord(record_args, global, allocator),\n+        .label => |label_args| try runLabel(label_args, global, allocator),\n+        .log => |log_args| try runLog(log_args, global, allocator),\n+        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n+        .list => |list_args| try runList(list_args, global, allocator),\n+    }\n+}\n+\n+fn runRecord(\n+    record_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Validate kind\n+    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n+        .llm_call\n+    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n+        .tool_call\n+    else {\n+        if (!global.silent) {\n+            if (global.isStructuredOutput()) {\n+                try ctx.output.printJson(AuditResult{\n+                    .success = false,\n+                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n+                });\n+            } else {\n+                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n+            }\n+        }\n+        return AuditError.InvalidKind;\n+    };\n+\n+    const actor = global.actor orelse \"unknown\";\n+    const now = std.time.timestamp();\n+\n+    // Build metadata JSON with all provided fields\n+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n+    defer metadata_parts.deinit(allocator);\n+\n+    try metadata_parts.appendSlice(allocator, \"{\");\n+    var first = true;\n+\n+    if (record_args.model) |model| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n+        try metadata_parts.appendSlice(allocator, model);\n+        try metadata_parts.appendSlice(allocator, \"\\\"\");\n+        first = false;\n+    }\n+    if (record_args.prompt) |prompt| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n+        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n+        defer allocator.free(escaped);\n+        try metadata_parts.appendSlice(allocator, escaped);\n+        first = false;\n+    }\n+    if (record_args.response) |response| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n+        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n+        defer allocator.free(escaped);\n+        try metadata_parts.appendSlice(allocator, escaped);\n+        first = false;\n+    }\n+    if (record_args.tool_name) |tool_name| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n+        try metadata_parts.appendSlice(allocator, tool_name);\n+        try metadata_parts.appendSlice(allocator, \"\\\"\");\n+        first = false;\n+    }\n+    if (record_args.exit_code) |exit_code| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        var buf: [32]u8 = undefined;\n+        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n+        try metadata_parts.appendSlice(allocator, s);\n+        first = false;\n+    }\n+    if (record_args.metadata) |metadata| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n+        try metadata_parts.appendSlice(allocator, metadata);\n+        first = false;\n+    }\n+    try metadata_parts.appendSlice(allocator, \"}\");\n+\n+    const new_value = try allocator.dupe(u8, metadata_parts.items);\n+    defer allocator.free(new_value);\n+\n+    const event = Event{\n+        .id = 0,\n+        .issue_id = record_args.issue_id orelse \"\",\n+        .event_type = event_type,\n+        .actor = actor,\n+        .old_value = null,\n+        .new_value = new_value,\n+        .created_at = now,\n+    };\n+\n+    const event_id = try ctx.event_store.append(event);\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .event_id = event_id,\n+            .message = \"Audit entry recorded\",\n+        });\n+    } else if (!global.quiet) {\n+        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n+    }\n+}\n+\n+fn runLabel(\n+    label_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Record a label event referencing the original entry\n+    const actor = global.actor orelse \"unknown\";\n+    const now = std.time.timestamp();\n+\n+    // Build the label metadata\n+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n+    defer metadata_parts.deinit(allocator);\n+\n+    var buf: [64]u8 = undefined;\n+    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n+    try metadata_parts.appendSlice(allocator, header);\n+\n+    if (label_args.reason) |reason| {\n+        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n+        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n+        defer allocator.free(escaped);\n+        try metadata_parts.appendSlice(allocator, escaped);\n+    }\n+    try metadata_parts.appendSlice(allocator, \"}\");\n+\n+    const new_value = try allocator.dupe(u8, metadata_parts.items);\n+    defer allocator.free(new_value);\n+\n+    // Use 'updated' event type to represent a label action on an existing entry\n+    const event = Event{\n+        .id = 0,\n+        .issue_id = \"\", // Labels are not issue-specific\n+        .event_type = .updated,\n+        .actor = actor,\n+        .old_value = null,\n+        .new_value = new_value,\n+        .created_at = now,\n+    };\n+\n+    const event_id = try ctx.event_store.append(event);\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .event_id = event_id,\n+            .message = \"Label applied to audit entry\",\n+        });\n+    } else if (!global.quiet) {\n+        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n+    }\n+}\n+\n+fn runLog(\n+    log_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    const limit = log_args.limit orelse 100;\n+\n+    // Query events for the specific issue from the event store\n+    const events = try ctx.event_store.queryEvents(.{\n+        .issue_id = log_args.issue_id,\n+        .limit = limit,\n+    });\n+    defer ctx.event_store.freeEvents(events);\n+\n+    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n+    defer audit_events.deinit(allocator);\n+\n+    for (events) |event| {\n+        try audit_events.append(allocator, .{\n+            .id = event.id,\n+            .issue_id = event.issue_id,\n+            .event_type = event.event_type.toString(),\n+            .actor = event.actor,\n+            .created_at = event.created_at,\n+            .old_value = event.old_value,\n+            .new_value = event.new_value,\n+        });\n+    }\n+\n+    // Sort by timestamp descending\n+    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n+        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n+            return a.created_at > b.created_at;\n+        }\n+    }.lessThan);\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .events = audit_events.items,\n+            .total = audit_events.items.len,\n+        });\n+    } else if (global.quiet) {\n+        for (audit_events.items) |event| {\n+            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n+        }\n+    } else {\n+        if (audit_events.items.len == 0) {\n+            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n+        } else {\n+            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n+            try ctx.output.print(\"\\n\", .{});\n+\n+            for (audit_events.items) |event| {\n+                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n+                    event.id,\n+                    event.created_at,\n+                    event.actor,\n+                    event.event_type,\n+                });\n+                if (event.new_value) |v| {\n+                    if (v.len > 0 and v.len < 200) {\n+                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn runSummary(\n+    summary_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n ) !void {\n     var ctx = (try CommandContext.init(allocator, global)) orelse {\n         return AuditError.WorkspaceNotInitialized;\n     };\n     defer ctx.deinit();\n \n-    const limit = audit_args.limit orelse 100;\n+    const now = std.time.timestamp();\n+    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n+\n+    // Query all events in the time period\n+    const events = try ctx.event_store.queryEvents(.{ .since = since });\n+    defer ctx.event_store.freeEvents(events);\n+\n+    // Count by type\n+    var llm_calls: usize = 0;\n+    var tool_calls: usize = 0;\n+    var issue_creates: usize = 0;\n+    var issue_closes: usize = 0;\n+    var other_events: usize = 0;\n+\n+    // Count by actor\n+    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n+    defer actor_counts.deinit(allocator);\n+\n+    for (events) |event| {\n+        switch (event.event_type) {\n+            .llm_call => llm_calls += 1,\n+            .tool_call => tool_calls += 1,\n+            .created => issue_creates += 1,\n+            .closed => issue_closes += 1,\n+            else => other_events += 1,\n+        }\n+\n+        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n+        entry.value_ptr.* += 1;\n+    }\n+\n+    // Convert actor counts to array\n+    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n+    defer actor_list.deinit(allocator);\n+\n+    var it = actor_counts.iterator();\n+    while (it.next()) |entry| {\n+        try actor_list.append(allocator, .{\n+            .actor = entry.key_ptr.*,\n+            .count = entry.value_ptr.*,\n+        });\n+    }\n+\n+    // Sort by count descending\n+    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n+        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n+            return a.count > b.count;\n+        }\n+    }.lessThan);\n+\n+    const summary = AuditResult.AuditSummary{\n+        .period_days = summary_args.days,\n+        .total_events = events.len,\n+        .llm_calls = llm_calls,\n+        .tool_calls = tool_calls,\n+        .issue_creates = issue_creates,\n+        .issue_closes = issue_closes,\n+        .other_events = other_events,\n+        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n+    };\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .summary = summary,\n+        });\n+    } else if (!global.quiet) {\n+        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n+        try ctx.output.print(\"\\n\", .{});\n+        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n+        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n+        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n+        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n+        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n+        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n+\n+        if (actor_list.items.len > 0) {\n+            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n+            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n+                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n+            }\n+        }\n+    }\n+}\n+\n+fn runList(\n+    list_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    const limit = list_args.limit orelse 100;\n \n     // Build synthetic audit log from all issues\n     var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n@@ -47,6 +427,7 @@ pub fn run(\n     for (ctx.store.issues.items) |issue| {\n         // Created event\n         try events.append(allocator, .{\n+            .id = 0,\n             .issue_id = issue.id,\n             .event_type = \"created\",\n             .actor = issue.created_by orelse \"unknown\",\n@@ -56,6 +437,7 @@ pub fn run(\n         // Closed event\n         if (issue.closed_at.value) |closed_ts| {\n             try events.append(allocator, .{\n+                .id = 0,\n                 .issue_id = issue.id,\n                 .event_type = \"closed\",\n                 .actor = \"unknown\",\n@@ -66,6 +448,7 @@ pub fn run(\n         // If tombstoned\n         if (issue.status.eql(.tombstone)) {\n             try events.append(allocator, .{\n+                .id = 0,\n                 .issue_id = issue.id,\n                 .event_type = \"deleted\",\n                 .actor = \"unknown\",\n@@ -139,9 +522,69 @@ test \"AuditResult struct works\" {\n test \"run detects uninitialized workspace\" {\n     const allocator = std.testing.allocator;\n \n-    const audit_args = args.AuditArgs{};\n+    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n \n     const result = run(audit_args, global, allocator);\n     try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n }\n+\n+test \"AuditSubcommand record parses correctly\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .audit => |a| {\n+            switch (a.subcommand) {\n+                .record => |r| {\n+                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n+                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n+                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n+                },\n+                else => try std.testing.expect(false),\n+            }\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"AuditSubcommand summary parses days\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .audit => |a| {\n+            switch (a.subcommand) {\n+                .summary => |s| {\n+                    try std.testing.expectEqual(@as(u32, 30), s.days);\n+                },\n+                else => try std.testing.expect(false),\n+            }\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"AuditSubcommand list is default\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{\"audit\"};\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .audit => |a| {\n+            switch (a.subcommand) {\n+                .list => {},\n+                else => try std.testing.expect(false),\n+            }\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/cli/backup.zig b/src/cli/backup.zig\nindex 9483ef0..0cbcab4 100644\n--- a/src/cli/backup.zig\n+++ b/src/cli/backup.zig\n@@ -27,6 +27,49 @@ pub const BackupInfo = struct {\n     modified: i64,\n };\n \n+/// Collect backup files from the .beads directory.\n+/// Returns a list of BackupInfo structs sorted by modified time (newest first).\n+/// Caller is responsible for freeing the filenames and deiniting the list.\n+fn collectBackups(beads_dir: []const u8, allocator: std.mem.Allocator) !?std.ArrayListUnmanaged(BackupInfo) {\n+    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n+        if (err == error.FileNotFound) return null;\n+        return err;\n+    };\n+    defer dir.close();\n+\n+    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n+    errdefer {\n+        for (backups.items) |b| allocator.free(b.filename);\n+        backups.deinit(allocator);\n+    }\n+\n+    var iter = dir.iterate();\n+    while (try iter.next()) |entry| {\n+        // Match backup files: issues.jsonl.bak.* or issues.*.jsonl (but not issues.jsonl)\n+        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n+            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n+            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n+            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n+        {\n+            const stat = dir.statFile(entry.name) catch continue;\n+            try backups.append(allocator, .{\n+                .filename = try allocator.dupe(u8, entry.name),\n+                .size = stat.size,\n+                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n+            });\n+        }\n+    }\n+\n+    // Sort by modified time (newest first)\n+    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n+        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n+            return a.modified > b.modified;\n+        }\n+    }.lessThan);\n+\n+    return backups;\n+}\n+\n pub const BackupResult = struct {\n     success: bool,\n     action: ?[]const u8 = null,\n@@ -65,55 +108,24 @@ pub fn run(\n fn runList(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n     const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n \n-    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n+    var backups = (try collectBackups(beads_dir, allocator)) orelse {\n+        if (structured_output) {\n+            try ctx.output.printJson(BackupResult{\n+                .success = true,\n+                .action = \"list\",\n+                .backup_count = 0,\n+                .message = \"no backups found\",\n+            });\n+        } else if (!quiet) {\n+            try ctx.output.info(\"No backups found\", .{});\n+        }\n+        return;\n+    };\n     defer {\n         for (backups.items) |b| allocator.free(b.filename);\n         backups.deinit(allocator);\n     }\n \n-    // Open the .beads directory and look for backup files\n-    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n-        if (err == error.FileNotFound) {\n-            if (structured_output) {\n-                try ctx.output.printJson(BackupResult{\n-                    .success = true,\n-                    .action = \"list\",\n-                    .backup_count = 0,\n-                    .message = \"no backups found\",\n-                });\n-            } else if (!quiet) {\n-                try ctx.output.info(\"No backups found\", .{});\n-            }\n-            return;\n-        }\n-        return err;\n-    };\n-    defer dir.close();\n-\n-    var iter = dir.iterate();\n-    while (try iter.next()) |entry| {\n-        // Look for backup files matching pattern: issues.jsonl.bak.* or issues.*.jsonl\n-        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n-            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n-            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n-            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n-        {\n-            const stat = dir.statFile(entry.name) catch continue;\n-            try backups.append(allocator, .{\n-                .filename = try allocator.dupe(u8, entry.name),\n-                .size = stat.size,\n-                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n-            });\n-        }\n-    }\n-\n-    // Sort by modified time (newest first)\n-    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n-        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n-            return a.modified > b.modified;\n-        }\n-    }.lessThan);\n-\n     if (structured_output) {\n         try ctx.output.printJson(BackupResult{\n             .success = true,\n@@ -328,47 +340,24 @@ fn runRestore(ctx: *CommandContext, file: []const u8, dry_run: bool, structured_\n fn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n     const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n \n-    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n+    var backups = (try collectBackups(beads_dir, allocator)) orelse {\n+        if (structured_output) {\n+            try ctx.output.printJson(BackupResult{\n+                .success = true,\n+                .action = \"prune\",\n+                .pruned_count = 0,\n+                .message = \"no backups to prune\",\n+            });\n+        } else if (!quiet) {\n+            try ctx.output.info(\"No backups to prune\", .{});\n+        }\n+        return;\n+    };\n     defer {\n         for (backups.items) |b| allocator.free(b.filename);\n         backups.deinit(allocator);\n     }\n \n-    // Collect backup files\n-    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n-        if (err == error.FileNotFound) {\n-            if (structured_output) {\n-                try ctx.output.printJson(BackupResult{\n-                    .success = true,\n-                    .action = \"prune\",\n-                    .pruned_count = 0,\n-                    .message = \"no backups to prune\",\n-                });\n-            } else if (!quiet) {\n-                try ctx.output.info(\"No backups to prune\", .{});\n-            }\n-            return;\n-        }\n-        return err;\n-    };\n-    defer dir.close();\n-\n-    var iter = dir.iterate();\n-    while (try iter.next()) |entry| {\n-        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n-            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n-            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n-            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n-        {\n-            const stat = dir.statFile(entry.name) catch continue;\n-            try backups.append(allocator, .{\n-                .filename = try allocator.dupe(u8, entry.name),\n-                .size = stat.size,\n-                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n-            });\n-        }\n-    }\n-\n     if (backups.items.len <= keep) {\n         if (structured_output) {\n             try ctx.output.printJson(BackupResult{\n@@ -383,13 +372,6 @@ fn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: b\n         return;\n     }\n \n-    // Sort by modified time (newest first)\n-    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n-        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n-            return a.modified > b.modified;\n-        }\n-    }.lessThan);\n-\n     const to_prune = backups.items.len - keep;\n \n     if (dry_run) {\ndiff --git a/src/cli/changelog.zig b/src/cli/changelog.zig\nindex 35b2266..d7b5c90 100644\n--- a/src/cli/changelog.zig\n+++ b/src/cli/changelog.zig\n@@ -20,6 +20,9 @@ pub const ChangelogError = error{\n     InvalidDateFormat,\n     StorageError,\n     OutOfMemory,\n+    GitTagNotFound,\n+    GitCommitNotFound,\n+    GitError,\n };\n \n pub const ChangelogResult = struct {\n@@ -70,7 +73,26 @@ pub fn run(\n     var filtered_issues: std.ArrayListUnmanaged(Issue) = .{};\n     defer filtered_issues.deinit(allocator);\n \n-    const since_ts = if (changelog_args.since) |s| parseDateToTimestamp(s) else null;\n+    // Determine the since timestamp from various sources (priority: since_tag > since_commit > since)\n+    var since_ts: ?i64 = null;\n+    if (changelog_args.since_tag) |tag| {\n+        since_ts = getTimestampFromGitTag(allocator, tag) catch |err| {\n+            if (!global.isStructuredOutput()) {\n+                try ctx.output.err(\"Failed to get timestamp for tag '{s}': {s}\", .{ tag, @errorName(err) });\n+            }\n+            return err;\n+        };\n+    } else if (changelog_args.since_commit) |commit| {\n+        since_ts = getTimestampFromGitCommit(allocator, commit) catch |err| {\n+            if (!global.isStructuredOutput()) {\n+                try ctx.output.err(\"Failed to get timestamp for commit '{s}': {s}\", .{ commit, @errorName(err) });\n+            }\n+            return err;\n+        };\n+    } else if (changelog_args.since) |s| {\n+        since_ts = parseDateToTimestamp(s);\n+    }\n+\n     const until_ts = if (changelog_args.until) |u| parseDateToTimestamp(u) else null;\n \n     for (issues) |issue| {\n@@ -259,6 +281,48 @@ fn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n     return era * 146097 + doe - 719468;\n }\n \n+fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n+    // Get the commit timestamp for the given tag\n+    // Format: git log -1 --format=%ct <tag>\n+    const result = std.process.Child.run(.{\n+        .allocator = allocator,\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n+        .cwd = null,\n+    }) catch return ChangelogError.GitError;\n+\n+    defer allocator.free(result.stderr);\n+    defer allocator.free(result.stdout);\n+\n+    if (result.term.Exited != 0) {\n+        return ChangelogError.GitTagNotFound;\n+    }\n+\n+    // Parse the timestamp (trim newline)\n+    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n+    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n+}\n+\n+fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n+    // Get the commit timestamp for the given commit hash\n+    // Format: git log -1 --format=%ct <commit>\n+    const result = std.process.Child.run(.{\n+        .allocator = allocator,\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n+        .cwd = null,\n+    }) catch return ChangelogError.GitError;\n+\n+    defer allocator.free(result.stderr);\n+    defer allocator.free(result.stdout);\n+\n+    if (result.term.Exited != 0) {\n+        return ChangelogError.GitCommitNotFound;\n+    }\n+\n+    // Parse the timestamp (trim newline)\n+    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n+    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n+}\n+\n // --- Tests ---\n \n test \"ChangelogError enum exists\" {\n@@ -322,3 +386,49 @@ test \"parseDateToTimestamp returns null for invalid date\" {\n     try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"2024\"));\n     try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"\"));\n }\n+\n+test \"ChangelogArgs supports since_tag field\" {\n+    const changelog_args = args.ChangelogArgs{\n+        .since_tag = \"v1.0.0\",\n+    };\n+    try std.testing.expectEqualStrings(\"v1.0.0\", changelog_args.since_tag.?);\n+}\n+\n+test \"ChangelogArgs supports since_commit field\" {\n+    const changelog_args = args.ChangelogArgs{\n+        .since_commit = \"abc123\",\n+    };\n+    try std.testing.expectEqualStrings(\"abc123\", changelog_args.since_commit.?);\n+}\n+\n+test \"parse changelog with since-tag flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"changelog\", \"--since-tag\", \"v1.0.0\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .changelog => |c| {\n+            try std.testing.expect(c.since_tag != null);\n+            try std.testing.expectEqualStrings(\"v1.0.0\", c.since_tag.?);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse changelog with since-commit flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"changelog\", \"--since-commit\", \"abc123def\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .changelog => |c| {\n+            try std.testing.expect(c.since_commit != null);\n+            try std.testing.expectEqualStrings(\"abc123def\", c.since_commit.?);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/cli/graph.zig b/src/cli/graph.zig\nindex 6e44bc5..2e64f23 100644\n--- a/src/cli/graph.zig\n+++ b/src/cli/graph.zig\n@@ -52,6 +52,9 @@ pub fn run(\n             return GraphError.IssueNotFound;\n         }\n         try renderIssueGraph(&dep_graph, &ctx.output, id, graph_args, global, allocator);\n+    } else if (graph_args.all) {\n+        // Show dependency graph for all open issues\n+        try renderAllOpenGraph(&ctx.store, &ctx.output, graph_args, global, allocator);\n     } else {\n         try renderFullGraph(&ctx.store, &ctx.output, graph_args, global, allocator);\n     }\n@@ -65,6 +68,10 @@ fn renderIssueGraph(\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n+    if (graph_args.compact) {\n+        try renderCompactIssueGraph(graph, output, issue_id, graph_args.depth, global, allocator);\n+        return;\n+    }\n     switch (graph_args.format) {\n         .ascii => try renderAsciiTree(graph, output, issue_id, graph_args.depth, global, allocator),\n         .dot => try renderDotGraph(graph, output, issue_id, graph_args.depth, global, allocator),\n@@ -426,6 +433,169 @@ fn statusEql(a: Status, b: Status) bool {\n     return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n }\n \n+fn renderCompactIssueGraph(\n+    graph: *DependencyGraph,\n+    output: *Output,\n+    issue_id: []const u8,\n+    max_depth: ?u32,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var buf: std.ArrayListUnmanaged(u8) = .{};\n+    defer buf.deinit(allocator);\n+    const writer = buf.writer(allocator);\n+\n+    var visited: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var it = visited.keyIterator();\n+        while (it.next()) |key| {\n+            allocator.free(key.*);\n+        }\n+        visited.deinit(allocator);\n+    }\n+\n+    // Print root issue\n+    if (graph.store.getRef(issue_id)) |issue| {\n+        const status_indicator = if (statusEql(issue.status, .closed)) \"[x]\" else \"[ ]\";\n+        try writer.print(\"{s} {s} {s}\\n\", .{ issue.id, status_indicator, truncateTitle(issue.title, 60) });\n+    }\n+\n+    // Collect and print dependencies in compact format\n+    try renderCompactDeps(graph, writer, issue_id, 1, max_depth orelse 10, &visited, allocator);\n+\n+    if (global.isStructuredOutput()) {\n+        try output.printJson(GraphResult{\n+            .success = true,\n+            .format = \"compact\",\n+            .output = buf.items,\n+        });\n+    } else {\n+        try output.raw(buf.items);\n+    }\n+}\n+\n+fn renderCompactDeps(\n+    graph: *DependencyGraph,\n+    writer: anytype,\n+    issue_id: []const u8,\n+    depth: u32,\n+    max_depth: u32,\n+    visited: *std.StringHashMapUnmanaged(void),\n+    allocator: std.mem.Allocator,\n+) !void {\n+    if (depth > max_depth) return;\n+\n+    const id_key = try allocator.dupe(u8, issue_id);\n+    if (visited.contains(id_key)) {\n+        allocator.free(id_key);\n+        return;\n+    }\n+    try visited.put(allocator, id_key, {});\n+\n+    const deps = try graph.getDependencies(issue_id);\n+    defer graph.freeDependencies(deps);\n+\n+    for (deps) |dep| {\n+        if (graph.store.getRef(dep.depends_on_id)) |blocker| {\n+            const status_indicator = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n+            // Indent based on depth for hierarchy visibility\n+            var i: u32 = 0;\n+            while (i < depth) : (i += 1) {\n+                try writer.writeAll(\"  \");\n+            }\n+            try writer.print(\"-> {s} {s} {s}\\n\", .{ blocker.id, status_indicator, truncateTitle(blocker.title, 50) });\n+            try renderCompactDeps(graph, writer, dep.depends_on_id, depth + 1, max_depth, visited, allocator);\n+        }\n+    }\n+}\n+\n+fn renderAllOpenGraph(\n+    store: *storage.IssueStore,\n+    output: *Output,\n+    graph_args: args.GraphArgs,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var buf: std.ArrayListUnmanaged(u8) = .{};\n+    defer buf.deinit(allocator);\n+    const writer = buf.writer(allocator);\n+\n+    const issues = store.getAllRef();\n+    var open_with_deps: usize = 0;\n+\n+    if (!graph_args.compact) {\n+        try writer.writeAll(\"Open Issues Dependency Graph\\n\");\n+        try writer.writeAll(\"=============================\\n\\n\");\n+    }\n+\n+    for (issues) |issue| {\n+        // Only show open issues (not closed/tombstone)\n+        if (statusEql(issue.status, .closed) or statusEql(issue.status, .tombstone)) {\n+            continue;\n+        }\n+\n+        const has_deps = issue.dependencies.len > 0;\n+        const has_dependents = hasAnyDependents(store, issue.id);\n+\n+        if (has_deps or has_dependents) {\n+            open_with_deps += 1;\n+\n+            if (graph_args.compact) {\n+                // Compact: one line per issue showing status and dep count\n+                const status_indicator = if (statusEql(issue.status, .blocked)) \"[B]\" else \"[ ]\";\n+                const dep_count = issue.dependencies.len;\n+                if (dep_count > 0) {\n+                    try writer.print(\"{s} {s} {s} (deps: {d})\\n\", .{\n+                        issue.id,\n+                        status_indicator,\n+                        truncateTitle(issue.title, 50),\n+                        dep_count,\n+                    });\n+                } else {\n+                    try writer.print(\"{s} {s} {s}\\n\", .{\n+                        issue.id,\n+                        status_indicator,\n+                        truncateTitle(issue.title, 50),\n+                    });\n+                }\n+            } else {\n+                // Full ASCII format for each open issue with dependencies\n+                const status_str = issue.status.toString();\n+                try writer.print(\"{s} [{s}] - {s}\\n\", .{ issue.id, status_str, truncateTitle(issue.title, 50) });\n+\n+                for (issue.dependencies, 0..) |dep, i| {\n+                    const is_last = (i == issue.dependencies.len - 1);\n+                    const connector = if (is_last) \"`-- \" else \"|-- \";\n+\n+                    if (store.getRef(dep.depends_on_id)) |blocker| {\n+                        const blocker_status = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n+                        try writer.print(\"  {s}{s} {s} - {s}\\n\", .{ connector, blocker.id, blocker_status, truncateTitle(blocker.title, 40) });\n+                    } else {\n+                        try writer.print(\"  {s}{s} [?] - (not found)\\n\", .{ connector, dep.depends_on_id });\n+                    }\n+                }\n+                try writer.writeAll(\"\\n\");\n+            }\n+        }\n+    }\n+\n+    if (open_with_deps == 0) {\n+        try writer.writeAll(\"No open issues with dependencies found.\\n\");\n+    }\n+\n+    if (global.isStructuredOutput()) {\n+        const format_str = if (graph_args.compact) \"compact\" else \"ascii\";\n+        try output.printJson(GraphResult{\n+            .success = true,\n+            .format = format_str,\n+            .node_count = open_with_deps,\n+            .output = buf.items,\n+        });\n+    } else {\n+        try output.raw(buf.items);\n+    }\n+}\n+\n // --- Tests ---\n \n test \"GraphError enum exists\" {\n@@ -471,3 +641,83 @@ test \"GraphFormat.fromString parses correctly\" {\n     try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ASCII\").?);\n     try std.testing.expect(args.GraphFormat.fromString(\"invalid\") == null);\n }\n+\n+test \"GraphArgs supports all flag\" {\n+    const graph_args = args.GraphArgs{\n+        .all = true,\n+    };\n+    try std.testing.expect(graph_args.all);\n+    try std.testing.expect(!graph_args.compact);\n+}\n+\n+test \"GraphArgs supports compact flag\" {\n+    const graph_args = args.GraphArgs{\n+        .compact = true,\n+    };\n+    try std.testing.expect(graph_args.compact);\n+    try std.testing.expect(!graph_args.all);\n+}\n+\n+test \"parse graph with all flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"--all\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.all);\n+            try std.testing.expect(!g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse graph with compact flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"--compact\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse graph with id and compact flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"bd-123\", \"--compact\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.id != null);\n+            try std.testing.expectEqualStrings(\"bd-123\", g.id.?);\n+            try std.testing.expect(g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse graph with short flags\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"-a\", \"-c\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.all);\n+            try std.testing.expect(g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/cli/help.zig b/src/cli/help.zig\nindex 08d2349..d5ff84f 100644\n--- a/src/cli/help.zig\n+++ b/src/cli/help.zig\n@@ -518,19 +518,23 @@ const commands = [_]CommandHelp{\n     .{\n         .name = \"graph\",\n         .summary = \"Show dependency graph\",\n-        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n+        .usage = \"bz graph [ID] [--format FMT] [--depth N] [--all] [--compact]\",\n         .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n-            \"With an ID, shows that issue's dependency subgraph.\",\n+            \"With an ID, shows that issue's dependency subgraph. Use --all for open issues only, --compact for one-line output.\",\n         .arguments = &[_]ArgHelp{\n             .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n         },\n         .flags = &[_]FlagHelp{\n             .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n             .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n+            .{ .short = \"-a\", .long = \"--all\", .description = \"Show graph for all open issues\" },\n+            .{ .short = \"-c\", .long = \"--compact\", .description = \"Compact one-line-per-issue output\" },\n         },\n         .examples = &[_]ExampleHelp{\n             .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n             .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n+            .{ .command = \"bz graph --all\", .description = \"Show graph for all open issues\" },\n+            .{ .command = \"bz graph bd-abc --compact\", .description = \"Compact output for specific issue\" },\n             .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n         },\n         .see_also = &[_][]const u8{\"dep\"},\n@@ -627,18 +631,22 @@ const commands = [_]CommandHelp{\n     .{\n         .name = \"changelog\",\n         .summary = \"Generate changelog from closed issues\",\n-        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n+        .usage = \"bz changelog [--since DATE] [--until DATE] [--since-tag TAG] [--since-commit HASH] [--limit N] [--group-by FIELD]\",\n         .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n-            \"by date range and grouped by type.\",\n+            \"by date range and grouped by type. Can use git tags or commits for date references.\",\n         .flags = &[_]FlagHelp{\n             .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n             .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n+            .{ .short = null, .long = \"--since-tag\", .arg = \"TAG\", .description = \"Start from git tag (e.g., v1.0.0)\" },\n+            .{ .short = null, .long = \"--since-commit\", .arg = \"HASH\", .description = \"Start from git commit (e.g., abc123)\" },\n             .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n             .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n         },\n         .examples = &[_]ExampleHelp{\n             .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n             .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n+            .{ .command = \"bz changelog --since-tag v1.0.0\", .description = \"Since git tag v1.0.0\" },\n+            .{ .command = \"bz changelog --since-commit abc123\", .description = \"Since git commit\" },\n             .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n         },\n         .see_also = &[_][]const u8{\"audit\"},\ndiff --git a/src/cli/mod.zig b/src/cli/mod.zig\nindex 91977da..596bf1e 100644\n--- a/src/cli/mod.zig\n+++ b/src/cli/mod.zig\n@@ -150,6 +150,8 @@ pub const runHistory = history.run;\n pub const AuditError = audit.AuditError;\n pub const AuditResult = audit.AuditResult;\n pub const runAudit = audit.run;\n+pub const AuditArgs = args.AuditArgs;\n+pub const AuditSubcommand = args.AuditSubcommand;\n \n pub const ChangelogError = changelog.ChangelogError;\n pub const ChangelogResult = changelog.ChangelogResult;\n@@ -163,6 +165,7 @@ pub const runInfo = info.run;\n pub const StatsError = stats.StatsError;\n pub const StatsResult = stats.StatsResult;\n pub const runStats = stats.run;\n+pub const StatsArgs = args.StatsArgs;\n \n pub const DoctorError = doctor.DoctorError;\n pub const DoctorResult = doctor.DoctorResult;\ndiff --git a/src/cli/stats.zig b/src/cli/stats.zig\nindex 3b0819e..ff3ee64 100644\n--- a/src/cli/stats.zig\n+++ b/src/cli/stats.zig\n@@ -1,6 +1,8 @@\n //! Stats command for beads_zig.\n //!\n //! `bz stats` - Show project statistics\n+//! `bz stats --activity` - Show git-based activity statistics\n+//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n \n const std = @import(\"std\");\n const common = @import(\"common.zig\");\n@@ -12,6 +14,7 @@ pub const StatsError = error{\n     WorkspaceNotInitialized,\n     StorageError,\n     OutOfMemory,\n+    GitError,\n };\n \n pub const StatsResult = struct {\n@@ -22,15 +25,32 @@ pub const StatsResult = struct {\n     by_status: ?[]const CountEntry = null,\n     by_priority: ?[]const CountEntry = null,\n     by_type: ?[]const CountEntry = null,\n+    activity: ?ActivityStats = null,\n     message: ?[]const u8 = null,\n \n     pub const CountEntry = struct {\n         key: []const u8,\n         count: usize,\n     };\n+\n+    pub const ActivityStats = struct {\n+        period_hours: u32,\n+        git_commits: usize,\n+        issues_created: usize,\n+        issues_closed: usize,\n+        issues_updated: usize,\n+        commits_with_issue_refs: usize,\n+        issue_refs: ?[]const IssueRef = null,\n+\n+        pub const IssueRef = struct {\n+            issue_id: []const u8,\n+            commit_count: usize,\n+        };\n+    };\n };\n \n pub fn run(\n+    stats_args: args.StatsArgs,\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n@@ -109,6 +129,15 @@ pub fn run(\n         try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n     }\n \n+    // Activity stats (if requested)\n+    var activity_stats: ?StatsResult.ActivityStats = null;\n+    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n+    defer issue_refs_list.deinit(allocator);\n+\n+    if (stats_args.activity) {\n+        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n+    }\n+\n     if (global.isStructuredOutput()) {\n         try ctx.output.printJson(StatsResult{\n             .success = true,\n@@ -118,6 +147,7 @@ pub fn run(\n             .by_status = status_list.items,\n             .by_priority = priority_list.items,\n             .by_type = type_list.items,\n+            .activity = activity_stats,\n         });\n     } else if (!global.quiet) {\n         try ctx.output.println(\"Issue Statistics\", .{});\n@@ -145,9 +175,174 @@ pub fn run(\n                 try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n             }\n         }\n+\n+        if (activity_stats) |activity| {\n+            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n+            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n+            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n+            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n+            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n+            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n+\n+            if (activity.issue_refs) |refs| {\n+                if (refs.len > 0) {\n+                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n+                    for (refs[0..@min(10, refs.len)]) |ref| {\n+                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n+                    }\n+                    if (refs.len > 10) {\n+                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n+fn getActivityStats(\n+    allocator: std.mem.Allocator,\n+    ctx: *CommandContext,\n+    hours: u32,\n+    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n+) !StatsResult.ActivityStats {\n+    const now = std.time.timestamp();\n+    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n+\n+    // Count issue activity in the time period\n+    var issues_created: usize = 0;\n+    var issues_closed: usize = 0;\n+    var issues_updated: usize = 0;\n+\n+    for (ctx.store.issues.items) |issue| {\n+        if (issue.status.eql(.tombstone)) continue;\n+\n+        if (issue.created_at.value >= since) {\n+            issues_created += 1;\n+        }\n+        if (issue.closed_at.value) |closed_ts| {\n+            if (closed_ts >= since) {\n+                issues_closed += 1;\n+            }\n+        }\n+        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n+            issues_updated += 1;\n+        }\n+    }\n+\n+    // Get git commit stats\n+    var git_commits: usize = 0;\n+    var commits_with_refs: usize = 0;\n+    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n+    defer issue_ref_counts.deinit(allocator);\n+\n+    // Run git log to get recent commits\n+    const git_result = runGitLog(allocator, hours) catch {\n+        // Git not available or not a git repo - return partial stats\n+        return StatsResult.ActivityStats{\n+            .period_hours = hours,\n+            .git_commits = 0,\n+            .issues_created = issues_created,\n+            .issues_closed = issues_closed,\n+            .issues_updated = issues_updated,\n+            .commits_with_issue_refs = 0,\n+            .issue_refs = null,\n+        };\n+    };\n+    defer allocator.free(git_result);\n+\n+    // Parse git log output\n+    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n+    while (lines.next()) |line| {\n+        if (line.len == 0) continue;\n+        git_commits += 1;\n+\n+        // Look for issue references (bd-xxx pattern)\n+        var found_ref = false;\n+        var i: usize = 0;\n+        while (i < line.len) {\n+            // Look for \"bd-\" or similar prefix\n+            if (i + 3 < line.len and\n+                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n+            {\n+                // Extract the issue ID\n+                const start = i;\n+                i += 3;\n+                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n+                    i += 1;\n+                }\n+                const issue_id = line[start..i];\n+                if (issue_id.len > 3) {\n+                    // Normalize to lowercase\n+                    var normalized: [32]u8 = undefined;\n+                    const len = @min(issue_id.len, 32);\n+                    for (0..len) |j| {\n+                        normalized[j] = std.ascii.toLower(issue_id[j]);\n+                    }\n+                    const key = normalized[0..len];\n+\n+                    // Check if this issue exists in our store\n+                    if (ctx.store.exists(key) catch false) {\n+                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n+                        entry.value_ptr.* += 1;\n+                        found_ref = true;\n+                    }\n+                }\n+            } else {\n+                i += 1;\n+            }\n+        }\n+        if (found_ref) {\n+            commits_with_refs += 1;\n+        }\n+    }\n+\n+    // Convert issue refs to array\n+    var it = issue_ref_counts.iterator();\n+    while (it.next()) |entry| {\n+        try issue_refs_list.append(allocator, .{\n+            .issue_id = entry.key_ptr.*,\n+            .commit_count = entry.value_ptr.*,\n+        });\n+    }\n+\n+    // Sort by commit count descending\n+    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n+        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n+            return a.commit_count > b.commit_count;\n+        }\n+    }.lessThan);\n+\n+    return StatsResult.ActivityStats{\n+        .period_hours = hours,\n+        .git_commits = git_commits,\n+        .issues_created = issues_created,\n+        .issues_closed = issues_closed,\n+        .issues_updated = issues_updated,\n+        .commits_with_issue_refs = commits_with_refs,\n+        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n+    };\n+}\n+\n+fn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n+    var buf: [32]u8 = undefined;\n+    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n+\n+    const result = std.process.Child.run(.{\n+        .allocator = allocator,\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n+        .cwd = null,\n+    }) catch return StatsError.GitError;\n+\n+    defer allocator.free(result.stderr);\n+\n+    if (result.term.Exited != 0) {\n+        allocator.free(result.stdout);\n+        return StatsError.GitError;\n+    }\n+\n+    return result.stdout;\n+}\n+\n // --- Tests ---\n \n test \"StatsError enum exists\" {\n@@ -169,8 +364,47 @@ test \"StatsResult struct works\" {\n test \"run detects uninitialized workspace\" {\n     const allocator = std.testing.allocator;\n \n+    const stats_args = args.StatsArgs{};\n     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n \n-    const result = run(global, allocator);\n+    const result = run(stats_args, global, allocator);\n     try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n }\n+\n+test \"StatsArgs default values\" {\n+    const stats_args = args.StatsArgs{};\n+    try std.testing.expect(!stats_args.activity);\n+    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n+}\n+\n+test \"parse stats with activity flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .stats => |s| {\n+            try std.testing.expect(s.activity);\n+            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse stats with activity-hours flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .stats => |s| {\n+            try std.testing.expect(s.activity);\n+            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/main.zig b/src/main.zig\nindex adec608..1d0bbb8 100644\n--- a/src/main.zig\n+++ b/src/main.zig\n@@ -208,9 +208,9 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n                 else => return err,\n             };\n         },\n-        .stats => {\n-            cli.runStats(result.global, allocator) catch |err| switch (err) {\n-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n+        .stats => |stats_args| {\n+            cli.runStats(stats_args, result.global, allocator) catch |err| switch (err) {\n+                error.WorkspaceNotInitialized, error.StorageError, error.GitError => std.process.exit(1),\n                 else => return err,\n             };\n         },\n@@ -258,7 +258,7 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n         },\n         .audit => |audit_args| {\n             cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n+                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),\n                 else => return err,\n             };\n         },\ndiff --git a/src/models/event.zig b/src/models/event.zig\nindex 29dd632..ec69cfc 100644\n--- a/src/models/event.zig\n+++ b/src/models/event.zig\n@@ -24,6 +24,9 @@ pub const EventType = enum {\n     compacted,\n     deleted,\n     restored,\n+    // LLM/tool interaction tracking\n+    llm_call,\n+    tool_call,\n \n     const Self = @This();","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NVSdLT8BA7V9fbu8dMSvn4","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the full diff to understand what was changed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":904,"cache_read_input_tokens":22247,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":904},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"74aef503-1003-412e-bee9-dfa04e172dcb"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NVSdLT8BA7V9fbu8dMSvn4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PEkUUtQ8jFPS1krkQ2sRiY","name":"Read","input":{"file_path":"/home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/3427775d-9f02-439a-891d-b9ec8986d232/tool-results/toolu_01Pm8XPMYzPZkPyyDKCjXCJf.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":904,"cache_read_input_tokens":22247,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":904},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"a69cc39d-510b-45b1-a062-315edad2245a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PEkUUtQ8jFPS1krkQ2sRiY","type":"tool_result","content":"     1diff --git a/src/cli/args.zig b/src/cli/args.zig\n     2index 1a80844..ee9431d 100644\n     3--- a/src/cli/args.zig\n     4+++ b/src/cli/args.zig\n     5@@ -38,7 +38,7 @@ pub const Command = union(enum) {\n     6     // Workspace\n     7     init: InitArgs,\n     8     info: void,\n     9-    stats: void,\n    10+    stats: StatsArgs,\n    11     doctor: void,\n    12     config: ConfigArgs,\n    13     orphans: OrphansArgs,\n    14@@ -115,6 +115,12 @@ pub const InitArgs = struct {\n    15     prefix: []const u8 = \"bd\",\n    16 };\n    17 \n    18+/// Stats command arguments.\n    19+pub const StatsArgs = struct {\n    20+    activity: bool = false, // Show git-based activity statistics\n    21+    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n    22+};\n    23+\n    24 /// Create command arguments.\n    25 pub const CreateArgs = struct {\n    26     title: []const u8,\n    27@@ -426,6 +432,8 @@ pub const GraphArgs = struct {\n    28     id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    29     format: GraphFormat = .ascii,\n    30     depth: ?u32 = null, // Max depth for tree traversal\n    31+    all: bool = false, // Show dependency graph for all open issues\n    32+    compact: bool = false, // Compact one-line-per-issue output\n    33 };\n    34 \n    35 /// Label subcommand variants.\n    36@@ -474,15 +482,51 @@ pub const HistoryArgs = struct {\n    37     id: []const u8,\n    38 };\n    39 \n    40+/// Audit subcommand variants.\n    41+pub const AuditSubcommand = union(enum) {\n    42+    /// Record an LLM/tool interaction for training data.\n    43+    record: struct {\n    44+        kind: []const u8, // \"llm_call\" or \"tool_call\"\n    45+        issue_id: ?[]const u8 = null, // Optional issue context\n    46+        model: ?[]const u8 = null, // Model name (for llm_call)\n    47+        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n    48+        response: ?[]const u8 = null, // Output response (for llm_call)\n    49+        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n    50+        exit_code: ?i32 = null, // Exit code (for tool_call)\n    51+        metadata: ?[]const u8 = null, // Additional JSON metadata\n    52+    },\n    53+    /// Label an audit entry for quality tracking.\n    54+    label: struct {\n    55+        entry_id: i64, // Event ID to label\n    56+        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n    57+        reason: ?[]const u8 = null, // Explanation for the label\n    58+    },\n    59+    /// View audit log for a specific issue.\n    60+    log: struct {\n    61+        issue_id: []const u8,\n    62+        limit: ?u32 = null,\n    63+    },\n    64+    /// Summary of audit data over time period.\n    65+    summary: struct {\n    66+        days: u32 = 7, // Number of days to summarize\n    67+    },\n    68+    /// Legacy: show project-wide audit log (default behavior).\n    69+    list: struct {\n    70+        limit: ?u32 = null,\n    71+    },\n    72+};\n    73+\n    74 /// Audit command arguments.\n    75 pub const AuditArgs = struct {\n    76-    limit: ?u32 = null,\n    77+    subcommand: AuditSubcommand,\n    78 };\n    79 \n    80 /// Changelog command arguments.\n    81 pub const ChangelogArgs = struct {\n    82     since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    83     until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    84+    since_tag: ?[]const u8 = null, // Git tag for start date (e.g., \"v1.0.0\")\n    85+    since_commit: ?[]const u8 = null, // Git commit for start date (e.g., \"abc123\")\n    86     limit: ?u32 = null,\n    87     group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n    88 };\n    89@@ -804,7 +848,7 @@ pub const ArgParser = struct {\n    90             return .{ .info = {} };\n    91         }\n    92         if (std.mem.eql(u8, cmd, \"stats\")) {\n    93-            return .{ .stats = {} };\n    94+            return .{ .stats = try self.parseStatsArgs() };\n    95         }\n    96         if (std.mem.eql(u8, cmd, \"doctor\")) {\n    97             return .{ .doctor = {} };\n    98@@ -969,6 +1013,18 @@ pub const ArgParser = struct {\n    99         return result;\n   100     }\n   101 \n   102+    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n   103+        var result = StatsArgs{};\n   104+        while (self.hasNext()) {\n   105+            if (self.consumeFlag(\"-a\", \"--activity\")) {\n   106+                result.activity = true;\n   107+            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n   108+                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n   109+            } else break;\n   110+        }\n   111+        return result;\n   112+    }\n   113+\n   114     fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n   115         var result = CreateArgs{ .title = undefined };\n   116         var title_set = false;\n   117@@ -1429,6 +1485,10 @@ pub const ArgParser = struct {\n   118                 result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n   119             } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n   120                 result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n   121+            } else if (self.consumeFlag(\"-a\", \"--all\")) {\n   122+                result.all = true;\n   123+            } else if (self.consumeFlag(\"-c\", \"--compact\")) {\n   124+                result.compact = true;\n   125             } else if (self.peekPositional()) |_| {\n   126                 if (result.id == null) {\n   127                     result.id = self.next().?;\n   128@@ -1550,13 +1610,108 @@ pub const ArgParser = struct {\n   129     }\n   130 \n   131     fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n   132-        var result = AuditArgs{};\n   133-        while (self.hasNext()) {\n   134-            if (try self.parseLimitFlag()) |limit| {\n   135-                result.limit = limit;\n   136-            } else break;\n   137+        // Check for subcommand\n   138+        const subcmd = self.next() orelse {\n   139+            // Default: list with no limit\n   140+            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n   141+        };\n   142+\n   143+        // Handle --limit flag at top level (legacy support)\n   144+        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n   145+            // Put it back and parse as list subcommand with limit\n   146+            self.index -= 1;\n   147+            var limit: ?u32 = null;\n   148+            while (self.hasNext()) {\n   149+                if (try self.parseLimitFlag()) |l| {\n   150+                    limit = l;\n   151+                } else break;\n   152+            }\n   153+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n   154         }\n   155-        return result;\n   156+\n   157+        if (std.mem.eql(u8, subcmd, \"record\")) {\n   158+            const kind = self.next() orelse return error.MissingRequiredArgument;\n   159+            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n   160+\n   161+            while (self.hasNext()) {\n   162+                if (self.consumeFlag(\"-i\", \"--issue\")) {\n   163+                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n   164+                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n   165+                    result.record.model = self.next() orelse return error.MissingFlagValue;\n   166+                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n   167+                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n   168+                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n   169+                    result.record.response = self.next() orelse return error.MissingFlagValue;\n   170+                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n   171+                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n   172+                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n   173+                    const exit_str = self.next() orelse return error.MissingFlagValue;\n   174+                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n   175+                } else if (self.consumeFlag(null, \"--metadata\")) {\n   176+                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n   177+                } else break;\n   178+            }\n   179+            return .{ .subcommand = result };\n   180+        }\n   181+\n   182+        if (std.mem.eql(u8, subcmd, \"label\")) {\n   183+            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n   184+            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n   185+            var label_value: ?[]const u8 = null;\n   186+            var reason: ?[]const u8 = null;\n   187+\n   188+            while (self.hasNext()) {\n   189+                if (self.consumeFlag(\"-l\", \"--label\")) {\n   190+                    label_value = self.next() orelse return error.MissingFlagValue;\n   191+                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n   192+                    reason = self.next() orelse return error.MissingFlagValue;\n   193+                } else if (self.peekPositional()) |_| {\n   194+                    if (label_value == null) {\n   195+                        label_value = self.next().?;\n   196+                    } else break;\n   197+                } else break;\n   198+            }\n   199+\n   200+            if (label_value == null) return error.MissingRequiredArgument;\n   201+            return .{ .subcommand = .{ .label = .{\n   202+                .entry_id = entry_id,\n   203+                .label_value = label_value.?,\n   204+                .reason = reason,\n   205+            } } };\n   206+        }\n   207+\n   208+        if (std.mem.eql(u8, subcmd, \"log\")) {\n   209+            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n   210+            var limit: ?u32 = null;\n   211+            while (self.hasNext()) {\n   212+                if (try self.parseLimitFlag()) |l| {\n   213+                    limit = l;\n   214+                } else break;\n   215+            }\n   216+            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n   217+        }\n   218+\n   219+        if (std.mem.eql(u8, subcmd, \"summary\")) {\n   220+            var days: u32 = 7;\n   221+            while (self.hasNext()) {\n   222+                if (self.consumeFlag(\"-d\", \"--days\")) {\n   223+                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n   224+                } else break;\n   225+            }\n   226+            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n   227+        }\n   228+\n   229+        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n   230+            var limit: ?u32 = null;\n   231+            while (self.hasNext()) {\n   232+                if (try self.parseLimitFlag()) |l| {\n   233+                    limit = l;\n   234+                } else break;\n   235+            }\n   236+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n   237+        }\n   238+\n   239+        return error.UnknownSubcommand;\n   240     }\n   241 \n   242     fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n   243@@ -1566,6 +1721,10 @@ pub const ArgParser = struct {\n   244                 result.since = self.next() orelse return error.MissingFlagValue;\n   245             } else if (self.consumeFlag(null, \"--until\")) {\n   246                 result.until = self.next() orelse return error.MissingFlagValue;\n   247+            } else if (self.consumeFlag(null, \"--since-tag\")) {\n   248+                result.since_tag = self.next() orelse return error.MissingFlagValue;\n   249+            } else if (self.consumeFlag(null, \"--since-commit\")) {\n   250+                result.since_commit = self.next() orelse return error.MissingFlagValue;\n   251             } else if (try self.parseLimitFlag()) |limit| {\n   252                 result.limit = limit;\n   253             } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n   254@@ -2482,9 +2641,13 @@ test \"parse audit command\" {\n   255 test \"parse audit command with limit\" {\n   256     const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n   257     var parser = ArgParser.init(std.testing.allocator, &args);\n   258-    const result = try parser.parse();\n   259+    var result = try parser.parse();\n   260+    defer result.deinit(std.testing.allocator);\n   261 \n   262-    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n   263+    switch (result.command.audit.subcommand) {\n   264+        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n   265+        else => try std.testing.expect(false),\n   266+    }\n   267 }\n   268 \n   269 test \"parse sync command\" {\n   270diff --git a/src/cli/audit.zig b/src/cli/audit.zig\n   271index 50d3d6b..6860d8d 100644\n   272--- a/src/cli/audit.zig\n   273+++ b/src/cli/audit.zig\n   274@@ -1,10 +1,16 @@\n   275 //! Audit command for beads_zig.\n   276 //!\n   277-//! `bz audit [--limit N]` - Show project-wide audit log\n   278+//! `bz audit` - Show project-wide audit log (default)\n   279+//! `bz audit record <kind>` - Record LLM/tool interaction\n   280+//! `bz audit label <entry-id> <label>` - Label audit entry\n   281+//! `bz audit log <issue-id>` - View audit log for specific issue\n   282+//! `bz audit summary` - Summary of audit data over time period\n   283 \n   284 const std = @import(\"std\");\n   285 const common = @import(\"common.zig\");\n   286 const args = @import(\"args.zig\");\n   287+const Event = @import(\"../models/event.zig\").Event;\n   288+const EventType = @import(\"../models/event.zig\").EventType;\n   289 \n   290 const CommandContext = common.CommandContext;\n   291 \n   292@@ -12,19 +18,42 @@ pub const AuditError = error{\n   293     WorkspaceNotInitialized,\n   294     StorageError,\n   295     OutOfMemory,\n   296+    InvalidKind,\n   297+    EntryNotFound,\n   298 };\n   299 \n   300 pub const AuditResult = struct {\n   301     success: bool,\n   302     events: ?[]const AuditEvent = null,\n   303     total: ?usize = null,\n   304+    event_id: ?i64 = null,\n   305+    summary: ?AuditSummary = null,\n   306     message: ?[]const u8 = null,\n   307 \n   308     pub const AuditEvent = struct {\n   309+        id: i64,\n   310         issue_id: []const u8,\n   311         event_type: []const u8,\n   312         actor: []const u8,\n   313         created_at: i64,\n   314+        old_value: ?[]const u8 = null,\n   315+        new_value: ?[]const u8 = null,\n   316+    };\n   317+\n   318+    pub const AuditSummary = struct {\n   319+        period_days: u32,\n   320+        total_events: usize,\n   321+        llm_calls: usize,\n   322+        tool_calls: usize,\n   323+        issue_creates: usize,\n   324+        issue_closes: usize,\n   325+        other_events: usize,\n   326+        by_actor: ?[]const ActorCount = null,\n   327+\n   328+        pub const ActorCount = struct {\n   329+            actor: []const u8,\n   330+            count: usize,\n   331+        };\n   332     };\n   333 };\n   334 \n   335@@ -32,13 +61,364 @@ pub fn run(\n   336     audit_args: args.AuditArgs,\n   337     global: args.GlobalOptions,\n   338     allocator: std.mem.Allocator,\n   339+) !void {\n   340+    switch (audit_args.subcommand) {\n   341+        .record => |record_args| try runRecord(record_args, global, allocator),\n   342+        .label => |label_args| try runLabel(label_args, global, allocator),\n   343+        .log => |log_args| try runLog(log_args, global, allocator),\n   344+        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n   345+        .list => |list_args| try runList(list_args, global, allocator),\n   346+    }\n   347+}\n   348+\n   349+fn runRecord(\n   350+    record_args: anytype,\n   351+    global: args.GlobalOptions,\n   352+    allocator: std.mem.Allocator,\n   353+) !void {\n   354+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   355+        return AuditError.WorkspaceNotInitialized;\n   356+    };\n   357+    defer ctx.deinit();\n   358+\n   359+    // Validate kind\n   360+    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n   361+        .llm_call\n   362+    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n   363+        .tool_call\n   364+    else {\n   365+        if (!global.silent) {\n   366+            if (global.isStructuredOutput()) {\n   367+                try ctx.output.printJson(AuditResult{\n   368+                    .success = false,\n   369+                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n   370+                });\n   371+            } else {\n   372+                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n   373+            }\n   374+        }\n   375+        return AuditError.InvalidKind;\n   376+    };\n   377+\n   378+    const actor = global.actor orelse \"unknown\";\n   379+    const now = std.time.timestamp();\n   380+\n   381+    // Build metadata JSON with all provided fields\n   382+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n   383+    defer metadata_parts.deinit(allocator);\n   384+\n   385+    try metadata_parts.appendSlice(allocator, \"{\");\n   386+    var first = true;\n   387+\n   388+    if (record_args.model) |model| {\n   389+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   390+        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n   391+        try metadata_parts.appendSlice(allocator, model);\n   392+        try metadata_parts.appendSlice(allocator, \"\\\"\");\n   393+        first = false;\n   394+    }\n   395+    if (record_args.prompt) |prompt| {\n   396+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   397+        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n   398+        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n   399+        defer allocator.free(escaped);\n   400+        try metadata_parts.appendSlice(allocator, escaped);\n   401+        first = false;\n   402+    }\n   403+    if (record_args.response) |response| {\n   404+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   405+        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n   406+        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n   407+        defer allocator.free(escaped);\n   408+        try metadata_parts.appendSlice(allocator, escaped);\n   409+        first = false;\n   410+    }\n   411+    if (record_args.tool_name) |tool_name| {\n   412+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   413+        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n   414+        try metadata_parts.appendSlice(allocator, tool_name);\n   415+        try metadata_parts.appendSlice(allocator, \"\\\"\");\n   416+        first = false;\n   417+    }\n   418+    if (record_args.exit_code) |exit_code| {\n   419+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   420+        var buf: [32]u8 = undefined;\n   421+        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n   422+        try metadata_parts.appendSlice(allocator, s);\n   423+        first = false;\n   424+    }\n   425+    if (record_args.metadata) |metadata| {\n   426+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   427+        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n   428+        try metadata_parts.appendSlice(allocator, metadata);\n   429+        first = false;\n   430+    }\n   431+    try metadata_parts.appendSlice(allocator, \"}\");\n   432+\n   433+    const new_value = try allocator.dupe(u8, metadata_parts.items);\n   434+    defer allocator.free(new_value);\n   435+\n   436+    const event = Event{\n   437+        .id = 0,\n   438+        .issue_id = record_args.issue_id orelse \"\",\n   439+        .event_type = event_type,\n   440+        .actor = actor,\n   441+        .old_value = null,\n   442+        .new_value = new_value,\n   443+        .created_at = now,\n   444+    };\n   445+\n   446+    const event_id = try ctx.event_store.append(event);\n   447+\n   448+    if (global.isStructuredOutput()) {\n   449+        try ctx.output.printJson(AuditResult{\n   450+            .success = true,\n   451+            .event_id = event_id,\n   452+            .message = \"Audit entry recorded\",\n   453+        });\n   454+    } else if (!global.quiet) {\n   455+        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n   456+    }\n   457+}\n   458+\n   459+fn runLabel(\n   460+    label_args: anytype,\n   461+    global: args.GlobalOptions,\n   462+    allocator: std.mem.Allocator,\n   463+) !void {\n   464+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   465+        return AuditError.WorkspaceNotInitialized;\n   466+    };\n   467+    defer ctx.deinit();\n   468+\n   469+    // Record a label event referencing the original entry\n   470+    const actor = global.actor orelse \"unknown\";\n   471+    const now = std.time.timestamp();\n   472+\n   473+    // Build the label metadata\n   474+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n   475+    defer metadata_parts.deinit(allocator);\n   476+\n   477+    var buf: [64]u8 = undefined;\n   478+    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n   479+    try metadata_parts.appendSlice(allocator, header);\n   480+\n   481+    if (label_args.reason) |reason| {\n   482+        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n   483+        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n   484+        defer allocator.free(escaped);\n   485+        try metadata_parts.appendSlice(allocator, escaped);\n   486+    }\n   487+    try metadata_parts.appendSlice(allocator, \"}\");\n   488+\n   489+    const new_value = try allocator.dupe(u8, metadata_parts.items);\n   490+    defer allocator.free(new_value);\n   491+\n   492+    // Use 'updated' event type to represent a label action on an existing entry\n   493+    const event = Event{\n   494+        .id = 0,\n   495+        .issue_id = \"\", // Labels are not issue-specific\n   496+        .event_type = .updated,\n   497+        .actor = actor,\n   498+        .old_value = null,\n   499+        .new_value = new_value,\n   500+        .created_at = now,\n   501+    };\n   502+\n   503+    const event_id = try ctx.event_store.append(event);\n   504+\n   505+    if (global.isStructuredOutput()) {\n   506+        try ctx.output.printJson(AuditResult{\n   507+            .success = true,\n   508+            .event_id = event_id,\n   509+            .message = \"Label applied to audit entry\",\n   510+        });\n   511+    } else if (!global.quiet) {\n   512+        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n   513+    }\n   514+}\n   515+\n   516+fn runLog(\n   517+    log_args: anytype,\n   518+    global: args.GlobalOptions,\n   519+    allocator: std.mem.Allocator,\n   520+) !void {\n   521+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   522+        return AuditError.WorkspaceNotInitialized;\n   523+    };\n   524+    defer ctx.deinit();\n   525+\n   526+    const limit = log_args.limit orelse 100;\n   527+\n   528+    // Query events for the specific issue from the event store\n   529+    const events = try ctx.event_store.queryEvents(.{\n   530+        .issue_id = log_args.issue_id,\n   531+        .limit = limit,\n   532+    });\n   533+    defer ctx.event_store.freeEvents(events);\n   534+\n   535+    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n   536+    defer audit_events.deinit(allocator);\n   537+\n   538+    for (events) |event| {\n   539+        try audit_events.append(allocator, .{\n   540+            .id = event.id,\n   541+            .issue_id = event.issue_id,\n   542+            .event_type = event.event_type.toString(),\n   543+            .actor = event.actor,\n   544+            .created_at = event.created_at,\n   545+            .old_value = event.old_value,\n   546+            .new_value = event.new_value,\n   547+        });\n   548+    }\n   549+\n   550+    // Sort by timestamp descending\n   551+    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n   552+        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n   553+            return a.created_at > b.created_at;\n   554+        }\n   555+    }.lessThan);\n   556+\n   557+    if (global.isStructuredOutput()) {\n   558+        try ctx.output.printJson(AuditResult{\n   559+            .success = true,\n   560+            .events = audit_events.items,\n   561+            .total = audit_events.items.len,\n   562+        });\n   563+    } else if (global.quiet) {\n   564+        for (audit_events.items) |event| {\n   565+            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n   566+        }\n   567+    } else {\n   568+        if (audit_events.items.len == 0) {\n   569+            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n   570+        } else {\n   571+            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n   572+            try ctx.output.print(\"\\n\", .{});\n   573+\n   574+            for (audit_events.items) |event| {\n   575+                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n   576+                    event.id,\n   577+                    event.created_at,\n   578+                    event.actor,\n   579+                    event.event_type,\n   580+                });\n   581+                if (event.new_value) |v| {\n   582+                    if (v.len > 0 and v.len < 200) {\n   583+                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n   584+                    }\n   585+                }\n   586+            }\n   587+        }\n   588+    }\n   589+}\n   590+\n   591+fn runSummary(\n   592+    summary_args: anytype,\n   593+    global: args.GlobalOptions,\n   594+    allocator: std.mem.Allocator,\n   595 ) !void {\n   596     var ctx = (try CommandContext.init(allocator, global)) orelse {\n   597         return AuditError.WorkspaceNotInitialized;\n   598     };\n   599     defer ctx.deinit();\n   600 \n   601-    const limit = audit_args.limit orelse 100;\n   602+    const now = std.time.timestamp();\n   603+    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n   604+\n   605+    // Query all events in the time period\n   606+    const events = try ctx.event_store.queryEvents(.{ .since = since });\n   607+    defer ctx.event_store.freeEvents(events);\n   608+\n   609+    // Count by type\n   610+    var llm_calls: usize = 0;\n   611+    var tool_calls: usize = 0;\n   612+    var issue_creates: usize = 0;\n   613+    var issue_closes: usize = 0;\n   614+    var other_events: usize = 0;\n   615+\n   616+    // Count by actor\n   617+    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n   618+    defer actor_counts.deinit(allocator);\n   619+\n   620+    for (events) |event| {\n   621+        switch (event.event_type) {\n   622+            .llm_call => llm_calls += 1,\n   623+            .tool_call => tool_calls += 1,\n   624+            .created => issue_creates += 1,\n   625+            .closed => issue_closes += 1,\n   626+            else => other_events += 1,\n   627+        }\n   628+\n   629+        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n   630+        entry.value_ptr.* += 1;\n   631+    }\n   632+\n   633+    // Convert actor counts to array\n   634+    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n   635+    defer actor_list.deinit(allocator);\n   636+\n   637+    var it = actor_counts.iterator();\n   638+    while (it.next()) |entry| {\n   639+        try actor_list.append(allocator, .{\n   640+            .actor = entry.key_ptr.*,\n   641+            .count = entry.value_ptr.*,\n   642+        });\n   643+    }\n   644+\n   645+    // Sort by count descending\n   646+    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n   647+        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n   648+            return a.count > b.count;\n   649+        }\n   650+    }.lessThan);\n   651+\n   652+    const summary = AuditResult.AuditSummary{\n   653+        .period_days = summary_args.days,\n   654+        .total_events = events.len,\n   655+        .llm_calls = llm_calls,\n   656+        .tool_calls = tool_calls,\n   657+        .issue_creates = issue_creates,\n   658+        .issue_closes = issue_closes,\n   659+        .other_events = other_events,\n   660+        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n   661+    };\n   662+\n   663+    if (global.isStructuredOutput()) {\n   664+        try ctx.output.printJson(AuditResult{\n   665+            .success = true,\n   666+            .summary = summary,\n   667+        });\n   668+    } else if (!global.quiet) {\n   669+        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n   670+        try ctx.output.print(\"\\n\", .{});\n   671+        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n   672+        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n   673+        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n   674+        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n   675+        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n   676+        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n   677+\n   678+        if (actor_list.items.len > 0) {\n   679+            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n   680+            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n   681+                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n   682+            }\n   683+        }\n   684+    }\n   685+}\n   686+\n   687+fn runList(\n   688+    list_args: anytype,\n   689+    global: args.GlobalOptions,\n   690+    allocator: std.mem.Allocator,\n   691+) !void {\n   692+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   693+        return AuditError.WorkspaceNotInitialized;\n   694+    };\n   695+    defer ctx.deinit();\n   696+\n   697+    const limit = list_args.limit orelse 100;\n   698 \n   699     // Build synthetic audit log from all issues\n   700     var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n   701@@ -47,6 +427,7 @@ pub fn run(\n   702     for (ctx.store.issues.items) |issue| {\n   703         // Created event\n   704         try events.append(allocator, .{\n   705+            .id = 0,\n   706             .issue_id = issue.id,\n   707             .event_type = \"created\",\n   708             .actor = issue.created_by orelse \"unknown\",\n   709@@ -56,6 +437,7 @@ pub fn run(\n   710         // Closed event\n   711         if (issue.closed_at.value) |closed_ts| {\n   712             try events.append(allocator, .{\n   713+                .id = 0,\n   714                 .issue_id = issue.id,\n   715                 .event_type = \"closed\",\n   716                 .actor = \"unknown\",\n   717@@ -66,6 +448,7 @@ pub fn run(\n   718         // If tombstoned\n   719         if (issue.status.eql(.tombstone)) {\n   720             try events.append(allocator, .{\n   721+                .id = 0,\n   722                 .issue_id = issue.id,\n   723                 .event_type = \"deleted\",\n   724                 .actor = \"unknown\",\n   725@@ -139,9 +522,69 @@ test \"AuditResult struct works\" {\n   726 test \"run detects uninitialized workspace\" {\n   727     const allocator = std.testing.allocator;\n   728 \n   729-    const audit_args = args.AuditArgs{};\n   730+    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n   731     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   732 \n   733     const result = run(audit_args, global, allocator);\n   734     try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n   735 }\n   736+\n   737+test \"AuditSubcommand record parses correctly\" {\n   738+    const allocator = std.testing.allocator;\n   739+    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n   740+    var parser = args.ArgParser.init(allocator, &cmd_args);\n   741+    var result = parser.parse() catch unreachable;\n   742+    defer result.deinit(allocator);\n   743+\n   744+    switch (result.command) {\n   745+        .audit => |a| {\n   746+            switch (a.subcommand) {\n   747+                .record => |r| {\n   748+                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n   749+                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n   750+                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n   751+                },\n   752+                else => try std.testing.expect(false),\n   753+            }\n   754+        },\n   755+        else => try std.testing.expect(false),\n   756+    }\n   757+}\n   758+\n   759+test \"AuditSubcommand summary parses days\" {\n   760+    const allocator = std.testing.allocator;\n   761+    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n   762+    var parser = args.ArgParser.init(allocator, &cmd_args);\n   763+    var result = parser.parse() catch unreachable;\n   764+    defer result.deinit(allocator);\n   765+\n   766+    switch (result.command) {\n   767+        .audit => |a| {\n   768+            switch (a.subcommand) {\n   769+                .summary => |s| {\n   770+                    try std.testing.expectEqual(@as(u32, 30), s.days);\n   771+                },\n   772+                else => try std.testing.expect(false),\n   773+            }\n   774+        },\n   775+        else => try std.testing.expect(false),\n   776+    }\n   777+}\n   778+\n   779+test \"AuditSubcommand list is default\" {\n   780+    const allocator = std.testing.allocator;\n   781+    const cmd_args = [_][]const u8{\"audit\"};\n   782+    var parser = args.ArgParser.init(allocator, &cmd_args);\n   783+    var result = parser.parse() catch unreachable;\n   784+    defer result.deinit(allocator);\n   785+\n   786+    switch (result.command) {\n   787+        .audit => |a| {\n   788+            switch (a.subcommand) {\n   789+                .list => {},\n   790+                else => try std.testing.expect(false),\n   791+            }\n   792+        },\n   793+        else => try std.testing.expect(false),\n   794+    }\n   795+}\n   796diff --git a/src/cli/backup.zig b/src/cli/backup.zig\n   797index 9483ef0..0cbcab4 100644\n   798--- a/src/cli/backup.zig\n   799+++ b/src/cli/backup.zig\n   800@@ -27,6 +27,49 @@ pub const BackupInfo = struct {\n   801     modified: i64,\n   802 };\n   803 \n   804+/// Collect backup files from the .beads directory.\n   805+/// Returns a list of BackupInfo structs sorted by modified time (newest first).\n   806+/// Caller is responsible for freeing the filenames and deiniting the list.\n   807+fn collectBackups(beads_dir: []const u8, allocator: std.mem.Allocator) !?std.ArrayListUnmanaged(BackupInfo) {\n   808+    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n   809+        if (err == error.FileNotFound) return null;\n   810+        return err;\n   811+    };\n   812+    defer dir.close();\n   813+\n   814+    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n   815+    errdefer {\n   816+        for (backups.items) |b| allocator.free(b.filename);\n   817+        backups.deinit(allocator);\n   818+    }\n   819+\n   820+    var iter = dir.iterate();\n   821+    while (try iter.next()) |entry| {\n   822+        // Match backup files: issues.jsonl.bak.* or issues.*.jsonl (but not issues.jsonl)\n   823+        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n   824+            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n   825+            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n   826+            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n   827+        {\n   828+            const stat = dir.statFile(entry.name) catch continue;\n   829+            try backups.append(allocator, .{\n   830+                .filename = try allocator.dupe(u8, entry.name),\n   831+                .size = stat.size,\n   832+                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n   833+            });\n   834+        }\n   835+    }\n   836+\n   837+    // Sort by modified time (newest first)\n   838+    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n   839+        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n   840+            return a.modified > b.modified;\n   841+        }\n   842+    }.lessThan);\n   843+\n   844+    return backups;\n   845+}\n   846+\n   847 pub const BackupResult = struct {\n   848     success: bool,\n   849     action: ?[]const u8 = null,\n   850@@ -65,55 +108,24 @@ pub fn run(\n   851 fn runList(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   852     const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n   853 \n   854-    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n   855+    var backups = (try collectBackups(beads_dir, allocator)) orelse {\n   856+        if (structured_output) {\n   857+            try ctx.output.printJson(BackupResult{\n   858+                .success = true,\n   859+                .action = \"list\",\n   860+                .backup_count = 0,\n   861+                .message = \"no backups found\",\n   862+            });\n   863+        } else if (!quiet) {\n   864+            try ctx.output.info(\"No backups found\", .{});\n   865+        }\n   866+        return;\n   867+    };\n   868     defer {\n   869         for (backups.items) |b| allocator.free(b.filename);\n   870         backups.deinit(allocator);\n   871     }\n   872 \n   873-    // Open the .beads directory and look for backup files\n   874-    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n   875-        if (err == error.FileNotFound) {\n   876-            if (structured_output) {\n   877-                try ctx.output.printJson(BackupResult{\n   878-                    .success = true,\n   879-                    .action = \"list\",\n   880-                    .backup_count = 0,\n   881-                    .message = \"no backups found\",\n   882-                });\n   883-            } else if (!quiet) {\n   884-                try ctx.output.info(\"No backups found\", .{});\n   885-            }\n   886-            return;\n   887-        }\n   888-        return err;\n   889-    };\n   890-    defer dir.close();\n   891-\n   892-    var iter = dir.iterate();\n   893-    while (try iter.next()) |entry| {\n   894-        // Look for backup files matching pattern: issues.jsonl.bak.* or issues.*.jsonl\n   895-        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n   896-            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n   897-            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n   898-            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n   899-        {\n   900-            const stat = dir.statFile(entry.name) catch continue;\n   901-            try backups.append(allocator, .{\n   902-                .filename = try allocator.dupe(u8, entry.name),\n   903-                .size = stat.size,\n   904-                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n   905-            });\n   906-        }\n   907-    }\n   908-\n   909-    // Sort by modified time (newest first)\n   910-    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n   911-        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n   912-            return a.modified > b.modified;\n   913-        }\n   914-    }.lessThan);\n   915-\n   916     if (structured_output) {\n   917         try ctx.output.printJson(BackupResult{\n   918             .success = true,\n   919@@ -328,47 +340,24 @@ fn runRestore(ctx: *CommandContext, file: []const u8, dry_run: bool, structured_\n   920 fn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n   921     const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n   922 \n   923-    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n   924+    var backups = (try collectBackups(beads_dir, allocator)) orelse {\n   925+        if (structured_output) {\n   926+            try ctx.output.printJson(BackupResult{\n   927+                .success = true,\n   928+                .action = \"prune\",\n   929+                .pruned_count = 0,\n   930+                .message = \"no backups to prune\",\n   931+            });\n   932+        } else if (!quiet) {\n   933+            try ctx.output.info(\"No backups to prune\", .{});\n   934+        }\n   935+        return;\n   936+    };\n   937     defer {\n   938         for (backups.items) |b| allocator.free(b.filename);\n   939         backups.deinit(allocator);\n   940     }\n   941 \n   942-    // Collect backup files\n   943-    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n   944-        if (err == error.FileNotFound) {\n   945-            if (structured_output) {\n   946-                try ctx.output.printJson(BackupResult{\n   947-                    .success = true,\n   948-                    .action = \"prune\",\n   949-                    .pruned_count = 0,\n   950-                    .message = \"no backups to prune\",\n   951-                });\n   952-            } else if (!quiet) {\n   953-                try ctx.output.info(\"No backups to prune\", .{});\n   954-            }\n   955-            return;\n   956-        }\n   957-        return err;\n   958-    };\n   959-    defer dir.close();\n   960-\n   961-    var iter = dir.iterate();\n   962-    while (try iter.next()) |entry| {\n   963-        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n   964-            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n   965-            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n   966-            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n   967-        {\n   968-            const stat = dir.statFile(entry.name) catch continue;\n   969-            try backups.append(allocator, .{\n   970-                .filename = try allocator.dupe(u8, entry.name),\n   971-                .size = stat.size,\n   972-                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n   973-            });\n   974-        }\n   975-    }\n   976-\n   977     if (backups.items.len <= keep) {\n   978         if (structured_output) {\n   979             try ctx.output.printJson(BackupResult{\n   980@@ -383,13 +372,6 @@ fn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: b\n   981         return;\n   982     }\n   983 \n   984-    // Sort by modified time (newest first)\n   985-    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n   986-        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n   987-            return a.modified > b.modified;\n   988-        }\n   989-    }.lessThan);\n   990-\n   991     const to_prune = backups.items.len - keep;\n   992 \n   993     if (dry_run) {\n   994diff --git a/src/cli/changelog.zig b/src/cli/changelog.zig\n   995index 35b2266..d7b5c90 100644\n   996--- a/src/cli/changelog.zig\n   997+++ b/src/cli/changelog.zig\n   998@@ -20,6 +20,9 @@ pub const ChangelogError = error{\n   999     InvalidDateFormat,\n  1000     StorageError,\n  1001     OutOfMemory,\n  1002+    GitTagNotFound,\n  1003+    GitCommitNotFound,\n  1004+    GitError,\n  1005 };\n  1006 \n  1007 pub const ChangelogResult = struct {\n  1008@@ -70,7 +73,26 @@ pub fn run(\n  1009     var filtered_issues: std.ArrayListUnmanaged(Issue) = .{};\n  1010     defer filtered_issues.deinit(allocator);\n  1011 \n  1012-    const since_ts = if (changelog_args.since) |s| parseDateToTimestamp(s) else null;\n  1013+    // Determine the since timestamp from various sources (priority: since_tag > since_commit > since)\n  1014+    var since_ts: ?i64 = null;\n  1015+    if (changelog_args.since_tag) |tag| {\n  1016+        since_ts = getTimestampFromGitTag(allocator, tag) catch |err| {\n  1017+            if (!global.isStructuredOutput()) {\n  1018+                try ctx.output.err(\"Failed to get timestamp for tag '{s}': {s}\", .{ tag, @errorName(err) });\n  1019+            }\n  1020+            return err;\n  1021+        };\n  1022+    } else if (changelog_args.since_commit) |commit| {\n  1023+        since_ts = getTimestampFromGitCommit(allocator, commit) catch |err| {\n  1024+            if (!global.isStructuredOutput()) {\n  1025+                try ctx.output.err(\"Failed to get timestamp for commit '{s}': {s}\", .{ commit, @errorName(err) });\n  1026+            }\n  1027+            return err;\n  1028+        };\n  1029+    } else if (changelog_args.since) |s| {\n  1030+        since_ts = parseDateToTimestamp(s);\n  1031+    }\n  1032+\n  1033     const until_ts = if (changelog_args.until) |u| parseDateToTimestamp(u) else null;\n  1034 \n  1035     for (issues) |issue| {\n  1036@@ -259,6 +281,48 @@ fn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n  1037     return era * 146097 + doe - 719468;\n  1038 }\n  1039 \n  1040+fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n  1041+    // Get the commit timestamp for the given tag\n  1042+    // Format: git log -1 --format=%ct <tag>\n  1043+    const result = std.process.Child.run(.{\n  1044+        .allocator = allocator,\n  1045+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n  1046+        .cwd = null,\n  1047+    }) catch return ChangelogError.GitError;\n  1048+\n  1049+    defer allocator.free(result.stderr);\n  1050+    defer allocator.free(result.stdout);\n  1051+\n  1052+    if (result.term.Exited != 0) {\n  1053+        return ChangelogError.GitTagNotFound;\n  1054+    }\n  1055+\n  1056+    // Parse the timestamp (trim newline)\n  1057+    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n  1058+    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n  1059+}\n  1060+\n  1061+fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n  1062+    // Get the commit timestamp for the given commit hash\n  1063+    // Format: git log -1 --format=%ct <commit>\n  1064+    const result = std.process.Child.run(.{\n  1065+        .allocator = allocator,\n  1066+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n  1067+        .cwd = null,\n  1068+    }) catch return ChangelogError.GitError;\n  1069+\n  1070+    defer allocator.free(result.stderr);\n  1071+    defer allocator.free(result.stdout);\n  1072+\n  1073+    if (result.term.Exited != 0) {\n  1074+        return ChangelogError.GitCommitNotFound;\n  1075+    }\n  1076+\n  1077+    // Parse the timestamp (trim newline)\n  1078+    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n  1079+    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n  1080+}\n  1081+\n  1082 // --- Tests ---\n  1083 \n  1084 test \"ChangelogError enum exists\" {\n  1085@@ -322,3 +386,49 @@ test \"parseDateToTimestamp returns null for invalid date\" {\n  1086     try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"2024\"));\n  1087     try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"\"));\n  1088 }\n  1089+\n  1090+test \"ChangelogArgs supports since_tag field\" {\n  1091+    const changelog_args = args.ChangelogArgs{\n  1092+        .since_tag = \"v1.0.0\",\n  1093+    };\n  1094+    try std.testing.expectEqualStrings(\"v1.0.0\", changelog_args.since_tag.?);\n  1095+}\n  1096+\n  1097+test \"ChangelogArgs supports since_commit field\" {\n  1098+    const changelog_args = args.ChangelogArgs{\n  1099+        .since_commit = \"abc123\",\n  1100+    };\n  1101+    try std.testing.expectEqualStrings(\"abc123\", changelog_args.since_commit.?);\n  1102+}\n  1103+\n  1104+test \"parse changelog with since-tag flag\" {\n  1105+    const allocator = std.testing.allocator;\n  1106+    const cmd_args = [_][]const u8{ \"changelog\", \"--since-tag\", \"v1.0.0\" };\n  1107+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1108+    var result = parser.parse() catch unreachable;\n  1109+    defer result.deinit(allocator);\n  1110+\n  1111+    switch (result.command) {\n  1112+        .changelog => |c| {\n  1113+            try std.testing.expect(c.since_tag != null);\n  1114+            try std.testing.expectEqualStrings(\"v1.0.0\", c.since_tag.?);\n  1115+        },\n  1116+        else => try std.testing.expect(false),\n  1117+    }\n  1118+}\n  1119+\n  1120+test \"parse changelog with since-commit flag\" {\n  1121+    const allocator = std.testing.allocator;\n  1122+    const cmd_args = [_][]const u8{ \"changelog\", \"--since-commit\", \"abc123def\" };\n  1123+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1124+    var result = parser.parse() catch unreachable;\n  1125+    defer result.deinit(allocator);\n  1126+\n  1127+    switch (result.command) {\n  1128+        .changelog => |c| {\n  1129+            try std.testing.expect(c.since_commit != null);\n  1130+            try std.testing.expectEqualStrings(\"abc123def\", c.since_commit.?);\n  1131+        },\n  1132+        else => try std.testing.expect(false),\n  1133+    }\n  1134+}\n  1135diff --git a/src/cli/graph.zig b/src/cli/graph.zig\n  1136index 6e44bc5..2e64f23 100644\n  1137--- a/src/cli/graph.zig\n  1138+++ b/src/cli/graph.zig\n  1139@@ -52,6 +52,9 @@ pub fn run(\n  1140             return GraphError.IssueNotFound;\n  1141         }\n  1142         try renderIssueGraph(&dep_graph, &ctx.output, id, graph_args, global, allocator);\n  1143+    } else if (graph_args.all) {\n  1144+        // Show dependency graph for all open issues\n  1145+        try renderAllOpenGraph(&ctx.store, &ctx.output, graph_args, global, allocator);\n  1146     } else {\n  1147         try renderFullGraph(&ctx.store, &ctx.output, graph_args, global, allocator);\n  1148     }\n  1149@@ -65,6 +68,10 @@ fn renderIssueGraph(\n  1150     global: args.GlobalOptions,\n  1151     allocator: std.mem.Allocator,\n  1152 ) !void {\n  1153+    if (graph_args.compact) {\n  1154+        try renderCompactIssueGraph(graph, output, issue_id, graph_args.depth, global, allocator);\n  1155+        return;\n  1156+    }\n  1157     switch (graph_args.format) {\n  1158         .ascii => try renderAsciiTree(graph, output, issue_id, graph_args.depth, global, allocator),\n  1159         .dot => try renderDotGraph(graph, output, issue_id, graph_args.depth, global, allocator),\n  1160@@ -426,6 +433,169 @@ fn statusEql(a: Status, b: Status) bool {\n  1161     return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n  1162 }\n  1163 \n  1164+fn renderCompactIssueGraph(\n  1165+    graph: *DependencyGraph,\n  1166+    output: *Output,\n  1167+    issue_id: []const u8,\n  1168+    max_depth: ?u32,\n  1169+    global: args.GlobalOptions,\n  1170+    allocator: std.mem.Allocator,\n  1171+) !void {\n  1172+    var buf: std.ArrayListUnmanaged(u8) = .{};\n  1173+    defer buf.deinit(allocator);\n  1174+    const writer = buf.writer(allocator);\n  1175+\n  1176+    var visited: std.StringHashMapUnmanaged(void) = .{};\n  1177+    defer {\n  1178+        var it = visited.keyIterator();\n  1179+        while (it.next()) |key| {\n  1180+            allocator.free(key.*);\n  1181+        }\n  1182+        visited.deinit(allocator);\n  1183+    }\n  1184+\n  1185+    // Print root issue\n  1186+    if (graph.store.getRef(issue_id)) |issue| {\n  1187+        const status_indicator = if (statusEql(issue.status, .closed)) \"[x]\" else \"[ ]\";\n  1188+        try writer.print(\"{s} {s} {s}\\n\", .{ issue.id, status_indicator, truncateTitle(issue.title, 60) });\n  1189+    }\n  1190+\n  1191+    // Collect and print dependencies in compact format\n  1192+    try renderCompactDeps(graph, writer, issue_id, 1, max_depth orelse 10, &visited, allocator);\n  1193+\n  1194+    if (global.isStructuredOutput()) {\n  1195+        try output.printJson(GraphResult{\n  1196+            .success = true,\n  1197+            .format = \"compact\",\n  1198+            .output = buf.items,\n  1199+        });\n  1200+    } else {\n  1201+        try output.raw(buf.items);\n  1202+    }\n  1203+}\n  1204+\n  1205+fn renderCompactDeps(\n  1206+    graph: *DependencyGraph,\n  1207+    writer: anytype,\n  1208+    issue_id: []const u8,\n  1209+    depth: u32,\n  1210+    max_depth: u32,\n  1211+    visited: *std.StringHashMapUnmanaged(void),\n  1212+    allocator: std.mem.Allocator,\n  1213+) !void {\n  1214+    if (depth > max_depth) return;\n  1215+\n  1216+    const id_key = try allocator.dupe(u8, issue_id);\n  1217+    if (visited.contains(id_key)) {\n  1218+        allocator.free(id_key);\n  1219+        return;\n  1220+    }\n  1221+    try visited.put(allocator, id_key, {});\n  1222+\n  1223+    const deps = try graph.getDependencies(issue_id);\n  1224+    defer graph.freeDependencies(deps);\n  1225+\n  1226+    for (deps) |dep| {\n  1227+        if (graph.store.getRef(dep.depends_on_id)) |blocker| {\n  1228+            const status_indicator = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n  1229+            // Indent based on depth for hierarchy visibility\n  1230+            var i: u32 = 0;\n  1231+            while (i < depth) : (i += 1) {\n  1232+                try writer.writeAll(\"  \");\n  1233+            }\n  1234+            try writer.print(\"-> {s} {s} {s}\\n\", .{ blocker.id, status_indicator, truncateTitle(blocker.title, 50) });\n  1235+            try renderCompactDeps(graph, writer, dep.depends_on_id, depth + 1, max_depth, visited, allocator);\n  1236+        }\n  1237+    }\n  1238+}\n  1239+\n  1240+fn renderAllOpenGraph(\n  1241+    store: *storage.IssueStore,\n  1242+    output: *Output,\n  1243+    graph_args: args.GraphArgs,\n  1244+    global: args.GlobalOptions,\n  1245+    allocator: std.mem.Allocator,\n  1246+) !void {\n  1247+    var buf: std.ArrayListUnmanaged(u8) = .{};\n  1248+    defer buf.deinit(allocator);\n  1249+    const writer = buf.writer(allocator);\n  1250+\n  1251+    const issues = store.getAllRef();\n  1252+    var open_with_deps: usize = 0;\n  1253+\n  1254+    if (!graph_args.compact) {\n  1255+        try writer.writeAll(\"Open Issues Dependency Graph\\n\");\n  1256+        try writer.writeAll(\"=============================\\n\\n\");\n  1257+    }\n  1258+\n  1259+    for (issues) |issue| {\n  1260+        // Only show open issues (not closed/tombstone)\n  1261+        if (statusEql(issue.status, .closed) or statusEql(issue.status, .tombstone)) {\n  1262+            continue;\n  1263+        }\n  1264+\n  1265+        const has_deps = issue.dependencies.len > 0;\n  1266+        const has_dependents = hasAnyDependents(store, issue.id);\n  1267+\n  1268+        if (has_deps or has_dependents) {\n  1269+            open_with_deps += 1;\n  1270+\n  1271+            if (graph_args.compact) {\n  1272+                // Compact: one line per issue showing status and dep count\n  1273+                const status_indicator = if (statusEql(issue.status, .blocked)) \"[B]\" else \"[ ]\";\n  1274+                const dep_count = issue.dependencies.len;\n  1275+                if (dep_count > 0) {\n  1276+                    try writer.print(\"{s} {s} {s} (deps: {d})\\n\", .{\n  1277+                        issue.id,\n  1278+                        status_indicator,\n  1279+                        truncateTitle(issue.title, 50),\n  1280+                        dep_count,\n  1281+                    });\n  1282+                } else {\n  1283+                    try writer.print(\"{s} {s} {s}\\n\", .{\n  1284+                        issue.id,\n  1285+                        status_indicator,\n  1286+                        truncateTitle(issue.title, 50),\n  1287+                    });\n  1288+                }\n  1289+            } else {\n  1290+                // Full ASCII format for each open issue with dependencies\n  1291+                const status_str = issue.status.toString();\n  1292+                try writer.print(\"{s} [{s}] - {s}\\n\", .{ issue.id, status_str, truncateTitle(issue.title, 50) });\n  1293+\n  1294+                for (issue.dependencies, 0..) |dep, i| {\n  1295+                    const is_last = (i == issue.dependencies.len - 1);\n  1296+                    const connector = if (is_last) \"`-- \" else \"|-- \";\n  1297+\n  1298+                    if (store.getRef(dep.depends_on_id)) |blocker| {\n  1299+                        const blocker_status = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n  1300+                        try writer.print(\"  {s}{s} {s} - {s}\\n\", .{ connector, blocker.id, blocker_status, truncateTitle(blocker.title, 40) });\n  1301+                    } else {\n  1302+                        try writer.print(\"  {s}{s} [?] - (not found)\\n\", .{ connector, dep.depends_on_id });\n  1303+                    }\n  1304+                }\n  1305+                try writer.writeAll(\"\\n\");\n  1306+            }\n  1307+        }\n  1308+    }\n  1309+\n  1310+    if (open_with_deps == 0) {\n  1311+        try writer.writeAll(\"No open issues with dependencies found.\\n\");\n  1312+    }\n  1313+\n  1314+    if (global.isStructuredOutput()) {\n  1315+        const format_str = if (graph_args.compact) \"compact\" else \"ascii\";\n  1316+        try output.printJson(GraphResult{\n  1317+            .success = true,\n  1318+            .format = format_str,\n  1319+            .node_count = open_with_deps,\n  1320+            .output = buf.items,\n  1321+        });\n  1322+    } else {\n  1323+        try output.raw(buf.items);\n  1324+    }\n  1325+}\n  1326+\n  1327 // --- Tests ---\n  1328 \n  1329 test \"GraphError enum exists\" {\n  1330@@ -471,3 +641,83 @@ test \"GraphFormat.fromString parses correctly\" {\n  1331     try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ASCII\").?);\n  1332     try std.testing.expect(args.GraphFormat.fromString(\"invalid\") == null);\n  1333 }\n  1334+\n  1335+test \"GraphArgs supports all flag\" {\n  1336+    const graph_args = args.GraphArgs{\n  1337+        .all = true,\n  1338+    };\n  1339+    try std.testing.expect(graph_args.all);\n  1340+    try std.testing.expect(!graph_args.compact);\n  1341+}\n  1342+\n  1343+test \"GraphArgs supports compact flag\" {\n  1344+    const graph_args = args.GraphArgs{\n  1345+        .compact = true,\n  1346+    };\n  1347+    try std.testing.expect(graph_args.compact);\n  1348+    try std.testing.expect(!graph_args.all);\n  1349+}\n  1350+\n  1351+test \"parse graph with all flag\" {\n  1352+    const allocator = std.testing.allocator;\n  1353+    const cmd_args = [_][]const u8{ \"graph\", \"--all\" };\n  1354+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1355+    var result = parser.parse() catch unreachable;\n  1356+    defer result.deinit(allocator);\n  1357+\n  1358+    switch (result.command) {\n  1359+        .graph => |g| {\n  1360+            try std.testing.expect(g.all);\n  1361+            try std.testing.expect(!g.compact);\n  1362+        },\n  1363+        else => try std.testing.expect(false),\n  1364+    }\n  1365+}\n  1366+\n  1367+test \"parse graph with compact flag\" {\n  1368+    const allocator = std.testing.allocator;\n  1369+    const cmd_args = [_][]const u8{ \"graph\", \"--compact\" };\n  1370+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1371+    var result = parser.parse() catch unreachable;\n  1372+    defer result.deinit(allocator);\n  1373+\n  1374+    switch (result.command) {\n  1375+        .graph => |g| {\n  1376+            try std.testing.expect(g.compact);\n  1377+        },\n  1378+        else => try std.testing.expect(false),\n  1379+    }\n  1380+}\n  1381+\n  1382+test \"parse graph with id and compact flag\" {\n  1383+    const allocator = std.testing.allocator;\n  1384+    const cmd_args = [_][]const u8{ \"graph\", \"bd-123\", \"--compact\" };\n  1385+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1386+    var result = parser.parse() catch unreachable;\n  1387+    defer result.deinit(allocator);\n  1388+\n  1389+    switch (result.command) {\n  1390+        .graph => |g| {\n  1391+            try std.testing.expect(g.id != null);\n  1392+            try std.testing.expectEqualStrings(\"bd-123\", g.id.?);\n  1393+            try std.testing.expect(g.compact);\n  1394+        },\n  1395+        else => try std.testing.expect(false),\n  1396+    }\n  1397+}\n  1398+\n  1399+test \"parse graph with short flags\" {\n  1400+    const allocator = std.testing.allocator;\n  1401+    const cmd_args = [_][]const u8{ \"graph\", \"-a\", \"-c\" };\n  1402+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1403+    var result = parser.parse() catch unreachable;\n  1404+    defer result.deinit(allocator);\n  1405+\n  1406+    switch (result.command) {\n  1407+        .graph => |g| {\n  1408+            try std.testing.expect(g.all);\n  1409+            try std.testing.expect(g.compact);\n  1410+        },\n  1411+        else => try std.testing.expect(false),\n  1412+    }\n  1413+}\n  1414diff --git a/src/cli/help.zig b/src/cli/help.zig\n  1415index 08d2349..d5ff84f 100644\n  1416--- a/src/cli/help.zig\n  1417+++ b/src/cli/help.zig\n  1418@@ -518,19 +518,23 @@ const commands = [_]CommandHelp{\n  1419     .{\n  1420         .name = \"graph\",\n  1421         .summary = \"Show dependency graph\",\n  1422-        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n  1423+        .usage = \"bz graph [ID] [--format FMT] [--depth N] [--all] [--compact]\",\n  1424         .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n  1425-            \"With an ID, shows that issue's dependency subgraph.\",\n  1426+            \"With an ID, shows that issue's dependency subgraph. Use --all for open issues only, --compact for one-line output.\",\n  1427         .arguments = &[_]ArgHelp{\n  1428             .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n  1429         },\n  1430         .flags = &[_]FlagHelp{\n  1431             .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n  1432             .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n  1433+            .{ .short = \"-a\", .long = \"--all\", .description = \"Show graph for all open issues\" },\n  1434+            .{ .short = \"-c\", .long = \"--compact\", .description = \"Compact one-line-per-issue output\" },\n  1435         },\n  1436         .examples = &[_]ExampleHelp{\n  1437             .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n  1438             .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n  1439+            .{ .command = \"bz graph --all\", .description = \"Show graph for all open issues\" },\n  1440+            .{ .command = \"bz graph bd-abc --compact\", .description = \"Compact output for specific issue\" },\n  1441             .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n  1442         },\n  1443         .see_also = &[_][]const u8{\"dep\"},\n  1444@@ -627,18 +631,22 @@ const commands = [_]CommandHelp{\n  1445     .{\n  1446         .name = \"changelog\",\n  1447         .summary = \"Generate changelog from closed issues\",\n  1448-        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n  1449+        .usage = \"bz changelog [--since DATE] [--until DATE] [--since-tag TAG] [--since-commit HASH] [--limit N] [--group-by FIELD]\",\n  1450         .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n  1451-            \"by date range and grouped by type.\",\n  1452+            \"by date range and grouped by type. Can use git tags or commits for date references.\",\n  1453         .flags = &[_]FlagHelp{\n  1454             .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n  1455             .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n  1456+            .{ .short = null, .long = \"--since-tag\", .arg = \"TAG\", .description = \"Start from git tag (e.g., v1.0.0)\" },\n  1457+            .{ .short = null, .long = \"--since-commit\", .arg = \"HASH\", .description = \"Start from git commit (e.g., abc123)\" },\n  1458             .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n  1459             .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n  1460         },\n  1461         .examples = &[_]ExampleHelp{\n  1462             .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n  1463             .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n  1464+            .{ .command = \"bz changelog --since-tag v1.0.0\", .description = \"Since git tag v1.0.0\" },\n  1465+            .{ .command = \"bz changelog --since-commit abc123\", .description = \"Since git commit\" },\n  1466             .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n  1467         },\n  1468         .see_also = &[_][]const u8{\"audit\"},\n  1469diff --git a/src/cli/mod.zig b/src/cli/mod.zig\n  1470index 91977da..596bf1e 100644\n  1471--- a/src/cli/mod.zig\n  1472+++ b/src/cli/mod.zig\n  1473@@ -150,6 +150,8 @@ pub const runHistory = history.run;\n  1474 pub const AuditError = audit.AuditError;\n  1475 pub const AuditResult = audit.AuditResult;\n  1476 pub const runAudit = audit.run;\n  1477+pub const AuditArgs = args.AuditArgs;\n  1478+pub const AuditSubcommand = args.AuditSubcommand;\n  1479 \n  1480 pub const ChangelogError = changelog.ChangelogError;\n  1481 pub const ChangelogResult = changelog.ChangelogResult;\n  1482@@ -163,6 +165,7 @@ pub const runInfo = info.run;\n  1483 pub const StatsError = stats.StatsError;\n  1484 pub const StatsResult = stats.StatsResult;\n  1485 pub const runStats = stats.run;\n  1486+pub const StatsArgs = args.StatsArgs;\n  1487 \n  1488 pub const DoctorError = doctor.DoctorError;\n  1489 pub const DoctorResult = doctor.DoctorResult;\n  1490diff --git a/src/cli/stats.zig b/src/cli/stats.zig\n  1491index 3b0819e..ff3ee64 100644\n  1492--- a/src/cli/stats.zig\n  1493+++ b/src/cli/stats.zig\n  1494@@ -1,6 +1,8 @@\n  1495 //! Stats command for beads_zig.\n  1496 //!\n  1497 //! `bz stats` - Show project statistics\n  1498+//! `bz stats --activity` - Show git-based activity statistics\n  1499+//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n  1500 \n  1501 const std = @import(\"std\");\n  1502 const common = @import(\"common.zig\");\n  1503@@ -12,6 +14,7 @@ pub const StatsError = error{\n  1504     WorkspaceNotInitialized,\n  1505     StorageError,\n  1506     OutOfMemory,\n  1507+    GitError,\n  1508 };\n  1509 \n  1510 pub const StatsResult = struct {\n  1511@@ -22,15 +25,32 @@ pub const StatsResult = struct {\n  1512     by_status: ?[]const CountEntry = null,\n  1513     by_priority: ?[]const CountEntry = null,\n  1514     by_type: ?[]const CountEntry = null,\n  1515+    activity: ?ActivityStats = null,\n  1516     message: ?[]const u8 = null,\n  1517 \n  1518     pub const CountEntry = struct {\n  1519         key: []const u8,\n  1520         count: usize,\n  1521     };\n  1522+\n  1523+    pub const ActivityStats = struct {\n  1524+        period_hours: u32,\n  1525+        git_commits: usize,\n  1526+        issues_created: usize,\n  1527+        issues_closed: usize,\n  1528+        issues_updated: usize,\n  1529+        commits_with_issue_refs: usize,\n  1530+        issue_refs: ?[]const IssueRef = null,\n  1531+\n  1532+        pub const IssueRef = struct {\n  1533+            issue_id: []const u8,\n  1534+            commit_count: usize,\n  1535+        };\n  1536+    };\n  1537 };\n  1538 \n  1539 pub fn run(\n  1540+    stats_args: args.StatsArgs,\n  1541     global: args.GlobalOptions,\n  1542     allocator: std.mem.Allocator,\n  1543 ) !void {\n  1544@@ -109,6 +129,15 @@ pub fn run(\n  1545         try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n  1546     }\n  1547 \n  1548+    // Activity stats (if requested)\n  1549+    var activity_stats: ?StatsResult.ActivityStats = null;\n  1550+    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n  1551+    defer issue_refs_list.deinit(allocator);\n  1552+\n  1553+    if (stats_args.activity) {\n  1554+        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n  1555+    }\n  1556+\n  1557     if (global.isStructuredOutput()) {\n  1558         try ctx.output.printJson(StatsResult{\n  1559             .success = true,\n  1560@@ -118,6 +147,7 @@ pub fn run(\n  1561             .by_status = status_list.items,\n  1562             .by_priority = priority_list.items,\n  1563             .by_type = type_list.items,\n  1564+            .activity = activity_stats,\n  1565         });\n  1566     } else if (!global.quiet) {\n  1567         try ctx.output.println(\"Issue Statistics\", .{});\n  1568@@ -145,9 +175,174 @@ pub fn run(\n  1569                 try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n  1570             }\n  1571         }\n  1572+\n  1573+        if (activity_stats) |activity| {\n  1574+            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n  1575+            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n  1576+            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n  1577+            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n  1578+            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n  1579+            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n  1580+\n  1581+            if (activity.issue_refs) |refs| {\n  1582+                if (refs.len > 0) {\n  1583+                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n  1584+                    for (refs[0..@min(10, refs.len)]) |ref| {\n  1585+                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n  1586+                    }\n  1587+                    if (refs.len > 10) {\n  1588+                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n  1589+                    }\n  1590+                }\n  1591+            }\n  1592+        }\n  1593     }\n  1594 }\n  1595 \n  1596+fn getActivityStats(\n  1597+    allocator: std.mem.Allocator,\n  1598+    ctx: *CommandContext,\n  1599+    hours: u32,\n  1600+    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n  1601+) !StatsResult.ActivityStats {\n  1602+    const now = std.time.timestamp();\n  1603+    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n  1604+\n  1605+    // Count issue activity in the time period\n  1606+    var issues_created: usize = 0;\n  1607+    var issues_closed: usize = 0;\n  1608+    var issues_updated: usize = 0;\n  1609+\n  1610+    for (ctx.store.issues.items) |issue| {\n  1611+        if (issue.status.eql(.tombstone)) continue;\n  1612+\n  1613+        if (issue.created_at.value >= since) {\n  1614+            issues_created += 1;\n  1615+        }\n  1616+        if (issue.closed_at.value) |closed_ts| {\n  1617+            if (closed_ts >= since) {\n  1618+                issues_closed += 1;\n  1619+            }\n  1620+        }\n  1621+        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n  1622+            issues_updated += 1;\n  1623+        }\n  1624+    }\n  1625+\n  1626+    // Get git commit stats\n  1627+    var git_commits: usize = 0;\n  1628+    var commits_with_refs: usize = 0;\n  1629+    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n  1630+    defer issue_ref_counts.deinit(allocator);\n  1631+\n  1632+    // Run git log to get recent commits\n  1633+    const git_result = runGitLog(allocator, hours) catch {\n  1634+        // Git not available or not a git repo - return partial stats\n  1635+        return StatsResult.ActivityStats{\n  1636+            .period_hours = hours,\n  1637+            .git_commits = 0,\n  1638+            .issues_created = issues_created,\n  1639+            .issues_closed = issues_closed,\n  1640+            .issues_updated = issues_updated,\n  1641+            .commits_with_issue_refs = 0,\n  1642+            .issue_refs = null,\n  1643+        };\n  1644+    };\n  1645+    defer allocator.free(git_result);\n  1646+\n  1647+    // Parse git log output\n  1648+    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n  1649+    while (lines.next()) |line| {\n  1650+        if (line.len == 0) continue;\n  1651+        git_commits += 1;\n  1652+\n  1653+        // Look for issue references (bd-xxx pattern)\n  1654+        var found_ref = false;\n  1655+        var i: usize = 0;\n  1656+        while (i < line.len) {\n  1657+            // Look for \"bd-\" or similar prefix\n  1658+            if (i + 3 < line.len and\n  1659+                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n  1660+            {\n  1661+                // Extract the issue ID\n  1662+                const start = i;\n  1663+                i += 3;\n  1664+                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n  1665+                    i += 1;\n  1666+                }\n  1667+                const issue_id = line[start..i];\n  1668+                if (issue_id.len > 3) {\n  1669+                    // Normalize to lowercase\n  1670+                    var normalized: [32]u8 = undefined;\n  1671+                    const len = @min(issue_id.len, 32);\n  1672+                    for (0..len) |j| {\n  1673+                        normalized[j] = std.ascii.toLower(issue_id[j]);\n  1674+                    }\n  1675+                    const key = normalized[0..len];\n  1676+\n  1677+                    // Check if this issue exists in our store\n  1678+                    if (ctx.store.exists(key) catch false) {\n  1679+                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n  1680+                        entry.value_ptr.* += 1;\n  1681+                        found_ref = true;\n  1682+                    }\n  1683+                }\n  1684+            } else {\n  1685+                i += 1;\n  1686+            }\n  1687+        }\n  1688+        if (found_ref) {\n  1689+            commits_with_refs += 1;\n  1690+        }\n  1691+    }\n  1692+\n  1693+    // Convert issue refs to array\n  1694+    var it = issue_ref_counts.iterator();\n  1695+    while (it.next()) |entry| {\n  1696+        try issue_refs_list.append(allocator, .{\n  1697+            .issue_id = entry.key_ptr.*,\n  1698+            .commit_count = entry.value_ptr.*,\n  1699+        });\n  1700+    }\n  1701+\n  1702+    // Sort by commit count descending\n  1703+    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n  1704+        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n  1705+            return a.commit_count > b.commit_count;\n  1706+        }\n  1707+    }.lessThan);\n  1708+\n  1709+    return StatsResult.ActivityStats{\n  1710+        .period_hours = hours,\n  1711+        .git_commits = git_commits,\n  1712+        .issues_created = issues_created,\n  1713+        .issues_closed = issues_closed,\n  1714+        .issues_updated = issues_updated,\n  1715+        .commits_with_issue_refs = commits_with_refs,\n  1716+        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n  1717+    };\n  1718+}\n  1719+\n  1720+fn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n  1721+    var buf: [32]u8 = undefined;\n  1722+    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n  1723+\n  1724+    const result = std.process.Child.run(.{\n  1725+        .allocator = allocator,\n  1726+        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n  1727+        .cwd = null,\n  1728+    }) catch return StatsError.GitError;\n  1729+\n  1730+    defer allocator.free(result.stderr);\n  1731+\n  1732+    if (result.term.Exited != 0) {\n  1733+        allocator.free(result.stdout);\n  1734+        return StatsError.GitError;\n  1735+    }\n  1736+\n  1737+    return result.stdout;\n  1738+}\n  1739+\n  1740 // --- Tests ---\n  1741 \n  1742 test \"StatsError enum exists\" {\n  1743@@ -169,8 +364,47 @@ test \"StatsResult struct works\" {\n  1744 test \"run detects uninitialized workspace\" {\n  1745     const allocator = std.testing.allocator;\n  1746 \n  1747+    const stats_args = args.StatsArgs{};\n  1748     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n  1749 \n  1750-    const result = run(global, allocator);\n  1751+    const result = run(stats_args, global, allocator);\n  1752     try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n  1753 }\n  1754+\n  1755+test \"StatsArgs default values\" {\n  1756+    const stats_args = args.StatsArgs{};\n  1757+    try std.testing.expect(!stats_args.activity);\n  1758+    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n  1759+}\n  1760+\n  1761+test \"parse stats with activity flag\" {\n  1762+    const allocator = std.testing.allocator;\n  1763+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n  1764+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1765+    var result = parser.parse() catch unreachable;\n  1766+    defer result.deinit(allocator);\n  1767+\n  1768+    switch (result.command) {\n  1769+        .stats => |s| {\n  1770+            try std.testing.expect(s.activity);\n  1771+            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n  1772+        },\n  1773+        else => try std.testing.expect(false),\n  1774+    }\n  1775+}\n  1776+\n  1777+test \"parse stats with activity-hours flag\" {\n  1778+    const allocator = std.testing.allocator;\n  1779+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n  1780+    var parser = args.ArgParser.init(allocator, &cmd_args);\n  1781+    var result = parser.parse() catch unreachable;\n  1782+    defer result.deinit(allocator);\n  1783+\n  1784+    switch (result.command) {\n  1785+        .stats => |s| {\n  1786+            try std.testing.expect(s.activity);\n  1787+            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n  1788+        },\n  1789+        else => try std.testing.expect(false),\n  1790+    }\n  1791+}\n  1792diff --git a/src/main.zig b/src/main.zig\n  1793index adec608..1d0bbb8 100644\n  1794--- a/src/main.zig\n  1795+++ b/src/main.zig\n  1796@@ -208,9 +208,9 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n  1797                 else => return err,\n  1798             };\n  1799         },\n  1800-        .stats => {\n  1801-            cli.runStats(result.global, allocator) catch |err| switch (err) {\n  1802-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n  1803+        .stats => |stats_args| {\n  1804+            cli.runStats(stats_args, result.global, allocator) catch |err| switch (err) {\n  1805+                error.WorkspaceNotInitialized, error.StorageError, error.GitError => std.process.exit(1),\n  1806                 else => return err,\n  1807             };\n  1808         },\n  1809@@ -258,7 +258,7 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n  1810         },\n  1811         .audit => |audit_args| {\n  1812             cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n  1813-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n  1814+                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),\n  1815                 else => return err,\n  1816             };\n  1817         },\n  1818diff --git a/src/models/event.zig b/src/models/event.zig\n  1819index 29dd632..ec69cfc 100644\n  1820--- a/src/models/event.zig\n  1821+++ b/src/models/event.zig\n  1822@@ -24,6 +24,9 @@ pub const EventType = enum {\n  1823     compacted,\n  1824     deleted,\n  1825     restored,\n  1826+    // LLM/tool interaction tracking\n  1827+    llm_call,\n  1828+    tool_call,\n  1829 \n  1830     const Self = @This();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"b9cdec4c-a259-43b1-9ebe-26fb4ae0ed06","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/3427775d-9f02-439a-891d-b9ec8986d232/tool-results/toolu_01Pm8XPMYzPZkPyyDKCjXCJf.txt","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 1a80844..ee9431d 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -38,7 +38,7 @@ pub const Command = union(enum) {\n     // Workspace\n     init: InitArgs,\n     info: void,\n-    stats: void,\n+    stats: StatsArgs,\n     doctor: void,\n     config: ConfigArgs,\n     orphans: OrphansArgs,\n@@ -115,6 +115,12 @@ pub const InitArgs = struct {\n     prefix: []const u8 = \"bd\",\n };\n \n+/// Stats command arguments.\n+pub const StatsArgs = struct {\n+    activity: bool = false, // Show git-based activity statistics\n+    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n+};\n+\n /// Create command arguments.\n pub const CreateArgs = struct {\n     title: []const u8,\n@@ -426,6 +432,8 @@ pub const GraphArgs = struct {\n     id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n     format: GraphFormat = .ascii,\n     depth: ?u32 = null, // Max depth for tree traversal\n+    all: bool = false, // Show dependency graph for all open issues\n+    compact: bool = false, // Compact one-line-per-issue output\n };\n \n /// Label subcommand variants.\n@@ -474,15 +482,51 @@ pub const HistoryArgs = struct {\n     id: []const u8,\n };\n \n+/// Audit subcommand variants.\n+pub const AuditSubcommand = union(enum) {\n+    /// Record an LLM/tool interaction for training data.\n+    record: struct {\n+        kind: []const u8, // \"llm_call\" or \"tool_call\"\n+        issue_id: ?[]const u8 = null, // Optional issue context\n+        model: ?[]const u8 = null, // Model name (for llm_call)\n+        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n+        response: ?[]const u8 = null, // Output response (for llm_call)\n+        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n+        exit_code: ?i32 = null, // Exit code (for tool_call)\n+        metadata: ?[]const u8 = null, // Additional JSON metadata\n+    },\n+    /// Label an audit entry for quality tracking.\n+    label: struct {\n+        entry_id: i64, // Event ID to label\n+        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n+        reason: ?[]const u8 = null, // Explanation for the label\n+    },\n+    /// View audit log for a specific issue.\n+    log: struct {\n+        issue_id: []const u8,\n+        limit: ?u32 = null,\n+    },\n+    /// Summary of audit data over time period.\n+    summary: struct {\n+        days: u32 = 7, // Number of days to summarize\n+    },\n+    /// Legacy: show project-wide audit log (default behavior).\n+    list: struct {\n+        limit: ?u32 = null,\n+    },\n+};\n+\n /// Audit command arguments.\n pub const AuditArgs = struct {\n-    limit: ?u32 = null,\n+    subcommand: AuditSubcommand,\n };\n \n /// Changelog command arguments.\n pub const ChangelogArgs = struct {\n     since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n     until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n+    since_tag: ?[]const u8 = null, // Git tag for start date (e.g., \"v1.0.0\")\n+    since_commit: ?[]const u8 = null, // Git commit for start date (e.g., \"abc123\")\n     limit: ?u32 = null,\n     group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n };\n@@ -804,7 +848,7 @@ pub const ArgParser = struct {\n             return .{ .info = {} };\n         }\n         if (std.mem.eql(u8, cmd, \"stats\")) {\n-            return .{ .stats = {} };\n+            return .{ .stats = try self.parseStatsArgs() };\n         }\n         if (std.mem.eql(u8, cmd, \"doctor\")) {\n             return .{ .doctor = {} };\n@@ -969,6 +1013,18 @@ pub const ArgParser = struct {\n         return result;\n     }\n \n+    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n+        var result = StatsArgs{};\n+        while (self.hasNext()) {\n+            if (self.consumeFlag(\"-a\", \"--activity\")) {\n+                result.activity = true;\n+            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n+                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n+            } else break;\n+        }\n+        return result;\n+    }\n+\n     fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n         var result = CreateArgs{ .title = undefined };\n         var title_set = false;\n@@ -1429,6 +1485,10 @@ pub const ArgParser = struct {\n                 result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n             } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                 result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(\"-a\", \"--all\")) {\n+                result.all = true;\n+            } else if (self.consumeFlag(\"-c\", \"--compact\")) {\n+                result.compact = true;\n             } else if (self.peekPositional()) |_| {\n                 if (result.id == null) {\n                     result.id = self.next().?;\n@@ -1550,13 +1610,108 @@ pub const ArgParser = struct {\n     }\n \n     fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n-        var result = AuditArgs{};\n-        while (self.hasNext()) {\n-            if (try self.parseLimitFlag()) |limit| {\n-                result.limit = limit;\n-            } else break;\n+        // Check for subcommand\n+        const subcmd = self.next() orelse {\n+            // Default: list with no limit\n+            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n+        };\n+\n+        // Handle --limit flag at top level (legacy support)\n+        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n+            // Put it back and parse as list subcommand with limit\n+            self.index -= 1;\n+            var limit: ?u32 = null;\n+            while (self.hasNext()) {\n+                if (try self.parseLimitFlag()) |l| {\n+                    limit = l;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n         }\n-        return result;\n+\n+        if (std.mem.eql(u8, subcmd, \"record\")) {\n+            const kind = self.next() orelse return error.MissingRequiredArgument;\n+            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n+\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-i\", \"--issue\")) {\n+                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n+                    result.record.model = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n+                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n+                    result.record.response = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n+                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n+                    const exit_str = self.next() orelse return error.MissingFlagValue;\n+                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n+                } else if (self.consumeFlag(null, \"--metadata\")) {\n+                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n+                } else break;\n+            }\n+            return .{ .subcommand = result };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"label\")) {\n+            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n+            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n+            var label_value: ?[]const u8 = null;\n+            var reason: ?[]const u8 = null;\n+\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-l\", \"--label\")) {\n+                    label_value = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n+                    reason = self.next() orelse return error.MissingFlagValue;\n+                } else if (self.peekPositional()) |_| {\n+                    if (label_value == null) {\n+                        label_value = self.next().?;\n+                    } else break;\n+                } else break;\n+            }\n+\n+            if (label_value == null) return error.MissingRequiredArgument;\n+            return .{ .subcommand = .{ .label = .{\n+                .entry_id = entry_id,\n+                .label_value = label_value.?,\n+                .reason = reason,\n+            } } };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"log\")) {\n+            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n+            var limit: ?u32 = null;\n+            while (self.hasNext()) {\n+                if (try self.parseLimitFlag()) |l| {\n+                    limit = l;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"summary\")) {\n+            var days: u32 = 7;\n+            while (self.hasNext()) {\n+                if (self.consumeFlag(\"-d\", \"--days\")) {\n+                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n+        }\n+\n+        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n+            var limit: ?u32 = null;\n+            while (self.hasNext()) {\n+                if (try self.parseLimitFlag()) |l| {\n+                    limit = l;\n+                } else break;\n+            }\n+            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n+        }\n+\n+        return error.UnknownSubcommand;\n     }\n \n     fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n@@ -1566,6 +1721,10 @@ pub const ArgParser = struct {\n                 result.since = self.next() orelse return error.MissingFlagValue;\n             } else if (self.consumeFlag(null, \"--until\")) {\n                 result.until = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--since-tag\")) {\n+                result.since_tag = self.next() orelse return error.MissingFlagValue;\n+            } else if (self.consumeFlag(null, \"--since-commit\")) {\n+                result.since_commit = self.next() orelse return error.MissingFlagValue;\n             } else if (try self.parseLimitFlag()) |limit| {\n                 result.limit = limit;\n             } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n@@ -2482,9 +2641,13 @@ test \"parse audit command\" {\n test \"parse audit command with limit\" {\n     const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\n-    const result = try parser.parse();\n+    var result = try parser.parse();\n+    defer result.deinit(std.testing.allocator);\n \n-    try std.testing.expectEqual(@as(u32, 50), result.command.audit.limit.?);\n+    switch (result.command.audit.subcommand) {\n+        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n+        else => try std.testing.expect(false),\n+    }\n }\n \n test \"parse sync command\" {\ndiff --git a/src/cli/audit.zig b/src/cli/audit.zig\nindex 50d3d6b..6860d8d 100644\n--- a/src/cli/audit.zig\n+++ b/src/cli/audit.zig\n@@ -1,10 +1,16 @@\n //! Audit command for beads_zig.\n //!\n-//! `bz audit [--limit N]` - Show project-wide audit log\n+//! `bz audit` - Show project-wide audit log (default)\n+//! `bz audit record <kind>` - Record LLM/tool interaction\n+//! `bz audit label <entry-id> <label>` - Label audit entry\n+//! `bz audit log <issue-id>` - View audit log for specific issue\n+//! `bz audit summary` - Summary of audit data over time period\n \n const std = @import(\"std\");\n const common = @import(\"common.zig\");\n const args = @import(\"args.zig\");\n+const Event = @import(\"../models/event.zig\").Event;\n+const EventType = @import(\"../models/event.zig\").EventType;\n \n const CommandContext = common.CommandContext;\n \n@@ -12,19 +18,42 @@ pub const AuditError = error{\n     WorkspaceNotInitialized,\n     StorageError,\n     OutOfMemory,\n+    InvalidKind,\n+    EntryNotFound,\n };\n \n pub const AuditResult = struct {\n     success: bool,\n     events: ?[]const AuditEvent = null,\n     total: ?usize = null,\n+    event_id: ?i64 = null,\n+    summary: ?AuditSummary = null,\n     message: ?[]const u8 = null,\n \n     pub const AuditEvent = struct {\n+        id: i64,\n         issue_id: []const u8,\n         event_type: []const u8,\n         actor: []const u8,\n         created_at: i64,\n+        old_value: ?[]const u8 = null,\n+        new_value: ?[]const u8 = null,\n+    };\n+\n+    pub const AuditSummary = struct {\n+        period_days: u32,\n+        total_events: usize,\n+        llm_calls: usize,\n+        tool_calls: usize,\n+        issue_creates: usize,\n+        issue_closes: usize,\n+        other_events: usize,\n+        by_actor: ?[]const ActorCount = null,\n+\n+        pub const ActorCount = struct {\n+            actor: []const u8,\n+            count: usize,\n+        };\n     };\n };\n \n@@ -32,13 +61,364 @@ pub fn run(\n     audit_args: args.AuditArgs,\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n+) !void {\n+    switch (audit_args.subcommand) {\n+        .record => |record_args| try runRecord(record_args, global, allocator),\n+        .label => |label_args| try runLabel(label_args, global, allocator),\n+        .log => |log_args| try runLog(log_args, global, allocator),\n+        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n+        .list => |list_args| try runList(list_args, global, allocator),\n+    }\n+}\n+\n+fn runRecord(\n+    record_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Validate kind\n+    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n+        .llm_call\n+    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n+        .tool_call\n+    else {\n+        if (!global.silent) {\n+            if (global.isStructuredOutput()) {\n+                try ctx.output.printJson(AuditResult{\n+                    .success = false,\n+                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n+                });\n+            } else {\n+                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n+            }\n+        }\n+        return AuditError.InvalidKind;\n+    };\n+\n+    const actor = global.actor orelse \"unknown\";\n+    const now = std.time.timestamp();\n+\n+    // Build metadata JSON with all provided fields\n+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n+    defer metadata_parts.deinit(allocator);\n+\n+    try metadata_parts.appendSlice(allocator, \"{\");\n+    var first = true;\n+\n+    if (record_args.model) |model| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n+        try metadata_parts.appendSlice(allocator, model);\n+        try metadata_parts.appendSlice(allocator, \"\\\"\");\n+        first = false;\n+    }\n+    if (record_args.prompt) |prompt| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n+        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n+        defer allocator.free(escaped);\n+        try metadata_parts.appendSlice(allocator, escaped);\n+        first = false;\n+    }\n+    if (record_args.response) |response| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n+        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n+        defer allocator.free(escaped);\n+        try metadata_parts.appendSlice(allocator, escaped);\n+        first = false;\n+    }\n+    if (record_args.tool_name) |tool_name| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n+        try metadata_parts.appendSlice(allocator, tool_name);\n+        try metadata_parts.appendSlice(allocator, \"\\\"\");\n+        first = false;\n+    }\n+    if (record_args.exit_code) |exit_code| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        var buf: [32]u8 = undefined;\n+        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n+        try metadata_parts.appendSlice(allocator, s);\n+        first = false;\n+    }\n+    if (record_args.metadata) |metadata| {\n+        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n+        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n+        try metadata_parts.appendSlice(allocator, metadata);\n+        first = false;\n+    }\n+    try metadata_parts.appendSlice(allocator, \"}\");\n+\n+    const new_value = try allocator.dupe(u8, metadata_parts.items);\n+    defer allocator.free(new_value);\n+\n+    const event = Event{\n+        .id = 0,\n+        .issue_id = record_args.issue_id orelse \"\",\n+        .event_type = event_type,\n+        .actor = actor,\n+        .old_value = null,\n+        .new_value = new_value,\n+        .created_at = now,\n+    };\n+\n+    const event_id = try ctx.event_store.append(event);\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .event_id = event_id,\n+            .message = \"Audit entry recorded\",\n+        });\n+    } else if (!global.quiet) {\n+        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n+    }\n+}\n+\n+fn runLabel(\n+    label_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    // Record a label event referencing the original entry\n+    const actor = global.actor orelse \"unknown\";\n+    const now = std.time.timestamp();\n+\n+    // Build the label metadata\n+    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n+    defer metadata_parts.deinit(allocator);\n+\n+    var buf: [64]u8 = undefined;\n+    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n+    try metadata_parts.appendSlice(allocator, header);\n+\n+    if (label_args.reason) |reason| {\n+        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n+        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n+        defer allocator.free(escaped);\n+        try metadata_parts.appendSlice(allocator, escaped);\n+    }\n+    try metadata_parts.appendSlice(allocator, \"}\");\n+\n+    const new_value = try allocator.dupe(u8, metadata_parts.items);\n+    defer allocator.free(new_value);\n+\n+    // Use 'updated' event type to represent a label action on an existing entry\n+    const event = Event{\n+        .id = 0,\n+        .issue_id = \"\", // Labels are not issue-specific\n+        .event_type = .updated,\n+        .actor = actor,\n+        .old_value = null,\n+        .new_value = new_value,\n+        .created_at = now,\n+    };\n+\n+    const event_id = try ctx.event_store.append(event);\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .event_id = event_id,\n+            .message = \"Label applied to audit entry\",\n+        });\n+    } else if (!global.quiet) {\n+        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n+    }\n+}\n+\n+fn runLog(\n+    log_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    const limit = log_args.limit orelse 100;\n+\n+    // Query events for the specific issue from the event store\n+    const events = try ctx.event_store.queryEvents(.{\n+        .issue_id = log_args.issue_id,\n+        .limit = limit,\n+    });\n+    defer ctx.event_store.freeEvents(events);\n+\n+    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n+    defer audit_events.deinit(allocator);\n+\n+    for (events) |event| {\n+        try audit_events.append(allocator, .{\n+            .id = event.id,\n+            .issue_id = event.issue_id,\n+            .event_type = event.event_type.toString(),\n+            .actor = event.actor,\n+            .created_at = event.created_at,\n+            .old_value = event.old_value,\n+            .new_value = event.new_value,\n+        });\n+    }\n+\n+    // Sort by timestamp descending\n+    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n+        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n+            return a.created_at > b.created_at;\n+        }\n+    }.lessThan);\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .events = audit_events.items,\n+            .total = audit_events.items.len,\n+        });\n+    } else if (global.quiet) {\n+        for (audit_events.items) |event| {\n+            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n+        }\n+    } else {\n+        if (audit_events.items.len == 0) {\n+            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n+        } else {\n+            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n+            try ctx.output.print(\"\\n\", .{});\n+\n+            for (audit_events.items) |event| {\n+                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n+                    event.id,\n+                    event.created_at,\n+                    event.actor,\n+                    event.event_type,\n+                });\n+                if (event.new_value) |v| {\n+                    if (v.len > 0 and v.len < 200) {\n+                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn runSummary(\n+    summary_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n ) !void {\n     var ctx = (try CommandContext.init(allocator, global)) orelse {\n         return AuditError.WorkspaceNotInitialized;\n     };\n     defer ctx.deinit();\n \n-    const limit = audit_args.limit orelse 100;\n+    const now = std.time.timestamp();\n+    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n+\n+    // Query all events in the time period\n+    const events = try ctx.event_store.queryEvents(.{ .since = since });\n+    defer ctx.event_store.freeEvents(events);\n+\n+    // Count by type\n+    var llm_calls: usize = 0;\n+    var tool_calls: usize = 0;\n+    var issue_creates: usize = 0;\n+    var issue_closes: usize = 0;\n+    var other_events: usize = 0;\n+\n+    // Count by actor\n+    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n+    defer actor_counts.deinit(allocator);\n+\n+    for (events) |event| {\n+        switch (event.event_type) {\n+            .llm_call => llm_calls += 1,\n+            .tool_call => tool_calls += 1,\n+            .created => issue_creates += 1,\n+            .closed => issue_closes += 1,\n+            else => other_events += 1,\n+        }\n+\n+        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n+        entry.value_ptr.* += 1;\n+    }\n+\n+    // Convert actor counts to array\n+    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n+    defer actor_list.deinit(allocator);\n+\n+    var it = actor_counts.iterator();\n+    while (it.next()) |entry| {\n+        try actor_list.append(allocator, .{\n+            .actor = entry.key_ptr.*,\n+            .count = entry.value_ptr.*,\n+        });\n+    }\n+\n+    // Sort by count descending\n+    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n+        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n+            return a.count > b.count;\n+        }\n+    }.lessThan);\n+\n+    const summary = AuditResult.AuditSummary{\n+        .period_days = summary_args.days,\n+        .total_events = events.len,\n+        .llm_calls = llm_calls,\n+        .tool_calls = tool_calls,\n+        .issue_creates = issue_creates,\n+        .issue_closes = issue_closes,\n+        .other_events = other_events,\n+        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n+    };\n+\n+    if (global.isStructuredOutput()) {\n+        try ctx.output.printJson(AuditResult{\n+            .success = true,\n+            .summary = summary,\n+        });\n+    } else if (!global.quiet) {\n+        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n+        try ctx.output.print(\"\\n\", .{});\n+        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n+        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n+        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n+        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n+        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n+        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n+\n+        if (actor_list.items.len > 0) {\n+            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n+            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n+                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n+            }\n+        }\n+    }\n+}\n+\n+fn runList(\n+    list_args: anytype,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var ctx = (try CommandContext.init(allocator, global)) orelse {\n+        return AuditError.WorkspaceNotInitialized;\n+    };\n+    defer ctx.deinit();\n+\n+    const limit = list_args.limit orelse 100;\n \n     // Build synthetic audit log from all issues\n     var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n@@ -47,6 +427,7 @@ pub fn run(\n     for (ctx.store.issues.items) |issue| {\n         // Created event\n         try events.append(allocator, .{\n+            .id = 0,\n             .issue_id = issue.id,\n             .event_type = \"created\",\n             .actor = issue.created_by orelse \"unknown\",\n@@ -56,6 +437,7 @@ pub fn run(\n         // Closed event\n         if (issue.closed_at.value) |closed_ts| {\n             try events.append(allocator, .{\n+                .id = 0,\n                 .issue_id = issue.id,\n                 .event_type = \"closed\",\n                 .actor = \"unknown\",\n@@ -66,6 +448,7 @@ pub fn run(\n         // If tombstoned\n         if (issue.status.eql(.tombstone)) {\n             try events.append(allocator, .{\n+                .id = 0,\n                 .issue_id = issue.id,\n                 .event_type = \"deleted\",\n                 .actor = \"unknown\",\n@@ -139,9 +522,69 @@ test \"AuditResult struct works\" {\n test \"run detects uninitialized workspace\" {\n     const allocator = std.testing.allocator;\n \n-    const audit_args = args.AuditArgs{};\n+    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n \n     const result = run(audit_args, global, allocator);\n     try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n }\n+\n+test \"AuditSubcommand record parses correctly\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .audit => |a| {\n+            switch (a.subcommand) {\n+                .record => |r| {\n+                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n+                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n+                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n+                },\n+                else => try std.testing.expect(false),\n+            }\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"AuditSubcommand summary parses days\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .audit => |a| {\n+            switch (a.subcommand) {\n+                .summary => |s| {\n+                    try std.testing.expectEqual(@as(u32, 30), s.days);\n+                },\n+                else => try std.testing.expect(false),\n+            }\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"AuditSubcommand list is default\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{\"audit\"};\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .audit => |a| {\n+            switch (a.subcommand) {\n+                .list => {},\n+                else => try std.testing.expect(false),\n+            }\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/cli/backup.zig b/src/cli/backup.zig\nindex 9483ef0..0cbcab4 100644\n--- a/src/cli/backup.zig\n+++ b/src/cli/backup.zig\n@@ -27,6 +27,49 @@ pub const BackupInfo = struct {\n     modified: i64,\n };\n \n+/// Collect backup files from the .beads directory.\n+/// Returns a list of BackupInfo structs sorted by modified time (newest first).\n+/// Caller is responsible for freeing the filenames and deiniting the list.\n+fn collectBackups(beads_dir: []const u8, allocator: std.mem.Allocator) !?std.ArrayListUnmanaged(BackupInfo) {\n+    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n+        if (err == error.FileNotFound) return null;\n+        return err;\n+    };\n+    defer dir.close();\n+\n+    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n+    errdefer {\n+        for (backups.items) |b| allocator.free(b.filename);\n+        backups.deinit(allocator);\n+    }\n+\n+    var iter = dir.iterate();\n+    while (try iter.next()) |entry| {\n+        // Match backup files: issues.jsonl.bak.* or issues.*.jsonl (but not issues.jsonl)\n+        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n+            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n+            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n+            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n+        {\n+            const stat = dir.statFile(entry.name) catch continue;\n+            try backups.append(allocator, .{\n+                .filename = try allocator.dupe(u8, entry.name),\n+                .size = stat.size,\n+                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n+            });\n+        }\n+    }\n+\n+    // Sort by modified time (newest first)\n+    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n+        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n+            return a.modified > b.modified;\n+        }\n+    }.lessThan);\n+\n+    return backups;\n+}\n+\n pub const BackupResult = struct {\n     success: bool,\n     action: ?[]const u8 = null,\n@@ -65,55 +108,24 @@ pub fn run(\n fn runList(ctx: *CommandContext, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n     const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n \n-    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n+    var backups = (try collectBackups(beads_dir, allocator)) orelse {\n+        if (structured_output) {\n+            try ctx.output.printJson(BackupResult{\n+                .success = true,\n+                .action = \"list\",\n+                .backup_count = 0,\n+                .message = \"no backups found\",\n+            });\n+        } else if (!quiet) {\n+            try ctx.output.info(\"No backups found\", .{});\n+        }\n+        return;\n+    };\n     defer {\n         for (backups.items) |b| allocator.free(b.filename);\n         backups.deinit(allocator);\n     }\n \n-    // Open the .beads directory and look for backup files\n-    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n-        if (err == error.FileNotFound) {\n-            if (structured_output) {\n-                try ctx.output.printJson(BackupResult{\n-                    .success = true,\n-                    .action = \"list\",\n-                    .backup_count = 0,\n-                    .message = \"no backups found\",\n-                });\n-            } else if (!quiet) {\n-                try ctx.output.info(\"No backups found\", .{});\n-            }\n-            return;\n-        }\n-        return err;\n-    };\n-    defer dir.close();\n-\n-    var iter = dir.iterate();\n-    while (try iter.next()) |entry| {\n-        // Look for backup files matching pattern: issues.jsonl.bak.* or issues.*.jsonl\n-        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n-            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n-            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n-            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n-        {\n-            const stat = dir.statFile(entry.name) catch continue;\n-            try backups.append(allocator, .{\n-                .filename = try allocator.dupe(u8, entry.name),\n-                .size = stat.size,\n-                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n-            });\n-        }\n-    }\n-\n-    // Sort by modified time (newest first)\n-    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n-        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n-            return a.modified > b.modified;\n-        }\n-    }.lessThan);\n-\n     if (structured_output) {\n         try ctx.output.printJson(BackupResult{\n             .success = true,\n@@ -328,47 +340,24 @@ fn runRestore(ctx: *CommandContext, file: []const u8, dry_run: bool, structured_\n fn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: bool, quiet: bool, allocator: std.mem.Allocator) !void {\n     const beads_dir = std.fs.path.dirname(ctx.store.jsonl_path) orelse \".beads\";\n \n-    var backups: std.ArrayListUnmanaged(BackupInfo) = .{};\n+    var backups = (try collectBackups(beads_dir, allocator)) orelse {\n+        if (structured_output) {\n+            try ctx.output.printJson(BackupResult{\n+                .success = true,\n+                .action = \"prune\",\n+                .pruned_count = 0,\n+                .message = \"no backups to prune\",\n+            });\n+        } else if (!quiet) {\n+            try ctx.output.info(\"No backups to prune\", .{});\n+        }\n+        return;\n+    };\n     defer {\n         for (backups.items) |b| allocator.free(b.filename);\n         backups.deinit(allocator);\n     }\n \n-    // Collect backup files\n-    var dir = std.fs.cwd().openDir(beads_dir, .{ .iterate = true }) catch |err| {\n-        if (err == error.FileNotFound) {\n-            if (structured_output) {\n-                try ctx.output.printJson(BackupResult{\n-                    .success = true,\n-                    .action = \"prune\",\n-                    .pruned_count = 0,\n-                    .message = \"no backups to prune\",\n-                });\n-            } else if (!quiet) {\n-                try ctx.output.info(\"No backups to prune\", .{});\n-            }\n-            return;\n-        }\n-        return err;\n-    };\n-    defer dir.close();\n-\n-    var iter = dir.iterate();\n-    while (try iter.next()) |entry| {\n-        if (std.mem.startsWith(u8, entry.name, \"issues.jsonl.bak\") or\n-            (std.mem.startsWith(u8, entry.name, \"issues.\") and\n-            std.mem.endsWith(u8, entry.name, \".jsonl\") and\n-            !std.mem.eql(u8, entry.name, \"issues.jsonl\")))\n-        {\n-            const stat = dir.statFile(entry.name) catch continue;\n-            try backups.append(allocator, .{\n-                .filename = try allocator.dupe(u8, entry.name),\n-                .size = stat.size,\n-                .modified = @intCast(@divFloor(stat.mtime, std.time.ns_per_s)),\n-            });\n-        }\n-    }\n-\n     if (backups.items.len <= keep) {\n         if (structured_output) {\n             try ctx.output.printJson(BackupResult{\n@@ -383,13 +372,6 @@ fn runPrune(ctx: *CommandContext, keep: u32, dry_run: bool, structured_output: b\n         return;\n     }\n \n-    // Sort by modified time (newest first)\n-    std.mem.sortUnstable(BackupInfo, backups.items, {}, struct {\n-        fn lessThan(_: void, a: BackupInfo, b: BackupInfo) bool {\n-            return a.modified > b.modified;\n-        }\n-    }.lessThan);\n-\n     const to_prune = backups.items.len - keep;\n \n     if (dry_run) {\ndiff --git a/src/cli/changelog.zig b/src/cli/changelog.zig\nindex 35b2266..d7b5c90 100644\n--- a/src/cli/changelog.zig\n+++ b/src/cli/changelog.zig\n@@ -20,6 +20,9 @@ pub const ChangelogError = error{\n     InvalidDateFormat,\n     StorageError,\n     OutOfMemory,\n+    GitTagNotFound,\n+    GitCommitNotFound,\n+    GitError,\n };\n \n pub const ChangelogResult = struct {\n@@ -70,7 +73,26 @@ pub fn run(\n     var filtered_issues: std.ArrayListUnmanaged(Issue) = .{};\n     defer filtered_issues.deinit(allocator);\n \n-    const since_ts = if (changelog_args.since) |s| parseDateToTimestamp(s) else null;\n+    // Determine the since timestamp from various sources (priority: since_tag > since_commit > since)\n+    var since_ts: ?i64 = null;\n+    if (changelog_args.since_tag) |tag| {\n+        since_ts = getTimestampFromGitTag(allocator, tag) catch |err| {\n+            if (!global.isStructuredOutput()) {\n+                try ctx.output.err(\"Failed to get timestamp for tag '{s}': {s}\", .{ tag, @errorName(err) });\n+            }\n+            return err;\n+        };\n+    } else if (changelog_args.since_commit) |commit| {\n+        since_ts = getTimestampFromGitCommit(allocator, commit) catch |err| {\n+            if (!global.isStructuredOutput()) {\n+                try ctx.output.err(\"Failed to get timestamp for commit '{s}': {s}\", .{ commit, @errorName(err) });\n+            }\n+            return err;\n+        };\n+    } else if (changelog_args.since) |s| {\n+        since_ts = parseDateToTimestamp(s);\n+    }\n+\n     const until_ts = if (changelog_args.until) |u| parseDateToTimestamp(u) else null;\n \n     for (issues) |issue| {\n@@ -259,6 +281,48 @@ fn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n     return era * 146097 + doe - 719468;\n }\n \n+fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n+    // Get the commit timestamp for the given tag\n+    // Format: git log -1 --format=%ct <tag>\n+    const result = std.process.Child.run(.{\n+        .allocator = allocator,\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n+        .cwd = null,\n+    }) catch return ChangelogError.GitError;\n+\n+    defer allocator.free(result.stderr);\n+    defer allocator.free(result.stdout);\n+\n+    if (result.term.Exited != 0) {\n+        return ChangelogError.GitTagNotFound;\n+    }\n+\n+    // Parse the timestamp (trim newline)\n+    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n+    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n+}\n+\n+fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n+    // Get the commit timestamp for the given commit hash\n+    // Format: git log -1 --format=%ct <commit>\n+    const result = std.process.Child.run(.{\n+        .allocator = allocator,\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n+        .cwd = null,\n+    }) catch return ChangelogError.GitError;\n+\n+    defer allocator.free(result.stderr);\n+    defer allocator.free(result.stdout);\n+\n+    if (result.term.Exited != 0) {\n+        return ChangelogError.GitCommitNotFound;\n+    }\n+\n+    // Parse the timestamp (trim newline)\n+    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n+    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n+}\n+\n // --- Tests ---\n \n test \"ChangelogError enum exists\" {\n@@ -322,3 +386,49 @@ test \"parseDateToTimestamp returns null for invalid date\" {\n     try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"2024\"));\n     try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"\"));\n }\n+\n+test \"ChangelogArgs supports since_tag field\" {\n+    const changelog_args = args.ChangelogArgs{\n+        .since_tag = \"v1.0.0\",\n+    };\n+    try std.testing.expectEqualStrings(\"v1.0.0\", changelog_args.since_tag.?);\n+}\n+\n+test \"ChangelogArgs supports since_commit field\" {\n+    const changelog_args = args.ChangelogArgs{\n+        .since_commit = \"abc123\",\n+    };\n+    try std.testing.expectEqualStrings(\"abc123\", changelog_args.since_commit.?);\n+}\n+\n+test \"parse changelog with since-tag flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"changelog\", \"--since-tag\", \"v1.0.0\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .changelog => |c| {\n+            try std.testing.expect(c.since_tag != null);\n+            try std.testing.expectEqualStrings(\"v1.0.0\", c.since_tag.?);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse changelog with since-commit flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"changelog\", \"--since-commit\", \"abc123def\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .changelog => |c| {\n+            try std.testing.expect(c.since_commit != null);\n+            try std.testing.expectEqualStrings(\"abc123def\", c.since_commit.?);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/cli/graph.zig b/src/cli/graph.zig\nindex 6e44bc5..2e64f23 100644\n--- a/src/cli/graph.zig\n+++ b/src/cli/graph.zig\n@@ -52,6 +52,9 @@ pub fn run(\n             return GraphError.IssueNotFound;\n         }\n         try renderIssueGraph(&dep_graph, &ctx.output, id, graph_args, global, allocator);\n+    } else if (graph_args.all) {\n+        // Show dependency graph for all open issues\n+        try renderAllOpenGraph(&ctx.store, &ctx.output, graph_args, global, allocator);\n     } else {\n         try renderFullGraph(&ctx.store, &ctx.output, graph_args, global, allocator);\n     }\n@@ -65,6 +68,10 @@ fn renderIssueGraph(\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n+    if (graph_args.compact) {\n+        try renderCompactIssueGraph(graph, output, issue_id, graph_args.depth, global, allocator);\n+        return;\n+    }\n     switch (graph_args.format) {\n         .ascii => try renderAsciiTree(graph, output, issue_id, graph_args.depth, global, allocator),\n         .dot => try renderDotGraph(graph, output, issue_id, graph_args.depth, global, allocator),\n@@ -426,6 +433,169 @@ fn statusEql(a: Status, b: Status) bool {\n     return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n }\n \n+fn renderCompactIssueGraph(\n+    graph: *DependencyGraph,\n+    output: *Output,\n+    issue_id: []const u8,\n+    max_depth: ?u32,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var buf: std.ArrayListUnmanaged(u8) = .{};\n+    defer buf.deinit(allocator);\n+    const writer = buf.writer(allocator);\n+\n+    var visited: std.StringHashMapUnmanaged(void) = .{};\n+    defer {\n+        var it = visited.keyIterator();\n+        while (it.next()) |key| {\n+            allocator.free(key.*);\n+        }\n+        visited.deinit(allocator);\n+    }\n+\n+    // Print root issue\n+    if (graph.store.getRef(issue_id)) |issue| {\n+        const status_indicator = if (statusEql(issue.status, .closed)) \"[x]\" else \"[ ]\";\n+        try writer.print(\"{s} {s} {s}\\n\", .{ issue.id, status_indicator, truncateTitle(issue.title, 60) });\n+    }\n+\n+    // Collect and print dependencies in compact format\n+    try renderCompactDeps(graph, writer, issue_id, 1, max_depth orelse 10, &visited, allocator);\n+\n+    if (global.isStructuredOutput()) {\n+        try output.printJson(GraphResult{\n+            .success = true,\n+            .format = \"compact\",\n+            .output = buf.items,\n+        });\n+    } else {\n+        try output.raw(buf.items);\n+    }\n+}\n+\n+fn renderCompactDeps(\n+    graph: *DependencyGraph,\n+    writer: anytype,\n+    issue_id: []const u8,\n+    depth: u32,\n+    max_depth: u32,\n+    visited: *std.StringHashMapUnmanaged(void),\n+    allocator: std.mem.Allocator,\n+) !void {\n+    if (depth > max_depth) return;\n+\n+    const id_key = try allocator.dupe(u8, issue_id);\n+    if (visited.contains(id_key)) {\n+        allocator.free(id_key);\n+        return;\n+    }\n+    try visited.put(allocator, id_key, {});\n+\n+    const deps = try graph.getDependencies(issue_id);\n+    defer graph.freeDependencies(deps);\n+\n+    for (deps) |dep| {\n+        if (graph.store.getRef(dep.depends_on_id)) |blocker| {\n+            const status_indicator = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n+            // Indent based on depth for hierarchy visibility\n+            var i: u32 = 0;\n+            while (i < depth) : (i += 1) {\n+                try writer.writeAll(\"  \");\n+            }\n+            try writer.print(\"-> {s} {s} {s}\\n\", .{ blocker.id, status_indicator, truncateTitle(blocker.title, 50) });\n+            try renderCompactDeps(graph, writer, dep.depends_on_id, depth + 1, max_depth, visited, allocator);\n+        }\n+    }\n+}\n+\n+fn renderAllOpenGraph(\n+    store: *storage.IssueStore,\n+    output: *Output,\n+    graph_args: args.GraphArgs,\n+    global: args.GlobalOptions,\n+    allocator: std.mem.Allocator,\n+) !void {\n+    var buf: std.ArrayListUnmanaged(u8) = .{};\n+    defer buf.deinit(allocator);\n+    const writer = buf.writer(allocator);\n+\n+    const issues = store.getAllRef();\n+    var open_with_deps: usize = 0;\n+\n+    if (!graph_args.compact) {\n+        try writer.writeAll(\"Open Issues Dependency Graph\\n\");\n+        try writer.writeAll(\"=============================\\n\\n\");\n+    }\n+\n+    for (issues) |issue| {\n+        // Only show open issues (not closed/tombstone)\n+        if (statusEql(issue.status, .closed) or statusEql(issue.status, .tombstone)) {\n+            continue;\n+        }\n+\n+        const has_deps = issue.dependencies.len > 0;\n+        const has_dependents = hasAnyDependents(store, issue.id);\n+\n+        if (has_deps or has_dependents) {\n+            open_with_deps += 1;\n+\n+            if (graph_args.compact) {\n+                // Compact: one line per issue showing status and dep count\n+                const status_indicator = if (statusEql(issue.status, .blocked)) \"[B]\" else \"[ ]\";\n+                const dep_count = issue.dependencies.len;\n+                if (dep_count > 0) {\n+                    try writer.print(\"{s} {s} {s} (deps: {d})\\n\", .{\n+                        issue.id,\n+                        status_indicator,\n+                        truncateTitle(issue.title, 50),\n+                        dep_count,\n+                    });\n+                } else {\n+                    try writer.print(\"{s} {s} {s}\\n\", .{\n+                        issue.id,\n+                        status_indicator,\n+                        truncateTitle(issue.title, 50),\n+                    });\n+                }\n+            } else {\n+                // Full ASCII format for each open issue with dependencies\n+                const status_str = issue.status.toString();\n+                try writer.print(\"{s} [{s}] - {s}\\n\", .{ issue.id, status_str, truncateTitle(issue.title, 50) });\n+\n+                for (issue.dependencies, 0..) |dep, i| {\n+                    const is_last = (i == issue.dependencies.len - 1);\n+                    const connector = if (is_last) \"`-- \" else \"|-- \";\n+\n+                    if (store.getRef(dep.depends_on_id)) |blocker| {\n+                        const blocker_status = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n+                        try writer.print(\"  {s}{s} {s} - {s}\\n\", .{ connector, blocker.id, blocker_status, truncateTitle(blocker.title, 40) });\n+                    } else {\n+                        try writer.print(\"  {s}{s} [?] - (not found)\\n\", .{ connector, dep.depends_on_id });\n+                    }\n+                }\n+                try writer.writeAll(\"\\n\");\n+            }\n+        }\n+    }\n+\n+    if (open_with_deps == 0) {\n+        try writer.writeAll(\"No open issues with dependencies found.\\n\");\n+    }\n+\n+    if (global.isStructuredOutput()) {\n+        const format_str = if (graph_args.compact) \"compact\" else \"ascii\";\n+        try output.printJson(GraphResult{\n+            .success = true,\n+            .format = format_str,\n+            .node_count = open_with_deps,\n+            .output = buf.items,\n+        });\n+    } else {\n+        try output.raw(buf.items);\n+    }\n+}\n+\n // --- Tests ---\n \n test \"GraphError enum exists\" {\n@@ -471,3 +641,83 @@ test \"GraphFormat.fromString parses correctly\" {\n     try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ASCII\").?);\n     try std.testing.expect(args.GraphFormat.fromString(\"invalid\") == null);\n }\n+\n+test \"GraphArgs supports all flag\" {\n+    const graph_args = args.GraphArgs{\n+        .all = true,\n+    };\n+    try std.testing.expect(graph_args.all);\n+    try std.testing.expect(!graph_args.compact);\n+}\n+\n+test \"GraphArgs supports compact flag\" {\n+    const graph_args = args.GraphArgs{\n+        .compact = true,\n+    };\n+    try std.testing.expect(graph_args.compact);\n+    try std.testing.expect(!graph_args.all);\n+}\n+\n+test \"parse graph with all flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"--all\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.all);\n+            try std.testing.expect(!g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse graph with compact flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"--compact\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse graph with id and compact flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"bd-123\", \"--compact\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.id != null);\n+            try std.testing.expectEqualStrings(\"bd-123\", g.id.?);\n+            try std.testing.expect(g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse graph with short flags\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"graph\", \"-a\", \"-c\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .graph => |g| {\n+            try std.testing.expect(g.all);\n+            try std.testing.expect(g.compact);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/cli/help.zig b/src/cli/help.zig\nindex 08d2349..d5ff84f 100644\n--- a/src/cli/help.zig\n+++ b/src/cli/help.zig\n@@ -518,19 +518,23 @@ const commands = [_]CommandHelp{\n     .{\n         .name = \"graph\",\n         .summary = \"Show dependency graph\",\n-        .usage = \"bz graph [ID] [--format FMT] [--depth N]\",\n+        .usage = \"bz graph [ID] [--format FMT] [--depth N] [--all] [--compact]\",\n         .description = \"Visualizes the dependency graph. Without an ID, shows all dependencies. \" ++\n-            \"With an ID, shows that issue's dependency subgraph.\",\n+            \"With an ID, shows that issue's dependency subgraph. Use --all for open issues only, --compact for one-line output.\",\n         .arguments = &[_]ArgHelp{\n             .{ .name = \"id\", .description = \"Issue ID (optional, shows all if omitted)\", .required = false },\n         },\n         .flags = &[_]FlagHelp{\n             .{ .short = \"-f\", .long = \"--format\", .arg = \"FMT\", .description = \"Output format: ascii (default) or dot\" },\n             .{ .short = \"-d\", .long = \"--depth\", .arg = \"N\", .description = \"Maximum tree depth\" },\n+            .{ .short = \"-a\", .long = \"--all\", .description = \"Show graph for all open issues\" },\n+            .{ .short = \"-c\", .long = \"--compact\", .description = \"Compact one-line-per-issue output\" },\n         },\n         .examples = &[_]ExampleHelp{\n             .{ .command = \"bz graph\", .description = \"Show full dependency graph (ASCII)\" },\n             .{ .command = \"bz graph bd-abc\", .description = \"Show graph for specific issue\" },\n+            .{ .command = \"bz graph --all\", .description = \"Show graph for all open issues\" },\n+            .{ .command = \"bz graph bd-abc --compact\", .description = \"Compact output for specific issue\" },\n             .{ .command = \"bz graph --format dot | dot -Tpng -o graph.png\", .description = \"Generate PNG via Graphviz\" },\n         },\n         .see_also = &[_][]const u8{\"dep\"},\n@@ -627,18 +631,22 @@ const commands = [_]CommandHelp{\n     .{\n         .name = \"changelog\",\n         .summary = \"Generate changelog from closed issues\",\n-        .usage = \"bz changelog [--since DATE] [--until DATE] [--limit N] [--group-by FIELD]\",\n+        .usage = \"bz changelog [--since DATE] [--until DATE] [--since-tag TAG] [--since-commit HASH] [--limit N] [--group-by FIELD]\",\n         .description = \"Generates a changelog from recently closed issues, optionally filtered \" ++\n-            \"by date range and grouped by type.\",\n+            \"by date range and grouped by type. Can use git tags or commits for date references.\",\n         .flags = &[_]FlagHelp{\n             .{ .short = null, .long = \"--since\", .arg = \"DATE\", .description = \"Start date (YYYY-MM-DD)\" },\n             .{ .short = null, .long = \"--until\", .arg = \"DATE\", .description = \"End date (YYYY-MM-DD)\" },\n+            .{ .short = null, .long = \"--since-tag\", .arg = \"TAG\", .description = \"Start from git tag (e.g., v1.0.0)\" },\n+            .{ .short = null, .long = \"--since-commit\", .arg = \"HASH\", .description = \"Start from git commit (e.g., abc123)\" },\n             .{ .short = \"-n\", .long = \"--limit\", .arg = \"N\", .description = \"Maximum entries\" },\n             .{ .short = \"-g\", .long = \"--group-by\", .arg = \"FIELD\", .description = \"Group by field (e.g., type)\" },\n         },\n         .examples = &[_]ExampleHelp{\n             .{ .command = \"bz changelog\", .description = \"Generate changelog\" },\n             .{ .command = \"bz changelog --since 2024-01-01\", .description = \"Since specific date\" },\n+            .{ .command = \"bz changelog --since-tag v1.0.0\", .description = \"Since git tag v1.0.0\" },\n+            .{ .command = \"bz changelog --since-commit abc123\", .description = \"Since git commit\" },\n             .{ .command = \"bz changelog --group-by type\", .description = \"Group by issue type\" },\n         },\n         .see_also = &[_][]const u8{\"audit\"},\ndiff --git a/src/cli/mod.zig b/src/cli/mod.zig\nindex 91977da..596bf1e 100644\n--- a/src/cli/mod.zig\n+++ b/src/cli/mod.zig\n@@ -150,6 +150,8 @@ pub const runHistory = history.run;\n pub const AuditError = audit.AuditError;\n pub const AuditResult = audit.AuditResult;\n pub const runAudit = audit.run;\n+pub const AuditArgs = args.AuditArgs;\n+pub const AuditSubcommand = args.AuditSubcommand;\n \n pub const ChangelogError = changelog.ChangelogError;\n pub const ChangelogResult = changelog.ChangelogResult;\n@@ -163,6 +165,7 @@ pub const runInfo = info.run;\n pub const StatsError = stats.StatsError;\n pub const StatsResult = stats.StatsResult;\n pub const runStats = stats.run;\n+pub const StatsArgs = args.StatsArgs;\n \n pub const DoctorError = doctor.DoctorError;\n pub const DoctorResult = doctor.DoctorResult;\ndiff --git a/src/cli/stats.zig b/src/cli/stats.zig\nindex 3b0819e..ff3ee64 100644\n--- a/src/cli/stats.zig\n+++ b/src/cli/stats.zig\n@@ -1,6 +1,8 @@\n //! Stats command for beads_zig.\n //!\n //! `bz stats` - Show project statistics\n+//! `bz stats --activity` - Show git-based activity statistics\n+//! `bz stats --activity-hours 48` - Show activity for last 48 hours\n \n const std = @import(\"std\");\n const common = @import(\"common.zig\");\n@@ -12,6 +14,7 @@ pub const StatsError = error{\n     WorkspaceNotInitialized,\n     StorageError,\n     OutOfMemory,\n+    GitError,\n };\n \n pub const StatsResult = struct {\n@@ -22,15 +25,32 @@ pub const StatsResult = struct {\n     by_status: ?[]const CountEntry = null,\n     by_priority: ?[]const CountEntry = null,\n     by_type: ?[]const CountEntry = null,\n+    activity: ?ActivityStats = null,\n     message: ?[]const u8 = null,\n \n     pub const CountEntry = struct {\n         key: []const u8,\n         count: usize,\n     };\n+\n+    pub const ActivityStats = struct {\n+        period_hours: u32,\n+        git_commits: usize,\n+        issues_created: usize,\n+        issues_closed: usize,\n+        issues_updated: usize,\n+        commits_with_issue_refs: usize,\n+        issue_refs: ?[]const IssueRef = null,\n+\n+        pub const IssueRef = struct {\n+            issue_id: []const u8,\n+            commit_count: usize,\n+        };\n+    };\n };\n \n pub fn run(\n+    stats_args: args.StatsArgs,\n     global: args.GlobalOptions,\n     allocator: std.mem.Allocator,\n ) !void {\n@@ -109,6 +129,15 @@ pub fn run(\n         try type_list.append(allocator, .{ .key = entry.key_ptr.*, .count = entry.value_ptr.* });\n     }\n \n+    // Activity stats (if requested)\n+    var activity_stats: ?StatsResult.ActivityStats = null;\n+    var issue_refs_list: std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef) = .{};\n+    defer issue_refs_list.deinit(allocator);\n+\n+    if (stats_args.activity) {\n+        activity_stats = try getActivityStats(allocator, &ctx, stats_args.activity_hours, &issue_refs_list);\n+    }\n+\n     if (global.isStructuredOutput()) {\n         try ctx.output.printJson(StatsResult{\n             .success = true,\n@@ -118,6 +147,7 @@ pub fn run(\n             .by_status = status_list.items,\n             .by_priority = priority_list.items,\n             .by_type = type_list.items,\n+            .activity = activity_stats,\n         });\n     } else if (!global.quiet) {\n         try ctx.output.println(\"Issue Statistics\", .{});\n@@ -145,9 +175,174 @@ pub fn run(\n                 try ctx.output.print(\"  {s: <12} {d}\\n\", .{ entry.key, entry.count });\n             }\n         }\n+\n+        if (activity_stats) |activity| {\n+            try ctx.output.print(\"\\nActivity (last {d} hours):\\n\", .{activity.period_hours});\n+            try ctx.output.print(\"  Git commits:           {d}\\n\", .{activity.git_commits});\n+            try ctx.output.print(\"  Issues created:        {d}\\n\", .{activity.issues_created});\n+            try ctx.output.print(\"  Issues closed:         {d}\\n\", .{activity.issues_closed});\n+            try ctx.output.print(\"  Issues updated:        {d}\\n\", .{activity.issues_updated});\n+            try ctx.output.print(\"  Commits with refs:     {d}\\n\", .{activity.commits_with_issue_refs});\n+\n+            if (activity.issue_refs) |refs| {\n+                if (refs.len > 0) {\n+                    try ctx.output.print(\"\\n  Referenced Issues:\\n\", .{});\n+                    for (refs[0..@min(10, refs.len)]) |ref| {\n+                        try ctx.output.print(\"    {s: <12} {d} commits\\n\", .{ ref.issue_id, ref.commit_count });\n+                    }\n+                    if (refs.len > 10) {\n+                        try ctx.output.print(\"    ... and {d} more\\n\", .{refs.len - 10});\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n+fn getActivityStats(\n+    allocator: std.mem.Allocator,\n+    ctx: *CommandContext,\n+    hours: u32,\n+    issue_refs_list: *std.ArrayListUnmanaged(StatsResult.ActivityStats.IssueRef),\n+) !StatsResult.ActivityStats {\n+    const now = std.time.timestamp();\n+    const since = now - @as(i64, @intCast(hours)) * 60 * 60;\n+\n+    // Count issue activity in the time period\n+    var issues_created: usize = 0;\n+    var issues_closed: usize = 0;\n+    var issues_updated: usize = 0;\n+\n+    for (ctx.store.issues.items) |issue| {\n+        if (issue.status.eql(.tombstone)) continue;\n+\n+        if (issue.created_at.value >= since) {\n+            issues_created += 1;\n+        }\n+        if (issue.closed_at.value) |closed_ts| {\n+            if (closed_ts >= since) {\n+                issues_closed += 1;\n+            }\n+        }\n+        if (issue.updated_at.value >= since and issue.created_at.value < since) {\n+            issues_updated += 1;\n+        }\n+    }\n+\n+    // Get git commit stats\n+    var git_commits: usize = 0;\n+    var commits_with_refs: usize = 0;\n+    var issue_ref_counts: std.StringHashMapUnmanaged(usize) = .{};\n+    defer issue_ref_counts.deinit(allocator);\n+\n+    // Run git log to get recent commits\n+    const git_result = runGitLog(allocator, hours) catch {\n+        // Git not available or not a git repo - return partial stats\n+        return StatsResult.ActivityStats{\n+            .period_hours = hours,\n+            .git_commits = 0,\n+            .issues_created = issues_created,\n+            .issues_closed = issues_closed,\n+            .issues_updated = issues_updated,\n+            .commits_with_issue_refs = 0,\n+            .issue_refs = null,\n+        };\n+    };\n+    defer allocator.free(git_result);\n+\n+    // Parse git log output\n+    var lines = std.mem.splitScalar(u8, git_result, '\\n');\n+    while (lines.next()) |line| {\n+        if (line.len == 0) continue;\n+        git_commits += 1;\n+\n+        // Look for issue references (bd-xxx pattern)\n+        var found_ref = false;\n+        var i: usize = 0;\n+        while (i < line.len) {\n+            // Look for \"bd-\" or similar prefix\n+            if (i + 3 < line.len and\n+                (std.mem.eql(u8, line[i .. i + 3], \"bd-\") or std.mem.eql(u8, line[i .. i + 3], \"BD-\")))\n+            {\n+                // Extract the issue ID\n+                const start = i;\n+                i += 3;\n+                while (i < line.len and (std.ascii.isAlphanumeric(line[i]) or line[i] == '-' or line[i] == '.')) {\n+                    i += 1;\n+                }\n+                const issue_id = line[start..i];\n+                if (issue_id.len > 3) {\n+                    // Normalize to lowercase\n+                    var normalized: [32]u8 = undefined;\n+                    const len = @min(issue_id.len, 32);\n+                    for (0..len) |j| {\n+                        normalized[j] = std.ascii.toLower(issue_id[j]);\n+                    }\n+                    const key = normalized[0..len];\n+\n+                    // Check if this issue exists in our store\n+                    if (ctx.store.exists(key) catch false) {\n+                        const entry = try issue_ref_counts.getOrPutValue(allocator, key, 0);\n+                        entry.value_ptr.* += 1;\n+                        found_ref = true;\n+                    }\n+                }\n+            } else {\n+                i += 1;\n+            }\n+        }\n+        if (found_ref) {\n+            commits_with_refs += 1;\n+        }\n+    }\n+\n+    // Convert issue refs to array\n+    var it = issue_ref_counts.iterator();\n+    while (it.next()) |entry| {\n+        try issue_refs_list.append(allocator, .{\n+            .issue_id = entry.key_ptr.*,\n+            .commit_count = entry.value_ptr.*,\n+        });\n+    }\n+\n+    // Sort by commit count descending\n+    std.mem.sortUnstable(StatsResult.ActivityStats.IssueRef, issue_refs_list.items, {}, struct {\n+        fn lessThan(_: void, a: StatsResult.ActivityStats.IssueRef, b: StatsResult.ActivityStats.IssueRef) bool {\n+            return a.commit_count > b.commit_count;\n+        }\n+    }.lessThan);\n+\n+    return StatsResult.ActivityStats{\n+        .period_hours = hours,\n+        .git_commits = git_commits,\n+        .issues_created = issues_created,\n+        .issues_closed = issues_closed,\n+        .issues_updated = issues_updated,\n+        .commits_with_issue_refs = commits_with_refs,\n+        .issue_refs = if (issue_refs_list.items.len > 0) issue_refs_list.items else null,\n+    };\n+}\n+\n+fn runGitLog(allocator: std.mem.Allocator, hours: u32) ![]const u8 {\n+    var buf: [32]u8 = undefined;\n+    const since_arg = std.fmt.bufPrint(&buf, \"--since={d}.hours.ago\", .{hours}) catch unreachable;\n+\n+    const result = std.process.Child.run(.{\n+        .allocator = allocator,\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"--oneline\", since_arg },\n+        .cwd = null,\n+    }) catch return StatsError.GitError;\n+\n+    defer allocator.free(result.stderr);\n+\n+    if (result.term.Exited != 0) {\n+        allocator.free(result.stdout);\n+        return StatsError.GitError;\n+    }\n+\n+    return result.stdout;\n+}\n+\n // --- Tests ---\n \n test \"StatsError enum exists\" {\n@@ -169,8 +364,47 @@ test \"StatsResult struct works\" {\n test \"run detects uninitialized workspace\" {\n     const allocator = std.testing.allocator;\n \n+    const stats_args = args.StatsArgs{};\n     const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n \n-    const result = run(global, allocator);\n+    const result = run(stats_args, global, allocator);\n     try std.testing.expectError(StatsError.WorkspaceNotInitialized, result);\n }\n+\n+test \"StatsArgs default values\" {\n+    const stats_args = args.StatsArgs{};\n+    try std.testing.expect(!stats_args.activity);\n+    try std.testing.expectEqual(@as(u32, 24), stats_args.activity_hours);\n+}\n+\n+test \"parse stats with activity flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .stats => |s| {\n+            try std.testing.expect(s.activity);\n+            try std.testing.expectEqual(@as(u32, 24), s.activity_hours);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\n+\n+test \"parse stats with activity-hours flag\" {\n+    const allocator = std.testing.allocator;\n+    const cmd_args = [_][]const u8{ \"stats\", \"--activity\", \"--activity-hours\", \"48\" };\n+    var parser = args.ArgParser.init(allocator, &cmd_args);\n+    var result = parser.parse() catch unreachable;\n+    defer result.deinit(allocator);\n+\n+    switch (result.command) {\n+        .stats => |s| {\n+            try std.testing.expect(s.activity);\n+            try std.testing.expectEqual(@as(u32, 48), s.activity_hours);\n+        },\n+        else => try std.testing.expect(false),\n+    }\n+}\ndiff --git a/src/main.zig b/src/main.zig\nindex adec608..1d0bbb8 100644\n--- a/src/main.zig\n+++ b/src/main.zig\n@@ -208,9 +208,9 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n                 else => return err,\n             };\n         },\n-        .stats => {\n-            cli.runStats(result.global, allocator) catch |err| switch (err) {\n-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n+        .stats => |stats_args| {\n+            cli.runStats(stats_args, result.global, allocator) catch |err| switch (err) {\n+                error.WorkspaceNotInitialized, error.StorageError, error.GitError => std.process.exit(1),\n                 else => return err,\n             };\n         },\n@@ -258,7 +258,7 @@ fn dispatch(result: cli.ParseResult, allocator: std.mem.Allocator) !void {\n         },\n         .audit => |audit_args| {\n             cli.runAudit(audit_args, result.global, allocator) catch |err| switch (err) {\n-                error.WorkspaceNotInitialized, error.StorageError => std.process.exit(1),\n+                error.WorkspaceNotInitialized, error.StorageError, error.InvalidKind, error.EntryNotFound => std.process.exit(1),\n                 else => return err,\n             };\n         },\ndiff --git a/src/models/event.zig b/src/models/event.zig\nindex 29dd632..ec69cfc 100644\n--- a/src/models/event.zig\n+++ b/src/models/event.zig\n@@ -24,6 +24,9 @@ pub const EventType = enum {\n     compacted,\n     deleted,\n     restored,\n+    // LLM/tool interaction tracking\n+    llm_call,\n+    tool_call,\n \n     const Self = @This();","numLines":1830,"startLine":1,"totalLines":1830}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01U1wV17M3of5qMusVBomSRX","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a clear picture of the changes. Let me check the current state of the modified files to look for simplification opportunities."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":30325,"cache_read_input_tokens":23151,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":30325},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"fdde0c45-d0fc-46b0-8295-3d63a68d4fa7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01U1wV17M3of5qMusVBomSRX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AxqbjARWcHESeaN5Vbmozv","name":"TodoWrite","input":{"todos":[{"content":"Review recently modified code for simplification opportunities","status":"in_progress","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"pending","activeForm":"Running tests"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":30325,"cache_read_input_tokens":23151,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":30325},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"10ad8f7b-9c5c-4393-96df-29fdc83cf098"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AxqbjARWcHESeaN5Vbmozv","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"5dfa5dfa-260d-438b-a0c2-001f4b5886be","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Review recently modified code for simplification opportunities","status":"in_progress","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"pending","activeForm":"Running tests"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VGW6onHSU289vHcQrkfVgR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016nxtHSwoXts8FXmccdYovP","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/audit.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":180,"cache_read_input_tokens":53476,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":180},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"179215ef-1557-4667-a068-6deb46dbb6dc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016nxtHSwoXts8FXmccdYovP","type":"tool_result","content":"     1//! Audit command for beads_zig.\n     2//!\n     3//! `bz audit` - Show project-wide audit log (default)\n     4//! `bz audit record <kind>` - Record LLM/tool interaction\n     5//! `bz audit label <entry-id> <label>` - Label audit entry\n     6//! `bz audit log <issue-id>` - View audit log for specific issue\n     7//! `bz audit summary` - Summary of audit data over time period\n     8\n     9const std = @import(\"std\");\n    10const common = @import(\"common.zig\");\n    11const args = @import(\"args.zig\");\n    12const Event = @import(\"../models/event.zig\").Event;\n    13const EventType = @import(\"../models/event.zig\").EventType;\n    14\n    15const CommandContext = common.CommandContext;\n    16\n    17pub const AuditError = error{\n    18    WorkspaceNotInitialized,\n    19    StorageError,\n    20    OutOfMemory,\n    21    InvalidKind,\n    22    EntryNotFound,\n    23};\n    24\n    25pub const AuditResult = struct {\n    26    success: bool,\n    27    events: ?[]const AuditEvent = null,\n    28    total: ?usize = null,\n    29    event_id: ?i64 = null,\n    30    summary: ?AuditSummary = null,\n    31    message: ?[]const u8 = null,\n    32\n    33    pub const AuditEvent = struct {\n    34        id: i64,\n    35        issue_id: []const u8,\n    36        event_type: []const u8,\n    37        actor: []const u8,\n    38        created_at: i64,\n    39        old_value: ?[]const u8 = null,\n    40        new_value: ?[]const u8 = null,\n    41    };\n    42\n    43    pub const AuditSummary = struct {\n    44        period_days: u32,\n    45        total_events: usize,\n    46        llm_calls: usize,\n    47        tool_calls: usize,\n    48        issue_creates: usize,\n    49        issue_closes: usize,\n    50        other_events: usize,\n    51        by_actor: ?[]const ActorCount = null,\n    52\n    53        pub const ActorCount = struct {\n    54            actor: []const u8,\n    55            count: usize,\n    56        };\n    57    };\n    58};\n    59\n    60pub fn run(\n    61    audit_args: args.AuditArgs,\n    62    global: args.GlobalOptions,\n    63    allocator: std.mem.Allocator,\n    64) !void {\n    65    switch (audit_args.subcommand) {\n    66        .record => |record_args| try runRecord(record_args, global, allocator),\n    67        .label => |label_args| try runLabel(label_args, global, allocator),\n    68        .log => |log_args| try runLog(log_args, global, allocator),\n    69        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n    70        .list => |list_args| try runList(list_args, global, allocator),\n    71    }\n    72}\n    73\n    74fn runRecord(\n    75    record_args: anytype,\n    76    global: args.GlobalOptions,\n    77    allocator: std.mem.Allocator,\n    78) !void {\n    79    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    80        return AuditError.WorkspaceNotInitialized;\n    81    };\n    82    defer ctx.deinit();\n    83\n    84    // Validate kind\n    85    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n    86        .llm_call\n    87    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n    88        .tool_call\n    89    else {\n    90        if (!global.silent) {\n    91            if (global.isStructuredOutput()) {\n    92                try ctx.output.printJson(AuditResult{\n    93                    .success = false,\n    94                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n    95                });\n    96            } else {\n    97                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n    98            }\n    99        }\n   100        return AuditError.InvalidKind;\n   101    };\n   102\n   103    const actor = global.actor orelse \"unknown\";\n   104    const now = std.time.timestamp();\n   105\n   106    // Build metadata JSON with all provided fields\n   107    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n   108    defer metadata_parts.deinit(allocator);\n   109\n   110    try metadata_parts.appendSlice(allocator, \"{\");\n   111    var first = true;\n   112\n   113    if (record_args.model) |model| {\n   114        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   115        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n   116        try metadata_parts.appendSlice(allocator, model);\n   117        try metadata_parts.appendSlice(allocator, \"\\\"\");\n   118        first = false;\n   119    }\n   120    if (record_args.prompt) |prompt| {\n   121        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   122        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n   123        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n   124        defer allocator.free(escaped);\n   125        try metadata_parts.appendSlice(allocator, escaped);\n   126        first = false;\n   127    }\n   128    if (record_args.response) |response| {\n   129        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   130        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n   131        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n   132        defer allocator.free(escaped);\n   133        try metadata_parts.appendSlice(allocator, escaped);\n   134        first = false;\n   135    }\n   136    if (record_args.tool_name) |tool_name| {\n   137        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   138        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n   139        try metadata_parts.appendSlice(allocator, tool_name);\n   140        try metadata_parts.appendSlice(allocator, \"\\\"\");\n   141        first = false;\n   142    }\n   143    if (record_args.exit_code) |exit_code| {\n   144        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   145        var buf: [32]u8 = undefined;\n   146        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n   147        try metadata_parts.appendSlice(allocator, s);\n   148        first = false;\n   149    }\n   150    if (record_args.metadata) |metadata| {\n   151        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n   152        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n   153        try metadata_parts.appendSlice(allocator, metadata);\n   154        first = false;\n   155    }\n   156    try metadata_parts.appendSlice(allocator, \"}\");\n   157\n   158    const new_value = try allocator.dupe(u8, metadata_parts.items);\n   159    defer allocator.free(new_value);\n   160\n   161    const event = Event{\n   162        .id = 0,\n   163        .issue_id = record_args.issue_id orelse \"\",\n   164        .event_type = event_type,\n   165        .actor = actor,\n   166        .old_value = null,\n   167        .new_value = new_value,\n   168        .created_at = now,\n   169    };\n   170\n   171    const event_id = try ctx.event_store.append(event);\n   172\n   173    if (global.isStructuredOutput()) {\n   174        try ctx.output.printJson(AuditResult{\n   175            .success = true,\n   176            .event_id = event_id,\n   177            .message = \"Audit entry recorded\",\n   178        });\n   179    } else if (!global.quiet) {\n   180        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n   181    }\n   182}\n   183\n   184fn runLabel(\n   185    label_args: anytype,\n   186    global: args.GlobalOptions,\n   187    allocator: std.mem.Allocator,\n   188) !void {\n   189    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   190        return AuditError.WorkspaceNotInitialized;\n   191    };\n   192    defer ctx.deinit();\n   193\n   194    // Record a label event referencing the original entry\n   195    const actor = global.actor orelse \"unknown\";\n   196    const now = std.time.timestamp();\n   197\n   198    // Build the label metadata\n   199    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n   200    defer metadata_parts.deinit(allocator);\n   201\n   202    var buf: [64]u8 = undefined;\n   203    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n   204    try metadata_parts.appendSlice(allocator, header);\n   205\n   206    if (label_args.reason) |reason| {\n   207        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n   208        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n   209        defer allocator.free(escaped);\n   210        try metadata_parts.appendSlice(allocator, escaped);\n   211    }\n   212    try metadata_parts.appendSlice(allocator, \"}\");\n   213\n   214    const new_value = try allocator.dupe(u8, metadata_parts.items);\n   215    defer allocator.free(new_value);\n   216\n   217    // Use 'updated' event type to represent a label action on an existing entry\n   218    const event = Event{\n   219        .id = 0,\n   220        .issue_id = \"\", // Labels are not issue-specific\n   221        .event_type = .updated,\n   222        .actor = actor,\n   223        .old_value = null,\n   224        .new_value = new_value,\n   225        .created_at = now,\n   226    };\n   227\n   228    const event_id = try ctx.event_store.append(event);\n   229\n   230    if (global.isStructuredOutput()) {\n   231        try ctx.output.printJson(AuditResult{\n   232            .success = true,\n   233            .event_id = event_id,\n   234            .message = \"Label applied to audit entry\",\n   235        });\n   236    } else if (!global.quiet) {\n   237        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n   238    }\n   239}\n   240\n   241fn runLog(\n   242    log_args: anytype,\n   243    global: args.GlobalOptions,\n   244    allocator: std.mem.Allocator,\n   245) !void {\n   246    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   247        return AuditError.WorkspaceNotInitialized;\n   248    };\n   249    defer ctx.deinit();\n   250\n   251    const limit = log_args.limit orelse 100;\n   252\n   253    // Query events for the specific issue from the event store\n   254    const events = try ctx.event_store.queryEvents(.{\n   255        .issue_id = log_args.issue_id,\n   256        .limit = limit,\n   257    });\n   258    defer ctx.event_store.freeEvents(events);\n   259\n   260    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n   261    defer audit_events.deinit(allocator);\n   262\n   263    for (events) |event| {\n   264        try audit_events.append(allocator, .{\n   265            .id = event.id,\n   266            .issue_id = event.issue_id,\n   267            .event_type = event.event_type.toString(),\n   268            .actor = event.actor,\n   269            .created_at = event.created_at,\n   270            .old_value = event.old_value,\n   271            .new_value = event.new_value,\n   272        });\n   273    }\n   274\n   275    // Sort by timestamp descending\n   276    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n   277        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n   278            return a.created_at > b.created_at;\n   279        }\n   280    }.lessThan);\n   281\n   282    if (global.isStructuredOutput()) {\n   283        try ctx.output.printJson(AuditResult{\n   284            .success = true,\n   285            .events = audit_events.items,\n   286            .total = audit_events.items.len,\n   287        });\n   288    } else if (global.quiet) {\n   289        for (audit_events.items) |event| {\n   290            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n   291        }\n   292    } else {\n   293        if (audit_events.items.len == 0) {\n   294            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n   295        } else {\n   296            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n   297            try ctx.output.print(\"\\n\", .{});\n   298\n   299            for (audit_events.items) |event| {\n   300                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n   301                    event.id,\n   302                    event.created_at,\n   303                    event.actor,\n   304                    event.event_type,\n   305                });\n   306                if (event.new_value) |v| {\n   307                    if (v.len > 0 and v.len < 200) {\n   308                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n   309                    }\n   310                }\n   311            }\n   312        }\n   313    }\n   314}\n   315\n   316fn runSummary(\n   317    summary_args: anytype,\n   318    global: args.GlobalOptions,\n   319    allocator: std.mem.Allocator,\n   320) !void {\n   321    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   322        return AuditError.WorkspaceNotInitialized;\n   323    };\n   324    defer ctx.deinit();\n   325\n   326    const now = std.time.timestamp();\n   327    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n   328\n   329    // Query all events in the time period\n   330    const events = try ctx.event_store.queryEvents(.{ .since = since });\n   331    defer ctx.event_store.freeEvents(events);\n   332\n   333    // Count by type\n   334    var llm_calls: usize = 0;\n   335    var tool_calls: usize = 0;\n   336    var issue_creates: usize = 0;\n   337    var issue_closes: usize = 0;\n   338    var other_events: usize = 0;\n   339\n   340    // Count by actor\n   341    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n   342    defer actor_counts.deinit(allocator);\n   343\n   344    for (events) |event| {\n   345        switch (event.event_type) {\n   346            .llm_call => llm_calls += 1,\n   347            .tool_call => tool_calls += 1,\n   348            .created => issue_creates += 1,\n   349            .closed => issue_closes += 1,\n   350            else => other_events += 1,\n   351        }\n   352\n   353        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n   354        entry.value_ptr.* += 1;\n   355    }\n   356\n   357    // Convert actor counts to array\n   358    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n   359    defer actor_list.deinit(allocator);\n   360\n   361    var it = actor_counts.iterator();\n   362    while (it.next()) |entry| {\n   363        try actor_list.append(allocator, .{\n   364            .actor = entry.key_ptr.*,\n   365            .count = entry.value_ptr.*,\n   366        });\n   367    }\n   368\n   369    // Sort by count descending\n   370    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n   371        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n   372            return a.count > b.count;\n   373        }\n   374    }.lessThan);\n   375\n   376    const summary = AuditResult.AuditSummary{\n   377        .period_days = summary_args.days,\n   378        .total_events = events.len,\n   379        .llm_calls = llm_calls,\n   380        .tool_calls = tool_calls,\n   381        .issue_creates = issue_creates,\n   382        .issue_closes = issue_closes,\n   383        .other_events = other_events,\n   384        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n   385    };\n   386\n   387    if (global.isStructuredOutput()) {\n   388        try ctx.output.printJson(AuditResult{\n   389            .success = true,\n   390            .summary = summary,\n   391        });\n   392    } else if (!global.quiet) {\n   393        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n   394        try ctx.output.print(\"\\n\", .{});\n   395        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n   396        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n   397        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n   398        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n   399        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n   400        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n   401\n   402        if (actor_list.items.len > 0) {\n   403            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n   404            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n   405                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n   406            }\n   407        }\n   408    }\n   409}\n   410\n   411fn runList(\n   412    list_args: anytype,\n   413    global: args.GlobalOptions,\n   414    allocator: std.mem.Allocator,\n   415) !void {\n   416    var ctx = (try CommandContext.init(allocator, global)) orelse {\n   417        return AuditError.WorkspaceNotInitialized;\n   418    };\n   419    defer ctx.deinit();\n   420\n   421    const limit = list_args.limit orelse 100;\n   422\n   423    // Build synthetic audit log from all issues\n   424    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n   425    defer events.deinit(allocator);\n   426\n   427    for (ctx.store.issues.items) |issue| {\n   428        // Created event\n   429        try events.append(allocator, .{\n   430            .id = 0,\n   431            .issue_id = issue.id,\n   432            .event_type = \"created\",\n   433            .actor = issue.created_by orelse \"unknown\",\n   434            .created_at = issue.created_at.value,\n   435        });\n   436\n   437        // Closed event\n   438        if (issue.closed_at.value) |closed_ts| {\n   439            try events.append(allocator, .{\n   440                .id = 0,\n   441                .issue_id = issue.id,\n   442                .event_type = \"closed\",\n   443                .actor = \"unknown\",\n   444                .created_at = closed_ts,\n   445            });\n   446        }\n   447\n   448        // If tombstoned\n   449        if (issue.status.eql(.tombstone)) {\n   450            try events.append(allocator, .{\n   451                .id = 0,\n   452                .issue_id = issue.id,\n   453                .event_type = \"deleted\",\n   454                .actor = \"unknown\",\n   455                .created_at = issue.updated_at.value,\n   456            });\n   457        }\n   458    }\n   459\n   460    // Sort by timestamp descending (most recent first)\n   461    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n   462        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n   463            return a.created_at > b.created_at;\n   464        }\n   465    }.lessThan);\n   466\n   467    // Apply limit\n   468    const display_count = @min(events.items.len, limit);\n   469    const display_events = events.items[0..display_count];\n   470\n   471    if (global.isStructuredOutput()) {\n   472        try ctx.output.printJson(AuditResult{\n   473            .success = true,\n   474            .events = display_events,\n   475            .total = events.items.len,\n   476        });\n   477    } else if (global.quiet) {\n   478        for (display_events) |event| {\n   479            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n   480        }\n   481    } else {\n   482        if (display_events.len == 0) {\n   483            try ctx.output.info(\"No events found\", .{});\n   484        } else {\n   485            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n   486            try ctx.output.print(\"\\n\", .{});\n   487\n   488            for (display_events) |event| {\n   489                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n   490                    event.created_at,\n   491                    event.issue_id,\n   492                    event.actor,\n   493                    event.event_type,\n   494                });\n   495            }\n   496\n   497            if (events.items.len > display_count) {\n   498                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n   499                    events.items.len - display_count,\n   500                });\n   501            }\n   502        }\n   503    }\n   504}\n   505\n   506// --- Tests ---\n   507\n   508test \"AuditError enum exists\" {\n   509    const err: AuditError = AuditError.WorkspaceNotInitialized;\n   510    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n   511}\n   512\n   513test \"AuditResult struct works\" {\n   514    const result = AuditResult{\n   515        .success = true,\n   516        .total = 10,\n   517    };\n   518    try std.testing.expect(result.success);\n   519    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n   520}\n   521\n   522test \"run detects uninitialized workspace\" {\n   523    const allocator = std.testing.allocator;\n   524\n   525    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n   526    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   527\n   528    const result = run(audit_args, global, allocator);\n   529    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n   530}\n   531\n   532test \"AuditSubcommand record parses correctly\" {\n   533    const allocator = std.testing.allocator;\n   534    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n   535    var parser = args.ArgParser.init(allocator, &cmd_args);\n   536    var result = parser.parse() catch unreachable;\n   537    defer result.deinit(allocator);\n   538\n   539    switch (result.command) {\n   540        .audit => |a| {\n   541            switch (a.subcommand) {\n   542                .record => |r| {\n   543                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n   544                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n   545                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n   546                },\n   547                else => try std.testing.expect(false),\n   548            }\n   549        },\n   550        else => try std.testing.expect(false),\n   551    }\n   552}\n   553\n   554test \"AuditSubcommand summary parses days\" {\n   555    const allocator = std.testing.allocator;\n   556    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n   557    var parser = args.ArgParser.init(allocator, &cmd_args);\n   558    var result = parser.parse() catch unreachable;\n   559    defer result.deinit(allocator);\n   560\n   561    switch (result.command) {\n   562        .audit => |a| {\n   563            switch (a.subcommand) {\n   564                .summary => |s| {\n   565                    try std.testing.expectEqual(@as(u32, 30), s.days);\n   566                },\n   567                else => try std.testing.expect(false),\n   568            }\n   569        },\n   570        else => try std.testing.expect(false),\n   571    }\n   572}\n   573\n   574test \"AuditSubcommand list is default\" {\n   575    const allocator = std.testing.allocator;\n   576    const cmd_args = [_][]const u8{\"audit\"};\n   577    var parser = args.ArgParser.init(allocator, &cmd_args);\n   578    var result = parser.parse() catch unreachable;\n   579    defer result.deinit(allocator);\n   580\n   581    switch (result.command) {\n   582        .audit => |a| {\n   583            switch (a.subcommand) {\n   584                .list => {},\n   585                else => try std.testing.expect(false),\n   586            }\n   587        },\n   588        else => try std.testing.expect(false),\n   589    }\n   590}\n   591\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"ba5a645b-2b80-4b4c-9543-b534828dbcd9","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/audit.zig","content":"//! Audit command for beads_zig.\n//!\n//! `bz audit` - Show project-wide audit log (default)\n//! `bz audit record <kind>` - Record LLM/tool interaction\n//! `bz audit label <entry-id> <label>` - Label audit entry\n//! `bz audit log <issue-id>` - View audit log for specific issue\n//! `bz audit summary` - Summary of audit data over time period\n\nconst std = @import(\"std\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst Event = @import(\"../models/event.zig\").Event;\nconst EventType = @import(\"../models/event.zig\").EventType;\n\nconst CommandContext = common.CommandContext;\n\npub const AuditError = error{\n    WorkspaceNotInitialized,\n    StorageError,\n    OutOfMemory,\n    InvalidKind,\n    EntryNotFound,\n};\n\npub const AuditResult = struct {\n    success: bool,\n    events: ?[]const AuditEvent = null,\n    total: ?usize = null,\n    event_id: ?i64 = null,\n    summary: ?AuditSummary = null,\n    message: ?[]const u8 = null,\n\n    pub const AuditEvent = struct {\n        id: i64,\n        issue_id: []const u8,\n        event_type: []const u8,\n        actor: []const u8,\n        created_at: i64,\n        old_value: ?[]const u8 = null,\n        new_value: ?[]const u8 = null,\n    };\n\n    pub const AuditSummary = struct {\n        period_days: u32,\n        total_events: usize,\n        llm_calls: usize,\n        tool_calls: usize,\n        issue_creates: usize,\n        issue_closes: usize,\n        other_events: usize,\n        by_actor: ?[]const ActorCount = null,\n\n        pub const ActorCount = struct {\n            actor: []const u8,\n            count: usize,\n        };\n    };\n};\n\npub fn run(\n    audit_args: args.AuditArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    switch (audit_args.subcommand) {\n        .record => |record_args| try runRecord(record_args, global, allocator),\n        .label => |label_args| try runLabel(label_args, global, allocator),\n        .log => |log_args| try runLog(log_args, global, allocator),\n        .summary => |summary_args| try runSummary(summary_args, global, allocator),\n        .list => |list_args| try runList(list_args, global, allocator),\n    }\n}\n\nfn runRecord(\n    record_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Validate kind\n    const event_type: EventType = if (std.mem.eql(u8, record_args.kind, \"llm_call\"))\n        .llm_call\n    else if (std.mem.eql(u8, record_args.kind, \"tool_call\"))\n        .tool_call\n    else {\n        if (!global.silent) {\n            if (global.isStructuredOutput()) {\n                try ctx.output.printJson(AuditResult{\n                    .success = false,\n                    .message = \"Invalid kind. Use 'llm_call' or 'tool_call'\",\n                });\n            } else {\n                try ctx.output.err(\"Invalid kind '{s}'. Use 'llm_call' or 'tool_call'\", .{record_args.kind});\n            }\n        }\n        return AuditError.InvalidKind;\n    };\n\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build metadata JSON with all provided fields\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    try metadata_parts.appendSlice(allocator, \"{\");\n    var first = true;\n\n    if (record_args.model) |model| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"model\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, model);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.prompt) |prompt| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"prompt\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, prompt, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.response) |response| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"response\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, response, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n        first = false;\n    }\n    if (record_args.tool_name) |tool_name| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"tool_name\\\":\\\"\");\n        try metadata_parts.appendSlice(allocator, tool_name);\n        try metadata_parts.appendSlice(allocator, \"\\\"\");\n        first = false;\n    }\n    if (record_args.exit_code) |exit_code| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        var buf: [32]u8 = undefined;\n        const s = std.fmt.bufPrint(&buf, \"\\\"exit_code\\\":{d}\", .{exit_code}) catch unreachable;\n        try metadata_parts.appendSlice(allocator, s);\n        first = false;\n    }\n    if (record_args.metadata) |metadata| {\n        if (!first) try metadata_parts.appendSlice(allocator, \",\");\n        try metadata_parts.appendSlice(allocator, \"\\\"extra\\\":\");\n        try metadata_parts.appendSlice(allocator, metadata);\n        first = false;\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);\n\n    const event = Event{\n        .id = 0,\n        .issue_id = record_args.issue_id orelse \"\",\n        .event_type = event_type,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Audit entry recorded\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Recorded audit entry {d}\", .{event_id});\n    }\n}\n\nfn runLabel(\n    label_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    // Record a label event referencing the original entry\n    const actor = global.actor orelse \"unknown\";\n    const now = std.time.timestamp();\n\n    // Build the label metadata\n    var metadata_parts: std.ArrayListUnmanaged(u8) = .{};\n    defer metadata_parts.deinit(allocator);\n\n    var buf: [64]u8 = undefined;\n    const header = std.fmt.bufPrint(&buf, \"{{\\\"entry_id\\\":{d},\\\"label\\\":\\\"{s}\\\"\", .{ label_args.entry_id, label_args.label_value }) catch unreachable;\n    try metadata_parts.appendSlice(allocator, header);\n\n    if (label_args.reason) |reason| {\n        try metadata_parts.appendSlice(allocator, \",\\\"reason\\\":\");\n        const escaped = try std.json.Stringify.valueAlloc(allocator, reason, .{});\n        defer allocator.free(escaped);\n        try metadata_parts.appendSlice(allocator, escaped);\n    }\n    try metadata_parts.appendSlice(allocator, \"}\");\n\n    const new_value = try allocator.dupe(u8, metadata_parts.items);\n    defer allocator.free(new_value);\n\n    // Use 'updated' event type to represent a label action on an existing entry\n    const event = Event{\n        .id = 0,\n        .issue_id = \"\", // Labels are not issue-specific\n        .event_type = .updated,\n        .actor = actor,\n        .old_value = null,\n        .new_value = new_value,\n        .created_at = now,\n    };\n\n    const event_id = try ctx.event_store.append(event);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .event_id = event_id,\n            .message = \"Label applied to audit entry\",\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Labeled entry {d} as '{s}'\", .{ label_args.entry_id, label_args.label_value });\n    }\n}\n\nfn runLog(\n    log_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = log_args.limit orelse 100;\n\n    // Query events for the specific issue from the event store\n    const events = try ctx.event_store.queryEvents(.{\n        .issue_id = log_args.issue_id,\n        .limit = limit,\n    });\n    defer ctx.event_store.freeEvents(events);\n\n    var audit_events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer audit_events.deinit(allocator);\n\n    for (events) |event| {\n        try audit_events.append(allocator, .{\n            .id = event.id,\n            .issue_id = event.issue_id,\n            .event_type = event.event_type.toString(),\n            .actor = event.actor,\n            .created_at = event.created_at,\n            .old_value = event.old_value,\n            .new_value = event.new_value,\n        });\n    }\n\n    // Sort by timestamp descending\n    std.mem.sortUnstable(AuditResult.AuditEvent, audit_events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = audit_events.items,\n            .total = audit_events.items.len,\n        });\n    } else if (global.quiet) {\n        for (audit_events.items) |event| {\n            try ctx.output.print(\"{d} {s} {s}\\n\", .{ event.id, event.issue_id, event.event_type });\n        }\n    } else {\n        if (audit_events.items.len == 0) {\n            try ctx.output.info(\"No events found for issue {s}\", .{log_args.issue_id});\n        } else {\n            try ctx.output.println(\"Audit Log for {s} ({d} events):\", .{ log_args.issue_id, audit_events.items.len });\n            try ctx.output.print(\"\\n\", .{});\n\n            for (audit_events.items) |event| {\n                try ctx.output.print(\"[{d}] ts:{d}  {s: <15}  {s}\\n\", .{\n                    event.id,\n                    event.created_at,\n                    event.actor,\n                    event.event_type,\n                });\n                if (event.new_value) |v| {\n                    if (v.len > 0 and v.len < 200) {\n                        try ctx.output.print(\"      -> {s}\\n\", .{v});\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn runSummary(\n    summary_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const now = std.time.timestamp();\n    const since = now - @as(i64, @intCast(summary_args.days)) * 24 * 60 * 60;\n\n    // Query all events in the time period\n    const events = try ctx.event_store.queryEvents(.{ .since = since });\n    defer ctx.event_store.freeEvents(events);\n\n    // Count by type\n    var llm_calls: usize = 0;\n    var tool_calls: usize = 0;\n    var issue_creates: usize = 0;\n    var issue_closes: usize = 0;\n    var other_events: usize = 0;\n\n    // Count by actor\n    var actor_counts: std.StringHashMapUnmanaged(usize) = .{};\n    defer actor_counts.deinit(allocator);\n\n    for (events) |event| {\n        switch (event.event_type) {\n            .llm_call => llm_calls += 1,\n            .tool_call => tool_calls += 1,\n            .created => issue_creates += 1,\n            .closed => issue_closes += 1,\n            else => other_events += 1,\n        }\n\n        const entry = try actor_counts.getOrPutValue(allocator, event.actor, 0);\n        entry.value_ptr.* += 1;\n    }\n\n    // Convert actor counts to array\n    var actor_list: std.ArrayListUnmanaged(AuditResult.AuditSummary.ActorCount) = .{};\n    defer actor_list.deinit(allocator);\n\n    var it = actor_counts.iterator();\n    while (it.next()) |entry| {\n        try actor_list.append(allocator, .{\n            .actor = entry.key_ptr.*,\n            .count = entry.value_ptr.*,\n        });\n    }\n\n    // Sort by count descending\n    std.mem.sortUnstable(AuditResult.AuditSummary.ActorCount, actor_list.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditSummary.ActorCount, b: AuditResult.AuditSummary.ActorCount) bool {\n            return a.count > b.count;\n        }\n    }.lessThan);\n\n    const summary = AuditResult.AuditSummary{\n        .period_days = summary_args.days,\n        .total_events = events.len,\n        .llm_calls = llm_calls,\n        .tool_calls = tool_calls,\n        .issue_creates = issue_creates,\n        .issue_closes = issue_closes,\n        .other_events = other_events,\n        .by_actor = if (actor_list.items.len > 0) actor_list.items else null,\n    };\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .summary = summary,\n        });\n    } else if (!global.quiet) {\n        try ctx.output.println(\"Audit Summary (last {d} days)\", .{summary_args.days});\n        try ctx.output.print(\"\\n\", .{});\n        try ctx.output.print(\"Total Events:   {d}\\n\", .{summary.total_events});\n        try ctx.output.print(\"LLM Calls:      {d}\\n\", .{summary.llm_calls});\n        try ctx.output.print(\"Tool Calls:     {d}\\n\", .{summary.tool_calls});\n        try ctx.output.print(\"Issues Created: {d}\\n\", .{summary.issue_creates});\n        try ctx.output.print(\"Issues Closed:  {d}\\n\", .{summary.issue_closes});\n        try ctx.output.print(\"Other Events:   {d}\\n\", .{summary.other_events});\n\n        if (actor_list.items.len > 0) {\n            try ctx.output.print(\"\\nBy Actor:\\n\", .{});\n            for (actor_list.items[0..@min(10, actor_list.items.len)]) |actor_count| {\n                try ctx.output.print(\"  {s: <20} {d}\\n\", .{ actor_count.actor, actor_count.count });\n            }\n        }\n    }\n}\n\nfn runList(\n    list_args: anytype,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return AuditError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    const limit = list_args.limit orelse 100;\n\n    // Build synthetic audit log from all issues\n    var events: std.ArrayListUnmanaged(AuditResult.AuditEvent) = .{};\n    defer events.deinit(allocator);\n\n    for (ctx.store.issues.items) |issue| {\n        // Created event\n        try events.append(allocator, .{\n            .id = 0,\n            .issue_id = issue.id,\n            .event_type = \"created\",\n            .actor = issue.created_by orelse \"unknown\",\n            .created_at = issue.created_at.value,\n        });\n\n        // Closed event\n        if (issue.closed_at.value) |closed_ts| {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"closed\",\n                .actor = \"unknown\",\n                .created_at = closed_ts,\n            });\n        }\n\n        // If tombstoned\n        if (issue.status.eql(.tombstone)) {\n            try events.append(allocator, .{\n                .id = 0,\n                .issue_id = issue.id,\n                .event_type = \"deleted\",\n                .actor = \"unknown\",\n                .created_at = issue.updated_at.value,\n            });\n        }\n    }\n\n    // Sort by timestamp descending (most recent first)\n    std.mem.sortUnstable(AuditResult.AuditEvent, events.items, {}, struct {\n        fn lessThan(_: void, a: AuditResult.AuditEvent, b: AuditResult.AuditEvent) bool {\n            return a.created_at > b.created_at;\n        }\n    }.lessThan);\n\n    // Apply limit\n    const display_count = @min(events.items.len, limit);\n    const display_events = events.items[0..display_count];\n\n    if (global.isStructuredOutput()) {\n        try ctx.output.printJson(AuditResult{\n            .success = true,\n            .events = display_events,\n            .total = events.items.len,\n        });\n    } else if (global.quiet) {\n        for (display_events) |event| {\n            try ctx.output.print(\"{s} {s}\\n\", .{ event.issue_id, event.event_type });\n        }\n    } else {\n        if (display_events.len == 0) {\n            try ctx.output.info(\"No events found\", .{});\n        } else {\n            try ctx.output.println(\"Audit Log ({d} events):\", .{events.items.len});\n            try ctx.output.print(\"\\n\", .{});\n\n            for (display_events) |event| {\n                try ctx.output.print(\"[ts:{d}]  {s: <12}  {s: <15}  {s}\\n\", .{\n                    event.created_at,\n                    event.issue_id,\n                    event.actor,\n                    event.event_type,\n                });\n            }\n\n            if (events.items.len > display_count) {\n                try ctx.output.print(\"\\n...and {d} more (use --limit to show more)\\n\", .{\n                    events.items.len - display_count,\n                });\n            }\n        }\n    }\n}\n\n// --- Tests ---\n\ntest \"AuditError enum exists\" {\n    const err: AuditError = AuditError.WorkspaceNotInitialized;\n    try std.testing.expect(err == AuditError.WorkspaceNotInitialized);\n}\n\ntest \"AuditResult struct works\" {\n    const result = AuditResult{\n        .success = true,\n        .total = 10,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 10), result.total.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const audit_args = args.AuditArgs{ .subcommand = .{ .list = .{ .limit = null } } };\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(audit_args, global, allocator);\n    try std.testing.expectError(AuditError.WorkspaceNotInitialized, result);\n}\n\ntest \"AuditSubcommand record parses correctly\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"record\", \"llm_call\", \"--model\", \"gpt-4\", \"--prompt\", \"hello\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .record => |r| {\n                    try std.testing.expectEqualStrings(\"llm_call\", r.kind);\n                    try std.testing.expectEqualStrings(\"gpt-4\", r.model.?);\n                    try std.testing.expectEqualStrings(\"hello\", r.prompt.?);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand summary parses days\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"audit\", \"summary\", \"--days\", \"30\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .summary => |s| {\n                    try std.testing.expectEqual(@as(u32, 30), s.days);\n                },\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"AuditSubcommand list is default\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{\"audit\"};\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .audit => |a| {\n            switch (a.subcommand) {\n                .list => {},\n                else => try std.testing.expect(false),\n            }\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","numLines":591,"startLine":1,"totalLines":591}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VGW6onHSU289vHcQrkfVgR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NoSvV3DjEToNS52Rk2Funa","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/changelog.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":180,"cache_read_input_tokens":53476,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":180},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"41f03fbc-a48d-4b2b-9fde-c0f742769258"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NoSvV3DjEToNS52Rk2Funa","type":"tool_result","content":"     1//! Changelog command for beads_zig.\n     2//!\n     3//! `bz changelog [--since DATE] [--until DATE] [-n LIMIT] [--group-by TYPE]`\n     4//!\n     5//! Generates a changelog from closed issues, optionally filtered by date range.\n     6\n     7const std = @import(\"std\");\n     8const models = @import(\"../models/mod.zig\");\n     9const common = @import(\"common.zig\");\n    10const args = @import(\"args.zig\");\n    11const test_util = @import(\"../test_util.zig\");\n    12\n    13const Issue = models.Issue;\n    14const IssueStore = common.IssueStore;\n    15const CommandContext = common.CommandContext;\n    16const timestamp = models.timestamp;\n    17\n    18pub const ChangelogError = error{\n    19    WorkspaceNotInitialized,\n    20    InvalidDateFormat,\n    21    StorageError,\n    22    OutOfMemory,\n    23    GitTagNotFound,\n    24    GitCommitNotFound,\n    25    GitError,\n    26};\n    27\n    28pub const ChangelogResult = struct {\n    29    success: bool,\n    30    entries: ?[]const ChangelogEntry = null,\n    31    count: ?usize = null,\n    32    message: ?[]const u8 = null,\n    33\n    34    pub const ChangelogEntry = struct {\n    35        id: []const u8,\n    36        title: []const u8,\n    37        issue_type: []const u8,\n    38        closed_at: ?[]const u8 = null,\n    39        close_reason: ?[]const u8 = null,\n    40        labels: []const []const u8 = &.{},\n    41    };\n    42};\n    43\n    44pub fn run(\n    45    changelog_args: args.ChangelogArgs,\n    46    global: args.GlobalOptions,\n    47    allocator: std.mem.Allocator,\n    48) !void {\n    49    var ctx = (try CommandContext.init(allocator, global)) orelse {\n    50        return ChangelogError.WorkspaceNotInitialized;\n    51    };\n    52    defer ctx.deinit();\n    53\n    54    var filters = IssueStore.ListFilters{};\n    55    filters.status = .closed;\n    56    filters.order_by = .updated_at;\n    57    filters.order_desc = true;\n    58\n    59    if (changelog_args.limit) |n| {\n    60        filters.limit = n;\n    61    }\n    62\n    63    const issues = try ctx.store.list(filters);\n    64    defer {\n    65        for (issues) |*issue| {\n    66            var i = issue.*;\n    67            i.deinit(allocator);\n    68        }\n    69        allocator.free(issues);\n    70    }\n    71\n    72    // Filter by date range if specified\n    73    var filtered_issues: std.ArrayListUnmanaged(Issue) = .{};\n    74    defer filtered_issues.deinit(allocator);\n    75\n    76    // Determine the since timestamp from various sources (priority: since_tag > since_commit > since)\n    77    var since_ts: ?i64 = null;\n    78    if (changelog_args.since_tag) |tag| {\n    79        since_ts = getTimestampFromGitTag(allocator, tag) catch |err| {\n    80            if (!global.isStructuredOutput()) {\n    81                try ctx.output.err(\"Failed to get timestamp for tag '{s}': {s}\", .{ tag, @errorName(err) });\n    82            }\n    83            return err;\n    84        };\n    85    } else if (changelog_args.since_commit) |commit| {\n    86        since_ts = getTimestampFromGitCommit(allocator, commit) catch |err| {\n    87            if (!global.isStructuredOutput()) {\n    88                try ctx.output.err(\"Failed to get timestamp for commit '{s}': {s}\", .{ commit, @errorName(err) });\n    89            }\n    90            return err;\n    91        };\n    92    } else if (changelog_args.since) |s| {\n    93        since_ts = parseDateToTimestamp(s);\n    94    }\n    95\n    96    const until_ts = if (changelog_args.until) |u| parseDateToTimestamp(u) else null;\n    97\n    98    for (issues) |issue| {\n    99        const closed_ts = if (issue.closed_at.value) |t| t else continue;\n   100\n   101        if (since_ts) |since| {\n   102            if (closed_ts < since) continue;\n   103        }\n   104        if (until_ts) |until| {\n   105            if (closed_ts > until) continue;\n   106        }\n   107\n   108        try filtered_issues.append(allocator, issue);\n   109    }\n   110\n   111    if (global.isStructuredOutput()) {\n   112        var entries = try allocator.alloc(ChangelogResult.ChangelogEntry, filtered_issues.items.len);\n   113        defer allocator.free(entries);\n   114\n   115        // Track allocated timestamp strings for cleanup\n   116        var timestamp_strings: std.ArrayListUnmanaged([]const u8) = .{};\n   117        defer {\n   118            for (timestamp_strings.items) |ts| {\n   119                allocator.free(ts);\n   120            }\n   121            timestamp_strings.deinit(allocator);\n   122        }\n   123\n   124        for (filtered_issues.items, 0..) |issue, i| {\n   125            var closed_at_str: ?[]const u8 = null;\n   126            if (issue.closed_at.value) |ts_val| {\n   127                if (timestamp.formatRfc3339Alloc(allocator, ts_val)) |ts| {\n   128                    closed_at_str = ts;\n   129                    try timestamp_strings.append(allocator, ts);\n   130                } else |_| {}\n   131            }\n   132\n   133            entries[i] = .{\n   134                .id = issue.id,\n   135                .title = issue.title,\n   136                .issue_type = issue.issue_type.toString(),\n   137                .closed_at = closed_at_str,\n   138                .close_reason = issue.close_reason,\n   139                .labels = issue.labels,\n   140            };\n   141        }\n   142\n   143        try ctx.output.printJson(ChangelogResult{\n   144            .success = true,\n   145            .entries = entries,\n   146            .count = filtered_issues.items.len,\n   147        });\n   148    } else {\n   149        if (filtered_issues.items.len == 0) {\n   150            if (!global.quiet) {\n   151                try ctx.output.info(\"No closed issues found\", .{});\n   152            }\n   153            return;\n   154        }\n   155\n   156        // Group by issue type if requested\n   157        if (changelog_args.group_by) |group| {\n   158            if (std.ascii.eqlIgnoreCase(group, \"type\")) {\n   159                try printGroupedByType(&ctx.output, filtered_issues.items, allocator);\n   160                return;\n   161            }\n   162        }\n   163\n   164        // Default: print as a simple changelog list\n   165        try ctx.output.println(\"# Changelog\", .{});\n   166        try ctx.output.println(\"\", .{});\n   167\n   168        for (filtered_issues.items) |issue| {\n   169            const type_str = issue.issue_type.toString();\n   170            const reason_suffix = if (issue.close_reason) |r| blk: {\n   171                var buf: [256]u8 = undefined;\n   172                const result = std.fmt.bufPrint(&buf, \" ({s})\", .{r}) catch \"\";\n   173                break :blk result;\n   174            } else \"\";\n   175\n   176            try ctx.output.println(\"- [{s}] {s}: {s}{s}\", .{\n   177                issue.id,\n   178                type_str,\n   179                issue.title,\n   180                reason_suffix,\n   181            });\n   182        }\n   183\n   184        if (!global.quiet) {\n   185            try ctx.output.println(\"\", .{});\n   186            try ctx.output.info(\"{d} closed issue(s)\", .{filtered_issues.items.len});\n   187        }\n   188    }\n   189}\n   190\n   191fn printGroupedByType(output: *common.Output, issues: []Issue, allocator: std.mem.Allocator) !void {\n   192    // Group issues by type\n   193    var type_groups: std.StringHashMapUnmanaged(std.ArrayListUnmanaged(Issue)) = .{};\n   194    defer {\n   195        var it = type_groups.valueIterator();\n   196        while (it.next()) |list| {\n   197            list.deinit(allocator);\n   198        }\n   199        type_groups.deinit(allocator);\n   200    }\n   201\n   202    for (issues) |issue| {\n   203        const type_str = issue.issue_type.toString();\n   204        const result = type_groups.getOrPut(allocator, type_str) catch continue;\n   205        if (!result.found_existing) {\n   206            result.value_ptr.* = .{};\n   207        }\n   208        result.value_ptr.append(allocator, issue) catch continue;\n   209    }\n   210\n   211    try output.println(\"# Changelog\", .{});\n   212    try output.println(\"\", .{});\n   213\n   214    // Print in a consistent order\n   215    const type_order = [_][]const u8{ \"feature\", \"bug\", \"task\", \"chore\", \"docs\", \"epic\", \"question\" };\n   216\n   217    for (type_order) |type_str| {\n   218        if (type_groups.get(type_str)) |group| {\n   219            if (group.items.len > 0) {\n   220                try output.println(\"## {s}\", .{type_str});\n   221                try output.println(\"\", .{});\n   222                for (group.items) |issue| {\n   223                    try output.println(\"- [{s}] {s}\", .{ issue.id, issue.title });\n   224                }\n   225                try output.println(\"\", .{});\n   226            }\n   227        }\n   228    }\n   229\n   230    // Print any remaining types not in the order list\n   231    var it = type_groups.iterator();\n   232    while (it.next()) |entry| {\n   233        var found = false;\n   234        for (type_order) |t| {\n   235            if (std.mem.eql(u8, entry.key_ptr.*, t)) {\n   236                found = true;\n   237                break;\n   238            }\n   239        }\n   240        if (!found and entry.value_ptr.items.len > 0) {\n   241            try output.println(\"## {s}\", .{entry.key_ptr.*});\n   242            try output.println(\"\", .{});\n   243            for (entry.value_ptr.items) |issue| {\n   244                try output.println(\"- [{s}] {s}\", .{ issue.id, issue.title });\n   245            }\n   246            try output.println(\"\", .{});\n   247        }\n   248    }\n   249}\n   250\n   251fn parseDateToTimestamp(date_str: []const u8) ?i64 {\n   252    // Parse YYYY-MM-DD format to Unix timestamp\n   253    if (date_str.len < 10) return null;\n   254\n   255    const year = std.fmt.parseInt(i32, date_str[0..4], 10) catch return null;\n   256    const month = std.fmt.parseInt(u4, date_str[5..7], 10) catch return null;\n   257    const day = std.fmt.parseInt(u5, date_str[8..10], 10) catch return null;\n   258\n   259    // Simple epoch calculation (not accounting for leap seconds)\n   260    const epoch_day = epochDayFromDate(year, month, day);\n   261    return epoch_day * 86400;\n   262}\n   263\n   264fn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n   265    // Days since Unix epoch (1970-01-01)\n   266    var y = @as(i64, year);\n   267    var m = @as(i64, month);\n   268    const d = @as(i64, day);\n   269\n   270    // Adjust for months\n   271    if (m <= 2) {\n   272        y -= 1;\n   273        m += 12;\n   274    }\n   275\n   276    const era: i64 = @divFloor(y, 400);\n   277    const yoe: i64 = @mod(y, 400);\n   278    const doy: i64 = @divFloor(153 * (m - 3) + 2, 5) + d - 1;\n   279    const doe: i64 = yoe * 365 + @divFloor(yoe, 4) - @divFloor(yoe, 100) + doy;\n   280\n   281    return era * 146097 + doe - 719468;\n   282}\n   283\n   284fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n   285    // Get the commit timestamp for the given tag\n   286    // Format: git log -1 --format=%ct <tag>\n   287    const result = std.process.Child.run(.{\n   288        .allocator = allocator,\n   289        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n   290        .cwd = null,\n   291    }) catch return ChangelogError.GitError;\n   292\n   293    defer allocator.free(result.stderr);\n   294    defer allocator.free(result.stdout);\n   295\n   296    if (result.term.Exited != 0) {\n   297        return ChangelogError.GitTagNotFound;\n   298    }\n   299\n   300    // Parse the timestamp (trim newline)\n   301    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n   302    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n   303}\n   304\n   305fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n   306    // Get the commit timestamp for the given commit hash\n   307    // Format: git log -1 --format=%ct <commit>\n   308    const result = std.process.Child.run(.{\n   309        .allocator = allocator,\n   310        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n   311        .cwd = null,\n   312    }) catch return ChangelogError.GitError;\n   313\n   314    defer allocator.free(result.stderr);\n   315    defer allocator.free(result.stdout);\n   316\n   317    if (result.term.Exited != 0) {\n   318        return ChangelogError.GitCommitNotFound;\n   319    }\n   320\n   321    // Parse the timestamp (trim newline)\n   322    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n   323    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n   324}\n   325\n   326// --- Tests ---\n   327\n   328test \"ChangelogError enum exists\" {\n   329    const err: ChangelogError = ChangelogError.WorkspaceNotInitialized;\n   330    try std.testing.expect(err == ChangelogError.WorkspaceNotInitialized);\n   331}\n   332\n   333test \"ChangelogResult struct works\" {\n   334    const result = ChangelogResult{\n   335        .success = true,\n   336        .count = 5,\n   337    };\n   338    try std.testing.expect(result.success);\n   339    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n   340}\n   341\n   342test \"run detects uninitialized workspace\" {\n   343    const allocator = std.testing.allocator;\n   344\n   345    const changelog_args = args.ChangelogArgs{};\n   346    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   347\n   348    const result = run(changelog_args, global, allocator);\n   349    try std.testing.expectError(ChangelogError.WorkspaceNotInitialized, result);\n   350}\n   351\n   352test \"run lists closed issues successfully\" {\n   353    const allocator = std.testing.allocator;\n   354\n   355    const tmp_dir_path = try test_util.createTestDir(allocator, \"changelog_test\");\n   356    defer allocator.free(tmp_dir_path);\n   357    defer test_util.cleanupTestDir(tmp_dir_path);\n   358\n   359    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n   360    defer allocator.free(data_path);\n   361\n   362    try std.fs.cwd().makeDir(data_path);\n   363\n   364    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n   365    defer allocator.free(issues_path);\n   366\n   367    const f = try std.fs.cwd().createFile(issues_path, .{});\n   368    defer f.close();\n   369\n   370    const changelog_args = args.ChangelogArgs{};\n   371    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n   372\n   373    try run(changelog_args, global, allocator);\n   374}\n   375\n   376test \"parseDateToTimestamp parses valid date\" {\n   377    const ts = parseDateToTimestamp(\"2024-01-15\");\n   378    try std.testing.expect(ts != null);\n   379    // 2024-01-15 should be around 1705276800 (depends on exact calculation)\n   380    try std.testing.expect(ts.? > 1704067200); // > 2024-01-01\n   381    try std.testing.expect(ts.? < 1706745600); // < 2024-02-01\n   382}\n   383\n   384test \"parseDateToTimestamp returns null for invalid date\" {\n   385    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"invalid\"));\n   386    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"2024\"));\n   387    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"\"));\n   388}\n   389\n   390test \"ChangelogArgs supports since_tag field\" {\n   391    const changelog_args = args.ChangelogArgs{\n   392        .since_tag = \"v1.0.0\",\n   393    };\n   394    try std.testing.expectEqualStrings(\"v1.0.0\", changelog_args.since_tag.?);\n   395}\n   396\n   397test \"ChangelogArgs supports since_commit field\" {\n   398    const changelog_args = args.ChangelogArgs{\n   399        .since_commit = \"abc123\",\n   400    };\n   401    try std.testing.expectEqualStrings(\"abc123\", changelog_args.since_commit.?);\n   402}\n   403\n   404test \"parse changelog with since-tag flag\" {\n   405    const allocator = std.testing.allocator;\n   406    const cmd_args = [_][]const u8{ \"changelog\", \"--since-tag\", \"v1.0.0\" };\n   407    var parser = args.ArgParser.init(allocator, &cmd_args);\n   408    var result = parser.parse() catch unreachable;\n   409    defer result.deinit(allocator);\n   410\n   411    switch (result.command) {\n   412        .changelog => |c| {\n   413            try std.testing.expect(c.since_tag != null);\n   414            try std.testing.expectEqualStrings(\"v1.0.0\", c.since_tag.?);\n   415        },\n   416        else => try std.testing.expect(false),\n   417    }\n   418}\n   419\n   420test \"parse changelog with since-commit flag\" {\n   421    const allocator = std.testing.allocator;\n   422    const cmd_args = [_][]const u8{ \"changelog\", \"--since-commit\", \"abc123def\" };\n   423    var parser = args.ArgParser.init(allocator, &cmd_args);\n   424    var result = parser.parse() catch unreachable;\n   425    defer result.deinit(allocator);\n   426\n   427    switch (result.command) {\n   428        .changelog => |c| {\n   429            try std.testing.expect(c.since_commit != null);\n   430            try std.testing.expectEqualStrings(\"abc123def\", c.since_commit.?);\n   431        },\n   432        else => try std.testing.expect(false),\n   433    }\n   434}\n   435\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"eb8eeef8-0091-4e8b-88eb-783c0933ef53","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/changelog.zig","content":"//! Changelog command for beads_zig.\n//!\n//! `bz changelog [--since DATE] [--until DATE] [-n LIMIT] [--group-by TYPE]`\n//!\n//! Generates a changelog from closed issues, optionally filtered by date range.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\nconst timestamp = models.timestamp;\n\npub const ChangelogError = error{\n    WorkspaceNotInitialized,\n    InvalidDateFormat,\n    StorageError,\n    OutOfMemory,\n    GitTagNotFound,\n    GitCommitNotFound,\n    GitError,\n};\n\npub const ChangelogResult = struct {\n    success: bool,\n    entries: ?[]const ChangelogEntry = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    pub const ChangelogEntry = struct {\n        id: []const u8,\n        title: []const u8,\n        issue_type: []const u8,\n        closed_at: ?[]const u8 = null,\n        close_reason: ?[]const u8 = null,\n        labels: []const []const u8 = &.{},\n    };\n};\n\npub fn run(\n    changelog_args: args.ChangelogArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ChangelogError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n    filters.status = .closed;\n    filters.order_by = .updated_at;\n    filters.order_desc = true;\n\n    if (changelog_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    // Filter by date range if specified\n    var filtered_issues: std.ArrayListUnmanaged(Issue) = .{};\n    defer filtered_issues.deinit(allocator);\n\n    // Determine the since timestamp from various sources (priority: since_tag > since_commit > since)\n    var since_ts: ?i64 = null;\n    if (changelog_args.since_tag) |tag| {\n        since_ts = getTimestampFromGitTag(allocator, tag) catch |err| {\n            if (!global.isStructuredOutput()) {\n                try ctx.output.err(\"Failed to get timestamp for tag '{s}': {s}\", .{ tag, @errorName(err) });\n            }\n            return err;\n        };\n    } else if (changelog_args.since_commit) |commit| {\n        since_ts = getTimestampFromGitCommit(allocator, commit) catch |err| {\n            if (!global.isStructuredOutput()) {\n                try ctx.output.err(\"Failed to get timestamp for commit '{s}': {s}\", .{ commit, @errorName(err) });\n            }\n            return err;\n        };\n    } else if (changelog_args.since) |s| {\n        since_ts = parseDateToTimestamp(s);\n    }\n\n    const until_ts = if (changelog_args.until) |u| parseDateToTimestamp(u) else null;\n\n    for (issues) |issue| {\n        const closed_ts = if (issue.closed_at.value) |t| t else continue;\n\n        if (since_ts) |since| {\n            if (closed_ts < since) continue;\n        }\n        if (until_ts) |until| {\n            if (closed_ts > until) continue;\n        }\n\n        try filtered_issues.append(allocator, issue);\n    }\n\n    if (global.isStructuredOutput()) {\n        var entries = try allocator.alloc(ChangelogResult.ChangelogEntry, filtered_issues.items.len);\n        defer allocator.free(entries);\n\n        // Track allocated timestamp strings for cleanup\n        var timestamp_strings: std.ArrayListUnmanaged([]const u8) = .{};\n        defer {\n            for (timestamp_strings.items) |ts| {\n                allocator.free(ts);\n            }\n            timestamp_strings.deinit(allocator);\n        }\n\n        for (filtered_issues.items, 0..) |issue, i| {\n            var closed_at_str: ?[]const u8 = null;\n            if (issue.closed_at.value) |ts_val| {\n                if (timestamp.formatRfc3339Alloc(allocator, ts_val)) |ts| {\n                    closed_at_str = ts;\n                    try timestamp_strings.append(allocator, ts);\n                } else |_| {}\n            }\n\n            entries[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .issue_type = issue.issue_type.toString(),\n                .closed_at = closed_at_str,\n                .close_reason = issue.close_reason,\n                .labels = issue.labels,\n            };\n        }\n\n        try ctx.output.printJson(ChangelogResult{\n            .success = true,\n            .entries = entries,\n            .count = filtered_issues.items.len,\n        });\n    } else {\n        if (filtered_issues.items.len == 0) {\n            if (!global.quiet) {\n                try ctx.output.info(\"No closed issues found\", .{});\n            }\n            return;\n        }\n\n        // Group by issue type if requested\n        if (changelog_args.group_by) |group| {\n            if (std.ascii.eqlIgnoreCase(group, \"type\")) {\n                try printGroupedByType(&ctx.output, filtered_issues.items, allocator);\n                return;\n            }\n        }\n\n        // Default: print as a simple changelog list\n        try ctx.output.println(\"# Changelog\", .{});\n        try ctx.output.println(\"\", .{});\n\n        for (filtered_issues.items) |issue| {\n            const type_str = issue.issue_type.toString();\n            const reason_suffix = if (issue.close_reason) |r| blk: {\n                var buf: [256]u8 = undefined;\n                const result = std.fmt.bufPrint(&buf, \" ({s})\", .{r}) catch \"\";\n                break :blk result;\n            } else \"\";\n\n            try ctx.output.println(\"- [{s}] {s}: {s}{s}\", .{\n                issue.id,\n                type_str,\n                issue.title,\n                reason_suffix,\n            });\n        }\n\n        if (!global.quiet) {\n            try ctx.output.println(\"\", .{});\n            try ctx.output.info(\"{d} closed issue(s)\", .{filtered_issues.items.len});\n        }\n    }\n}\n\nfn printGroupedByType(output: *common.Output, issues: []Issue, allocator: std.mem.Allocator) !void {\n    // Group issues by type\n    var type_groups: std.StringHashMapUnmanaged(std.ArrayListUnmanaged(Issue)) = .{};\n    defer {\n        var it = type_groups.valueIterator();\n        while (it.next()) |list| {\n            list.deinit(allocator);\n        }\n        type_groups.deinit(allocator);\n    }\n\n    for (issues) |issue| {\n        const type_str = issue.issue_type.toString();\n        const result = type_groups.getOrPut(allocator, type_str) catch continue;\n        if (!result.found_existing) {\n            result.value_ptr.* = .{};\n        }\n        result.value_ptr.append(allocator, issue) catch continue;\n    }\n\n    try output.println(\"# Changelog\", .{});\n    try output.println(\"\", .{});\n\n    // Print in a consistent order\n    const type_order = [_][]const u8{ \"feature\", \"bug\", \"task\", \"chore\", \"docs\", \"epic\", \"question\" };\n\n    for (type_order) |type_str| {\n        if (type_groups.get(type_str)) |group| {\n            if (group.items.len > 0) {\n                try output.println(\"## {s}\", .{type_str});\n                try output.println(\"\", .{});\n                for (group.items) |issue| {\n                    try output.println(\"- [{s}] {s}\", .{ issue.id, issue.title });\n                }\n                try output.println(\"\", .{});\n            }\n        }\n    }\n\n    // Print any remaining types not in the order list\n    var it = type_groups.iterator();\n    while (it.next()) |entry| {\n        var found = false;\n        for (type_order) |t| {\n            if (std.mem.eql(u8, entry.key_ptr.*, t)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found and entry.value_ptr.items.len > 0) {\n            try output.println(\"## {s}\", .{entry.key_ptr.*});\n            try output.println(\"\", .{});\n            for (entry.value_ptr.items) |issue| {\n                try output.println(\"- [{s}] {s}\", .{ issue.id, issue.title });\n            }\n            try output.println(\"\", .{});\n        }\n    }\n}\n\nfn parseDateToTimestamp(date_str: []const u8) ?i64 {\n    // Parse YYYY-MM-DD format to Unix timestamp\n    if (date_str.len < 10) return null;\n\n    const year = std.fmt.parseInt(i32, date_str[0..4], 10) catch return null;\n    const month = std.fmt.parseInt(u4, date_str[5..7], 10) catch return null;\n    const day = std.fmt.parseInt(u5, date_str[8..10], 10) catch return null;\n\n    // Simple epoch calculation (not accounting for leap seconds)\n    const epoch_day = epochDayFromDate(year, month, day);\n    return epoch_day * 86400;\n}\n\nfn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n    // Days since Unix epoch (1970-01-01)\n    var y = @as(i64, year);\n    var m = @as(i64, month);\n    const d = @as(i64, day);\n\n    // Adjust for months\n    if (m <= 2) {\n        y -= 1;\n        m += 12;\n    }\n\n    const era: i64 = @divFloor(y, 400);\n    const yoe: i64 = @mod(y, 400);\n    const doy: i64 = @divFloor(153 * (m - 3) + 2, 5) + d - 1;\n    const doe: i64 = yoe * 365 + @divFloor(yoe, 4) - @divFloor(yoe, 100) + doy;\n\n    return era * 146097 + doe - 719468;\n}\n\nfn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n    // Get the commit timestamp for the given tag\n    // Format: git log -1 --format=%ct <tag>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitTagNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\nfn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n    // Get the commit timestamp for the given commit hash\n    // Format: git log -1 --format=%ct <commit>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitCommitNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\n// --- Tests ---\n\ntest \"ChangelogError enum exists\" {\n    const err: ChangelogError = ChangelogError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ChangelogError.WorkspaceNotInitialized);\n}\n\ntest \"ChangelogResult struct works\" {\n    const result = ChangelogResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const changelog_args = args.ChangelogArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(changelog_args, global, allocator);\n    try std.testing.expectError(ChangelogError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists closed issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"changelog_test\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const changelog_args = args.ChangelogArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(changelog_args, global, allocator);\n}\n\ntest \"parseDateToTimestamp parses valid date\" {\n    const ts = parseDateToTimestamp(\"2024-01-15\");\n    try std.testing.expect(ts != null);\n    // 2024-01-15 should be around 1705276800 (depends on exact calculation)\n    try std.testing.expect(ts.? > 1704067200); // > 2024-01-01\n    try std.testing.expect(ts.? < 1706745600); // < 2024-02-01\n}\n\ntest \"parseDateToTimestamp returns null for invalid date\" {\n    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"invalid\"));\n    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"2024\"));\n    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"\"));\n}\n\ntest \"ChangelogArgs supports since_tag field\" {\n    const changelog_args = args.ChangelogArgs{\n        .since_tag = \"v1.0.0\",\n    };\n    try std.testing.expectEqualStrings(\"v1.0.0\", changelog_args.since_tag.?);\n}\n\ntest \"ChangelogArgs supports since_commit field\" {\n    const changelog_args = args.ChangelogArgs{\n        .since_commit = \"abc123\",\n    };\n    try std.testing.expectEqualStrings(\"abc123\", changelog_args.since_commit.?);\n}\n\ntest \"parse changelog with since-tag flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"changelog\", \"--since-tag\", \"v1.0.0\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .changelog => |c| {\n            try std.testing.expect(c.since_tag != null);\n            try std.testing.expectEqualStrings(\"v1.0.0\", c.since_tag.?);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse changelog with since-commit flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"changelog\", \"--since-commit\", \"abc123def\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .changelog => |c| {\n            try std.testing.expect(c.since_commit != null);\n            try std.testing.expectEqualStrings(\"abc123def\", c.since_commit.?);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","numLines":435,"startLine":1,"totalLines":435}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JjudRw1tHyhWdsL8APquNJ","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check stats.zig and graph.zig for simplification opportunities:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14671,"cache_read_input_tokens":53656,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14671},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"6df2ea13-2a5a-4c1e-a646-c897decab69e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JjudRw1tHyhWdsL8APquNJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Jj1Y4CVrGKYneto6XeVLX","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/graph.zig","offset":400,"limit":250}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14671,"cache_read_input_tokens":53656,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":14671},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"27b05abf-dd8f-449a-b88d-51209d09b625"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Jj1Y4CVrGKYneto6XeVLX","type":"tool_result","content":"   400        errdefer allocator.free(from_copy);\n   401        const to_copy = try allocator.dupe(u8, dep.depends_on_id);\n   402        try edges.append(allocator, .{ .from = from_copy, .to = to_copy });\n   403\n   404        try collectGraphData(graph, dep.depends_on_id, depth + 1, max_depth, visited, nodes, edges, allocator);\n   405    }\n   406}\n   407\n   408fn hasAnyDependents(store: *storage.IssueStore, issue_id: []const u8) bool {\n   409    for (store.getAllRef()) |issue| {\n   410        for (issue.dependencies) |dep| {\n   411            if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n   412                return true;\n   413            }\n   414        }\n   415    }\n   416    return false;\n   417}\n   418\n   419fn truncateTitle(title: []const u8, max_len: usize) []const u8 {\n   420    if (title.len <= max_len) return title;\n   421    return title[0..max_len];\n   422}\n   423\n   424fn escapeDotString(s: []const u8) []const u8 {\n   425    return s;\n   426}\n   427\n   428fn statusEql(a: Status, b: Status) bool {\n   429    const Tag = std.meta.Tag(Status);\n   430    const tag_a: Tag = a;\n   431    const tag_b: Tag = b;\n   432    if (tag_a != tag_b) return false;\n   433    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n   434}\n   435\n   436fn renderCompactIssueGraph(\n   437    graph: *DependencyGraph,\n   438    output: *Output,\n   439    issue_id: []const u8,\n   440    max_depth: ?u32,\n   441    global: args.GlobalOptions,\n   442    allocator: std.mem.Allocator,\n   443) !void {\n   444    var buf: std.ArrayListUnmanaged(u8) = .{};\n   445    defer buf.deinit(allocator);\n   446    const writer = buf.writer(allocator);\n   447\n   448    var visited: std.StringHashMapUnmanaged(void) = .{};\n   449    defer {\n   450        var it = visited.keyIterator();\n   451        while (it.next()) |key| {\n   452            allocator.free(key.*);\n   453        }\n   454        visited.deinit(allocator);\n   455    }\n   456\n   457    // Print root issue\n   458    if (graph.store.getRef(issue_id)) |issue| {\n   459        const status_indicator = if (statusEql(issue.status, .closed)) \"[x]\" else \"[ ]\";\n   460        try writer.print(\"{s} {s} {s}\\n\", .{ issue.id, status_indicator, truncateTitle(issue.title, 60) });\n   461    }\n   462\n   463    // Collect and print dependencies in compact format\n   464    try renderCompactDeps(graph, writer, issue_id, 1, max_depth orelse 10, &visited, allocator);\n   465\n   466    if (global.isStructuredOutput()) {\n   467        try output.printJson(GraphResult{\n   468            .success = true,\n   469            .format = \"compact\",\n   470            .output = buf.items,\n   471        });\n   472    } else {\n   473        try output.raw(buf.items);\n   474    }\n   475}\n   476\n   477fn renderCompactDeps(\n   478    graph: *DependencyGraph,\n   479    writer: anytype,\n   480    issue_id: []const u8,\n   481    depth: u32,\n   482    max_depth: u32,\n   483    visited: *std.StringHashMapUnmanaged(void),\n   484    allocator: std.mem.Allocator,\n   485) !void {\n   486    if (depth > max_depth) return;\n   487\n   488    const id_key = try allocator.dupe(u8, issue_id);\n   489    if (visited.contains(id_key)) {\n   490        allocator.free(id_key);\n   491        return;\n   492    }\n   493    try visited.put(allocator, id_key, {});\n   494\n   495    const deps = try graph.getDependencies(issue_id);\n   496    defer graph.freeDependencies(deps);\n   497\n   498    for (deps) |dep| {\n   499        if (graph.store.getRef(dep.depends_on_id)) |blocker| {\n   500            const status_indicator = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n   501            // Indent based on depth for hierarchy visibility\n   502            var i: u32 = 0;\n   503            while (i < depth) : (i += 1) {\n   504                try writer.writeAll(\"  \");\n   505            }\n   506            try writer.print(\"-> {s} {s} {s}\\n\", .{ blocker.id, status_indicator, truncateTitle(blocker.title, 50) });\n   507            try renderCompactDeps(graph, writer, dep.depends_on_id, depth + 1, max_depth, visited, allocator);\n   508        }\n   509    }\n   510}\n   511\n   512fn renderAllOpenGraph(\n   513    store: *storage.IssueStore,\n   514    output: *Output,\n   515    graph_args: args.GraphArgs,\n   516    global: args.GlobalOptions,\n   517    allocator: std.mem.Allocator,\n   518) !void {\n   519    var buf: std.ArrayListUnmanaged(u8) = .{};\n   520    defer buf.deinit(allocator);\n   521    const writer = buf.writer(allocator);\n   522\n   523    const issues = store.getAllRef();\n   524    var open_with_deps: usize = 0;\n   525\n   526    if (!graph_args.compact) {\n   527        try writer.writeAll(\"Open Issues Dependency Graph\\n\");\n   528        try writer.writeAll(\"=============================\\n\\n\");\n   529    }\n   530\n   531    for (issues) |issue| {\n   532        // Only show open issues (not closed/tombstone)\n   533        if (statusEql(issue.status, .closed) or statusEql(issue.status, .tombstone)) {\n   534            continue;\n   535        }\n   536\n   537        const has_deps = issue.dependencies.len > 0;\n   538        const has_dependents = hasAnyDependents(store, issue.id);\n   539\n   540        if (has_deps or has_dependents) {\n   541            open_with_deps += 1;\n   542\n   543            if (graph_args.compact) {\n   544                // Compact: one line per issue showing status and dep count\n   545                const status_indicator = if (statusEql(issue.status, .blocked)) \"[B]\" else \"[ ]\";\n   546                const dep_count = issue.dependencies.len;\n   547                if (dep_count > 0) {\n   548                    try writer.print(\"{s} {s} {s} (deps: {d})\\n\", .{\n   549                        issue.id,\n   550                        status_indicator,\n   551                        truncateTitle(issue.title, 50),\n   552                        dep_count,\n   553                    });\n   554                } else {\n   555                    try writer.print(\"{s} {s} {s}\\n\", .{\n   556                        issue.id,\n   557                        status_indicator,\n   558                        truncateTitle(issue.title, 50),\n   559                    });\n   560                }\n   561            } else {\n   562                // Full ASCII format for each open issue with dependencies\n   563                const status_str = issue.status.toString();\n   564                try writer.print(\"{s} [{s}] - {s}\\n\", .{ issue.id, status_str, truncateTitle(issue.title, 50) });\n   565\n   566                for (issue.dependencies, 0..) |dep, i| {\n   567                    const is_last = (i == issue.dependencies.len - 1);\n   568                    const connector = if (is_last) \"`-- \" else \"|-- \";\n   569\n   570                    if (store.getRef(dep.depends_on_id)) |blocker| {\n   571                        const blocker_status = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n   572                        try writer.print(\"  {s}{s} {s} - {s}\\n\", .{ connector, blocker.id, blocker_status, truncateTitle(blocker.title, 40) });\n   573                    } else {\n   574                        try writer.print(\"  {s}{s} [?] - (not found)\\n\", .{ connector, dep.depends_on_id });\n   575                    }\n   576                }\n   577                try writer.writeAll(\"\\n\");\n   578            }\n   579        }\n   580    }\n   581\n   582    if (open_with_deps == 0) {\n   583        try writer.writeAll(\"No open issues with dependencies found.\\n\");\n   584    }\n   585\n   586    if (global.isStructuredOutput()) {\n   587        const format_str = if (graph_args.compact) \"compact\" else \"ascii\";\n   588        try output.printJson(GraphResult{\n   589            .success = true,\n   590            .format = format_str,\n   591            .node_count = open_with_deps,\n   592            .output = buf.items,\n   593        });\n   594    } else {\n   595        try output.raw(buf.items);\n   596    }\n   597}\n   598\n   599// --- Tests ---\n   600\n   601test \"GraphError enum exists\" {\n   602    const err: GraphError = GraphError.IssueNotFound;\n   603    try std.testing.expect(err == GraphError.IssueNotFound);\n   604}\n   605\n   606test \"GraphResult struct works\" {\n   607    const result = GraphResult{\n   608        .success = true,\n   609        .format = \"ascii\",\n   610        .node_count = 5,\n   611        .edge_count = 4,\n   612    };\n   613    try std.testing.expect(result.success);\n   614    try std.testing.expectEqualStrings(\"ascii\", result.format.?);\n   615}\n   616\n   617test \"run detects uninitialized workspace\" {\n   618    const allocator = std.testing.allocator;\n   619\n   620    const graph_args = args.GraphArgs{};\n   621    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n   622\n   623    const result = run(graph_args, global, allocator);\n   624    try std.testing.expectError(GraphError.WorkspaceNotInitialized, result);\n   625}\n   626\n   627test \"truncateTitle works correctly\" {\n   628    const full = \"This is a very long title that should be truncated\";\n   629    const truncated = truncateTitle(full, 20);\n   630    try std.testing.expectEqual(@as(usize, 20), truncated.len);\n   631\n   632    const short = \"Short\";\n   633    const not_truncated = truncateTitle(short, 20);\n   634    try std.testing.expectEqualStrings(\"Short\", not_truncated);\n   635}\n   636\n   637test \"GraphFormat.fromString parses correctly\" {\n   638    try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ascii\").?);\n   639    try std.testing.expectEqual(args.GraphFormat.dot, args.GraphFormat.fromString(\"dot\").?);\n   640    try std.testing.expectEqual(args.GraphFormat.dot, args.GraphFormat.fromString(\"graphviz\").?);\n   641    try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ASCII\").?);\n   642    try std.testing.expect(args.GraphFormat.fromString(\"invalid\") == null);\n   643}\n   644\n   645test \"GraphArgs supports all flag\" {\n   646    const graph_args = args.GraphArgs{\n   647        .all = true,\n   648    };\n   649    try std.testing.expect(graph_args.all);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"dc076cb0-a735-4ec2-8204-5c6badb5be43","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/graph.zig","content":"        errdefer allocator.free(from_copy);\n        const to_copy = try allocator.dupe(u8, dep.depends_on_id);\n        try edges.append(allocator, .{ .from = from_copy, .to = to_copy });\n\n        try collectGraphData(graph, dep.depends_on_id, depth + 1, max_depth, visited, nodes, edges, allocator);\n    }\n}\n\nfn hasAnyDependents(store: *storage.IssueStore, issue_id: []const u8) bool {\n    for (store.getAllRef()) |issue| {\n        for (issue.dependencies) |dep| {\n            if (std.mem.eql(u8, dep.depends_on_id, issue_id)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfn truncateTitle(title: []const u8, max_len: usize) []const u8 {\n    if (title.len <= max_len) return title;\n    return title[0..max_len];\n}\n\nfn escapeDotString(s: []const u8) []const u8 {\n    return s;\n}\n\nfn statusEql(a: Status, b: Status) bool {\n    const Tag = std.meta.Tag(Status);\n    const tag_a: Tag = a;\n    const tag_b: Tag = b;\n    if (tag_a != tag_b) return false;\n    return if (tag_a == .custom) std.mem.eql(u8, a.custom, b.custom) else true;\n}\n\nfn renderCompactIssueGraph(\n    graph: *DependencyGraph,\n    output: *Output,\n    issue_id: []const u8,\n    max_depth: ?u32,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var buf: std.ArrayListUnmanaged(u8) = .{};\n    defer buf.deinit(allocator);\n    const writer = buf.writer(allocator);\n\n    var visited: std.StringHashMapUnmanaged(void) = .{};\n    defer {\n        var it = visited.keyIterator();\n        while (it.next()) |key| {\n            allocator.free(key.*);\n        }\n        visited.deinit(allocator);\n    }\n\n    // Print root issue\n    if (graph.store.getRef(issue_id)) |issue| {\n        const status_indicator = if (statusEql(issue.status, .closed)) \"[x]\" else \"[ ]\";\n        try writer.print(\"{s} {s} {s}\\n\", .{ issue.id, status_indicator, truncateTitle(issue.title, 60) });\n    }\n\n    // Collect and print dependencies in compact format\n    try renderCompactDeps(graph, writer, issue_id, 1, max_depth orelse 10, &visited, allocator);\n\n    if (global.isStructuredOutput()) {\n        try output.printJson(GraphResult{\n            .success = true,\n            .format = \"compact\",\n            .output = buf.items,\n        });\n    } else {\n        try output.raw(buf.items);\n    }\n}\n\nfn renderCompactDeps(\n    graph: *DependencyGraph,\n    writer: anytype,\n    issue_id: []const u8,\n    depth: u32,\n    max_depth: u32,\n    visited: *std.StringHashMapUnmanaged(void),\n    allocator: std.mem.Allocator,\n) !void {\n    if (depth > max_depth) return;\n\n    const id_key = try allocator.dupe(u8, issue_id);\n    if (visited.contains(id_key)) {\n        allocator.free(id_key);\n        return;\n    }\n    try visited.put(allocator, id_key, {});\n\n    const deps = try graph.getDependencies(issue_id);\n    defer graph.freeDependencies(deps);\n\n    for (deps) |dep| {\n        if (graph.store.getRef(dep.depends_on_id)) |blocker| {\n            const status_indicator = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n            // Indent based on depth for hierarchy visibility\n            var i: u32 = 0;\n            while (i < depth) : (i += 1) {\n                try writer.writeAll(\"  \");\n            }\n            try writer.print(\"-> {s} {s} {s}\\n\", .{ blocker.id, status_indicator, truncateTitle(blocker.title, 50) });\n            try renderCompactDeps(graph, writer, dep.depends_on_id, depth + 1, max_depth, visited, allocator);\n        }\n    }\n}\n\nfn renderAllOpenGraph(\n    store: *storage.IssueStore,\n    output: *Output,\n    graph_args: args.GraphArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var buf: std.ArrayListUnmanaged(u8) = .{};\n    defer buf.deinit(allocator);\n    const writer = buf.writer(allocator);\n\n    const issues = store.getAllRef();\n    var open_with_deps: usize = 0;\n\n    if (!graph_args.compact) {\n        try writer.writeAll(\"Open Issues Dependency Graph\\n\");\n        try writer.writeAll(\"=============================\\n\\n\");\n    }\n\n    for (issues) |issue| {\n        // Only show open issues (not closed/tombstone)\n        if (statusEql(issue.status, .closed) or statusEql(issue.status, .tombstone)) {\n            continue;\n        }\n\n        const has_deps = issue.dependencies.len > 0;\n        const has_dependents = hasAnyDependents(store, issue.id);\n\n        if (has_deps or has_dependents) {\n            open_with_deps += 1;\n\n            if (graph_args.compact) {\n                // Compact: one line per issue showing status and dep count\n                const status_indicator = if (statusEql(issue.status, .blocked)) \"[B]\" else \"[ ]\";\n                const dep_count = issue.dependencies.len;\n                if (dep_count > 0) {\n                    try writer.print(\"{s} {s} {s} (deps: {d})\\n\", .{\n                        issue.id,\n                        status_indicator,\n                        truncateTitle(issue.title, 50),\n                        dep_count,\n                    });\n                } else {\n                    try writer.print(\"{s} {s} {s}\\n\", .{\n                        issue.id,\n                        status_indicator,\n                        truncateTitle(issue.title, 50),\n                    });\n                }\n            } else {\n                // Full ASCII format for each open issue with dependencies\n                const status_str = issue.status.toString();\n                try writer.print(\"{s} [{s}] - {s}\\n\", .{ issue.id, status_str, truncateTitle(issue.title, 50) });\n\n                for (issue.dependencies, 0..) |dep, i| {\n                    const is_last = (i == issue.dependencies.len - 1);\n                    const connector = if (is_last) \"`-- \" else \"|-- \";\n\n                    if (store.getRef(dep.depends_on_id)) |blocker| {\n                        const blocker_status = if (statusEql(blocker.status, .closed)) \"[x]\" else \"[ ]\";\n                        try writer.print(\"  {s}{s} {s} - {s}\\n\", .{ connector, blocker.id, blocker_status, truncateTitle(blocker.title, 40) });\n                    } else {\n                        try writer.print(\"  {s}{s} [?] - (not found)\\n\", .{ connector, dep.depends_on_id });\n                    }\n                }\n                try writer.writeAll(\"\\n\");\n            }\n        }\n    }\n\n    if (open_with_deps == 0) {\n        try writer.writeAll(\"No open issues with dependencies found.\\n\");\n    }\n\n    if (global.isStructuredOutput()) {\n        const format_str = if (graph_args.compact) \"compact\" else \"ascii\";\n        try output.printJson(GraphResult{\n            .success = true,\n            .format = format_str,\n            .node_count = open_with_deps,\n            .output = buf.items,\n        });\n    } else {\n        try output.raw(buf.items);\n    }\n}\n\n// --- Tests ---\n\ntest \"GraphError enum exists\" {\n    const err: GraphError = GraphError.IssueNotFound;\n    try std.testing.expect(err == GraphError.IssueNotFound);\n}\n\ntest \"GraphResult struct works\" {\n    const result = GraphResult{\n        .success = true,\n        .format = \"ascii\",\n        .node_count = 5,\n        .edge_count = 4,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqualStrings(\"ascii\", result.format.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const graph_args = args.GraphArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(graph_args, global, allocator);\n    try std.testing.expectError(GraphError.WorkspaceNotInitialized, result);\n}\n\ntest \"truncateTitle works correctly\" {\n    const full = \"This is a very long title that should be truncated\";\n    const truncated = truncateTitle(full, 20);\n    try std.testing.expectEqual(@as(usize, 20), truncated.len);\n\n    const short = \"Short\";\n    const not_truncated = truncateTitle(short, 20);\n    try std.testing.expectEqualStrings(\"Short\", not_truncated);\n}\n\ntest \"GraphFormat.fromString parses correctly\" {\n    try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ascii\").?);\n    try std.testing.expectEqual(args.GraphFormat.dot, args.GraphFormat.fromString(\"dot\").?);\n    try std.testing.expectEqual(args.GraphFormat.dot, args.GraphFormat.fromString(\"graphviz\").?);\n    try std.testing.expectEqual(args.GraphFormat.ascii, args.GraphFormat.fromString(\"ASCII\").?);\n    try std.testing.expect(args.GraphFormat.fromString(\"invalid\") == null);\n}\n\ntest \"GraphArgs supports all flag\" {\n    const graph_args = args.GraphArgs{\n        .all = true,\n    };\n    try std.testing.expect(graph_args.all);","numLines":250,"startLine":400,"totalLines":724}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PQ4WxmWAyRJ23qRJaYTtUx","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good picture of the code. I notice a clear simplification opportunity in `changelog.zig` - the two git timestamp functions (`getTimestampFromGitTag` and `getTimestampFromGitCommit`) are nearly identical and can be merged into a single function. Let me run the tests first to establish a baseline, then make the simplification."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3711,"cache_read_input_tokens":68327,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3711},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"f57df67b-d582-4239-b9e2-060a83a9e52e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PQ4WxmWAyRJ23qRJaYTtUx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L4btyVczDXs34HFRSAyySB","name":"Bash","input":{"command":"zig build test 2>&1 | tail -30","description":"Run tests to establish baseline"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3711,"cache_read_input_tokens":68327,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3711},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"59c69b34-20fc-4c34-82d5-709f19dfe680"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L4btyVczDXs34HFRSAyySB","type":"tool_result","content":"673/694 tests.cli_test.test.bz create returns ID...OK\n674/694 tests.cli_test.test.bz q returns ID...OK\n675/694 tests.cli_test.test.bz list returns issues...OK\n676/694 tests.cli_test.test.bz list --json returns output...OK\n677/694 tests.cli_test.test.bz show displays issue...OK\n678/694 tests.cli_test.test.bz show not-found returns error...OK\n679/694 tests.cli_test.test.bz close marks issue as closed...OK\n680/694 tests.cli_test.test.bz reopen reopens closed issue...OK\n681/694 tests.cli_test.test.bz delete soft deletes issue...OK\n682/694 tests.cli_test.test.bz search finds matching issues...OK\n683/694 tests.cli_test.test.bz dep add creates dependency...OK\n684/694 tests.cli_test.test.bz dep add rejects cycles...OK\n685/694 tests.cli_test.test.bz ready shows unblocked issues...OK\n686/694 tests.cli_test.test.bz blocked shows blocked issues...OK\n687/694 tests.cli_test.test.bz unknown command returns error...OK\n688/694 tests.cli_test.test.bz without workspace shows error...OK\n689/694 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n690/694 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n691/694 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n692/694 tests.stress_test.test.sequential writes: single thread baseline...OK\n693/694 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n694/694 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 694 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"10f89486-efe5-48be-b030-9c353d21170e","tool_use_result":{"stdout":"673/694 tests.cli_test.test.bz create returns ID...OK\n674/694 tests.cli_test.test.bz q returns ID...OK\n675/694 tests.cli_test.test.bz list returns issues...OK\n676/694 tests.cli_test.test.bz list --json returns output...OK\n677/694 tests.cli_test.test.bz show displays issue...OK\n678/694 tests.cli_test.test.bz show not-found returns error...OK\n679/694 tests.cli_test.test.bz close marks issue as closed...OK\n680/694 tests.cli_test.test.bz reopen reopens closed issue...OK\n681/694 tests.cli_test.test.bz delete soft deletes issue...OK\n682/694 tests.cli_test.test.bz search finds matching issues...OK\n683/694 tests.cli_test.test.bz dep add creates dependency...OK\n684/694 tests.cli_test.test.bz dep add rejects cycles...OK\n685/694 tests.cli_test.test.bz ready shows unblocked issues...OK\n686/694 tests.cli_test.test.bz blocked shows blocked issues...OK\n687/694 tests.cli_test.test.bz unknown command returns error...OK\n688/694 tests.cli_test.test.bz without workspace shows error...OK\n689/694 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n690/694 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n691/694 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n692/694 tests.stress_test.test.sequential writes: single thread baseline...OK\n693/694 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n694/694 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 694 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017TXDMUxyQKHHPa3eGyUf9L","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Now let me simplify `changelog.zig` by merging the two nearly-identical git timestamp functions:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":720,"cache_read_input_tokens":72038,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":720},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"3af8173c-bb7a-43ab-a409-87f6bd57bf35"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017TXDMUxyQKHHPa3eGyUf9L","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NjDqPRSPuLnfUuzKn1skS9","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/changelog.zig","old_string":"fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n    // Get the commit timestamp for the given tag\n    // Format: git log -1 --format=%ct <tag>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitTagNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\nfn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n    // Get the commit timestamp for the given commit hash\n    // Format: git log -1 --format=%ct <commit>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitCommitNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}","new_string":"fn getTimestampFromGitRef(allocator: std.mem.Allocator, git_ref: []const u8, not_found_error: ChangelogError) !i64 {\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", git_ref },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return not_found_error;\n    }\n\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\nfn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n    return getTimestampFromGitRef(allocator, tag, ChangelogError.GitTagNotFound);\n}\n\nfn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n    return getTimestampFromGitRef(allocator, commit, ChangelogError.GitCommitNotFound);\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":720,"cache_read_input_tokens":72038,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":720},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"4035aad0-8e53-43c7-b9d4-d92138a5a054"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NjDqPRSPuLnfUuzKn1skS9","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/changelog.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"71447456-d2f1-4edf-8f59-de13fc992733","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/changelog.zig","oldString":"fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n    // Get the commit timestamp for the given tag\n    // Format: git log -1 --format=%ct <tag>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitTagNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\nfn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n    // Get the commit timestamp for the given commit hash\n    // Format: git log -1 --format=%ct <commit>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitCommitNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}","newString":"fn getTimestampFromGitRef(allocator: std.mem.Allocator, git_ref: []const u8, not_found_error: ChangelogError) !i64 {\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", git_ref },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return not_found_error;\n    }\n\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\nfn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n    return getTimestampFromGitRef(allocator, tag, ChangelogError.GitTagNotFound);\n}\n\nfn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n    return getTimestampFromGitRef(allocator, commit, ChangelogError.GitCommitNotFound);\n}","originalFile":"//! Changelog command for beads_zig.\n//!\n//! `bz changelog [--since DATE] [--until DATE] [-n LIMIT] [--group-by TYPE]`\n//!\n//! Generates a changelog from closed issues, optionally filtered by date range.\n\nconst std = @import(\"std\");\nconst models = @import(\"../models/mod.zig\");\nconst common = @import(\"common.zig\");\nconst args = @import(\"args.zig\");\nconst test_util = @import(\"../test_util.zig\");\n\nconst Issue = models.Issue;\nconst IssueStore = common.IssueStore;\nconst CommandContext = common.CommandContext;\nconst timestamp = models.timestamp;\n\npub const ChangelogError = error{\n    WorkspaceNotInitialized,\n    InvalidDateFormat,\n    StorageError,\n    OutOfMemory,\n    GitTagNotFound,\n    GitCommitNotFound,\n    GitError,\n};\n\npub const ChangelogResult = struct {\n    success: bool,\n    entries: ?[]const ChangelogEntry = null,\n    count: ?usize = null,\n    message: ?[]const u8 = null,\n\n    pub const ChangelogEntry = struct {\n        id: []const u8,\n        title: []const u8,\n        issue_type: []const u8,\n        closed_at: ?[]const u8 = null,\n        close_reason: ?[]const u8 = null,\n        labels: []const []const u8 = &.{},\n    };\n};\n\npub fn run(\n    changelog_args: args.ChangelogArgs,\n    global: args.GlobalOptions,\n    allocator: std.mem.Allocator,\n) !void {\n    var ctx = (try CommandContext.init(allocator, global)) orelse {\n        return ChangelogError.WorkspaceNotInitialized;\n    };\n    defer ctx.deinit();\n\n    var filters = IssueStore.ListFilters{};\n    filters.status = .closed;\n    filters.order_by = .updated_at;\n    filters.order_desc = true;\n\n    if (changelog_args.limit) |n| {\n        filters.limit = n;\n    }\n\n    const issues = try ctx.store.list(filters);\n    defer {\n        for (issues) |*issue| {\n            var i = issue.*;\n            i.deinit(allocator);\n        }\n        allocator.free(issues);\n    }\n\n    // Filter by date range if specified\n    var filtered_issues: std.ArrayListUnmanaged(Issue) = .{};\n    defer filtered_issues.deinit(allocator);\n\n    // Determine the since timestamp from various sources (priority: since_tag > since_commit > since)\n    var since_ts: ?i64 = null;\n    if (changelog_args.since_tag) |tag| {\n        since_ts = getTimestampFromGitTag(allocator, tag) catch |err| {\n            if (!global.isStructuredOutput()) {\n                try ctx.output.err(\"Failed to get timestamp for tag '{s}': {s}\", .{ tag, @errorName(err) });\n            }\n            return err;\n        };\n    } else if (changelog_args.since_commit) |commit| {\n        since_ts = getTimestampFromGitCommit(allocator, commit) catch |err| {\n            if (!global.isStructuredOutput()) {\n                try ctx.output.err(\"Failed to get timestamp for commit '{s}': {s}\", .{ commit, @errorName(err) });\n            }\n            return err;\n        };\n    } else if (changelog_args.since) |s| {\n        since_ts = parseDateToTimestamp(s);\n    }\n\n    const until_ts = if (changelog_args.until) |u| parseDateToTimestamp(u) else null;\n\n    for (issues) |issue| {\n        const closed_ts = if (issue.closed_at.value) |t| t else continue;\n\n        if (since_ts) |since| {\n            if (closed_ts < since) continue;\n        }\n        if (until_ts) |until| {\n            if (closed_ts > until) continue;\n        }\n\n        try filtered_issues.append(allocator, issue);\n    }\n\n    if (global.isStructuredOutput()) {\n        var entries = try allocator.alloc(ChangelogResult.ChangelogEntry, filtered_issues.items.len);\n        defer allocator.free(entries);\n\n        // Track allocated timestamp strings for cleanup\n        var timestamp_strings: std.ArrayListUnmanaged([]const u8) = .{};\n        defer {\n            for (timestamp_strings.items) |ts| {\n                allocator.free(ts);\n            }\n            timestamp_strings.deinit(allocator);\n        }\n\n        for (filtered_issues.items, 0..) |issue, i| {\n            var closed_at_str: ?[]const u8 = null;\n            if (issue.closed_at.value) |ts_val| {\n                if (timestamp.formatRfc3339Alloc(allocator, ts_val)) |ts| {\n                    closed_at_str = ts;\n                    try timestamp_strings.append(allocator, ts);\n                } else |_| {}\n            }\n\n            entries[i] = .{\n                .id = issue.id,\n                .title = issue.title,\n                .issue_type = issue.issue_type.toString(),\n                .closed_at = closed_at_str,\n                .close_reason = issue.close_reason,\n                .labels = issue.labels,\n            };\n        }\n\n        try ctx.output.printJson(ChangelogResult{\n            .success = true,\n            .entries = entries,\n            .count = filtered_issues.items.len,\n        });\n    } else {\n        if (filtered_issues.items.len == 0) {\n            if (!global.quiet) {\n                try ctx.output.info(\"No closed issues found\", .{});\n            }\n            return;\n        }\n\n        // Group by issue type if requested\n        if (changelog_args.group_by) |group| {\n            if (std.ascii.eqlIgnoreCase(group, \"type\")) {\n                try printGroupedByType(&ctx.output, filtered_issues.items, allocator);\n                return;\n            }\n        }\n\n        // Default: print as a simple changelog list\n        try ctx.output.println(\"# Changelog\", .{});\n        try ctx.output.println(\"\", .{});\n\n        for (filtered_issues.items) |issue| {\n            const type_str = issue.issue_type.toString();\n            const reason_suffix = if (issue.close_reason) |r| blk: {\n                var buf: [256]u8 = undefined;\n                const result = std.fmt.bufPrint(&buf, \" ({s})\", .{r}) catch \"\";\n                break :blk result;\n            } else \"\";\n\n            try ctx.output.println(\"- [{s}] {s}: {s}{s}\", .{\n                issue.id,\n                type_str,\n                issue.title,\n                reason_suffix,\n            });\n        }\n\n        if (!global.quiet) {\n            try ctx.output.println(\"\", .{});\n            try ctx.output.info(\"{d} closed issue(s)\", .{filtered_issues.items.len});\n        }\n    }\n}\n\nfn printGroupedByType(output: *common.Output, issues: []Issue, allocator: std.mem.Allocator) !void {\n    // Group issues by type\n    var type_groups: std.StringHashMapUnmanaged(std.ArrayListUnmanaged(Issue)) = .{};\n    defer {\n        var it = type_groups.valueIterator();\n        while (it.next()) |list| {\n            list.deinit(allocator);\n        }\n        type_groups.deinit(allocator);\n    }\n\n    for (issues) |issue| {\n        const type_str = issue.issue_type.toString();\n        const result = type_groups.getOrPut(allocator, type_str) catch continue;\n        if (!result.found_existing) {\n            result.value_ptr.* = .{};\n        }\n        result.value_ptr.append(allocator, issue) catch continue;\n    }\n\n    try output.println(\"# Changelog\", .{});\n    try output.println(\"\", .{});\n\n    // Print in a consistent order\n    const type_order = [_][]const u8{ \"feature\", \"bug\", \"task\", \"chore\", \"docs\", \"epic\", \"question\" };\n\n    for (type_order) |type_str| {\n        if (type_groups.get(type_str)) |group| {\n            if (group.items.len > 0) {\n                try output.println(\"## {s}\", .{type_str});\n                try output.println(\"\", .{});\n                for (group.items) |issue| {\n                    try output.println(\"- [{s}] {s}\", .{ issue.id, issue.title });\n                }\n                try output.println(\"\", .{});\n            }\n        }\n    }\n\n    // Print any remaining types not in the order list\n    var it = type_groups.iterator();\n    while (it.next()) |entry| {\n        var found = false;\n        for (type_order) |t| {\n            if (std.mem.eql(u8, entry.key_ptr.*, t)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found and entry.value_ptr.items.len > 0) {\n            try output.println(\"## {s}\", .{entry.key_ptr.*});\n            try output.println(\"\", .{});\n            for (entry.value_ptr.items) |issue| {\n                try output.println(\"- [{s}] {s}\", .{ issue.id, issue.title });\n            }\n            try output.println(\"\", .{});\n        }\n    }\n}\n\nfn parseDateToTimestamp(date_str: []const u8) ?i64 {\n    // Parse YYYY-MM-DD format to Unix timestamp\n    if (date_str.len < 10) return null;\n\n    const year = std.fmt.parseInt(i32, date_str[0..4], 10) catch return null;\n    const month = std.fmt.parseInt(u4, date_str[5..7], 10) catch return null;\n    const day = std.fmt.parseInt(u5, date_str[8..10], 10) catch return null;\n\n    // Simple epoch calculation (not accounting for leap seconds)\n    const epoch_day = epochDayFromDate(year, month, day);\n    return epoch_day * 86400;\n}\n\nfn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n    // Days since Unix epoch (1970-01-01)\n    var y = @as(i64, year);\n    var m = @as(i64, month);\n    const d = @as(i64, day);\n\n    // Adjust for months\n    if (m <= 2) {\n        y -= 1;\n        m += 12;\n    }\n\n    const era: i64 = @divFloor(y, 400);\n    const yoe: i64 = @mod(y, 400);\n    const doy: i64 = @divFloor(153 * (m - 3) + 2, 5) + d - 1;\n    const doe: i64 = yoe * 365 + @divFloor(yoe, 4) - @divFloor(yoe, 100) + doy;\n\n    return era * 146097 + doe - 719468;\n}\n\nfn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n    // Get the commit timestamp for the given tag\n    // Format: git log -1 --format=%ct <tag>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitTagNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\nfn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n    // Get the commit timestamp for the given commit hash\n    // Format: git log -1 --format=%ct <commit>\n    const result = std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n        .cwd = null,\n    }) catch return ChangelogError.GitError;\n\n    defer allocator.free(result.stderr);\n    defer allocator.free(result.stdout);\n\n    if (result.term.Exited != 0) {\n        return ChangelogError.GitCommitNotFound;\n    }\n\n    // Parse the timestamp (trim newline)\n    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n}\n\n// --- Tests ---\n\ntest \"ChangelogError enum exists\" {\n    const err: ChangelogError = ChangelogError.WorkspaceNotInitialized;\n    try std.testing.expect(err == ChangelogError.WorkspaceNotInitialized);\n}\n\ntest \"ChangelogResult struct works\" {\n    const result = ChangelogResult{\n        .success = true,\n        .count = 5,\n    };\n    try std.testing.expect(result.success);\n    try std.testing.expectEqual(@as(usize, 5), result.count.?);\n}\n\ntest \"run detects uninitialized workspace\" {\n    const allocator = std.testing.allocator;\n\n    const changelog_args = args.ChangelogArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = \"/nonexistent/path\" };\n\n    const result = run(changelog_args, global, allocator);\n    try std.testing.expectError(ChangelogError.WorkspaceNotInitialized, result);\n}\n\ntest \"run lists closed issues successfully\" {\n    const allocator = std.testing.allocator;\n\n    const tmp_dir_path = try test_util.createTestDir(allocator, \"changelog_test\");\n    defer allocator.free(tmp_dir_path);\n    defer test_util.cleanupTestDir(tmp_dir_path);\n\n    const data_path = try std.fs.path.join(allocator, &.{ tmp_dir_path, \".beads\" });\n    defer allocator.free(data_path);\n\n    try std.fs.cwd().makeDir(data_path);\n\n    const issues_path = try std.fs.path.join(allocator, &.{ data_path, \"issues.jsonl\" });\n    defer allocator.free(issues_path);\n\n    const f = try std.fs.cwd().createFile(issues_path, .{});\n    defer f.close();\n\n    const changelog_args = args.ChangelogArgs{};\n    const global = args.GlobalOptions{ .silent = true, .data_path = data_path };\n\n    try run(changelog_args, global, allocator);\n}\n\ntest \"parseDateToTimestamp parses valid date\" {\n    const ts = parseDateToTimestamp(\"2024-01-15\");\n    try std.testing.expect(ts != null);\n    // 2024-01-15 should be around 1705276800 (depends on exact calculation)\n    try std.testing.expect(ts.? > 1704067200); // > 2024-01-01\n    try std.testing.expect(ts.? < 1706745600); // < 2024-02-01\n}\n\ntest \"parseDateToTimestamp returns null for invalid date\" {\n    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"invalid\"));\n    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"2024\"));\n    try std.testing.expectEqual(@as(?i64, null), parseDateToTimestamp(\"\"));\n}\n\ntest \"ChangelogArgs supports since_tag field\" {\n    const changelog_args = args.ChangelogArgs{\n        .since_tag = \"v1.0.0\",\n    };\n    try std.testing.expectEqualStrings(\"v1.0.0\", changelog_args.since_tag.?);\n}\n\ntest \"ChangelogArgs supports since_commit field\" {\n    const changelog_args = args.ChangelogArgs{\n        .since_commit = \"abc123\",\n    };\n    try std.testing.expectEqualStrings(\"abc123\", changelog_args.since_commit.?);\n}\n\ntest \"parse changelog with since-tag flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"changelog\", \"--since-tag\", \"v1.0.0\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .changelog => |c| {\n            try std.testing.expect(c.since_tag != null);\n            try std.testing.expectEqualStrings(\"v1.0.0\", c.since_tag.?);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse changelog with since-commit flag\" {\n    const allocator = std.testing.allocator;\n    const cmd_args = [_][]const u8{ \"changelog\", \"--since-commit\", \"abc123def\" };\n    var parser = args.ArgParser.init(allocator, &cmd_args);\n    var result = parser.parse() catch unreachable;\n    defer result.deinit(allocator);\n\n    switch (result.command) {\n        .changelog => |c| {\n            try std.testing.expect(c.since_commit != null);\n            try std.testing.expectEqualStrings(\"abc123def\", c.since_commit.?);\n        },\n        else => try std.testing.expect(false),\n    }\n}\n","structuredPatch":[{"oldStart":281,"oldLines":12,"newStart":281,"newLines":10,"lines":["     return era * 146097 + doe - 719468;"," }"," ","-fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {","-    // Get the commit timestamp for the given tag","-    // Format: git log -1 --format=%ct <tag>","+fn getTimestampFromGitRef(allocator: std.mem.Allocator, git_ref: []const u8, not_found_error: ChangelogError) !i64 {","     const result = std.process.Child.run(.{","         .allocator = allocator,","-        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },","+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", git_ref },","         .cwd = null,","     }) catch return ChangelogError.GitError;"," "]},{"oldStart":294,"oldLines":33,"newStart":292,"newLines":19,"lines":["     defer allocator.free(result.stdout);"," ","     if (result.term.Exited != 0) {","-        return ChangelogError.GitTagNotFound;","+        return not_found_error;","     }"," ","-    // Parse the timestamp (trim newline)","     const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");","     return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;"," }"," ","-fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {","-    // Get the commit timestamp for the given commit hash","-    // Format: git log -1 --format=%ct <commit>","-    const result = std.process.Child.run(.{","-        .allocator = allocator,","-        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },","-        .cwd = null,","-    }) catch return ChangelogError.GitError;","+fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {","+    return getTimestampFromGitRef(allocator, tag, ChangelogError.GitTagNotFound);","+}"," ","-    defer allocator.free(result.stderr);","-    defer allocator.free(result.stdout);","-","-    if (result.term.Exited != 0) {","-        return ChangelogError.GitCommitNotFound;","-    }","-","-    // Parse the timestamp (trim newline)","-    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");","-    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;","+fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {","+    return getTimestampFromGitRef(allocator, commit, ChangelogError.GitCommitNotFound);"," }"," "," // --- Tests ---"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Uo6Npwff4BVKAcNMUjEGAK","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run the tests to verify the simplification works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1076,"cache_read_input_tokens":72758,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1076},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"584aae7b-5679-4329-a448-05e36f314e03"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Uo6Npwff4BVKAcNMUjEGAK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RJ2QdCd1JUC1RXSwqx5Mvb","name":"Bash","input":{"command":"zig build test 2>&1 | tail -20","description":"Run tests to verify simplification"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1076,"cache_read_input_tokens":72758,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1076},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"1775c262-079e-4197-b813-5eaafa03f05b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RJ2QdCd1JUC1RXSwqx5Mvb","type":"tool_result","content":"683/694 tests.cli_test.test.bz dep add creates dependency...OK\n684/694 tests.cli_test.test.bz dep add rejects cycles...OK\n685/694 tests.cli_test.test.bz ready shows unblocked issues...OK\n686/694 tests.cli_test.test.bz blocked shows blocked issues...OK\n687/694 tests.cli_test.test.bz unknown command returns error...OK\n688/694 tests.cli_test.test.bz without workspace shows error...OK\n689/694 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n690/694 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n691/694 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 73 issues created\nOK\n692/694 tests.stress_test.test.sequential writes: single thread baseline...OK\n693/694 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n694/694 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 694 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"11a83702-4c6e-4ab0-ac6d-6ce361fe40e3","tool_use_result":{"stdout":"683/694 tests.cli_test.test.bz dep add creates dependency...OK\n684/694 tests.cli_test.test.bz dep add rejects cycles...OK\n685/694 tests.cli_test.test.bz ready shows unblocked issues...OK\n686/694 tests.cli_test.test.bz blocked shows blocked issues...OK\n687/694 tests.cli_test.test.bz unknown command returns error...OK\n688/694 tests.cli_test.test.bz without workspace shows error...OK\n689/694 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n690/694 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n691/694 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 73 issues created\nOK\n692/694 tests.stress_test.test.sequential writes: single thread baseline...OK\n693/694 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n694/694 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 694 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014QbF6k62Y8Dvu9mGk7AjuS","type":"message","role":"assistant","content":[{"type":"text","text":"Tests pass. Let me update the todo list and check if there are any other simplification opportunities in the recently modified files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":585,"cache_read_input_tokens":73834,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":585},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"ddb97a62-71d8-401e-b6c9-d6569bbb7349"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014QbF6k62Y8Dvu9mGk7AjuS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q45DRk9gMSUrH8trRDhvHX","name":"TodoWrite","input":{"todos":[{"content":"Review recently modified code for simplification opportunities","status":"completed","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes","status":"in_progress","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":585,"cache_read_input_tokens":73834,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":585},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"f8c74d9b-83e4-45a2-b278-f5f695959970"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q45DRk9gMSUrH8trRDhvHX","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"9acf29cd-82d1-47d6-9aed-9535d5ec1b13","tool_use_result":{"oldTodos":[{"content":"Review recently modified code for simplification opportunities","status":"in_progress","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"pending","activeForm":"Running tests"}],"newTodos":[{"content":"Review recently modified code for simplification opportunities","status":"completed","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes","status":"in_progress","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RBfrWyVdfkpxENwWriCk1S","type":"message","role":"assistant","content":[{"type":"text","text":"The changelog.zig simplification is complete - I extracted a common helper function `getTimestampFromGitRef` to eliminate duplication between `getTimestampFromGitTag` and `getTimestampFromGitCommit`. This reduces code without changing behavior.\n\nLooking at the other modified files (audit.zig, graph.zig, stats.zig, backup.zig), the code structure is reasonable and functional. The backup.zig already had a good `collectBackups` helper extracted in the recent changes.\n\nLet me commit the simplification:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":205,"cache_read_input_tokens":74419,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":205},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"fa4500d2-81ee-4869-b3ad-3b718eea20c7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RBfrWyVdfkpxENwWriCk1S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GiNenMvbRs8ALPqiXUTtuf","name":"Bash","input":{"command":"git diff src/cli/changelog.zig","description":"Show the changelog.zig changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":205,"cache_read_input_tokens":74419,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":205},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"9b3a5252-25f7-45ec-8527-c1e2b2acaba8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GiNenMvbRs8ALPqiXUTtuf","type":"tool_result","content":"diff --git a/src/cli/changelog.zig b/src/cli/changelog.zig\nindex d7b5c90..dcdce5a 100644\n--- a/src/cli/changelog.zig\n+++ b/src/cli/changelog.zig\n@@ -281,12 +281,10 @@ fn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n     return era * 146097 + doe - 719468;\n }\n \n-fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n-    // Get the commit timestamp for the given tag\n-    // Format: git log -1 --format=%ct <tag>\n+fn getTimestampFromGitRef(allocator: std.mem.Allocator, git_ref: []const u8, not_found_error: ChangelogError) !i64 {\n     const result = std.process.Child.run(.{\n         .allocator = allocator,\n-        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", git_ref },\n         .cwd = null,\n     }) catch return ChangelogError.GitError;\n \n@@ -294,33 +292,19 @@ fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n     defer allocator.free(result.stdout);\n \n     if (result.term.Exited != 0) {\n-        return ChangelogError.GitTagNotFound;\n+        return not_found_error;\n     }\n \n-    // Parse the timestamp (trim newline)\n     const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n     return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n }\n \n-fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n-    // Get the commit timestamp for the given commit hash\n-    // Format: git log -1 --format=%ct <commit>\n-    const result = std.process.Child.run(.{\n-        .allocator = allocator,\n-        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n-        .cwd = null,\n-    }) catch return ChangelogError.GitError;\n-\n-    defer allocator.free(result.stderr);\n-    defer allocator.free(result.stdout);\n-\n-    if (result.term.Exited != 0) {\n-        return ChangelogError.GitCommitNotFound;\n-    }\n+fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n+    return getTimestampFromGitRef(allocator, tag, ChangelogError.GitTagNotFound);\n+}\n \n-    // Parse the timestamp (trim newline)\n-    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n-    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n+fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n+    return getTimestampFromGitRef(allocator, commit, ChangelogError.GitCommitNotFound);\n }\n \n // --- Tests ---","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"2005d079-6c4d-4658-82de-928295e9bf14","tool_use_result":{"stdout":"diff --git a/src/cli/changelog.zig b/src/cli/changelog.zig\nindex d7b5c90..dcdce5a 100644\n--- a/src/cli/changelog.zig\n+++ b/src/cli/changelog.zig\n@@ -281,12 +281,10 @@ fn epochDayFromDate(year: i32, month: u4, day: u5) i64 {\n     return era * 146097 + doe - 719468;\n }\n \n-fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n-    // Get the commit timestamp for the given tag\n-    // Format: git log -1 --format=%ct <tag>\n+fn getTimestampFromGitRef(allocator: std.mem.Allocator, git_ref: []const u8, not_found_error: ChangelogError) !i64 {\n     const result = std.process.Child.run(.{\n         .allocator = allocator,\n-        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", tag },\n+        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", git_ref },\n         .cwd = null,\n     }) catch return ChangelogError.GitError;\n \n@@ -294,33 +292,19 @@ fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n     defer allocator.free(result.stdout);\n \n     if (result.term.Exited != 0) {\n-        return ChangelogError.GitTagNotFound;\n+        return not_found_error;\n     }\n \n-    // Parse the timestamp (trim newline)\n     const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n     return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n }\n \n-fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n-    // Get the commit timestamp for the given commit hash\n-    // Format: git log -1 --format=%ct <commit>\n-    const result = std.process.Child.run(.{\n-        .allocator = allocator,\n-        .argv = &[_][]const u8{ \"git\", \"log\", \"-1\", \"--format=%ct\", commit },\n-        .cwd = null,\n-    }) catch return ChangelogError.GitError;\n-\n-    defer allocator.free(result.stderr);\n-    defer allocator.free(result.stdout);\n-\n-    if (result.term.Exited != 0) {\n-        return ChangelogError.GitCommitNotFound;\n-    }\n+fn getTimestampFromGitTag(allocator: std.mem.Allocator, tag: []const u8) !i64 {\n+    return getTimestampFromGitRef(allocator, tag, ChangelogError.GitTagNotFound);\n+}\n \n-    // Parse the timestamp (trim newline)\n-    const trimmed = std.mem.trim(u8, result.stdout, \" \\n\\r\\t\");\n-    return std.fmt.parseInt(i64, trimmed, 10) catch return ChangelogError.GitError;\n+fn getTimestampFromGitCommit(allocator: std.mem.Allocator, commit: []const u8) !i64 {\n+    return getTimestampFromGitRef(allocator, commit, ChangelogError.GitCommitNotFound);\n }\n \n // --- Tests ---","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01US57RZP6xnHKruxBpBuyJ7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011EkvcxGurzdJMJGGKUi8L4","name":"Bash","input":{"command":"git add src/cli/changelog.zig && git commit -m \"$(cat <<'EOF'\nrefactor(changelog): extract common git timestamp helper\n\nMerge getTimestampFromGitTag and getTimestampFromGitCommit into a\nshared getTimestampFromGitRef helper to eliminate code duplication.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the simplification"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1176,"cache_read_input_tokens":74624,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1176},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"c306c7d2-1388-405d-a74e-ceaef2009527"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011EkvcxGurzdJMJGGKUi8L4","type":"tool_result","content":"[dev-hotschmoe e9b4226] refactor(changelog): extract common git timestamp helper\n 1 file changed, 8 insertions(+), 24 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"5b7d7b97-f842-478c-b00f-6485f2ec96f2","tool_use_result":{"stdout":"[dev-hotschmoe e9b4226] refactor(changelog): extract common git timestamp helper\n 1 file changed, 8 insertions(+), 24 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DG8mSQSX7xGQDrQzYm41Yh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U2hGissxv1xAtCuXZU8Qci","name":"TodoWrite","input":{"todos":[{"content":"Review recently modified code for simplification opportunities","status":"completed","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes","status":"completed","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":230,"cache_read_input_tokens":75800,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":230},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"5b90a421-629c-4db3-9d2e-c990fb32dd17"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U2hGissxv1xAtCuXZU8Qci","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"3b364914-e0c0-4fa9-9d85-f2eb72600c19","tool_use_result":{"oldTodos":[{"content":"Review recently modified code for simplification opportunities","status":"completed","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes","status":"in_progress","activeForm":"Committing changes"}],"newTodos":[{"content":"Review recently modified code for simplification opportunities","status":"completed","activeForm":"Reviewing modified code"},{"content":"Run tests to verify nothing broke","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes","status":"completed","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A2aavpH6f3idzorFYX3RwF","type":"message","role":"assistant","content":[{"type":"text","text":"Code review and simplification complete:\n\n**Changes made:**\n- Extracted `getTimestampFromGitRef` helper in `src/cli/changelog.zig:284` to eliminate duplication between `getTimestampFromGitTag` and `getTimestampFromGitCommit`\n- Reduced code by 16 lines while preserving identical functionality\n\n**Files reviewed (no changes needed):**\n- `src/cli/audit.zig` - New subcommand structure is well-organized\n- `src/cli/graph.zig` - Compact rendering functions are distinct enough to not warrant merging\n- `src/cli/stats.zig` - Activity stats implementation is clean\n- `src/cli/backup.zig` - Already had `collectBackups` helper properly extracted\n\nAll 694 tests pass."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":177,"cache_read_input_tokens":76030,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":177},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"3427775d-9f02-439a-891d-b9ec8986d232","uuid":"b20f89cf-e82a-468a-9bd1-4732ba1af1ee"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":89266,"duration_api_ms":84987,"num_turns":16,"result":"Code review and simplification complete:\n\n**Changes made:**\n- Extracted `getTimestampFromGitRef` helper in `src/cli/changelog.zig:284` to eliminate duplication between `getTimestampFromGitTag` and `getTimestampFromGitCommit`\n- Reduced code by 16 lines while preserving identical functionality\n\n**Files reviewed (no changes needed):**\n- `src/cli/audit.zig` - New subcommand structure is well-organized\n- `src/cli/graph.zig` - Compact rendering functions are distinct enough to not warrant merging\n- `src/cli/stats.zig` - Activity stats implementation is clean\n- `src/cli/backup.zig` - Already had `collectBackups` helper properly extracted\n\nAll 694 tests pass.","session_id":"3427775d-9f02-439a-891d-b9ec8986d232","total_cost_usd":0.8693445,"usage":{"input_tokens":2,"cache_creation_input_tokens":58231,"cache_read_input_tokens":779993,"output_tokens":2991,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":58231,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":2991,"cacheReadInputTokens":779993,"cacheCreationInputTokens":58231,"webSearchRequests":0,"costUSD":0.8287252500000001,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":8803,"outputTokens":354,"cacheReadInputTokens":0,"cacheCreationInputTokens":24037,"webSearchRequests":0,"costUSD":0.040619249999999996,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"2784c321-259d-4431-9f99-603ee240aa30"}
