{"type":"system","subtype":"init","cwd":"/home/hotschmoe/beads_zig","session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","bd-to-br-migration","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.29","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-simplifier:code-simplifier","build-verifier","coder-sonnet"],"skills":["keybindings-help","bd-to-br-migration"],"plugins":[{"name":"code-simplifier","path":"/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0"}],"uuid":"0d254f08-bb69-4bc4-876b-acbbeea3b7d0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017Sw6iwCAJ9BDeT4a65R7Ao","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mj8LLQpcRnJtukqLN6bnz1","name":"Bash","input":{"command":"git status","description":"Check git status for modified files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3693,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3693},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"b67017eb-4124-4f84-9bc6-7d3da204d865"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mj8LLQpcRnJtukqLN6bnz1","type":"tool_result","content":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 59 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260202_104547_plan_mode.md\n\tsandbox_test/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"b32cdf91-9ecd-464a-b224-75e5e8f4a16b","tool_use_result":{"stdout":"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 59 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260202_104547_plan_mode.md\n\tsandbox_test/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017Sw6iwCAJ9BDeT4a65R7Ao","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E4CJfv3SBwcTebfPuwNXBa","name":"Bash","input":{"command":"git diff --name-only HEAD~3","description":"List files changed in recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":3693,"cache_read_input_tokens":17976,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3693},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"79e9404c-7484-4de7-9403-312422eb199a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E4CJfv3SBwcTebfPuwNXBa","type":"tool_result","content":".beads/issues.jsonl\n.hot_ralph/20260202_103702_plan_mode.md\n.hot_ralph/20260202_103850_plan_simplify.md\n.hot_ralph/state.json\nsrc/cli/args.zig\nsrc/cli/batch.zig\nsrc/cli/create.zig\nsrc/cli/epic.zig\nsrc/id/generator.zig\nsrc/storage/migrations.zig\nsrc/storage/store.zig","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"3842a9f1-0f64-4e64-8dce-74d032ade951","tool_use_result":{"stdout":".beads/issues.jsonl\n.hot_ralph/20260202_103702_plan_mode.md\n.hot_ralph/20260202_103850_plan_simplify.md\n.hot_ralph/state.json\nsrc/cli/args.zig\nsrc/cli/batch.zig\nsrc/cli/create.zig\nsrc/cli/epic.zig\nsrc/id/generator.zig\nsrc/storage/migrations.zig\nsrc/storage/store.zig","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CpSDry3GfujB6NhfGfNkHs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0171QHwsMhwPQPwQzy3Hw8uq","name":"Bash","input":{"command":"git diff HEAD~3 -- src/","description":"Show diff of source code changes in recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":507,"cache_read_input_tokens":21669,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":507},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"a1638fa2-2e5d-4ce6-96a6-bef3022899f1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0171QHwsMhwPQPwQzy3Hw8uq","type":"tool_result","content":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 0112308..179513f 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -744,31 +744,67 @@ pub const ArgParser = struct {\n     }\n \n     /// Parse all arguments into a ParseResult.\n+    /// Global flags can appear before or after the subcommand.\n     pub fn parse(self: *Self) ParseError!ParseResult {\n         var global = GlobalOptions{};\n \n-        // Parse global flags first\n-        while (self.hasNext()) {\n-            const arg = self.peek().?;\n+        // First pass: extract global flags from anywhere in the argument list\n+        // and find the subcommand position\n+        var cmd_index: ?usize = null;\n+        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n+        defer filtered_indices.deinit(self.allocator);\n+\n+        var i: usize = 0;\n+        while (i < self.args.len) {\n+            const arg = self.args[i];\n+\n+            // Try to parse as global flag\n             if (std.mem.startsWith(u8, arg, \"-\")) {\n-                if (self.parseGlobalFlag(&global)) |consumed| {\n-                    if (!consumed) break;\n-                } else |_| {\n-                    break;\n+                if (isGlobalFlag(arg)) |needs_value| {\n+                    // Apply the global flag\n+                    applyGlobalFlag(arg, &global);\n+                    if (needs_value) {\n+                        // Consume the next argument as the value\n+                        i += 1;\n+                        if (i < self.args.len) {\n+                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n+                                return error.InvalidArgument;\n+                            };\n+                        } else {\n+                            return error.MissingFlagValue;\n+                        }\n+                    }\n+                    i += 1;\n+                    continue;\n                 }\n-            } else {\n-                break;\n             }\n+\n+            // Not a global flag - check if it's the subcommand\n+            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n+                cmd_index = filtered_indices.items.len;\n+            }\n+            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n+            i += 1;\n         }\n \n-        // Parse subcommand\n-        const cmd_str = self.next() orelse {\n+        // Reset parser to use filtered indices\n+        // We need to parse command args from the filtered list\n+        if (filtered_indices.items.len == 0) {\n             return .{\n                 .global = global,\n                 .command = .{ .help = .{ .topic = null } },\n             };\n-        };\n+        }\n \n+        // Get the subcommand string\n+        const first_filtered = filtered_indices.items[0];\n+        const cmd_str = self.args[first_filtered];\n+\n+        // Set parser index to after the filtered command for subcommand arg parsing\n+        // We need to skip processed global flags in subsequent parsing\n+        self.index = first_filtered + 1;\n+\n+        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n         const command = try self.parseCommand(cmd_str);\n \n         return .{\n@@ -777,6 +813,81 @@ pub const ArgParser = struct {\n         };\n     }\n \n+    /// Check if an argument is a global flag.\n+    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n+    fn isGlobalFlag(arg: []const u8) ?bool {\n+        // Flags that don't need values\n+        const no_value_flags = [_][]const u8{\n+            \"--json\",\n+            \"--toon\",\n+            \"-q\",\n+            \"--quiet\",\n+            \"-v\",\n+            \"--verbose\",\n+            \"-vv\",\n+            \"--no-color\",\n+            \"--no-auto-flush\",\n+            \"--no-auto-import\",\n+            \"--wrap\",\n+            \"--stats\",\n+            \"--robot\",\n+        };\n+        for (no_value_flags) |flag| {\n+            if (std.mem.eql(u8, arg, flag)) return false;\n+        }\n+\n+        // Flags that need values\n+        const value_flags = [_][]const u8{\n+            \"--data\",\n+            \"--db\",\n+            \"--actor\",\n+            \"--lock-timeout\",\n+        };\n+        for (value_flags) |flag| {\n+            if (std.mem.eql(u8, arg, flag)) return true;\n+        }\n+\n+        return null;\n+    }\n+\n+    /// Apply a global flag (no value).\n+    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n+        if (std.mem.eql(u8, arg, \"--json\")) {\n+            global.json = true;\n+        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n+            global.toon = true;\n+        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n+            global.quiet = true;\n+        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n+            global.verbose +|= 1;\n+        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n+            global.verbose +|= 2;\n+        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n+            global.no_color = true;\n+        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n+            global.no_auto_flush = true;\n+        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n+            global.no_auto_import = true;\n+        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n+            global.wrap = true;\n+        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n+            global.stats = true;\n+        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n+            global.robot = true;\n+        }\n+    }\n+\n+    /// Apply a global flag that requires a value.\n+    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n+        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n+            global.data_path = value;\n+        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n+            global.actor = value;\n+        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n+            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n+        }\n+    }\n+\n     fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n         const arg = self.next().?;\n \n@@ -1999,6 +2110,34 @@ test \"parse global flag --json\" {\n     try std.testing.expect(result.command == .list);\n }\n \n+test \"parse global flag --json after subcommand\" {\n+    const args = [_][]const u8{ \"list\", \"--json\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.global.json);\n+    try std.testing.expect(result.command == .list);\n+}\n+\n+test \"parse global flag --json after subcommand with ready\" {\n+    const args = [_][]const u8{ \"ready\", \"--json\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.global.json);\n+    try std.testing.expect(result.command == .ready);\n+}\n+\n+test \"parse global flags before and after subcommand\" {\n+    const args = [_][]const u8{ \"--quiet\", \"list\", \"--json\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.global.json);\n+    try std.testing.expect(result.global.quiet);\n+    try std.testing.expect(result.command == .list);\n+}\n+\n test \"parse global flag --toon\" {\n     const args = [_][]const u8{ \"--toon\", \"list\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\ndiff --git a/src/cli/batch.zig b/src/cli/batch.zig\nindex fdf272f..433e95c 100644\n--- a/src/cli/batch.zig\n+++ b/src/cli/batch.zig\n@@ -111,7 +111,17 @@ pub fn runAddBatch(\n \n     const now = std.time.timestamp();\n     var generator = IdGenerator.init(prefix);\n-    var issue_count = store.countTotal();\n+    const issue_count = store.countTotal();\n+\n+    // Track IDs generated in this batch to avoid intra-batch collisions\n+    var batch_ids = std.StringHashMap(void).init(allocator);\n+    defer batch_ids.deinit();\n+\n+    // Copy existing IDs to check against\n+    var id_it = store.getIdIndex().keyIterator();\n+    while (id_it.next()) |key| {\n+        try batch_ids.put(key.*, {});\n+    }\n \n     // Parse input and create issues\n     switch (batch_args.format) {\n@@ -122,9 +132,15 @@ pub fn runAddBatch(\n                 if (trimmed.len == 0) continue;\n                 if (trimmed.len > 500) continue; // Skip titles that are too long\n \n-                const issue_id = try generator.generate(allocator, issue_count);\n+                const issue_id = generator.generateUnique(allocator, issue_count + batch_ids.count(), batch_ids) catch |err| {\n+                    if (err == error.CollisionLimitExceeded) {\n+                        try common.outputErrorTyped(BatchResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+                        return BatchError.StorageError;\n+                    }\n+                    return err;\n+                };\n                 errdefer allocator.free(issue_id);\n-                issue_count += 1;\n+                try batch_ids.put(issue_id, {});\n \n                 var issue = Issue.init(issue_id, trimmed, now);\n                 issue.created_by = actor;\n@@ -152,10 +168,17 @@ pub fn runAddBatch(\n                 // If no ID, generate one\n                 var issue = parsed.value;\n                 if (issue.id.len == 0) {\n-                    const new_id = try generator.generate(allocator, issue_count);\n+                    const new_id = generator.generateUnique(allocator, issue_count + batch_ids.count(), batch_ids) catch |err| {\n+                        if (err == error.CollisionLimitExceeded) {\n+                            parsed.deinit();\n+                            try common.outputErrorTyped(BatchResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+                            return BatchError.StorageError;\n+                        }\n+                        return err;\n+                    };\n                     allocator.free(issue.id);\n                     issue.id = new_id;\n-                    issue_count += 1;\n+                    try batch_ids.put(new_id, {});\n                 }\n \n                 try issues_to_add.append(allocator, issue);\ndiff --git a/src/cli/create.zig b/src/cli/create.zig\nindex 1793039..6571e4f 100644\n--- a/src/cli/create.zig\n+++ b/src/cli/create.zig\n@@ -118,10 +118,16 @@ pub fn run(\n     const prefix = try getConfigPrefix(allocator, beads_dir);\n     defer allocator.free(prefix);\n \n-    // Generate ID\n+    // Generate ID with collision checking\n     var generator = IdGenerator.init(prefix);\n     const issue_count = store.countTotal();\n-    const issue_id = try generator.generate(allocator, issue_count);\n+    const issue_id = generator.generateUnique(allocator, issue_count, store.getIdIndex()) catch |err| {\n+        if (err == error.CollisionLimitExceeded) {\n+            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+            return CreateError.StorageError;\n+        }\n+        return err;\n+    };\n     defer allocator.free(issue_id);\n \n     // Create issue\ndiff --git a/src/cli/epic.zig b/src/cli/epic.zig\nindex 2abc6fc..ee5d8c1 100644\n--- a/src/cli/epic.zig\n+++ b/src/cli/epic.zig\n@@ -166,7 +166,13 @@ fn runCreate(\n \n     var generator = id_gen.IdGenerator.init(prefix);\n     const issue_count = store.countTotal();\n-    const issue_id = try generator.generate(allocator, issue_count);\n+    const issue_id = generator.generateUnique(allocator, issue_count, store.getIdIndex()) catch |err| {\n+        if (err == error.CollisionLimitExceeded) {\n+            try common.outputErrorTyped(EpicResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+            return EpicError.StorageError;\n+        }\n+        return err;\n+    };\n     defer allocator.free(issue_id);\n \n     const now = std.time.timestamp();\ndiff --git a/src/id/generator.zig b/src/id/generator.zig\nindex c63fcb1..8db5b73 100644\n--- a/src/id/generator.zig\n+++ b/src/id/generator.zig\n@@ -70,15 +70,51 @@ pub const IdGenerator = struct {\n \n     /// Adaptive hash length based on issue count.\n     /// Uses birthday problem approximation for collision resistance.\n+    ///\n+    /// Target: <0.1% collision probability per generation.\n+    /// Formula: P(collision) ~ n^2 / (2 * S) where S = 36^length\n+    ///\n+    /// Thresholds chosen conservatively:\n+    /// - 3 chars (46,656 space): safe for <100 issues (P < 0.1%)\n+    /// - 4 chars (1.68M space): safe for <1,000 issues (P < 0.03%)\n+    /// - 5 chars (60.5M space): safe for <10,000 issues (P < 0.008%)\n+    /// - 6 chars (2.18B space): safe for <100,000 issues\n+    /// - 7 chars (78.4B space): safe for <1,000,000 issues\n+    /// - 8 chars (2.82T space): safe for any practical count\n     fn adaptiveLength(self: IdGenerator, count: usize) u8 {\n-        // 36^3 = 46,656 - safe for <1000 issues\n-        // 36^4 = 1,679,616 - safe for <50,000 issues\n-        // 36^5 = 60,466,176 - safe for <1,000,000 issues\n-        // 36^6 = 2,176,782,336 - safe for >1,000,000 issues\n-        if (count < 1000) return @max(self.min_length, 3);\n-        if (count < 50000) return @max(self.min_length, 4);\n-        if (count < 1000000) return @max(self.min_length, 5);\n-        return @min(self.max_length, 6);\n+        if (count < 100) return @max(self.min_length, 3);\n+        if (count < 1000) return @max(self.min_length, 4);\n+        if (count < 10000) return @max(self.min_length, 5);\n+        if (count < 100000) return @max(self.min_length, 6);\n+        if (count < 1000000) return @max(self.min_length, 7);\n+        return @min(self.max_length, 8);\n+    }\n+\n+    /// Generate a unique issue ID with collision checking.\n+    /// Retries up to max_retries times if ID already exists.\n+    /// Returns error.CollisionLimitExceeded if all retries fail.\n+    pub fn generateUnique(\n+        self: *IdGenerator,\n+        allocator: std.mem.Allocator,\n+        issue_count: usize,\n+        existing_ids: anytype,\n+    ) ![]u8 {\n+        const max_retries = 10;\n+        var attempts: usize = 0;\n+\n+        while (attempts < max_retries) : (attempts += 1) {\n+            const id = try self.generate(allocator, issue_count);\n+\n+            // Check if ID already exists\n+            if (!existing_ids.contains(id)) {\n+                return id;\n+            }\n+\n+            // ID collision - free and retry\n+            allocator.free(id);\n+        }\n+\n+        return error.CollisionLimitExceeded;\n     }\n \n     /// Generate child ID for hierarchical issues.\n@@ -174,19 +210,19 @@ test \"IdGenerator.generate adaptive length increases with count\" {\n     const parsed_small = try parseId(id_small);\n     try std.testing.expect(parsed_small.hash.len >= 3);\n \n-    // With 50000 issues, should use longer hashes\n+    // With 1000 issues, should use 5-char hashes (new threshold)\n     var gen2 = IdGenerator.initWithSeed(\"bd\", 12345);\n-    const id_medium = try gen2.generate(allocator, 50000);\n+    const id_medium = try gen2.generate(allocator, 1000);\n     defer allocator.free(id_medium);\n     const parsed_medium = try parseId(id_medium);\n-    try std.testing.expect(parsed_medium.hash.len >= 4);\n+    try std.testing.expect(parsed_medium.hash.len >= 5);\n \n-    // With 1000000 issues, should use even longer hashes\n+    // With 1000000 issues, should use 8-char hashes (max)\n     var gen3 = IdGenerator.initWithSeed(\"bd\", 12345);\n     const id_large = try gen3.generate(allocator, 1000000);\n     defer allocator.free(id_large);\n     const parsed_large = try parseId(id_large);\n-    try std.testing.expect(parsed_large.hash.len >= 5);\n+    try std.testing.expect(parsed_large.hash.len >= 8);\n }\n \n test \"IdGenerator.generateChild creates hierarchical ID\" {\n@@ -264,10 +300,10 @@ test \"generated IDs are unique\" {\n     }\n \n     // Generate IDs and check for collisions.\n-    // Pass issue_count=1000 to use 4-char hashes (36^4 = 1,679,616 space).\n-    // With 50 IDs, birthday collision probability is negligible (~0.07%).\n+    // Pass issue_count=10000 to use 6-char hashes (36^6 = 2.18B space).\n+    // With 50 IDs, birthday collision probability is negligible.\n     const count = 50;\n-    const base_count = 1000; // Force 4-char hashes for better uniqueness\n+    const base_count = 10000; // Force 6-char hashes for better uniqueness\n     for (0..count) |i| {\n         const id = try gen.generate(allocator, base_count + i);\n         errdefer allocator.free(id);\n@@ -293,3 +329,24 @@ test \"custom prefix works\" {\n     try std.testing.expect(std.mem.startsWith(u8, id, \"myapp-\"));\n     try std.testing.expect(validateId(id));\n }\n+\n+test \"generateUnique avoids collisions\" {\n+    const allocator = std.testing.allocator;\n+    var gen = IdGenerator.initWithSeed(\"bd\", 42);\n+\n+    // Create a set with one pre-existing ID\n+    var existing = std.StringHashMap(void).init(allocator);\n+    defer existing.deinit();\n+\n+    // Generate first ID\n+    const id1 = try gen.generate(allocator, 0);\n+    defer allocator.free(id1);\n+    try existing.put(id1, {});\n+\n+    // generateUnique should return a different ID\n+    const id2 = try gen.generateUnique(allocator, 0, existing);\n+    defer allocator.free(id2);\n+\n+    try std.testing.expect(!std.mem.eql(u8, id1, id2));\n+    try std.testing.expect(!existing.contains(id2));\n+}\ndiff --git a/src/storage/migrations.zig b/src/storage/migrations.zig\nindex 02d61bd..661c22f 100644\n--- a/src/storage/migrations.zig\n+++ b/src/storage/migrations.zig\n@@ -8,9 +8,10 @@\n //!   const result = try migrations.migrateIfNeeded(allocator, \".beads\");\n \n const std = @import(\"std\");\n+const version_cmd = @import(\"../cli/version.zig\");\n \n-/// Current bz version - should match cli/version.zig VERSION constant.\n-pub const BZ_VERSION: []const u8 = \"0.1.5\";\n+/// Current bz version - imported from version.zig to avoid duplication.\n+pub const BZ_VERSION: []const u8 = version_cmd.VERSION;\n \n /// Current schema version expected by this build.\n pub const CURRENT_SCHEMA_VERSION: u32 = 1;\ndiff --git a/src/storage/store.zig b/src/storage/store.zig\nindex 1d120c5..0a20375 100644\n--- a/src/storage/store.zig\n+++ b/src/storage/store.zig\n@@ -190,6 +190,11 @@ pub const IssueStore = struct {\n         return &self.issues.items[idx];\n     }\n \n+    /// Get read-only access to the ID index for collision checking.\n+    pub fn getIdIndex(self: *const Self) std.StringHashMapUnmanaged(usize) {\n+        return self.id_index;\n+    }\n+\n     /// Fields that can be updated on an issue.\n     pub const IssueUpdate = struct {\n         title: ?[]const u8 = null,","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"b42cbba8-a469-4357-a920-8bfa53eb45bb","tool_use_result":{"stdout":"diff --git a/src/cli/args.zig b/src/cli/args.zig\nindex 0112308..179513f 100644\n--- a/src/cli/args.zig\n+++ b/src/cli/args.zig\n@@ -744,31 +744,67 @@ pub const ArgParser = struct {\n     }\n \n     /// Parse all arguments into a ParseResult.\n+    /// Global flags can appear before or after the subcommand.\n     pub fn parse(self: *Self) ParseError!ParseResult {\n         var global = GlobalOptions{};\n \n-        // Parse global flags first\n-        while (self.hasNext()) {\n-            const arg = self.peek().?;\n+        // First pass: extract global flags from anywhere in the argument list\n+        // and find the subcommand position\n+        var cmd_index: ?usize = null;\n+        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n+        defer filtered_indices.deinit(self.allocator);\n+\n+        var i: usize = 0;\n+        while (i < self.args.len) {\n+            const arg = self.args[i];\n+\n+            // Try to parse as global flag\n             if (std.mem.startsWith(u8, arg, \"-\")) {\n-                if (self.parseGlobalFlag(&global)) |consumed| {\n-                    if (!consumed) break;\n-                } else |_| {\n-                    break;\n+                if (isGlobalFlag(arg)) |needs_value| {\n+                    // Apply the global flag\n+                    applyGlobalFlag(arg, &global);\n+                    if (needs_value) {\n+                        // Consume the next argument as the value\n+                        i += 1;\n+                        if (i < self.args.len) {\n+                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n+                                return error.InvalidArgument;\n+                            };\n+                        } else {\n+                            return error.MissingFlagValue;\n+                        }\n+                    }\n+                    i += 1;\n+                    continue;\n                 }\n-            } else {\n-                break;\n             }\n+\n+            // Not a global flag - check if it's the subcommand\n+            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n+                cmd_index = filtered_indices.items.len;\n+            }\n+            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n+            i += 1;\n         }\n \n-        // Parse subcommand\n-        const cmd_str = self.next() orelse {\n+        // Reset parser to use filtered indices\n+        // We need to parse command args from the filtered list\n+        if (filtered_indices.items.len == 0) {\n             return .{\n                 .global = global,\n                 .command = .{ .help = .{ .topic = null } },\n             };\n-        };\n+        }\n \n+        // Get the subcommand string\n+        const first_filtered = filtered_indices.items[0];\n+        const cmd_str = self.args[first_filtered];\n+\n+        // Set parser index to after the filtered command for subcommand arg parsing\n+        // We need to skip processed global flags in subsequent parsing\n+        self.index = first_filtered + 1;\n+\n+        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n         const command = try self.parseCommand(cmd_str);\n \n         return .{\n@@ -777,6 +813,81 @@ pub const ArgParser = struct {\n         };\n     }\n \n+    /// Check if an argument is a global flag.\n+    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n+    fn isGlobalFlag(arg: []const u8) ?bool {\n+        // Flags that don't need values\n+        const no_value_flags = [_][]const u8{\n+            \"--json\",\n+            \"--toon\",\n+            \"-q\",\n+            \"--quiet\",\n+            \"-v\",\n+            \"--verbose\",\n+            \"-vv\",\n+            \"--no-color\",\n+            \"--no-auto-flush\",\n+            \"--no-auto-import\",\n+            \"--wrap\",\n+            \"--stats\",\n+            \"--robot\",\n+        };\n+        for (no_value_flags) |flag| {\n+            if (std.mem.eql(u8, arg, flag)) return false;\n+        }\n+\n+        // Flags that need values\n+        const value_flags = [_][]const u8{\n+            \"--data\",\n+            \"--db\",\n+            \"--actor\",\n+            \"--lock-timeout\",\n+        };\n+        for (value_flags) |flag| {\n+            if (std.mem.eql(u8, arg, flag)) return true;\n+        }\n+\n+        return null;\n+    }\n+\n+    /// Apply a global flag (no value).\n+    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n+        if (std.mem.eql(u8, arg, \"--json\")) {\n+            global.json = true;\n+        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n+            global.toon = true;\n+        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n+            global.quiet = true;\n+        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n+            global.verbose +|= 1;\n+        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n+            global.verbose +|= 2;\n+        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n+            global.no_color = true;\n+        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n+            global.no_auto_flush = true;\n+        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n+            global.no_auto_import = true;\n+        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n+            global.wrap = true;\n+        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n+            global.stats = true;\n+        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n+            global.robot = true;\n+        }\n+    }\n+\n+    /// Apply a global flag that requires a value.\n+    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n+        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n+            global.data_path = value;\n+        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n+            global.actor = value;\n+        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n+            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n+        }\n+    }\n+\n     fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n         const arg = self.next().?;\n \n@@ -1999,6 +2110,34 @@ test \"parse global flag --json\" {\n     try std.testing.expect(result.command == .list);\n }\n \n+test \"parse global flag --json after subcommand\" {\n+    const args = [_][]const u8{ \"list\", \"--json\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.global.json);\n+    try std.testing.expect(result.command == .list);\n+}\n+\n+test \"parse global flag --json after subcommand with ready\" {\n+    const args = [_][]const u8{ \"ready\", \"--json\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.global.json);\n+    try std.testing.expect(result.command == .ready);\n+}\n+\n+test \"parse global flags before and after subcommand\" {\n+    const args = [_][]const u8{ \"--quiet\", \"list\", \"--json\" };\n+    var parser = ArgParser.init(std.testing.allocator, &args);\n+    const result = try parser.parse();\n+\n+    try std.testing.expect(result.global.json);\n+    try std.testing.expect(result.global.quiet);\n+    try std.testing.expect(result.command == .list);\n+}\n+\n test \"parse global flag --toon\" {\n     const args = [_][]const u8{ \"--toon\", \"list\" };\n     var parser = ArgParser.init(std.testing.allocator, &args);\ndiff --git a/src/cli/batch.zig b/src/cli/batch.zig\nindex fdf272f..433e95c 100644\n--- a/src/cli/batch.zig\n+++ b/src/cli/batch.zig\n@@ -111,7 +111,17 @@ pub fn runAddBatch(\n \n     const now = std.time.timestamp();\n     var generator = IdGenerator.init(prefix);\n-    var issue_count = store.countTotal();\n+    const issue_count = store.countTotal();\n+\n+    // Track IDs generated in this batch to avoid intra-batch collisions\n+    var batch_ids = std.StringHashMap(void).init(allocator);\n+    defer batch_ids.deinit();\n+\n+    // Copy existing IDs to check against\n+    var id_it = store.getIdIndex().keyIterator();\n+    while (id_it.next()) |key| {\n+        try batch_ids.put(key.*, {});\n+    }\n \n     // Parse input and create issues\n     switch (batch_args.format) {\n@@ -122,9 +132,15 @@ pub fn runAddBatch(\n                 if (trimmed.len == 0) continue;\n                 if (trimmed.len > 500) continue; // Skip titles that are too long\n \n-                const issue_id = try generator.generate(allocator, issue_count);\n+                const issue_id = generator.generateUnique(allocator, issue_count + batch_ids.count(), batch_ids) catch |err| {\n+                    if (err == error.CollisionLimitExceeded) {\n+                        try common.outputErrorTyped(BatchResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+                        return BatchError.StorageError;\n+                    }\n+                    return err;\n+                };\n                 errdefer allocator.free(issue_id);\n-                issue_count += 1;\n+                try batch_ids.put(issue_id, {});\n \n                 var issue = Issue.init(issue_id, trimmed, now);\n                 issue.created_by = actor;\n@@ -152,10 +168,17 @@ pub fn runAddBatch(\n                 // If no ID, generate one\n                 var issue = parsed.value;\n                 if (issue.id.len == 0) {\n-                    const new_id = try generator.generate(allocator, issue_count);\n+                    const new_id = generator.generateUnique(allocator, issue_count + batch_ids.count(), batch_ids) catch |err| {\n+                        if (err == error.CollisionLimitExceeded) {\n+                            parsed.deinit();\n+                            try common.outputErrorTyped(BatchResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+                            return BatchError.StorageError;\n+                        }\n+                        return err;\n+                    };\n                     allocator.free(issue.id);\n                     issue.id = new_id;\n-                    issue_count += 1;\n+                    try batch_ids.put(new_id, {});\n                 }\n \n                 try issues_to_add.append(allocator, issue);\ndiff --git a/src/cli/create.zig b/src/cli/create.zig\nindex 1793039..6571e4f 100644\n--- a/src/cli/create.zig\n+++ b/src/cli/create.zig\n@@ -118,10 +118,16 @@ pub fn run(\n     const prefix = try getConfigPrefix(allocator, beads_dir);\n     defer allocator.free(prefix);\n \n-    // Generate ID\n+    // Generate ID with collision checking\n     var generator = IdGenerator.init(prefix);\n     const issue_count = store.countTotal();\n-    const issue_id = try generator.generate(allocator, issue_count);\n+    const issue_id = generator.generateUnique(allocator, issue_count, store.getIdIndex()) catch |err| {\n+        if (err == error.CollisionLimitExceeded) {\n+            try common.outputErrorTyped(CreateResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+            return CreateError.StorageError;\n+        }\n+        return err;\n+    };\n     defer allocator.free(issue_id);\n \n     // Create issue\ndiff --git a/src/cli/epic.zig b/src/cli/epic.zig\nindex 2abc6fc..ee5d8c1 100644\n--- a/src/cli/epic.zig\n+++ b/src/cli/epic.zig\n@@ -166,7 +166,13 @@ fn runCreate(\n \n     var generator = id_gen.IdGenerator.init(prefix);\n     const issue_count = store.countTotal();\n-    const issue_id = try generator.generate(allocator, issue_count);\n+    const issue_id = generator.generateUnique(allocator, issue_count, store.getIdIndex()) catch |err| {\n+        if (err == error.CollisionLimitExceeded) {\n+            try common.outputErrorTyped(EpicResult, &output, structured_output, \"failed to generate unique ID after multiple attempts\");\n+            return EpicError.StorageError;\n+        }\n+        return err;\n+    };\n     defer allocator.free(issue_id);\n \n     const now = std.time.timestamp();\ndiff --git a/src/id/generator.zig b/src/id/generator.zig\nindex c63fcb1..8db5b73 100644\n--- a/src/id/generator.zig\n+++ b/src/id/generator.zig\n@@ -70,15 +70,51 @@ pub const IdGenerator = struct {\n \n     /// Adaptive hash length based on issue count.\n     /// Uses birthday problem approximation for collision resistance.\n+    ///\n+    /// Target: <0.1% collision probability per generation.\n+    /// Formula: P(collision) ~ n^2 / (2 * S) where S = 36^length\n+    ///\n+    /// Thresholds chosen conservatively:\n+    /// - 3 chars (46,656 space): safe for <100 issues (P < 0.1%)\n+    /// - 4 chars (1.68M space): safe for <1,000 issues (P < 0.03%)\n+    /// - 5 chars (60.5M space): safe for <10,000 issues (P < 0.008%)\n+    /// - 6 chars (2.18B space): safe for <100,000 issues\n+    /// - 7 chars (78.4B space): safe for <1,000,000 issues\n+    /// - 8 chars (2.82T space): safe for any practical count\n     fn adaptiveLength(self: IdGenerator, count: usize) u8 {\n-        // 36^3 = 46,656 - safe for <1000 issues\n-        // 36^4 = 1,679,616 - safe for <50,000 issues\n-        // 36^5 = 60,466,176 - safe for <1,000,000 issues\n-        // 36^6 = 2,176,782,336 - safe for >1,000,000 issues\n-        if (count < 1000) return @max(self.min_length, 3);\n-        if (count < 50000) return @max(self.min_length, 4);\n-        if (count < 1000000) return @max(self.min_length, 5);\n-        return @min(self.max_length, 6);\n+        if (count < 100) return @max(self.min_length, 3);\n+        if (count < 1000) return @max(self.min_length, 4);\n+        if (count < 10000) return @max(self.min_length, 5);\n+        if (count < 100000) return @max(self.min_length, 6);\n+        if (count < 1000000) return @max(self.min_length, 7);\n+        return @min(self.max_length, 8);\n+    }\n+\n+    /// Generate a unique issue ID with collision checking.\n+    /// Retries up to max_retries times if ID already exists.\n+    /// Returns error.CollisionLimitExceeded if all retries fail.\n+    pub fn generateUnique(\n+        self: *IdGenerator,\n+        allocator: std.mem.Allocator,\n+        issue_count: usize,\n+        existing_ids: anytype,\n+    ) ![]u8 {\n+        const max_retries = 10;\n+        var attempts: usize = 0;\n+\n+        while (attempts < max_retries) : (attempts += 1) {\n+            const id = try self.generate(allocator, issue_count);\n+\n+            // Check if ID already exists\n+            if (!existing_ids.contains(id)) {\n+                return id;\n+            }\n+\n+            // ID collision - free and retry\n+            allocator.free(id);\n+        }\n+\n+        return error.CollisionLimitExceeded;\n     }\n \n     /// Generate child ID for hierarchical issues.\n@@ -174,19 +210,19 @@ test \"IdGenerator.generate adaptive length increases with count\" {\n     const parsed_small = try parseId(id_small);\n     try std.testing.expect(parsed_small.hash.len >= 3);\n \n-    // With 50000 issues, should use longer hashes\n+    // With 1000 issues, should use 5-char hashes (new threshold)\n     var gen2 = IdGenerator.initWithSeed(\"bd\", 12345);\n-    const id_medium = try gen2.generate(allocator, 50000);\n+    const id_medium = try gen2.generate(allocator, 1000);\n     defer allocator.free(id_medium);\n     const parsed_medium = try parseId(id_medium);\n-    try std.testing.expect(parsed_medium.hash.len >= 4);\n+    try std.testing.expect(parsed_medium.hash.len >= 5);\n \n-    // With 1000000 issues, should use even longer hashes\n+    // With 1000000 issues, should use 8-char hashes (max)\n     var gen3 = IdGenerator.initWithSeed(\"bd\", 12345);\n     const id_large = try gen3.generate(allocator, 1000000);\n     defer allocator.free(id_large);\n     const parsed_large = try parseId(id_large);\n-    try std.testing.expect(parsed_large.hash.len >= 5);\n+    try std.testing.expect(parsed_large.hash.len >= 8);\n }\n \n test \"IdGenerator.generateChild creates hierarchical ID\" {\n@@ -264,10 +300,10 @@ test \"generated IDs are unique\" {\n     }\n \n     // Generate IDs and check for collisions.\n-    // Pass issue_count=1000 to use 4-char hashes (36^4 = 1,679,616 space).\n-    // With 50 IDs, birthday collision probability is negligible (~0.07%).\n+    // Pass issue_count=10000 to use 6-char hashes (36^6 = 2.18B space).\n+    // With 50 IDs, birthday collision probability is negligible.\n     const count = 50;\n-    const base_count = 1000; // Force 4-char hashes for better uniqueness\n+    const base_count = 10000; // Force 6-char hashes for better uniqueness\n     for (0..count) |i| {\n         const id = try gen.generate(allocator, base_count + i);\n         errdefer allocator.free(id);\n@@ -293,3 +329,24 @@ test \"custom prefix works\" {\n     try std.testing.expect(std.mem.startsWith(u8, id, \"myapp-\"));\n     try std.testing.expect(validateId(id));\n }\n+\n+test \"generateUnique avoids collisions\" {\n+    const allocator = std.testing.allocator;\n+    var gen = IdGenerator.initWithSeed(\"bd\", 42);\n+\n+    // Create a set with one pre-existing ID\n+    var existing = std.StringHashMap(void).init(allocator);\n+    defer existing.deinit();\n+\n+    // Generate first ID\n+    const id1 = try gen.generate(allocator, 0);\n+    defer allocator.free(id1);\n+    try existing.put(id1, {});\n+\n+    // generateUnique should return a different ID\n+    const id2 = try gen.generateUnique(allocator, 0, existing);\n+    defer allocator.free(id2);\n+\n+    try std.testing.expect(!std.mem.eql(u8, id1, id2));\n+    try std.testing.expect(!existing.contains(id2));\n+}\ndiff --git a/src/storage/migrations.zig b/src/storage/migrations.zig\nindex 02d61bd..661c22f 100644\n--- a/src/storage/migrations.zig\n+++ b/src/storage/migrations.zig\n@@ -8,9 +8,10 @@\n //!   const result = try migrations.migrateIfNeeded(allocator, \".beads\");\n \n const std = @import(\"std\");\n+const version_cmd = @import(\"../cli/version.zig\");\n \n-/// Current bz version - should match cli/version.zig VERSION constant.\n-pub const BZ_VERSION: []const u8 = \"0.1.5\";\n+/// Current bz version - imported from version.zig to avoid duplication.\n+pub const BZ_VERSION: []const u8 = version_cmd.VERSION;\n \n /// Current schema version expected by this build.\n pub const CURRENT_SCHEMA_VERSION: u32 = 1;\ndiff --git a/src/storage/store.zig b/src/storage/store.zig\nindex 1d120c5..0a20375 100644\n--- a/src/storage/store.zig\n+++ b/src/storage/store.zig\n@@ -190,6 +190,11 @@ pub const IssueStore = struct {\n         return &self.issues.items[idx];\n     }\n \n+    /// Get read-only access to the ID index for collision checking.\n+    pub fn getIdIndex(self: *const Self) std.StringHashMapUnmanaged(usize) {\n+        return self.id_index;\n+    }\n+\n     /// Fields that can be updated on an issue.\n     pub const IssueUpdate = struct {\n         title: ?[]const u8 = null,","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XDgo3LYZiQHJuC2x3LLnsr","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the modified files to understand the changes better and identify simplification opportunities."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6288,"cache_read_input_tokens":22176,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6288},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"3650db79-4d79-4b78-b01e-33b9abbfb4a6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XDgo3LYZiQHJuC2x3LLnsr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Wd34sM25YGwKtTpQpnYwAB","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":744,"limit":170}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6288,"cache_read_input_tokens":22176,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6288},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"5322f985-4f3e-432d-96c3-14a7e80914be"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Wd34sM25YGwKtTpQpnYwAB","type":"tool_result","content":"   744→    }\n   745→\n   746→    /// Parse all arguments into a ParseResult.\n   747→    /// Global flags can appear before or after the subcommand.\n   748→    pub fn parse(self: *Self) ParseError!ParseResult {\n   749→        var global = GlobalOptions{};\n   750→\n   751→        // First pass: extract global flags from anywhere in the argument list\n   752→        // and find the subcommand position\n   753→        var cmd_index: ?usize = null;\n   754→        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n   755→        defer filtered_indices.deinit(self.allocator);\n   756→\n   757→        var i: usize = 0;\n   758→        while (i < self.args.len) {\n   759→            const arg = self.args[i];\n   760→\n   761→            // Try to parse as global flag\n   762→            if (std.mem.startsWith(u8, arg, \"-\")) {\n   763→                if (isGlobalFlag(arg)) |needs_value| {\n   764→                    // Apply the global flag\n   765→                    applyGlobalFlag(arg, &global);\n   766→                    if (needs_value) {\n   767→                        // Consume the next argument as the value\n   768→                        i += 1;\n   769→                        if (i < self.args.len) {\n   770→                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n   771→                                return error.InvalidArgument;\n   772→                            };\n   773→                        } else {\n   774→                            return error.MissingFlagValue;\n   775→                        }\n   776→                    }\n   777→                    i += 1;\n   778→                    continue;\n   779→                }\n   780→            }\n   781→\n   782→            // Not a global flag - check if it's the subcommand\n   783→            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n   784→                cmd_index = filtered_indices.items.len;\n   785→            }\n   786→            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n   787→            i += 1;\n   788→        }\n   789→\n   790→        // Reset parser to use filtered indices\n   791→        // We need to parse command args from the filtered list\n   792→        if (filtered_indices.items.len == 0) {\n   793→            return .{\n   794→                .global = global,\n   795→                .command = .{ .help = .{ .topic = null } },\n   796→            };\n   797→        }\n   798→\n   799→        // Get the subcommand string\n   800→        const first_filtered = filtered_indices.items[0];\n   801→        const cmd_str = self.args[first_filtered];\n   802→\n   803→        // Set parser index to after the filtered command for subcommand arg parsing\n   804→        // We need to skip processed global flags in subsequent parsing\n   805→        self.index = first_filtered + 1;\n   806→\n   807→        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n   808→        const command = try self.parseCommand(cmd_str);\n   809→\n   810→        return .{\n   811→            .global = global,\n   812→            .command = command,\n   813→        };\n   814→    }\n   815→\n   816→    /// Check if an argument is a global flag.\n   817→    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n   818→    fn isGlobalFlag(arg: []const u8) ?bool {\n   819→        // Flags that don't need values\n   820→        const no_value_flags = [_][]const u8{\n   821→            \"--json\",\n   822→            \"--toon\",\n   823→            \"-q\",\n   824→            \"--quiet\",\n   825→            \"-v\",\n   826→            \"--verbose\",\n   827→            \"-vv\",\n   828→            \"--no-color\",\n   829→            \"--no-auto-flush\",\n   830→            \"--no-auto-import\",\n   831→            \"--wrap\",\n   832→            \"--stats\",\n   833→            \"--robot\",\n   834→        };\n   835→        for (no_value_flags) |flag| {\n   836→            if (std.mem.eql(u8, arg, flag)) return false;\n   837→        }\n   838→\n   839→        // Flags that need values\n   840→        const value_flags = [_][]const u8{\n   841→            \"--data\",\n   842→            \"--db\",\n   843→            \"--actor\",\n   844→            \"--lock-timeout\",\n   845→        };\n   846→        for (value_flags) |flag| {\n   847→            if (std.mem.eql(u8, arg, flag)) return true;\n   848→        }\n   849→\n   850→        return null;\n   851→    }\n   852→\n   853→    /// Apply a global flag (no value).\n   854→    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n   855→        if (std.mem.eql(u8, arg, \"--json\")) {\n   856→            global.json = true;\n   857→        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n   858→            global.toon = true;\n   859→        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   860→            global.quiet = true;\n   861→        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   862→            global.verbose +|= 1;\n   863→        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n   864→            global.verbose +|= 2;\n   865→        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n   866→            global.no_color = true;\n   867→        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n   868→            global.no_auto_flush = true;\n   869→        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n   870→            global.no_auto_import = true;\n   871→        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n   872→            global.wrap = true;\n   873→        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n   874→            global.stats = true;\n   875→        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n   876→            global.robot = true;\n   877→        }\n   878→    }\n   879→\n   880→    /// Apply a global flag that requires a value.\n   881→    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n   882→        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n   883→            global.data_path = value;\n   884→        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n   885→            global.actor = value;\n   886→        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n   887→            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n   888→        }\n   889→    }\n   890→\n   891→    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n   892→        const arg = self.next().?;\n   893→\n   894→        if (std.mem.eql(u8, arg, \"--json\")) {\n   895→            global.json = true;\n   896→            return true;\n   897→        }\n   898→        if (std.mem.eql(u8, arg, \"--toon\")) {\n   899→            global.toon = true;\n   900→            return true;\n   901→        }\n   902→        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   903→            global.quiet = true;\n   904→            return true;\n   905→        }\n   906→        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   907→            global.verbose +|= 1;\n   908→            return true;\n   909→        }\n   910→        if (std.mem.eql(u8, arg, \"-vv\")) {\n   911→            global.verbose +|= 2;\n   912→            return true;\n   913→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"0b5051a5-0caf-46c3-a711-b0380a2354ef","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"    }\n\n    /// Parse all arguments into a ParseResult.\n    /// Global flags can appear before or after the subcommand.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // First pass: extract global flags from anywhere in the argument list\n        // and find the subcommand position\n        var cmd_index: ?usize = null;\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n        defer filtered_indices.deinit(self.allocator);\n\n        var i: usize = 0;\n        while (i < self.args.len) {\n            const arg = self.args[i];\n\n            // Try to parse as global flag\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (isGlobalFlag(arg)) |needs_value| {\n                    // Apply the global flag\n                    applyGlobalFlag(arg, &global);\n                    if (needs_value) {\n                        // Consume the next argument as the value\n                        i += 1;\n                        if (i < self.args.len) {\n                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n                                return error.InvalidArgument;\n                            };\n                        } else {\n                            return error.MissingFlagValue;\n                        }\n                    }\n                    i += 1;\n                    continue;\n                }\n            }\n\n            // Not a global flag - check if it's the subcommand\n            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n                cmd_index = filtered_indices.items.len;\n            }\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n            i += 1;\n        }\n\n        // Reset parser to use filtered indices\n        // We need to parse command args from the filtered list\n        if (filtered_indices.items.len == 0) {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        }\n\n        // Get the subcommand string\n        const first_filtered = filtered_indices.items[0];\n        const cmd_str = self.args[first_filtered];\n\n        // Set parser index to after the filtered command for subcommand arg parsing\n        // We need to skip processed global flags in subsequent parsing\n        self.index = first_filtered + 1;\n\n        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    /// Check if an argument is a global flag.\n    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n    fn isGlobalFlag(arg: []const u8) ?bool {\n        // Flags that don't need values\n        const no_value_flags = [_][]const u8{\n            \"--json\",\n            \"--toon\",\n            \"-q\",\n            \"--quiet\",\n            \"-v\",\n            \"--verbose\",\n            \"-vv\",\n            \"--no-color\",\n            \"--no-auto-flush\",\n            \"--no-auto-import\",\n            \"--wrap\",\n            \"--stats\",\n            \"--robot\",\n        };\n        for (no_value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return false;\n        }\n\n        // Flags that need values\n        const value_flags = [_][]const u8{\n            \"--data\",\n            \"--db\",\n            \"--actor\",\n            \"--lock-timeout\",\n        };\n        for (value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return true;\n        }\n\n        return null;\n    }\n\n    /// Apply a global flag (no value).\n    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n        }\n    }\n\n    /// Apply a global flag that requires a value.\n    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n            global.data_path = value;\n        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n            global.actor = value;\n        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n        }\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }","numLines":170,"startLine":744,"totalLines":3062}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XDgo3LYZiQHJuC2x3LLnsr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H7AoHKiudDd51RHjcJqWg7","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/id/generator.zig"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6288,"cache_read_input_tokens":22176,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":6288},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"76a72f29-7439-4002-92c5-587a1b126174"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H7AoHKiudDd51RHjcJqWg7","type":"tool_result","content":"     1→//! Issue ID generation with adaptive length.\n     2→//!\n     3→//! Generates unique issue IDs in the format: <prefix>-<hash>\n     4→//! - prefix: Configurable, default \"bd\"\n     5→//! - hash: Base36 encoded, adaptive length (3-8 chars)\n     6→//!\n     7→//! The hash length adapts based on issue count to maintain\n     8→//! low collision probability while keeping IDs short.\n     9→\n    10→const std = @import(\"std\");\n    11→const base36 = @import(\"base36.zig\");\n    12→\n    13→pub const IdGenerator = struct {\n    14→    prefix: []const u8,\n    15→    min_length: u8,\n    16→    max_length: u8,\n    17→    prng: std.Random.DefaultPrng,\n    18→\n    19→    pub fn init(prefix: []const u8) IdGenerator {\n    20→        const timestamp = std.time.nanoTimestamp();\n    21→        const seed: u64 = @truncate(@as(u128, @bitCast(timestamp)));\n    22→        return .{\n    23→            .prefix = prefix,\n    24→            .min_length = 3,\n    25→            .max_length = 8,\n    26→            .prng = std.Random.DefaultPrng.init(seed),\n    27→        };\n    28→    }\n    29→\n    30→    pub fn initWithSeed(prefix: []const u8, seed: u64) IdGenerator {\n    31→        return .{\n    32→            .prefix = prefix,\n    33→            .min_length = 3,\n    34→            .max_length = 8,\n    35→            .prng = std.Random.DefaultPrng.init(seed),\n    36→        };\n    37→    }\n    38→\n    39→    /// Generate a new issue ID.\n    40→    /// Format: <prefix>-<base36_hash>\n    41→    /// Example: \"bd-a3f8k2\"\n    42→    pub fn generate(self: *IdGenerator, allocator: std.mem.Allocator, issue_count: usize) ![]u8 {\n    43→        // 1. Generate 16 random bytes\n    44→        var random_bytes: [16]u8 = undefined;\n    45→        self.prng.random().bytes(&random_bytes);\n    46→\n    47→        // 2. Mix with nanosecond timestamp\n    48→        const timestamp_i128 = std.time.nanoTimestamp();\n    49→        const timestamp: u64 = @truncate(@as(u128, @bitCast(timestamp_i128)));\n    50→        var hasher = std.crypto.hash.sha2.Sha256.init(.{});\n    51→        hasher.update(&random_bytes);\n    52→        hasher.update(std.mem.asBytes(&timestamp));\n    53→        const digest = hasher.finalResult();\n    54→\n    55→        // 3. Take first 8 bytes as u64 for base36 encoding\n    56→        const hash_value = std.mem.readInt(u64, digest[0..8], .big);\n    57→\n    58→        // 4. Encode as base36\n    59→        var hash_buf: [base36.MAX_U64_ENCODED_LEN]u8 = undefined;\n    60→        const hash_str = base36.encode(hash_value, &hash_buf);\n    61→\n    62→        // 5. Truncate to adaptive length\n    63→        const hash_length = self.adaptiveLength(issue_count);\n    64→        const final_len = @min(hash_str.len, hash_length);\n    65→        const final_hash = hash_str[0..final_len];\n    66→\n    67→        // 6. Format: prefix-hash\n    68→        return std.fmt.allocPrint(allocator, \"{s}-{s}\", .{ self.prefix, final_hash });\n    69→    }\n    70→\n    71→    /// Adaptive hash length based on issue count.\n    72→    /// Uses birthday problem approximation for collision resistance.\n    73→    ///\n    74→    /// Target: <0.1% collision probability per generation.\n    75→    /// Formula: P(collision) ~ n^2 / (2 * S) where S = 36^length\n    76→    ///\n    77→    /// Thresholds chosen conservatively:\n    78→    /// - 3 chars (46,656 space): safe for <100 issues (P < 0.1%)\n    79→    /// - 4 chars (1.68M space): safe for <1,000 issues (P < 0.03%)\n    80→    /// - 5 chars (60.5M space): safe for <10,000 issues (P < 0.008%)\n    81→    /// - 6 chars (2.18B space): safe for <100,000 issues\n    82→    /// - 7 chars (78.4B space): safe for <1,000,000 issues\n    83→    /// - 8 chars (2.82T space): safe for any practical count\n    84→    fn adaptiveLength(self: IdGenerator, count: usize) u8 {\n    85→        if (count < 100) return @max(self.min_length, 3);\n    86→        if (count < 1000) return @max(self.min_length, 4);\n    87→        if (count < 10000) return @max(self.min_length, 5);\n    88→        if (count < 100000) return @max(self.min_length, 6);\n    89→        if (count < 1000000) return @max(self.min_length, 7);\n    90→        return @min(self.max_length, 8);\n    91→    }\n    92→\n    93→    /// Generate a unique issue ID with collision checking.\n    94→    /// Retries up to max_retries times if ID already exists.\n    95→    /// Returns error.CollisionLimitExceeded if all retries fail.\n    96→    pub fn generateUnique(\n    97→        self: *IdGenerator,\n    98→        allocator: std.mem.Allocator,\n    99→        issue_count: usize,\n   100→        existing_ids: anytype,\n   101→    ) ![]u8 {\n   102→        const max_retries = 10;\n   103→        var attempts: usize = 0;\n   104→\n   105→        while (attempts < max_retries) : (attempts += 1) {\n   106→            const id = try self.generate(allocator, issue_count);\n   107→\n   108→            // Check if ID already exists\n   109→            if (!existing_ids.contains(id)) {\n   110→                return id;\n   111→            }\n   112→\n   113→            // ID collision - free and retry\n   114→            allocator.free(id);\n   115→        }\n   116→\n   117→        return error.CollisionLimitExceeded;\n   118→    }\n   119→\n   120→    /// Generate child ID for hierarchical issues.\n   121→    /// Example: \"bd-abc123\" -> \"bd-abc123.1\"\n   122→    /// Maximum 3 levels per SPEC (parent, child, grandchild).\n   123→    pub fn generateChild(\n   124→        _: *IdGenerator,\n   125→        allocator: std.mem.Allocator,\n   126→        parent_id: []const u8,\n   127→        child_index: u32,\n   128→    ) ![]u8 {\n   129→        // Validate depth (max 3 levels per SPEC)\n   130→        const depth = std.mem.count(u8, parent_id, \".\");\n   131→        if (depth >= 2) return error.MaxHierarchyDepthExceeded;\n   132→\n   133→        return std.fmt.allocPrint(allocator, \"{s}.{d}\", .{ parent_id, child_index });\n   134→    }\n   135→};\n   136→\n   137→/// Parsed components of an issue ID.\n   138→pub const ParsedId = struct {\n   139→    prefix: []const u8,\n   140→    hash: []const u8,\n   141→    child_path: ?[]const u8,\n   142→};\n   143→\n   144→/// Parse an ID into its components.\n   145→pub fn parseId(id: []const u8) !ParsedId {\n   146→    // Find prefix-hash boundary\n   147→    const dash_idx = std.mem.indexOf(u8, id, \"-\") orelse return error.InvalidIssueId;\n   148→    if (dash_idx == 0) return error.InvalidIssueId;\n   149→\n   150→    const prefix = id[0..dash_idx];\n   151→    const rest = id[dash_idx + 1 ..];\n   152→    if (rest.len == 0) return error.InvalidIssueId;\n   153→\n   154→    // Find hash-child boundary\n   155→    if (std.mem.indexOf(u8, rest, \".\")) |dot_idx| {\n   156→        if (dot_idx == 0) return error.InvalidIssueId;\n   157→        const child = rest[dot_idx + 1 ..];\n   158→        if (child.len == 0) return error.InvalidIssueId;\n   159→        return .{\n   160→            .prefix = prefix,\n   161→            .hash = rest[0..dot_idx],\n   162→            .child_path = child,\n   163→        };\n   164→    }\n   165→\n   166→    return .{\n   167→        .prefix = prefix,\n   168→        .hash = rest,\n   169→        .child_path = null,\n   170→    };\n   171→}\n   172→\n   173→/// Validate ID format.\n   174→pub fn validateId(id: []const u8) bool {\n   175→    const parsed = parseId(id) catch return false;\n   176→    _ = base36.decode(parsed.hash) catch return false;\n   177→    return true;\n   178→}\n   179→\n   180→// --- Tests ---\n   181→\n   182→test \"IdGenerator.init creates generator with defaults\" {\n   183→    const gen = IdGenerator.init(\"bd\");\n   184→    try std.testing.expectEqualStrings(\"bd\", gen.prefix);\n   185→    try std.testing.expectEqual(@as(u8, 3), gen.min_length);\n   186→    try std.testing.expectEqual(@as(u8, 8), gen.max_length);\n   187→}\n   188→\n   189→test \"IdGenerator.generate produces valid format\" {\n   190→    const allocator = std.testing.allocator;\n   191→    var gen = IdGenerator.initWithSeed(\"bd\", 12345);\n   192→\n   193→    const id = try gen.generate(allocator, 0);\n   194→    defer allocator.free(id);\n   195→\n   196→    // Should start with prefix\n   197→    try std.testing.expect(std.mem.startsWith(u8, id, \"bd-\"));\n   198→\n   199→    // Should be valid\n   200→    try std.testing.expect(validateId(id));\n   201→}\n   202→\n   203→test \"IdGenerator.generate adaptive length increases with count\" {\n   204→    const allocator = std.testing.allocator;\n   205→    var gen = IdGenerator.initWithSeed(\"bd\", 12345);\n   206→\n   207→    // With 0 issues, should use minimum length (3)\n   208→    const id_small = try gen.generate(allocator, 0);\n   209→    defer allocator.free(id_small);\n   210→    const parsed_small = try parseId(id_small);\n   211→    try std.testing.expect(parsed_small.hash.len >= 3);\n   212→\n   213→    // With 1000 issues, should use 5-char hashes (new threshold)\n   214→    var gen2 = IdGenerator.initWithSeed(\"bd\", 12345);\n   215→    const id_medium = try gen2.generate(allocator, 1000);\n   216→    defer allocator.free(id_medium);\n   217→    const parsed_medium = try parseId(id_medium);\n   218→    try std.testing.expect(parsed_medium.hash.len >= 5);\n   219→\n   220→    // With 1000000 issues, should use 8-char hashes (max)\n   221→    var gen3 = IdGenerator.initWithSeed(\"bd\", 12345);\n   222→    const id_large = try gen3.generate(allocator, 1000000);\n   223→    defer allocator.free(id_large);\n   224→    const parsed_large = try parseId(id_large);\n   225→    try std.testing.expect(parsed_large.hash.len >= 8);\n   226→}\n   227→\n   228→test \"IdGenerator.generateChild creates hierarchical ID\" {\n   229→    const allocator = std.testing.allocator;\n   230→    var gen = IdGenerator.init(\"bd\");\n   231→\n   232→    const child = try gen.generateChild(allocator, \"bd-abc123\", 1);\n   233→    defer allocator.free(child);\n   234→    try std.testing.expectEqualStrings(\"bd-abc123.1\", child);\n   235→\n   236→    const grandchild = try gen.generateChild(allocator, \"bd-abc123.1\", 2);\n   237→    defer allocator.free(grandchild);\n   238→    try std.testing.expectEqualStrings(\"bd-abc123.1.2\", grandchild);\n   239→}\n   240→\n   241→test \"IdGenerator.generateChild rejects too deep hierarchy\" {\n   242→    const allocator = std.testing.allocator;\n   243→    var gen = IdGenerator.init(\"bd\");\n   244→\n   245→    // bd-abc123.1.2 already has 2 dots, can't go deeper\n   246→    try std.testing.expectError(\n   247→        error.MaxHierarchyDepthExceeded,\n   248→        gen.generateChild(allocator, \"bd-abc123.1.2\", 3),\n   249→    );\n   250→}\n   251→\n   252→test \"parseId extracts components\" {\n   253→    const parsed = try parseId(\"bd-abc123\");\n   254→    try std.testing.expectEqualStrings(\"bd\", parsed.prefix);\n   255→    try std.testing.expectEqualStrings(\"abc123\", parsed.hash);\n   256→    try std.testing.expectEqual(@as(?[]const u8, null), parsed.child_path);\n   257→}\n   258→\n   259→test \"parseId extracts child path\" {\n   260→    const parsed = try parseId(\"bd-abc123.1.2\");\n   261→    try std.testing.expectEqualStrings(\"bd\", parsed.prefix);\n   262→    try std.testing.expectEqualStrings(\"abc123\", parsed.hash);\n   263→    try std.testing.expectEqualStrings(\"1.2\", parsed.child_path.?);\n   264→}\n   265→\n   266→test \"parseId rejects invalid formats\" {\n   267→    try std.testing.expectError(error.InvalidIssueId, parseId(\"invalid\"));\n   268→    try std.testing.expectError(error.InvalidIssueId, parseId(\"-abc\"));\n   269→    try std.testing.expectError(error.InvalidIssueId, parseId(\"bd-\"));\n   270→    try std.testing.expectError(error.InvalidIssueId, parseId(\"bd-.1\"));\n   271→}\n   272→\n   273→test \"validateId accepts valid IDs\" {\n   274→    try std.testing.expect(validateId(\"bd-abc\"));\n   275→    try std.testing.expect(validateId(\"bd-a3f8k2\"));\n   276→    try std.testing.expect(validateId(\"custom-xyz789\"));\n   277→    try std.testing.expect(validateId(\"bd-abc123.1\"));\n   278→    try std.testing.expect(validateId(\"bd-abc123.1.2\"));\n   279→}\n   280→\n   281→test \"validateId rejects invalid IDs\" {\n   282→    try std.testing.expect(!validateId(\"invalid\"));\n   283→    try std.testing.expect(!validateId(\"-abc\"));\n   284→    try std.testing.expect(!validateId(\"bd-\"));\n   285→    try std.testing.expect(!validateId(\"\"));\n   286→    try std.testing.expect(!validateId(\"bd-!!!\"));\n   287→}\n   288→\n   289→test \"generated IDs are unique\" {\n   290→    const allocator = std.testing.allocator;\n   291→    var gen = IdGenerator.initWithSeed(\"bd\", 42);\n   292→\n   293→    var ids = std.StringHashMap(void).init(allocator);\n   294→    defer {\n   295→        var iter = ids.keyIterator();\n   296→        while (iter.next()) |key| {\n   297→            allocator.free(key.*);\n   298→        }\n   299→        ids.deinit();\n   300→    }\n   301→\n   302→    // Generate IDs and check for collisions.\n   303→    // Pass issue_count=10000 to use 6-char hashes (36^6 = 2.18B space).\n   304→    // With 50 IDs, birthday collision probability is negligible.\n   305→    const count = 50;\n   306→    const base_count = 10000; // Force 6-char hashes for better uniqueness\n   307→    for (0..count) |i| {\n   308→        const id = try gen.generate(allocator, base_count + i);\n   309→        errdefer allocator.free(id);\n   310→\n   311→        if (ids.contains(id)) {\n   312→            std.debug.print(\"Collision detected: {s}\\n\", .{id});\n   313→            try std.testing.expect(false);\n   314→        }\n   315→\n   316→        try ids.put(id, {});\n   317→    }\n   318→\n   319→    try std.testing.expectEqual(count, ids.count());\n   320→}\n   321→\n   322→test \"custom prefix works\" {\n   323→    const allocator = std.testing.allocator;\n   324→    var gen = IdGenerator.initWithSeed(\"myapp\", 12345);\n   325→\n   326→    const id = try gen.generate(allocator, 0);\n   327→    defer allocator.free(id);\n   328→\n   329→    try std.testing.expect(std.mem.startsWith(u8, id, \"myapp-\"));\n   330→    try std.testing.expect(validateId(id));\n   331→}\n   332→\n   333→test \"generateUnique avoids collisions\" {\n   334→    const allocator = std.testing.allocator;\n   335→    var gen = IdGenerator.initWithSeed(\"bd\", 42);\n   336→\n   337→    // Create a set with one pre-existing ID\n   338→    var existing = std.StringHashMap(void).init(allocator);\n   339→    defer existing.deinit();\n   340→\n   341→    // Generate first ID\n   342→    const id1 = try gen.generate(allocator, 0);\n   343→    defer allocator.free(id1);\n   344→    try existing.put(id1, {});\n   345→\n   346→    // generateUnique should return a different ID\n   347→    const id2 = try gen.generateUnique(allocator, 0, existing);\n   348→    defer allocator.free(id2);\n   349→\n   350→    try std.testing.expect(!std.mem.eql(u8, id1, id2));\n   351→    try std.testing.expect(!existing.contains(id2));\n   352→}\n   353→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"57931a54-d614-4c36-b895-64d0112bee81","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/id/generator.zig","content":"//! Issue ID generation with adaptive length.\n//!\n//! Generates unique issue IDs in the format: <prefix>-<hash>\n//! - prefix: Configurable, default \"bd\"\n//! - hash: Base36 encoded, adaptive length (3-8 chars)\n//!\n//! The hash length adapts based on issue count to maintain\n//! low collision probability while keeping IDs short.\n\nconst std = @import(\"std\");\nconst base36 = @import(\"base36.zig\");\n\npub const IdGenerator = struct {\n    prefix: []const u8,\n    min_length: u8,\n    max_length: u8,\n    prng: std.Random.DefaultPrng,\n\n    pub fn init(prefix: []const u8) IdGenerator {\n        const timestamp = std.time.nanoTimestamp();\n        const seed: u64 = @truncate(@as(u128, @bitCast(timestamp)));\n        return .{\n            .prefix = prefix,\n            .min_length = 3,\n            .max_length = 8,\n            .prng = std.Random.DefaultPrng.init(seed),\n        };\n    }\n\n    pub fn initWithSeed(prefix: []const u8, seed: u64) IdGenerator {\n        return .{\n            .prefix = prefix,\n            .min_length = 3,\n            .max_length = 8,\n            .prng = std.Random.DefaultPrng.init(seed),\n        };\n    }\n\n    /// Generate a new issue ID.\n    /// Format: <prefix>-<base36_hash>\n    /// Example: \"bd-a3f8k2\"\n    pub fn generate(self: *IdGenerator, allocator: std.mem.Allocator, issue_count: usize) ![]u8 {\n        // 1. Generate 16 random bytes\n        var random_bytes: [16]u8 = undefined;\n        self.prng.random().bytes(&random_bytes);\n\n        // 2. Mix with nanosecond timestamp\n        const timestamp_i128 = std.time.nanoTimestamp();\n        const timestamp: u64 = @truncate(@as(u128, @bitCast(timestamp_i128)));\n        var hasher = std.crypto.hash.sha2.Sha256.init(.{});\n        hasher.update(&random_bytes);\n        hasher.update(std.mem.asBytes(&timestamp));\n        const digest = hasher.finalResult();\n\n        // 3. Take first 8 bytes as u64 for base36 encoding\n        const hash_value = std.mem.readInt(u64, digest[0..8], .big);\n\n        // 4. Encode as base36\n        var hash_buf: [base36.MAX_U64_ENCODED_LEN]u8 = undefined;\n        const hash_str = base36.encode(hash_value, &hash_buf);\n\n        // 5. Truncate to adaptive length\n        const hash_length = self.adaptiveLength(issue_count);\n        const final_len = @min(hash_str.len, hash_length);\n        const final_hash = hash_str[0..final_len];\n\n        // 6. Format: prefix-hash\n        return std.fmt.allocPrint(allocator, \"{s}-{s}\", .{ self.prefix, final_hash });\n    }\n\n    /// Adaptive hash length based on issue count.\n    /// Uses birthday problem approximation for collision resistance.\n    ///\n    /// Target: <0.1% collision probability per generation.\n    /// Formula: P(collision) ~ n^2 / (2 * S) where S = 36^length\n    ///\n    /// Thresholds chosen conservatively:\n    /// - 3 chars (46,656 space): safe for <100 issues (P < 0.1%)\n    /// - 4 chars (1.68M space): safe for <1,000 issues (P < 0.03%)\n    /// - 5 chars (60.5M space): safe for <10,000 issues (P < 0.008%)\n    /// - 6 chars (2.18B space): safe for <100,000 issues\n    /// - 7 chars (78.4B space): safe for <1,000,000 issues\n    /// - 8 chars (2.82T space): safe for any practical count\n    fn adaptiveLength(self: IdGenerator, count: usize) u8 {\n        if (count < 100) return @max(self.min_length, 3);\n        if (count < 1000) return @max(self.min_length, 4);\n        if (count < 10000) return @max(self.min_length, 5);\n        if (count < 100000) return @max(self.min_length, 6);\n        if (count < 1000000) return @max(self.min_length, 7);\n        return @min(self.max_length, 8);\n    }\n\n    /// Generate a unique issue ID with collision checking.\n    /// Retries up to max_retries times if ID already exists.\n    /// Returns error.CollisionLimitExceeded if all retries fail.\n    pub fn generateUnique(\n        self: *IdGenerator,\n        allocator: std.mem.Allocator,\n        issue_count: usize,\n        existing_ids: anytype,\n    ) ![]u8 {\n        const max_retries = 10;\n        var attempts: usize = 0;\n\n        while (attempts < max_retries) : (attempts += 1) {\n            const id = try self.generate(allocator, issue_count);\n\n            // Check if ID already exists\n            if (!existing_ids.contains(id)) {\n                return id;\n            }\n\n            // ID collision - free and retry\n            allocator.free(id);\n        }\n\n        return error.CollisionLimitExceeded;\n    }\n\n    /// Generate child ID for hierarchical issues.\n    /// Example: \"bd-abc123\" -> \"bd-abc123.1\"\n    /// Maximum 3 levels per SPEC (parent, child, grandchild).\n    pub fn generateChild(\n        _: *IdGenerator,\n        allocator: std.mem.Allocator,\n        parent_id: []const u8,\n        child_index: u32,\n    ) ![]u8 {\n        // Validate depth (max 3 levels per SPEC)\n        const depth = std.mem.count(u8, parent_id, \".\");\n        if (depth >= 2) return error.MaxHierarchyDepthExceeded;\n\n        return std.fmt.allocPrint(allocator, \"{s}.{d}\", .{ parent_id, child_index });\n    }\n};\n\n/// Parsed components of an issue ID.\npub const ParsedId = struct {\n    prefix: []const u8,\n    hash: []const u8,\n    child_path: ?[]const u8,\n};\n\n/// Parse an ID into its components.\npub fn parseId(id: []const u8) !ParsedId {\n    // Find prefix-hash boundary\n    const dash_idx = std.mem.indexOf(u8, id, \"-\") orelse return error.InvalidIssueId;\n    if (dash_idx == 0) return error.InvalidIssueId;\n\n    const prefix = id[0..dash_idx];\n    const rest = id[dash_idx + 1 ..];\n    if (rest.len == 0) return error.InvalidIssueId;\n\n    // Find hash-child boundary\n    if (std.mem.indexOf(u8, rest, \".\")) |dot_idx| {\n        if (dot_idx == 0) return error.InvalidIssueId;\n        const child = rest[dot_idx + 1 ..];\n        if (child.len == 0) return error.InvalidIssueId;\n        return .{\n            .prefix = prefix,\n            .hash = rest[0..dot_idx],\n            .child_path = child,\n        };\n    }\n\n    return .{\n        .prefix = prefix,\n        .hash = rest,\n        .child_path = null,\n    };\n}\n\n/// Validate ID format.\npub fn validateId(id: []const u8) bool {\n    const parsed = parseId(id) catch return false;\n    _ = base36.decode(parsed.hash) catch return false;\n    return true;\n}\n\n// --- Tests ---\n\ntest \"IdGenerator.init creates generator with defaults\" {\n    const gen = IdGenerator.init(\"bd\");\n    try std.testing.expectEqualStrings(\"bd\", gen.prefix);\n    try std.testing.expectEqual(@as(u8, 3), gen.min_length);\n    try std.testing.expectEqual(@as(u8, 8), gen.max_length);\n}\n\ntest \"IdGenerator.generate produces valid format\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.initWithSeed(\"bd\", 12345);\n\n    const id = try gen.generate(allocator, 0);\n    defer allocator.free(id);\n\n    // Should start with prefix\n    try std.testing.expect(std.mem.startsWith(u8, id, \"bd-\"));\n\n    // Should be valid\n    try std.testing.expect(validateId(id));\n}\n\ntest \"IdGenerator.generate adaptive length increases with count\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.initWithSeed(\"bd\", 12345);\n\n    // With 0 issues, should use minimum length (3)\n    const id_small = try gen.generate(allocator, 0);\n    defer allocator.free(id_small);\n    const parsed_small = try parseId(id_small);\n    try std.testing.expect(parsed_small.hash.len >= 3);\n\n    // With 1000 issues, should use 5-char hashes (new threshold)\n    var gen2 = IdGenerator.initWithSeed(\"bd\", 12345);\n    const id_medium = try gen2.generate(allocator, 1000);\n    defer allocator.free(id_medium);\n    const parsed_medium = try parseId(id_medium);\n    try std.testing.expect(parsed_medium.hash.len >= 5);\n\n    // With 1000000 issues, should use 8-char hashes (max)\n    var gen3 = IdGenerator.initWithSeed(\"bd\", 12345);\n    const id_large = try gen3.generate(allocator, 1000000);\n    defer allocator.free(id_large);\n    const parsed_large = try parseId(id_large);\n    try std.testing.expect(parsed_large.hash.len >= 8);\n}\n\ntest \"IdGenerator.generateChild creates hierarchical ID\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.init(\"bd\");\n\n    const child = try gen.generateChild(allocator, \"bd-abc123\", 1);\n    defer allocator.free(child);\n    try std.testing.expectEqualStrings(\"bd-abc123.1\", child);\n\n    const grandchild = try gen.generateChild(allocator, \"bd-abc123.1\", 2);\n    defer allocator.free(grandchild);\n    try std.testing.expectEqualStrings(\"bd-abc123.1.2\", grandchild);\n}\n\ntest \"IdGenerator.generateChild rejects too deep hierarchy\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.init(\"bd\");\n\n    // bd-abc123.1.2 already has 2 dots, can't go deeper\n    try std.testing.expectError(\n        error.MaxHierarchyDepthExceeded,\n        gen.generateChild(allocator, \"bd-abc123.1.2\", 3),\n    );\n}\n\ntest \"parseId extracts components\" {\n    const parsed = try parseId(\"bd-abc123\");\n    try std.testing.expectEqualStrings(\"bd\", parsed.prefix);\n    try std.testing.expectEqualStrings(\"abc123\", parsed.hash);\n    try std.testing.expectEqual(@as(?[]const u8, null), parsed.child_path);\n}\n\ntest \"parseId extracts child path\" {\n    const parsed = try parseId(\"bd-abc123.1.2\");\n    try std.testing.expectEqualStrings(\"bd\", parsed.prefix);\n    try std.testing.expectEqualStrings(\"abc123\", parsed.hash);\n    try std.testing.expectEqualStrings(\"1.2\", parsed.child_path.?);\n}\n\ntest \"parseId rejects invalid formats\" {\n    try std.testing.expectError(error.InvalidIssueId, parseId(\"invalid\"));\n    try std.testing.expectError(error.InvalidIssueId, parseId(\"-abc\"));\n    try std.testing.expectError(error.InvalidIssueId, parseId(\"bd-\"));\n    try std.testing.expectError(error.InvalidIssueId, parseId(\"bd-.1\"));\n}\n\ntest \"validateId accepts valid IDs\" {\n    try std.testing.expect(validateId(\"bd-abc\"));\n    try std.testing.expect(validateId(\"bd-a3f8k2\"));\n    try std.testing.expect(validateId(\"custom-xyz789\"));\n    try std.testing.expect(validateId(\"bd-abc123.1\"));\n    try std.testing.expect(validateId(\"bd-abc123.1.2\"));\n}\n\ntest \"validateId rejects invalid IDs\" {\n    try std.testing.expect(!validateId(\"invalid\"));\n    try std.testing.expect(!validateId(\"-abc\"));\n    try std.testing.expect(!validateId(\"bd-\"));\n    try std.testing.expect(!validateId(\"\"));\n    try std.testing.expect(!validateId(\"bd-!!!\"));\n}\n\ntest \"generated IDs are unique\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.initWithSeed(\"bd\", 42);\n\n    var ids = std.StringHashMap(void).init(allocator);\n    defer {\n        var iter = ids.keyIterator();\n        while (iter.next()) |key| {\n            allocator.free(key.*);\n        }\n        ids.deinit();\n    }\n\n    // Generate IDs and check for collisions.\n    // Pass issue_count=10000 to use 6-char hashes (36^6 = 2.18B space).\n    // With 50 IDs, birthday collision probability is negligible.\n    const count = 50;\n    const base_count = 10000; // Force 6-char hashes for better uniqueness\n    for (0..count) |i| {\n        const id = try gen.generate(allocator, base_count + i);\n        errdefer allocator.free(id);\n\n        if (ids.contains(id)) {\n            std.debug.print(\"Collision detected: {s}\\n\", .{id});\n            try std.testing.expect(false);\n        }\n\n        try ids.put(id, {});\n    }\n\n    try std.testing.expectEqual(count, ids.count());\n}\n\ntest \"custom prefix works\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.initWithSeed(\"myapp\", 12345);\n\n    const id = try gen.generate(allocator, 0);\n    defer allocator.free(id);\n\n    try std.testing.expect(std.mem.startsWith(u8, id, \"myapp-\"));\n    try std.testing.expect(validateId(id));\n}\n\ntest \"generateUnique avoids collisions\" {\n    const allocator = std.testing.allocator;\n    var gen = IdGenerator.initWithSeed(\"bd\", 42);\n\n    // Create a set with one pre-existing ID\n    var existing = std.StringHashMap(void).init(allocator);\n    defer existing.deinit();\n\n    // Generate first ID\n    const id1 = try gen.generate(allocator, 0);\n    defer allocator.free(id1);\n    try existing.put(id1, {});\n\n    // generateUnique should return a different ID\n    const id2 = try gen.generateUnique(allocator, 0, existing);\n    defer allocator.free(id2);\n\n    try std.testing.expect(!std.mem.eql(u8, id1, id2));\n    try std.testing.expect(!existing.contains(id2));\n}\n","numLines":353,"startLine":1,"totalLines":353}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RGxc9r7jtreiCCuTyaDj8F","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check if `parseGlobalFlag` is still being used anywhere, since the new code uses standalone functions instead."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7913,"cache_read_input_tokens":28464,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7913},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"3d74610f-6db9-4069-80cf-3f123d7959df"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RGxc9r7jtreiCCuTyaDj8F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FaUGGfUo85LNe7Uh3zekb3","name":"Grep","input":{"pattern":"parseGlobalFlag","path":"/home/hotschmoe/beads_zig/src","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7913,"cache_read_input_tokens":28464,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":7913},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"4d3edc26-9b31-44ec-aaa7-08d7a17cb8cf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FaUGGfUo85LNe7Uh3zekb3","type":"tool_result","content":"src/cli/args.zig:891:    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"f1b3dac6-d8fc-4bbf-8c10-ea12a1c62063","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"src/cli/args.zig:891:    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {","numLines":1}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TSzCXihtfcC9EgsTLYeQeE","type":"message","role":"assistant","content":[{"type":"text","text":"The `parseGlobalFlag` function is defined but no longer called. Let me verify this by reading more of the args.zig file to see the full context."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":178,"cache_read_input_tokens":36377,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":178},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"868bd351-73b8-4eab-8316-8433a15d4ee6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TSzCXihtfcC9EgsTLYeQeE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PdzXnTkkxZ5WeTC3tNaCzB","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":891,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":178,"cache_read_input_tokens":36377,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":178},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"629064fe-da26-45b2-948e-40943c13d29e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PdzXnTkkxZ5WeTC3tNaCzB","type":"tool_result","content":"   891→    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n   892→        const arg = self.next().?;\n   893→\n   894→        if (std.mem.eql(u8, arg, \"--json\")) {\n   895→            global.json = true;\n   896→            return true;\n   897→        }\n   898→        if (std.mem.eql(u8, arg, \"--toon\")) {\n   899→            global.toon = true;\n   900→            return true;\n   901→        }\n   902→        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n   903→            global.quiet = true;\n   904→            return true;\n   905→        }\n   906→        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n   907→            global.verbose +|= 1;\n   908→            return true;\n   909→        }\n   910→        if (std.mem.eql(u8, arg, \"-vv\")) {\n   911→            global.verbose +|= 2;\n   912→            return true;\n   913→        }\n   914→        if (std.mem.eql(u8, arg, \"--no-color\")) {\n   915→            global.no_color = true;\n   916→            return true;\n   917→        }\n   918→        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n   919→            global.no_auto_flush = true;\n   920→            return true;\n   921→        }\n   922→        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n   923→            global.no_auto_import = true;\n   924→            return true;\n   925→        }\n   926→        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n   927→            global.data_path = self.next() orelse return error.MissingFlagValue;\n   928→            return true;\n   929→        }\n   930→        if (std.mem.eql(u8, arg, \"--actor\")) {\n   931→            global.actor = self.next() orelse return error.MissingFlagValue;\n   932→            return true;\n   933→        }\n   934→        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n   935→            const val = self.next() orelse return error.MissingFlagValue;\n   936→            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n   937→            return true;\n   938→        }\n   939→        if (std.mem.eql(u8, arg, \"--wrap\")) {\n   940→            global.wrap = true;\n   941→            return true;\n   942→        }\n   943→        if (std.mem.eql(u8, arg, \"--stats\")) {\n   944→            global.stats = true;\n   945→            return true;\n   946→        }\n   947→        if (std.mem.eql(u8, arg, \"--robot\")) {\n   948→            global.robot = true;\n   949→            return true;\n   950→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"63308337-2124-4a4c-b4b7-8143181c480d","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }","numLines":60,"startLine":891,"totalLines":3062}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EiqrJY99wneJunnSbdPtZd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01R5kvNTbA2FfVG2ToPwc86h","name":"Read","input":{"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","offset":948,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1208,"cache_read_input_tokens":36555,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1208},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"0896284d-872d-42eb-90a9-257e07c76fec"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R5kvNTbA2FfVG2ToPwc86h","type":"tool_result","content":"   948→            global.robot = true;\n   949→            return true;\n   950→        }\n   951→\n   952→        // Put back if not recognized\n   953→        self.index -= 1;\n   954→        return error.UnknownFlag;\n   955→    }\n   956→\n   957→    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n   958→        // Workspace\n   959→        if (std.mem.eql(u8, cmd, \"init\")) {\n   960→            return .{ .init = try self.parseInitArgs() };\n   961→        }\n   962→        if (std.mem.eql(u8, cmd, \"info\")) {\n   963→            return .{ .info = {} };\n   964→        }\n   965→        if (std.mem.eql(u8, cmd, \"stats\")) {\n   966→            return .{ .stats = try self.parseStatsArgs() };\n   967→        }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"6f8ec3b1-3e1d-4152-9d2d-5a068c2a59b0","tool_use_result":{"type":"text","file":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","content":"            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }","numLines":20,"startLine":948,"totalLines":3062}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Hbf5T8qubXBxuRxuaWZGZW","type":"message","role":"assistant","content":[{"type":"text","text":"I can see that `parseGlobalFlag` is now dead code - the new `parse()` function uses the standalone `isGlobalFlag`, `applyGlobalFlag`, and `applyGlobalFlagValue` functions instead. There's also redundancy: the same flag handling logic is duplicated between the old `parseGlobalFlag` and the new helper functions.\n\nLet me also check the `cmd_index` variable in `parse()` - it's assigned but never used."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":447,"cache_read_input_tokens":37763,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":447},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"fefc2f05-19aa-4b28-9c83-876a6aa3a5f4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Hbf5T8qubXBxuRxuaWZGZW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XsqTRvfMNk9c2B33U76M16","name":"TodoWrite","input":{"todos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"in_progress","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"pending","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":447,"cache_read_input_tokens":37763,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":447},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"635063ab-47df-4ca5-963c-88f34b5359d4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XsqTRvfMNk9c2B33U76M16","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"2b5828ca-56c4-4ece-b7ec-30f27d2eb8e4","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"in_progress","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"pending","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018k73DCPMaqsTtoNd2pm64v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014LL4v3PNRKoBc4PkXbcCas","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand","new_string":"    fn parseCommand"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":333,"cache_read_input_tokens":38210,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":333},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"4dd924ea-79a0-425c-9b3a-3d4234a57d25"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014LL4v3PNRKoBc4PkXbcCas","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"7b2bdcdb-e9e8-42aa-82c0-ed13824b7155","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand","newString":"    fn parseCommand","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n    dry_run: bool = false, // Preview issue creation without persisting\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n    all: bool = false, // Show dependency graph for all open issues\n    compact: bool = false, // Compact one-line-per-issue output\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    since_tag: ?[]const u8 = null, // Git tag for start date (e.g., \"v1.0.0\")\n    since_commit: ?[]const u8 = null, // Git commit for start date (e.g., \"abc123\")\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    dry_run: bool = false, // Show what would be updated without installing\n    version: ?[]const u8 = null,\n    verify: bool = true, // Verify checksum (default: on)\n    force: bool = false, // Force upgrade even if same version\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    /// Global flags can appear before or after the subcommand.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // First pass: extract global flags from anywhere in the argument list\n        // and find the subcommand position\n        var cmd_index: ?usize = null;\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n        defer filtered_indices.deinit(self.allocator);\n\n        var i: usize = 0;\n        while (i < self.args.len) {\n            const arg = self.args[i];\n\n            // Try to parse as global flag\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (isGlobalFlag(arg)) |needs_value| {\n                    // Apply the global flag\n                    applyGlobalFlag(arg, &global);\n                    if (needs_value) {\n                        // Consume the next argument as the value\n                        i += 1;\n                        if (i < self.args.len) {\n                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n                                return error.InvalidArgument;\n                            };\n                        } else {\n                            return error.MissingFlagValue;\n                        }\n                    }\n                    i += 1;\n                    continue;\n                }\n            }\n\n            // Not a global flag - check if it's the subcommand\n            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n                cmd_index = filtered_indices.items.len;\n            }\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n            i += 1;\n        }\n\n        // Reset parser to use filtered indices\n        // We need to parse command args from the filtered list\n        if (filtered_indices.items.len == 0) {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        }\n\n        // Get the subcommand string\n        const first_filtered = filtered_indices.items[0];\n        const cmd_str = self.args[first_filtered];\n\n        // Set parser index to after the filtered command for subcommand arg parsing\n        // We need to skip processed global flags in subsequent parsing\n        self.index = first_filtered + 1;\n\n        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    /// Check if an argument is a global flag.\n    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n    fn isGlobalFlag(arg: []const u8) ?bool {\n        // Flags that don't need values\n        const no_value_flags = [_][]const u8{\n            \"--json\",\n            \"--toon\",\n            \"-q\",\n            \"--quiet\",\n            \"-v\",\n            \"--verbose\",\n            \"-vv\",\n            \"--no-color\",\n            \"--no-auto-flush\",\n            \"--no-auto-import\",\n            \"--wrap\",\n            \"--stats\",\n            \"--robot\",\n        };\n        for (no_value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return false;\n        }\n\n        // Flags that need values\n        const value_flags = [_][]const u8{\n            \"--data\",\n            \"--db\",\n            \"--actor\",\n            \"--lock-timeout\",\n        };\n        for (value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return true;\n        }\n\n        return null;\n    }\n\n    /// Apply a global flag (no value).\n    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n        }\n    }\n\n    /// Apply a global flag that requires a value.\n    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n            global.data_path = value;\n        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n            global.actor = value;\n        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n        }\n    }\n\n    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {\n        const arg = self.next().?;\n\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {\n            global.data_path = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--actor\")) {\n            global.actor = self.next() orelse return error.MissingFlagValue;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {\n            const val = self.next() orelse return error.MissingFlagValue;\n            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n            return true;\n        }\n        if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n            return true;\n        }\n\n        // Put back if not recognized\n        self.index -= 1;\n        return error.UnknownFlag;\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n        var result = StatsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-a\", \"--activity\")) {\n                result.activity = true;\n            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(\"-c\", \"--compact\")) {\n                result.compact = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--since-tag\")) {\n                result.since_tag = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--since-commit\")) {\n                result.since_commit = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--no-verify\")) {\n                result.verify = false;\n            } else if (self.consumeFlag(null, \"--verify\")) {\n                result.verify = true;\n            } else if (self.consumeFlag(\"-f\", \"--force\")) {\n                result.force = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --json after subcommand\" {\n    const args = [_][]const u8{ \"list\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --json after subcommand with ready\" {\n    const args = [_][]const u8{ \"ready\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse global flags before and after subcommand\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":888,"oldLines":72,"newStart":888,"newLines":6,"lines":["         }","     }"," ","-    fn parseGlobalFlag(self: *Self, global: *GlobalOptions) ParseError!bool {","-        const arg = self.next().?;","-","-        if (std.mem.eql(u8, arg, \"--json\")) {","-            global.json = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--toon\")) {","-            global.toon = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {","-            global.quiet = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {","-            global.verbose +|= 1;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"-vv\")) {","-            global.verbose +|= 2;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--no-color\")) {","-            global.no_color = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {","-            global.no_auto_flush = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--no-auto-import\")) {","-            global.no_auto_import = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--data\") or std.mem.eql(u8, arg, \"--db\")) {","-            global.data_path = self.next() orelse return error.MissingFlagValue;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--actor\")) {","-            global.actor = self.next() orelse return error.MissingFlagValue;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--lock-timeout\")) {","-            const val = self.next() orelse return error.MissingFlagValue;","-            global.lock_timeout = std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--wrap\")) {","-            global.wrap = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--stats\")) {","-            global.stats = true;","-            return true;","-        }","-        if (std.mem.eql(u8, arg, \"--robot\")) {","-            global.robot = true;","-            return true;","-        }","-","-        // Put back if not recognized","-        self.index -= 1;","-        return error.UnknownFlag;","-    }","-","     fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {","         // Workspace","         if (std.mem.eql(u8, cmd, \"init\")) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013QAJkZPv3ZpE7Ti1vAU1cu","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me remove the unused `cmd_index` variable."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":898,"cache_read_input_tokens":38543,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":898},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"977165a2-c64d-4bc7-83ce-46b6f4169c02"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013QAJkZPv3ZpE7Ti1vAU1cu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RPDszvAAaeiMAKwBBUYcME","name":"TodoWrite","input":{"todos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"in_progress","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":898,"cache_read_input_tokens":38543,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":898},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"5fe1a702-2e33-4648-9a77-be37e94b787b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RPDszvAAaeiMAKwBBUYcME","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"e01256f9-1894-47d9-8886-9f666b79d079","tool_use_result":{"oldTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"in_progress","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"pending","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"in_progress","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01D66ppArVh9eZbuTaebnWTL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014X1hg41TZYSbcycHXypkn9","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"        // First pass: extract global flags from anywhere in the argument list\n        // and find the subcommand position\n        var cmd_index: ?usize = null;\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};","new_string":"        // First pass: extract global flags from anywhere in the argument list\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":241,"cache_read_input_tokens":39441,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":241},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"baea290d-8510-4bd6-ae31-8df3754e06d6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014X1hg41TZYSbcycHXypkn9","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"3e5510e7-5c08-4eb0-b990-6f6fc3cfa8ea","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"        // First pass: extract global flags from anywhere in the argument list\n        // and find the subcommand position\n        var cmd_index: ?usize = null;\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};","newString":"        // First pass: extract global flags from anywhere in the argument list\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n    dry_run: bool = false, // Preview issue creation without persisting\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n    all: bool = false, // Show dependency graph for all open issues\n    compact: bool = false, // Compact one-line-per-issue output\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    since_tag: ?[]const u8 = null, // Git tag for start date (e.g., \"v1.0.0\")\n    since_commit: ?[]const u8 = null, // Git commit for start date (e.g., \"abc123\")\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    dry_run: bool = false, // Show what would be updated without installing\n    version: ?[]const u8 = null,\n    verify: bool = true, // Verify checksum (default: on)\n    force: bool = false, // Force upgrade even if same version\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    /// Global flags can appear before or after the subcommand.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // First pass: extract global flags from anywhere in the argument list\n        // and find the subcommand position\n        var cmd_index: ?usize = null;\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n        defer filtered_indices.deinit(self.allocator);\n\n        var i: usize = 0;\n        while (i < self.args.len) {\n            const arg = self.args[i];\n\n            // Try to parse as global flag\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (isGlobalFlag(arg)) |needs_value| {\n                    // Apply the global flag\n                    applyGlobalFlag(arg, &global);\n                    if (needs_value) {\n                        // Consume the next argument as the value\n                        i += 1;\n                        if (i < self.args.len) {\n                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n                                return error.InvalidArgument;\n                            };\n                        } else {\n                            return error.MissingFlagValue;\n                        }\n                    }\n                    i += 1;\n                    continue;\n                }\n            }\n\n            // Not a global flag - check if it's the subcommand\n            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n                cmd_index = filtered_indices.items.len;\n            }\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n            i += 1;\n        }\n\n        // Reset parser to use filtered indices\n        // We need to parse command args from the filtered list\n        if (filtered_indices.items.len == 0) {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        }\n\n        // Get the subcommand string\n        const first_filtered = filtered_indices.items[0];\n        const cmd_str = self.args[first_filtered];\n\n        // Set parser index to after the filtered command for subcommand arg parsing\n        // We need to skip processed global flags in subsequent parsing\n        self.index = first_filtered + 1;\n\n        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    /// Check if an argument is a global flag.\n    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n    fn isGlobalFlag(arg: []const u8) ?bool {\n        // Flags that don't need values\n        const no_value_flags = [_][]const u8{\n            \"--json\",\n            \"--toon\",\n            \"-q\",\n            \"--quiet\",\n            \"-v\",\n            \"--verbose\",\n            \"-vv\",\n            \"--no-color\",\n            \"--no-auto-flush\",\n            \"--no-auto-import\",\n            \"--wrap\",\n            \"--stats\",\n            \"--robot\",\n        };\n        for (no_value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return false;\n        }\n\n        // Flags that need values\n        const value_flags = [_][]const u8{\n            \"--data\",\n            \"--db\",\n            \"--actor\",\n            \"--lock-timeout\",\n        };\n        for (value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return true;\n        }\n\n        return null;\n    }\n\n    /// Apply a global flag (no value).\n    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n        }\n    }\n\n    /// Apply a global flag that requires a value.\n    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n            global.data_path = value;\n        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n            global.actor = value;\n        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n        }\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n        var result = StatsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-a\", \"--activity\")) {\n                result.activity = true;\n            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(\"-c\", \"--compact\")) {\n                result.compact = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--since-tag\")) {\n                result.since_tag = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--since-commit\")) {\n                result.since_commit = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--no-verify\")) {\n                result.verify = false;\n            } else if (self.consumeFlag(null, \"--verify\")) {\n                result.verify = true;\n            } else if (self.consumeFlag(\"-f\", \"--force\")) {\n                result.force = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --json after subcommand\" {\n    const args = [_][]const u8{ \"list\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --json after subcommand with ready\" {\n    const args = [_][]const u8{ \"ready\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse global flags before and after subcommand\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":749,"oldLines":8,"newStart":749,"newLines":6,"lines":["         var global = GlobalOptions{};"," ","         // First pass: extract global flags from anywhere in the argument list","-        // and find the subcommand position","-        var cmd_index: ?usize = null;","         var filtered_indices: std.ArrayListUnmanaged(usize) = .{};","         defer filtered_indices.deinit(self.allocator);"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DyzH6vgss4cByyxbfPye2c","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B3D14wJ48Ete49vDaPcyxF","name":"Edit","input":{"replace_all":false,"file_path":"/home/hotschmoe/beads_zig/src/cli/args.zig","old_string":"            // Not a global flag - check if it's the subcommand\n            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n                cmd_index = filtered_indices.items.len;\n            }\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;","new_string":"            // Not a global flag - add to filtered list\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":262,"cache_read_input_tokens":39682,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":262},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"02622177-db25-41e6-a822-a0cdf44200ad"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B3D14wJ48Ete49vDaPcyxF","type":"tool_result","content":"The file /home/hotschmoe/beads_zig/src/cli/args.zig has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"ea981db9-be65-46a6-9182-89a228b79e2f","tool_use_result":{"filePath":"/home/hotschmoe/beads_zig/src/cli/args.zig","oldString":"            // Not a global flag - check if it's the subcommand\n            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n                cmd_index = filtered_indices.items.len;\n            }\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;","newString":"            // Not a global flag - add to filtered list\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;","originalFile":"//! CLI argument parsing for beads_zig.\n//!\n//! Parses command-line arguments into structured data for command dispatch.\n//! Supports global flags, subcommands, and subcommand-specific arguments.\n\nconst std = @import(\"std\");\n\n/// Global CLI options that apply to all commands.\npub const GlobalOptions = struct {\n    json: bool = false,\n    toon: bool = false,\n    robot: bool = false, // Line-oriented machine-readable output for scripting\n    quiet: bool = false,\n    silent: bool = false, // Suppress ALL output including errors (for tests)\n    verbose: u8 = 0,\n    no_color: bool = false,\n    wrap: bool = false, // Wrap long lines in plain text output\n    stats: bool = false, // Show token savings stats for TOON output\n    data_path: ?[]const u8 = null,\n    actor: ?[]const u8 = null,\n    lock_timeout: u32 = 5000,\n    no_auto_flush: bool = false,\n    no_auto_import: bool = false,\n\n    /// Returns true if structured output (JSON or TOON) is enabled.\n    pub fn isStructuredOutput(self: GlobalOptions) bool {\n        return self.json or self.toon;\n    }\n\n    /// Returns true if any machine-readable output is enabled.\n    pub fn isMachineOutput(self: GlobalOptions) bool {\n        return self.json or self.toon or self.robot;\n    }\n};\n\n/// All available subcommands.\npub const Command = union(enum) {\n    // Workspace\n    init: InitArgs,\n    info: void,\n    stats: StatsArgs,\n    doctor: void,\n    config: ConfigArgs,\n    orphans: OrphansArgs,\n    lint: LintArgs,\n    where: void,\n\n    // Issue CRUD\n    create: CreateArgs,\n    q: QuickArgs,\n    show: ShowArgs,\n    update: UpdateArgs,\n    close: CloseArgs,\n    reopen: ReopenArgs,\n    delete: DeleteArgs,\n\n    // Batch Operations\n    add_batch: AddBatchArgs,\n    import_cmd: ImportArgs,\n\n    // Query\n    list: ListArgs,\n    ready: ReadyArgs,\n    blocked: BlockedArgs,\n    search: SearchArgs,\n    stale: StaleArgs,\n    count: CountArgs,\n    defer_cmd: DeferArgs,\n    undefer: UndeferArgs,\n\n    // Dependencies\n    dep: DepArgs,\n    graph: GraphArgs,\n\n    // Epics\n    epic: EpicArgs,\n\n    // Labels\n    label: LabelArgs,\n\n    // Comments\n    comments: CommentsArgs,\n\n    // Audit\n    history: HistoryArgs,\n    audit: AuditArgs,\n\n    // Changelog\n    changelog: ChangelogArgs,\n\n    // Sync\n    sync: SyncArgs,\n\n    // Backup\n    backup: BackupArgs,\n\n    // System\n    version: void,\n    schema: void,\n    completions: CompletionsArgs,\n    metrics: MetricsArgs,\n\n    // Saved Queries\n    query: QueryArgs,\n\n    // Self-upgrade\n    upgrade: UpgradeArgs,\n\n    // Help\n    help: HelpArgs,\n};\n\n/// Init command arguments.\npub const InitArgs = struct {\n    prefix: []const u8 = \"bd\",\n};\n\n/// Stats command arguments.\npub const StatsArgs = struct {\n    activity: bool = false, // Show git-based activity statistics\n    activity_hours: u32 = 24, // Hours to look back for activity stats (default 24)\n};\n\n/// Create command arguments.\npub const CreateArgs = struct {\n    title: []const u8,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    labels: []const []const u8 = &[_][]const u8{},\n    deps: []const []const u8 = &[_][]const u8{},\n    due: ?[]const u8 = null,\n    estimate: ?i32 = null,\n    ephemeral: bool = false, // Local-only, not written to JSONL\n    dry_run: bool = false, // Preview issue creation without persisting\n};\n\n/// Quick capture command arguments.\npub const QuickArgs = struct {\n    title: []const u8,\n    priority: ?[]const u8 = null,\n};\n\n/// Show command arguments.\npub const ShowArgs = struct {\n    id: []const u8,\n    with_comments: bool = true,\n    with_history: bool = false,\n};\n\n/// Update command arguments.\npub const UpdateArgs = struct {\n    id: []const u8,\n    title: ?[]const u8 = null,\n    description: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    owner: ?[]const u8 = null,\n    design: ?[]const u8 = null,\n    acceptance_criteria: ?[]const u8 = null,\n    external_ref: ?[]const u8 = null,\n    status: ?[]const u8 = null,\n    /// Expected version for optimistic locking (compare-and-swap).\n    expected_version: ?u64 = null,\n    /// Claim: set assignee to actor AND status to in_progress atomically.\n    claim: bool = false,\n};\n\n/// Close command arguments.\npub const CloseArgs = struct {\n    id: []const u8,\n    reason: ?[]const u8 = null,\n    session: ?[]const u8 = null,\n};\n\n/// Reopen command arguments.\npub const ReopenArgs = struct {\n    id: []const u8,\n};\n\n/// Delete command arguments.\npub const DeleteArgs = struct {\n    /// Single issue ID to delete (mutually exclusive with from_file).\n    id: ?[]const u8 = null,\n    /// Path to file containing issue IDs to delete (one per line).\n    from_file: ?[]const u8 = null,\n    /// Delete issue and all its dependents recursively.\n    cascade: bool = false,\n    /// Prune from database immediately instead of marking as tombstone.\n    hard: bool = false,\n    /// Preview what would be deleted without making changes.\n    dry_run: bool = false,\n};\n\n/// Add-batch command arguments.\n/// Creates multiple issues from stdin or a file with single lock acquisition.\npub const AddBatchArgs = struct {\n    file: ?[]const u8 = null, // Read from file instead of stdin\n    format: BatchFormat = .titles, // Input format\n};\n\n/// Batch input format.\npub const BatchFormat = enum {\n    titles, // One title per line\n    jsonl, // Full JSONL format (one issue per line)\n\n    pub fn fromString(s: []const u8) ?BatchFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"titles\")) return .titles;\n        if (std.ascii.eqlIgnoreCase(s, \"jsonl\")) return .jsonl;\n        if (std.ascii.eqlIgnoreCase(s, \"json\")) return .jsonl;\n        return null;\n    }\n};\n\n/// Import command arguments.\n/// Imports issues from a JSONL file with single lock acquisition.\npub const ImportArgs = struct {\n    file: []const u8, // Path to JSONL file (required)\n    merge: bool = false, // Merge instead of replace\n    dry_run: bool = false, // Show what would be imported without importing\n};\n\n/// Output format for list/ready commands.\npub const OutputFormat = enum {\n    default,\n    csv,\n\n    pub fn fromString(s: []const u8) ?OutputFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"default\") or std.ascii.eqlIgnoreCase(s, \"plain\")) return .default;\n        if (std.ascii.eqlIgnoreCase(s, \"csv\")) return .csv;\n        return null;\n    }\n};\n\n/// Sort field options for list command.\npub const SortField = enum {\n    created_at,\n    updated_at,\n    priority,\n\n    pub fn fromString(s: []const u8) ?SortField {\n        if (std.ascii.eqlIgnoreCase(s, \"created\") or std.ascii.eqlIgnoreCase(s, \"created_at\")) return .created_at;\n        if (std.ascii.eqlIgnoreCase(s, \"updated\") or std.ascii.eqlIgnoreCase(s, \"updated_at\")) return .updated_at;\n        if (std.ascii.eqlIgnoreCase(s, \"priority\")) return .priority;\n        return null;\n    }\n};\n\n/// List command arguments.\npub const ListArgs = struct {\n    status: ?[]const u8 = null,\n    priority: ?[]const u8 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    issue_type: ?[]const u8 = null,\n    assignee: ?[]const u8 = null,\n    label: ?[]const u8 = null,\n    label_any: []const []const u8 = &[_][]const u8{},\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    limit: ?u32 = null,\n    all: bool = false,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    sort: SortField = .created_at,\n    sort_desc: bool = true,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Ready command arguments.\npub const ReadyArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n    overdue: bool = false,\n    include_deferred: bool = false,\n    parent: ?[]const u8 = null,\n    recursive: bool = false,\n    format: OutputFormat = .default,\n    fields: ?[]const u8 = null,\n};\n\n/// Blocked command arguments.\npub const BlockedArgs = struct {\n    limit: ?u32 = null,\n    priority_min: ?[]const u8 = null,\n    priority_max: ?[]const u8 = null,\n    title_contains: ?[]const u8 = null,\n    desc_contains: ?[]const u8 = null,\n    notes_contains: ?[]const u8 = null,\n};\n\n/// Search command arguments.\npub const SearchArgs = struct {\n    query: []const u8,\n    limit: ?u32 = null,\n};\n\n/// Stale command arguments.\npub const StaleArgs = struct {\n    days: u32 = 30,\n    limit: ?u32 = null,\n};\n\n/// Count command arguments.\npub const CountArgs = struct {\n    group_by: ?[]const u8 = null,\n};\n\n/// Defer command arguments.\npub const DeferArgs = struct {\n    id: []const u8,\n    until: ?[]const u8 = null, // RFC3339 date or relative like \"+7d\"\n    reason: ?[]const u8 = null,\n};\n\n/// Undefer command arguments.\npub const UndeferArgs = struct {\n    id: []const u8,\n};\n\n/// Epic subcommand variants.\npub const EpicSubcommand = union(enum) {\n    create: struct {\n        title: []const u8,\n        description: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n    },\n    add: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    remove: struct {\n        epic_id: []const u8,\n        issue_id: []const u8,\n    },\n    list: struct {\n        epic_id: []const u8,\n    },\n    status: void,\n    close_eligible: struct {\n        dry_run: bool = false,\n    },\n};\n\n/// Epic command arguments.\npub const EpicArgs = struct {\n    subcommand: EpicSubcommand,\n};\n\n/// Direction filter for dependency listing.\npub const DepDirection = enum {\n    up, // What depends on this issue (dependents/blocked-by)\n    down, // What this issue depends on\n    both, // Both directions (default)\n\n    pub fn fromString(s: []const u8) ?DepDirection {\n        if (std.ascii.eqlIgnoreCase(s, \"up\")) return .up;\n        if (std.ascii.eqlIgnoreCase(s, \"down\")) return .down;\n        if (std.ascii.eqlIgnoreCase(s, \"both\")) return .both;\n        return null;\n    }\n};\n\n/// Tree output formats for dep tree.\npub const TreeFormat = enum {\n    ascii,\n    mermaid,\n\n    pub fn fromString(s: []const u8) ?TreeFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"mermaid\")) return .mermaid;\n        return null;\n    }\n};\n\n/// Dependency subcommand variants.\npub const DepSubcommand = union(enum) {\n    add: struct {\n        child: []const u8,\n        parent: []const u8,\n        dep_type: []const u8 = \"blocks\",\n        metadata: ?[]const u8 = null,\n    },\n    remove: struct {\n        child: []const u8,\n        parent: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n        direction: DepDirection = .both,\n    },\n    tree: struct {\n        id: []const u8,\n        format: TreeFormat = .ascii,\n    },\n    cycles: void,\n};\n\n/// Dependency command arguments.\npub const DepArgs = struct {\n    subcommand: DepSubcommand,\n};\n\n/// Graph command output formats.\npub const GraphFormat = enum {\n    ascii,\n    dot,\n\n    pub fn fromString(s: []const u8) ?GraphFormat {\n        if (std.ascii.eqlIgnoreCase(s, \"ascii\")) return .ascii;\n        if (std.ascii.eqlIgnoreCase(s, \"dot\")) return .dot;\n        if (std.ascii.eqlIgnoreCase(s, \"graphviz\")) return .dot;\n        return null;\n    }\n};\n\n/// Graph command arguments.\npub const GraphArgs = struct {\n    id: ?[]const u8 = null, // Optional: show graph for specific issue, otherwise show all\n    format: GraphFormat = .ascii,\n    depth: ?u32 = null, // Max depth for tree traversal\n    all: bool = false, // Show dependency graph for all open issues\n    compact: bool = false, // Compact one-line-per-issue output\n};\n\n/// Label subcommand variants.\npub const LabelSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    remove: struct {\n        id: []const u8,\n        labels: []const []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n    list_all: void,\n    rename: struct {\n        old_name: []const u8,\n        new_name: []const u8,\n    },\n};\n\n/// Label command arguments.\npub const LabelArgs = struct {\n    subcommand: LabelSubcommand,\n};\n\n/// Comments subcommand variants.\npub const CommentsSubcommand = union(enum) {\n    add: struct {\n        id: []const u8,\n        text: []const u8,\n    },\n    list: struct {\n        id: []const u8,\n    },\n};\n\n/// Comments command arguments.\npub const CommentsArgs = struct {\n    subcommand: CommentsSubcommand,\n};\n\n/// History command arguments.\npub const HistoryArgs = struct {\n    id: []const u8,\n};\n\n/// Audit subcommand variants.\npub const AuditSubcommand = union(enum) {\n    /// Record an LLM/tool interaction for training data.\n    record: struct {\n        kind: []const u8, // \"llm_call\" or \"tool_call\"\n        issue_id: ?[]const u8 = null, // Optional issue context\n        model: ?[]const u8 = null, // Model name (for llm_call)\n        prompt: ?[]const u8 = null, // Input prompt (for llm_call)\n        response: ?[]const u8 = null, // Output response (for llm_call)\n        tool_name: ?[]const u8 = null, // Tool name (for tool_call)\n        exit_code: ?i32 = null, // Exit code (for tool_call)\n        metadata: ?[]const u8 = null, // Additional JSON metadata\n    },\n    /// Label an audit entry for quality tracking.\n    label: struct {\n        entry_id: i64, // Event ID to label\n        label_value: []const u8, // e.g., \"good\", \"bad\", \"neutral\"\n        reason: ?[]const u8 = null, // Explanation for the label\n    },\n    /// View audit log for a specific issue.\n    log: struct {\n        issue_id: []const u8,\n        limit: ?u32 = null,\n    },\n    /// Summary of audit data over time period.\n    summary: struct {\n        days: u32 = 7, // Number of days to summarize\n    },\n    /// Legacy: show project-wide audit log (default behavior).\n    list: struct {\n        limit: ?u32 = null,\n    },\n};\n\n/// Audit command arguments.\npub const AuditArgs = struct {\n    subcommand: AuditSubcommand,\n};\n\n/// Changelog command arguments.\npub const ChangelogArgs = struct {\n    since: ?[]const u8 = null, // Start date filter (YYYY-MM-DD)\n    until: ?[]const u8 = null, // End date filter (YYYY-MM-DD)\n    since_tag: ?[]const u8 = null, // Git tag for start date (e.g., \"v1.0.0\")\n    since_commit: ?[]const u8 = null, // Git commit for start date (e.g., \"abc123\")\n    limit: ?u32 = null,\n    group_by: ?[]const u8 = null, // Group by field (e.g., \"type\")\n};\n\n/// Error policy for export operations.\npub const ErrorPolicy = enum {\n    strict, // Fail on any error\n    best_effort, // Continue on errors, report at end\n    partial, // Export what we can, skip errors silently\n\n    pub fn fromString(s: []const u8) ?ErrorPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"best-effort\") or std.ascii.eqlIgnoreCase(s, \"best_effort\")) return .best_effort;\n        if (std.ascii.eqlIgnoreCase(s, \"partial\")) return .partial;\n        return null;\n    }\n};\n\n/// Orphan handling policy for import operations.\npub const OrphanPolicy = enum {\n    strict, // Fail if orphans detected\n    resurrect, // Create placeholder parents for orphans\n    skip, // Skip orphaned issues silently\n\n    pub fn fromString(s: []const u8) ?OrphanPolicy {\n        if (std.ascii.eqlIgnoreCase(s, \"strict\")) return .strict;\n        if (std.ascii.eqlIgnoreCase(s, \"resurrect\")) return .resurrect;\n        if (std.ascii.eqlIgnoreCase(s, \"skip\")) return .skip;\n        return null;\n    }\n};\n\n/// Sync command arguments.\npub const SyncArgs = struct {\n    flush_only: bool = false,\n    import_only: bool = false,\n    merge: bool = false,\n    status: bool = false,\n    manifest: bool = false,\n    error_policy: ErrorPolicy = .strict,\n    orphan_policy: OrphanPolicy = .strict,\n    rename_prefix: bool = false,\n};\n\n/// Backup subcommand variants.\npub const BackupSubcommand = union(enum) {\n    list: void,\n    diff: struct {\n        file: []const u8,\n    },\n    restore: struct {\n        file: []const u8,\n        dry_run: bool = false,\n    },\n    prune: struct {\n        keep: u32 = 10,\n        dry_run: bool = false,\n    },\n    create: void,\n};\n\n/// Backup command arguments.\npub const BackupArgs = struct {\n    subcommand: BackupSubcommand,\n};\n\n/// Shell completion types.\npub const Shell = enum {\n    bash,\n    zsh,\n    fish,\n    powershell,\n\n    pub fn fromString(s: []const u8) ?Shell {\n        if (std.ascii.eqlIgnoreCase(s, \"bash\")) return .bash;\n        if (std.ascii.eqlIgnoreCase(s, \"zsh\")) return .zsh;\n        if (std.ascii.eqlIgnoreCase(s, \"fish\")) return .fish;\n        if (std.ascii.eqlIgnoreCase(s, \"powershell\")) return .powershell;\n        if (std.ascii.eqlIgnoreCase(s, \"ps\")) return .powershell;\n        return null;\n    }\n};\n\n/// Completions command arguments.\npub const CompletionsArgs = struct {\n    shell: Shell,\n};\n\n/// Metrics command arguments.\npub const MetricsArgs = struct {\n    reset: bool = false, // Reset metrics after displaying\n};\n\n/// Help command arguments.\npub const HelpArgs = struct {\n    topic: ?[]const u8 = null,\n};\n\n/// Config subcommand variants.\npub const ConfigSubcommand = union(enum) {\n    get: struct {\n        key: []const u8,\n    },\n    set: struct {\n        key: []const u8,\n        value: []const u8,\n    },\n    list: void,\n};\n\n/// Config command arguments.\npub const ConfigArgs = struct {\n    subcommand: ConfigSubcommand,\n};\n\n/// Query subcommand variants.\npub const QuerySubcommand = union(enum) {\n    save: struct {\n        name: []const u8,\n        status: ?[]const u8 = null,\n        priority: ?[]const u8 = null,\n        issue_type: ?[]const u8 = null,\n        assignee: ?[]const u8 = null,\n        label: ?[]const u8 = null,\n        limit: ?u32 = null,\n    },\n    run: struct {\n        name: []const u8,\n    },\n    list: void,\n    delete: struct {\n        name: []const u8,\n    },\n};\n\n/// Query command arguments.\npub const QueryArgs = struct {\n    subcommand: QuerySubcommand,\n};\n\n/// Upgrade command arguments.\npub const UpgradeArgs = struct {\n    check_only: bool = false,\n    dry_run: bool = false, // Show what would be updated without installing\n    version: ?[]const u8 = null,\n    verify: bool = true, // Verify checksum (default: on)\n    force: bool = false, // Force upgrade even if same version\n};\n\n/// Orphans command arguments.\npub const OrphansArgs = struct {\n    limit: ?u32 = null,\n    hierarchy_only: bool = false,\n    deps_only: bool = false,\n};\n\n/// Lint command arguments.\npub const LintArgs = struct {\n    limit: ?u32 = null,\n};\n\n/// Result of parsing command-line arguments.\npub const ParseResult = struct {\n    global: GlobalOptions,\n    command: Command,\n\n    /// Free any memory allocated during parsing (labels, deps slices).\n    pub fn deinit(self: *ParseResult, allocator: std.mem.Allocator) void {\n        switch (self.command) {\n            .create => |create| {\n                if (create.labels.len > 0) allocator.free(create.labels);\n                if (create.deps.len > 0) allocator.free(create.deps);\n            },\n            .list => |list_cmd| {\n                if (list_cmd.label_any.len > 0) allocator.free(list_cmd.label_any);\n            },\n            .label => |label_cmd| {\n                switch (label_cmd.subcommand) {\n                    .add => |add| if (add.labels.len > 0) allocator.free(add.labels),\n                    .remove => |remove| if (remove.labels.len > 0) allocator.free(remove.labels),\n                    else => {},\n                }\n            },\n            else => {},\n        }\n    }\n};\n\n/// Errors that can occur during argument parsing.\npub const ParseError = error{\n    UnknownCommand,\n    MissingRequiredArgument,\n    InvalidArgument,\n    UnknownFlag,\n    MissingFlagValue,\n    InvalidFlagValue,\n    InvalidShell,\n    UnknownSubcommand,\n};\n\n/// Command-line argument parser.\npub const ArgParser = struct {\n    allocator: std.mem.Allocator,\n    args: []const []const u8,\n    index: usize = 0,\n\n    const Self = @This();\n\n    pub fn init(allocator: std.mem.Allocator, args: []const []const u8) Self {\n        return .{\n            .allocator = allocator,\n            .args = args,\n        };\n    }\n\n    /// Parse all arguments into a ParseResult.\n    /// Global flags can appear before or after the subcommand.\n    pub fn parse(self: *Self) ParseError!ParseResult {\n        var global = GlobalOptions{};\n\n        // First pass: extract global flags from anywhere in the argument list\n        var filtered_indices: std.ArrayListUnmanaged(usize) = .{};\n        defer filtered_indices.deinit(self.allocator);\n\n        var i: usize = 0;\n        while (i < self.args.len) {\n            const arg = self.args[i];\n\n            // Try to parse as global flag\n            if (std.mem.startsWith(u8, arg, \"-\")) {\n                if (isGlobalFlag(arg)) |needs_value| {\n                    // Apply the global flag\n                    applyGlobalFlag(arg, &global);\n                    if (needs_value) {\n                        // Consume the next argument as the value\n                        i += 1;\n                        if (i < self.args.len) {\n                            applyGlobalFlagValue(arg, self.args[i], &global) catch {\n                                return error.InvalidArgument;\n                            };\n                        } else {\n                            return error.MissingFlagValue;\n                        }\n                    }\n                    i += 1;\n                    continue;\n                }\n            }\n\n            // Not a global flag - check if it's the subcommand\n            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {\n                cmd_index = filtered_indices.items.len;\n            }\n            filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;\n            i += 1;\n        }\n\n        // Reset parser to use filtered indices\n        // We need to parse command args from the filtered list\n        if (filtered_indices.items.len == 0) {\n            return .{\n                .global = global,\n                .command = .{ .help = .{ .topic = null } },\n            };\n        }\n\n        // Get the subcommand string\n        const first_filtered = filtered_indices.items[0];\n        const cmd_str = self.args[first_filtered];\n\n        // Set parser index to after the filtered command for subcommand arg parsing\n        // We need to skip processed global flags in subsequent parsing\n        self.index = first_filtered + 1;\n\n        // Parse subcommand with remaining args (which may still have subcommand-specific flags)\n        const command = try self.parseCommand(cmd_str);\n\n        return .{\n            .global = global,\n            .command = command,\n        };\n    }\n\n    /// Check if an argument is a global flag.\n    /// Returns true (needs value) / false (no value) if it's a global flag, null otherwise.\n    fn isGlobalFlag(arg: []const u8) ?bool {\n        // Flags that don't need values\n        const no_value_flags = [_][]const u8{\n            \"--json\",\n            \"--toon\",\n            \"-q\",\n            \"--quiet\",\n            \"-v\",\n            \"--verbose\",\n            \"-vv\",\n            \"--no-color\",\n            \"--no-auto-flush\",\n            \"--no-auto-import\",\n            \"--wrap\",\n            \"--stats\",\n            \"--robot\",\n        };\n        for (no_value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return false;\n        }\n\n        // Flags that need values\n        const value_flags = [_][]const u8{\n            \"--data\",\n            \"--db\",\n            \"--actor\",\n            \"--lock-timeout\",\n        };\n        for (value_flags) |flag| {\n            if (std.mem.eql(u8, arg, flag)) return true;\n        }\n\n        return null;\n    }\n\n    /// Apply a global flag (no value).\n    fn applyGlobalFlag(arg: []const u8, global: *GlobalOptions) void {\n        if (std.mem.eql(u8, arg, \"--json\")) {\n            global.json = true;\n        } else if (std.mem.eql(u8, arg, \"--toon\")) {\n            global.toon = true;\n        } else if (std.mem.eql(u8, arg, \"-q\") or std.mem.eql(u8, arg, \"--quiet\")) {\n            global.quiet = true;\n        } else if (std.mem.eql(u8, arg, \"-v\") or std.mem.eql(u8, arg, \"--verbose\")) {\n            global.verbose +|= 1;\n        } else if (std.mem.eql(u8, arg, \"-vv\")) {\n            global.verbose +|= 2;\n        } else if (std.mem.eql(u8, arg, \"--no-color\")) {\n            global.no_color = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-flush\")) {\n            global.no_auto_flush = true;\n        } else if (std.mem.eql(u8, arg, \"--no-auto-import\")) {\n            global.no_auto_import = true;\n        } else if (std.mem.eql(u8, arg, \"--wrap\")) {\n            global.wrap = true;\n        } else if (std.mem.eql(u8, arg, \"--stats\")) {\n            global.stats = true;\n        } else if (std.mem.eql(u8, arg, \"--robot\")) {\n            global.robot = true;\n        }\n    }\n\n    /// Apply a global flag that requires a value.\n    fn applyGlobalFlagValue(flag: []const u8, value: []const u8, global: *GlobalOptions) !void {\n        if (std.mem.eql(u8, flag, \"--data\") or std.mem.eql(u8, flag, \"--db\")) {\n            global.data_path = value;\n        } else if (std.mem.eql(u8, flag, \"--actor\")) {\n            global.actor = value;\n        } else if (std.mem.eql(u8, flag, \"--lock-timeout\")) {\n            global.lock_timeout = std.fmt.parseInt(u32, value, 10) catch return error.InvalidArgument;\n        }\n    }\n\n    fn parseCommand(self: *Self, cmd: []const u8) ParseError!Command {\n        // Workspace\n        if (std.mem.eql(u8, cmd, \"init\")) {\n            return .{ .init = try self.parseInitArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"info\")) {\n            return .{ .info = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"stats\")) {\n            return .{ .stats = try self.parseStatsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"doctor\")) {\n            return .{ .doctor = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"config\")) {\n            return .{ .config = try self.parseConfigArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"orphans\")) {\n            return .{ .orphans = try self.parseOrphansArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"lint\")) {\n            return .{ .lint = try self.parseLintArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"where\")) {\n            return .{ .where = {} };\n        }\n\n        // Issue CRUD\n        if (std.mem.eql(u8, cmd, \"create\") or std.mem.eql(u8, cmd, \"add\") or std.mem.eql(u8, cmd, \"new\")) {\n            return .{ .create = try self.parseCreateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"q\") or std.mem.eql(u8, cmd, \"quick\")) {\n            return .{ .q = try self.parseQuickArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"show\") or std.mem.eql(u8, cmd, \"get\") or std.mem.eql(u8, cmd, \"view\")) {\n            return .{ .show = try self.parseShowArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"update\") or std.mem.eql(u8, cmd, \"edit\")) {\n            return .{ .update = try self.parseUpdateArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"close\") or std.mem.eql(u8, cmd, \"done\") or std.mem.eql(u8, cmd, \"finish\")) {\n            return .{ .close = try self.parseCloseArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"reopen\")) {\n            return .{ .reopen = try self.parseReopenArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"delete\") or std.mem.eql(u8, cmd, \"rm\") or std.mem.eql(u8, cmd, \"remove\")) {\n            return .{ .delete = try self.parseDeleteArgs() };\n        }\n\n        // Batch Operations\n        if (std.mem.eql(u8, cmd, \"add-batch\") or std.mem.eql(u8, cmd, \"batch-add\") or std.mem.eql(u8, cmd, \"batch\")) {\n            return .{ .add_batch = try self.parseAddBatchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"import\")) {\n            return .{ .import_cmd = try self.parseImportArgs() };\n        }\n\n        // Query\n        if (std.mem.eql(u8, cmd, \"list\") or std.mem.eql(u8, cmd, \"ls\")) {\n            return .{ .list = try self.parseListArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"ready\")) {\n            return .{ .ready = try self.parseReadyArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"blocked\")) {\n            return .{ .blocked = try self.parseBlockedArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"search\") or std.mem.eql(u8, cmd, \"find\")) {\n            return .{ .search = try self.parseSearchArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"stale\")) {\n            return .{ .stale = try self.parseStaleArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"count\")) {\n            return .{ .count = try self.parseCountArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"defer\")) {\n            return .{ .defer_cmd = try self.parseDeferArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"undefer\")) {\n            return .{ .undefer = try self.parseUndeferArgs() };\n        }\n\n        // Dependencies\n        if (std.mem.eql(u8, cmd, \"dep\") or std.mem.eql(u8, cmd, \"deps\") or std.mem.eql(u8, cmd, \"dependency\")) {\n            return .{ .dep = try self.parseDepArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"graph\")) {\n            return .{ .graph = try self.parseGraphArgs() };\n        }\n\n        // Epics\n        if (std.mem.eql(u8, cmd, \"epic\") or std.mem.eql(u8, cmd, \"epics\")) {\n            return .{ .epic = try self.parseEpicArgs() };\n        }\n\n        // Labels\n        if (std.mem.eql(u8, cmd, \"label\") or std.mem.eql(u8, cmd, \"labels\") or std.mem.eql(u8, cmd, \"tag\")) {\n            return .{ .label = try self.parseLabelArgs() };\n        }\n\n        // Comments\n        if (std.mem.eql(u8, cmd, \"comments\") or std.mem.eql(u8, cmd, \"comment\") or std.mem.eql(u8, cmd, \"note\")) {\n            return .{ .comments = try self.parseCommentsArgs() };\n        }\n\n        // Audit\n        if (std.mem.eql(u8, cmd, \"history\") or std.mem.eql(u8, cmd, \"log\")) {\n            return .{ .history = try self.parseHistoryArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"audit\")) {\n            return .{ .audit = try self.parseAuditArgs() };\n        }\n\n        // Changelog\n        if (std.mem.eql(u8, cmd, \"changelog\")) {\n            return .{ .changelog = try self.parseChangelogArgs() };\n        }\n\n        // Sync\n        if (std.mem.eql(u8, cmd, \"sync\") or std.mem.eql(u8, cmd, \"flush\") or std.mem.eql(u8, cmd, \"export\")) {\n            return .{ .sync = try self.parseSyncArgs() };\n        }\n\n        // Backup\n        if (std.mem.eql(u8, cmd, \"backup\") or std.mem.eql(u8, cmd, \"backups\")) {\n            return .{ .backup = try self.parseBackupArgs() };\n        }\n\n        // System\n        if (std.mem.eql(u8, cmd, \"version\") or std.mem.eql(u8, cmd, \"--version\") or std.mem.eql(u8, cmd, \"-V\")) {\n            return .{ .version = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"schema\")) {\n            return .{ .schema = {} };\n        }\n        if (std.mem.eql(u8, cmd, \"completions\") or std.mem.eql(u8, cmd, \"completion\")) {\n            return .{ .completions = try self.parseCompletionsArgs() };\n        }\n        if (std.mem.eql(u8, cmd, \"metrics\")) {\n            return .{ .metrics = try self.parseMetricsArgs() };\n        }\n\n        // Saved Queries\n        if (std.mem.eql(u8, cmd, \"query\")) {\n            return .{ .query = try self.parseQueryArgs() };\n        }\n\n        // Self-upgrade\n        if (std.mem.eql(u8, cmd, \"upgrade\")) {\n            return .{ .upgrade = try self.parseUpgradeArgs() };\n        }\n\n        // Help\n        if (std.mem.eql(u8, cmd, \"help\") or std.mem.eql(u8, cmd, \"--help\") or std.mem.eql(u8, cmd, \"-h\")) {\n            return .{ .help = try self.parseHelpArgs() };\n        }\n\n        return error.UnknownCommand;\n    }\n\n    fn parseInitArgs(self: *Self) ParseError!InitArgs {\n        var result = InitArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--prefix\")) {\n                result.prefix = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                result.prefix = self.next().?;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseStatsArgs(self: *Self) ParseError!StatsArgs {\n        var result = StatsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-a\", \"--activity\")) {\n                result.activity = true;\n            } else if (self.consumeFlag(null, \"--activity-hours\")) {\n                result.activity_hours = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCreateArgs(self: *Self) ParseError!CreateArgs {\n        var result = CreateArgs{ .title = undefined };\n        var title_set = false;\n        var labels: std.ArrayListUnmanaged([]const u8) = .{};\n        var deps: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                labels.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(\"--depends-on\", \"--dep\")) {\n                deps.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--due\")) {\n                result.due = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-e\", \"--estimate\")) {\n                const val = self.next() orelse return error.MissingFlagValue;\n                result.estimate = std.fmt.parseInt(i32, val, 10) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--ephemeral\")) {\n                result.ephemeral = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n\n        if (labels.items.len > 0) {\n            result.labels = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n        if (deps.items.len > 0) {\n            result.deps = deps.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseQuickArgs(self: *Self) ParseError!QuickArgs {\n        var result = QuickArgs{ .title = undefined };\n        var title_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!title_set) {\n                    result.title = self.next().?;\n                    title_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!title_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseShowArgs(self: *Self) ParseError!ShowArgs {\n        var result = ShowArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--no-comments\")) {\n                result.with_comments = false;\n            } else if (self.consumeFlag(null, \"--with-history\")) {\n                result.with_history = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseUpdateArgs(self: *Self) ParseError!UpdateArgs {\n        var result = UpdateArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--title\")) {\n                result.title = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-d\", \"--description\")) {\n                result.description = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-o\", \"--owner\")) {\n                result.owner = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--design\")) {\n                result.design = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--acceptance-criteria\")) {\n                result.acceptance_criteria = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--external-ref\")) {\n                result.external_ref = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-v\", \"--version\")) {\n                const version_str = self.next() orelse return error.MissingFlagValue;\n                result.expected_version = std.fmt.parseInt(u64, version_str, 10) catch return error.InvalidFlagValue;\n            } else if (self.consumeFlag(null, \"--claim\")) {\n                result.claim = true;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseCloseArgs(self: *Self) ParseError!CloseArgs {\n        var result = CloseArgs{ .id = undefined };\n        var id_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-s\", \"--session\")) {\n                result.session = self.next() orelse return error.MissingFlagValue;\n            } else if (self.peekPositional()) |_| {\n                if (!id_set) {\n                    result.id = self.next().?;\n                    id_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!id_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseReopenArgs(self: *Self) ParseError!ReopenArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseDeleteArgs(self: *Self) ParseError!DeleteArgs {\n        var result = DeleteArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--from-file\")) {\n                result.from_file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--cascade\")) {\n                result.cascade = true;\n            } else if (self.consumeFlag(null, \"--hard\")) {\n                result.hard = true;\n            } else if (self.consumeFlag(null, \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        // Require either id or from_file\n        if (result.id == null and result.from_file == null) {\n            return error.MissingRequiredArgument;\n        }\n\n        return result;\n    }\n\n    fn parseAddBatchArgs(self: *Self) ParseError!AddBatchArgs {\n        var result = AddBatchArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--file\")) {\n                result.file = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = BatchFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.peekPositional()) |_| {\n                // Positional argument is treated as file path\n                if (result.file == null) {\n                    result.file = self.next().?;\n                } else break;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseImportArgs(self: *Self) ParseError!ImportArgs {\n        var result = ImportArgs{ .file = undefined };\n        var file_set = false;\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.peekPositional()) |_| {\n                if (!file_set) {\n                    result.file = self.next().?;\n                    file_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!file_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseListArgs(self: *Self) ParseError!ListArgs {\n        var result = ListArgs{};\n        var label_any_list: std.ArrayListUnmanaged([]const u8) = .{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                result.priority = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                result.issue_type = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                result.assignee = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                result.label = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--label-any\")) {\n                label_any_list.append(self.allocator, self.next() orelse return error.MissingFlagValue) catch return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-A\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--deferred\") or self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--sort\")) {\n                const sort_str = self.next() orelse return error.MissingFlagValue;\n                result.sort = SortField.fromString(sort_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--asc\")) {\n                result.sort_desc = false;\n            } else if (self.consumeFlag(null, \"--desc\")) {\n                result.sort_desc = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n\n        if (label_any_list.items.len > 0) {\n            result.label_any = label_any_list.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n        }\n\n        return result;\n    }\n\n    fn parseReadyArgs(self: *Self) ParseError!ReadyArgs {\n        var result = ReadyArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--overdue\")) {\n                result.overdue = true;\n            } else if (self.consumeFlag(null, \"--include-deferred\")) {\n                result.include_deferred = true;\n            } else if (self.consumeFlag(null, \"--parent\")) {\n                result.parent = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--recursive\")) {\n                result.recursive = true;\n            } else if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = OutputFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--fields\")) {\n                result.fields = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBlockedArgs(self: *Self) ParseError!BlockedArgs {\n        var result = BlockedArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--priority-min\")) {\n                result.priority_min = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--priority-max\")) {\n                result.priority_max = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--title-contains\")) {\n                result.title_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--desc-contains\")) {\n                result.desc_contains = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--notes-contains\")) {\n                result.notes_contains = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSearchArgs(self: *Self) ParseError!SearchArgs {\n        var result = SearchArgs{ .query = undefined };\n        var query_set = false;\n\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.peekPositional()) |_| {\n                if (!query_set) {\n                    result.query = self.next().?;\n                    query_set = true;\n                } else break;\n            } else break;\n        }\n\n        if (!query_set) return error.MissingRequiredArgument;\n        return result;\n    }\n\n    fn parseStaleArgs(self: *Self) ParseError!StaleArgs {\n        var result = StaleArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-d\", \"--days\")) {\n                result.days = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseCountArgs(self: *Self) ParseError!CountArgs {\n        var result = CountArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseDeferArgs(self: *Self) ParseError!DeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        var result = DeferArgs{ .id = id };\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-u\", \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                result.reason = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseUndeferArgs(self: *Self) ParseError!UndeferArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return UndeferArgs{ .id = id };\n    }\n\n    fn parseDepArgs(self: *Self) ParseError!DepArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            var dep_type: []const u8 = \"blocks\";\n            var metadata: ?[]const u8 = null;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-t\", \"--type\")) {\n                    dep_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--metadata\")) {\n                    metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .add = .{ .child = child, .parent = parent, .dep_type = dep_type, .metadata = metadata } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const child = self.next() orelse return error.MissingRequiredArgument;\n            const parent = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .child = child, .parent = parent } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var direction: DepDirection = .both;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--direction\")) {\n                    const dir_str = self.next() orelse return error.MissingFlagValue;\n                    direction = DepDirection.fromString(dir_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .id = id, .direction = direction } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"tree\")) {\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var format: TreeFormat = .ascii;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-f\", \"--format\")) {\n                    const fmt_str = self.next() orelse return error.MissingFlagValue;\n                    format = TreeFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n                } else break;\n            }\n            return .{ .subcommand = .{ .tree = .{ .id = id, .format = format } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"cycles\")) {\n            return .{ .subcommand = .{ .cycles = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseGraphArgs(self: *Self) ParseError!GraphArgs {\n        var result = GraphArgs{};\n\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-f\", \"--format\")) {\n                const fmt_str = self.next() orelse return error.MissingFlagValue;\n                result.format = GraphFormat.fromString(fmt_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(\"-d\", \"--depth\")) {\n                result.depth = try self.consumeU32() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(\"-a\", \"--all\")) {\n                result.all = true;\n            } else if (self.consumeFlag(\"-c\", \"--compact\")) {\n                result.compact = true;\n            } else if (self.peekPositional()) |_| {\n                if (result.id == null) {\n                    result.id = self.next().?;\n                } else break;\n            } else break;\n        }\n\n        return result;\n    }\n\n    fn parseEpicArgs(self: *Self) ParseError!EpicArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            var title: ?[]const u8 = null;\n            var description: ?[]const u8 = null;\n            var priority: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--description\")) {\n                    description = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (title == null) {\n                        title = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (title == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .create = .{\n                .title = title.?,\n                .description = description,\n                .priority = priority,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .add = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const epic_id = self.next() orelse return error.MissingRequiredArgument;\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .remove = .{ .epic_id = epic_id, .issue_id = issue_id } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .epic_id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"status\")) {\n            return .{ .subcommand = .{ .status = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"close-eligible\")) {\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .close_eligible = .{ .dry_run = dry_run } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseLabelArgs(self: *Self) ParseError!LabelArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\") or std.mem.eql(u8, subcmd, \"remove\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            const is_add = std.mem.eql(u8, subcmd, \"add\");\n            const id = self.next() orelse return error.MissingRequiredArgument;\n            var labels: std.ArrayListUnmanaged([]const u8) = .{};\n\n            while (self.peekPositional()) |_| {\n                labels.append(self.allocator, self.next().?) catch return error.InvalidArgument;\n            }\n\n            if (labels.items.len == 0) return error.MissingRequiredArgument;\n\n            const label_slice = labels.toOwnedSlice(self.allocator) catch return error.InvalidArgument;\n            if (is_add) {\n                return .{ .subcommand = .{ .add = .{ .id = id, .labels = label_slice } } };\n            } else {\n                return .{ .subcommand = .{ .remove = .{ .id = id, .labels = label_slice } } };\n            }\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list-all\") or std.mem.eql(u8, subcmd, \"all\")) {\n            return .{ .subcommand = .{ .list_all = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"rename\") or std.mem.eql(u8, subcmd, \"mv\")) {\n            const old_name = self.next() orelse return error.MissingRequiredArgument;\n            const new_name = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .rename = .{ .old_name = old_name, .new_name = new_name } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCommentsArgs(self: *Self) ParseError!CommentsArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"add\")) {\n            return .{ .subcommand = .{ .add = .{\n                .id = self.next() orelse return error.MissingRequiredArgument,\n                .text = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = .{ .id = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseHistoryArgs(self: *Self) ParseError!HistoryArgs {\n        const id = self.next() orelse return error.MissingRequiredArgument;\n        return .{ .id = id };\n    }\n\n    fn parseAuditArgs(self: *Self) ParseError!AuditArgs {\n        // Check for subcommand\n        const subcmd = self.next() orelse {\n            // Default: list with no limit\n            return .{ .subcommand = .{ .list = .{ .limit = null } } };\n        };\n\n        // Handle --limit flag at top level (legacy support)\n        if (std.mem.startsWith(u8, subcmd, \"-\")) {\n            // Put it back and parse as list subcommand with limit\n            self.index -= 1;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"record\")) {\n            const kind = self.next() orelse return error.MissingRequiredArgument;\n            var result = AuditSubcommand{ .record = .{ .kind = kind } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-i\", \"--issue\")) {\n                    result.record.issue_id = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-m\", \"--model\")) {\n                    result.record.model = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--prompt\")) {\n                    result.record.prompt = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--response\")) {\n                    result.record.response = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--tool-name\")) {\n                    result.record.tool_name = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-e\", \"--exit-code\")) {\n                    const exit_str = self.next() orelse return error.MissingFlagValue;\n                    result.record.exit_code = std.fmt.parseInt(i32, exit_str, 10) catch return error.InvalidFlagValue;\n                } else if (self.consumeFlag(null, \"--metadata\")) {\n                    result.record.metadata = self.next() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = result };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"label\")) {\n            const entry_id_str = self.next() orelse return error.MissingRequiredArgument;\n            const entry_id = std.fmt.parseInt(i64, entry_id_str, 10) catch return error.InvalidArgument;\n            var label_value: ?[]const u8 = null;\n            var reason: ?[]const u8 = null;\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-l\", \"--label\")) {\n                    label_value = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-r\", \"--reason\")) {\n                    reason = self.next() orelse return error.MissingFlagValue;\n                } else if (self.peekPositional()) |_| {\n                    if (label_value == null) {\n                        label_value = self.next().?;\n                    } else break;\n                } else break;\n            }\n\n            if (label_value == null) return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .label = .{\n                .entry_id = entry_id,\n                .label_value = label_value.?,\n                .reason = reason,\n            } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"log\")) {\n            const issue_id = self.next() orelse return error.MissingRequiredArgument;\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .log = .{ .issue_id = issue_id, .limit = limit } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"summary\")) {\n            var days: u32 = 7;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-d\", \"--days\")) {\n                    days = try self.consumeU32() orelse return error.MissingFlagValue;\n                } else break;\n            }\n            return .{ .subcommand = .{ .summary = .{ .days = days } } };\n        }\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            var limit: ?u32 = null;\n            while (self.hasNext()) {\n                if (try self.parseLimitFlag()) |l| {\n                    limit = l;\n                } else break;\n            }\n            return .{ .subcommand = .{ .list = .{ .limit = limit } } };\n        }\n\n        return error.UnknownSubcommand;\n    }\n\n    fn parseChangelogArgs(self: *Self) ParseError!ChangelogArgs {\n        var result = ChangelogArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(null, \"--since\")) {\n                result.since = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--until\")) {\n                result.until = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--since-tag\")) {\n                result.since_tag = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--since-commit\")) {\n                result.since_commit = self.next() orelse return error.MissingFlagValue;\n            } else if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(\"-g\", \"--group-by\")) {\n                result.group_by = self.next() orelse return error.MissingFlagValue;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseSyncArgs(self: *Self) ParseError!SyncArgs {\n        var result = SyncArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"--export\", \"--flush-only\")) {\n                result.flush_only = true;\n            } else if (self.consumeFlag(\"--import\", \"--import-only\")) {\n                result.import_only = true;\n            } else if (self.consumeFlag(\"-m\", \"--merge\")) {\n                result.merge = true;\n            } else if (self.consumeFlag(\"-s\", \"--status\")) {\n                result.status = true;\n            } else if (self.consumeFlag(null, \"--manifest\")) {\n                result.manifest = true;\n            } else if (self.consumeFlag(null, \"--error-policy\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.error_policy = ErrorPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--orphans\")) {\n                const policy_str = self.next() orelse return error.MissingFlagValue;\n                result.orphan_policy = OrphanPolicy.fromString(policy_str) orelse return error.InvalidArgument;\n            } else if (self.consumeFlag(null, \"--rename-prefix\")) {\n                result.rename_prefix = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseBackupArgs(self: *Self) ParseError!BackupArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"diff\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            return .{ .subcommand = .{ .diff = .{ .file = file } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"restore\")) {\n            const file = self.next() orelse return error.MissingRequiredArgument;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .restore = .{ .file = file, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"prune\")) {\n            var keep: u32 = 10;\n            var dry_run = false;\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-k\", \"--keep\")) {\n                    const keep_str = self.next() orelse return error.MissingFlagValue;\n                    keep = std.fmt.parseInt(u32, keep_str, 10) catch return error.InvalidArgument;\n                } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                    dry_run = true;\n                } else break;\n            }\n            return .{ .subcommand = .{ .prune = .{ .keep = keep, .dry_run = dry_run } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"create\") or std.mem.eql(u8, subcmd, \"new\")) {\n            return .{ .subcommand = .{ .create = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseCompletionsArgs(self: *Self) ParseError!CompletionsArgs {\n        const shell_str = self.next() orelse return error.MissingRequiredArgument;\n        const shell = Shell.fromString(shell_str) orelse return error.InvalidShell;\n        return .{ .shell = shell };\n    }\n\n    fn parseMetricsArgs(self: *Self) ParseError!MetricsArgs {\n        var result = MetricsArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-r\", \"--reset\")) {\n                result.reset = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseHelpArgs(self: *Self) ParseError!HelpArgs {\n        return .{ .topic = self.next() };\n    }\n\n    fn parseConfigArgs(self: *Self) ParseError!ConfigArgs {\n        const subcmd = self.next() orelse return .{ .subcommand = .{ .list = {} } };\n\n        if (std.mem.eql(u8, subcmd, \"get\")) {\n            return .{ .subcommand = .{ .get = .{ .key = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"set\")) {\n            return .{ .subcommand = .{ .set = .{\n                .key = self.next() orelse return error.MissingRequiredArgument,\n                .value = self.next() orelse return error.MissingRequiredArgument,\n            } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseOrphansArgs(self: *Self) ParseError!OrphansArgs {\n        var result = OrphansArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else if (self.consumeFlag(null, \"--hierarchy-only\")) {\n                result.hierarchy_only = true;\n            } else if (self.consumeFlag(null, \"--deps-only\")) {\n                result.deps_only = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseLintArgs(self: *Self) ParseError!LintArgs {\n        var result = LintArgs{};\n        while (self.hasNext()) {\n            if (try self.parseLimitFlag()) |limit| {\n                result.limit = limit;\n            } else break;\n        }\n        return result;\n    }\n\n    fn parseQueryArgs(self: *Self) ParseError!QueryArgs {\n        const subcmd = self.next() orelse return error.MissingRequiredArgument;\n\n        if (std.mem.eql(u8, subcmd, \"save\")) {\n            const name = self.next() orelse return error.MissingRequiredArgument;\n            var save_args = QuerySubcommand{ .save = .{ .name = name } };\n\n            while (self.hasNext()) {\n                if (self.consumeFlag(\"-s\", \"--status\")) {\n                    save_args.save.status = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-p\", \"--priority\")) {\n                    save_args.save.priority = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-t\", \"--type\")) {\n                    save_args.save.issue_type = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-a\", \"--assignee\")) {\n                    save_args.save.assignee = self.next() orelse return error.MissingFlagValue;\n                } else if (self.consumeFlag(\"-l\", \"--label\")) {\n                    save_args.save.label = self.next() orelse return error.MissingFlagValue;\n                } else if (try self.parseLimitFlag()) |limit| {\n                    save_args.save.limit = limit;\n                } else break;\n            }\n\n            return .{ .subcommand = save_args };\n        }\n        if (std.mem.eql(u8, subcmd, \"run\")) {\n            return .{ .subcommand = .{ .run = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        if (std.mem.eql(u8, subcmd, \"list\") or std.mem.eql(u8, subcmd, \"ls\")) {\n            return .{ .subcommand = .{ .list = {} } };\n        }\n        if (std.mem.eql(u8, subcmd, \"delete\") or std.mem.eql(u8, subcmd, \"rm\")) {\n            return .{ .subcommand = .{ .delete = .{ .name = self.next() orelse return error.MissingRequiredArgument } } };\n        }\n        return error.UnknownSubcommand;\n    }\n\n    fn parseUpgradeArgs(self: *Self) ParseError!UpgradeArgs {\n        var result = UpgradeArgs{};\n        while (self.hasNext()) {\n            if (self.consumeFlag(\"-c\", \"--check\")) {\n                result.check_only = true;\n            } else if (self.consumeFlag(\"-n\", \"--dry-run\")) {\n                result.dry_run = true;\n            } else if (self.consumeFlag(\"-V\", \"--version\")) {\n                result.version = self.next() orelse return error.MissingFlagValue;\n            } else if (self.consumeFlag(null, \"--no-verify\")) {\n                result.verify = false;\n            } else if (self.consumeFlag(null, \"--verify\")) {\n                result.verify = true;\n            } else if (self.consumeFlag(\"-f\", \"--force\")) {\n                result.force = true;\n            } else break;\n        }\n        return result;\n    }\n\n    fn hasNext(self: *Self) bool {\n        return self.index < self.args.len;\n    }\n\n    fn peek(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        return self.args[self.index];\n    }\n\n    fn next(self: *Self) ?[]const u8 {\n        if (self.index >= self.args.len) return null;\n        const arg = self.args[self.index];\n        self.index += 1;\n        return arg;\n    }\n\n    /// Skip a peeked argument (used after checking with peek() and wanting to consume it).\n    fn skip(self: *Self) void {\n        if (self.index < self.args.len) {\n            self.index += 1;\n        }\n    }\n\n    /// Check if current arg matches a flag, and if so consume it and return true.\n    fn consumeFlag(self: *Self, short: ?[]const u8, long: []const u8) bool {\n        const arg = self.peek() orelse return false;\n        if (std.mem.eql(u8, arg, long) or (short != null and std.mem.eql(u8, arg, short.?))) {\n            self.skip();\n            return true;\n        }\n        return false;\n    }\n\n    /// Parse a u32 value after consuming a flag. Returns null if missing, error if invalid.\n    fn consumeU32(self: *Self) ParseError!?u32 {\n        const val = self.next() orelse return error.MissingFlagValue;\n        return std.fmt.parseInt(u32, val, 10) catch return error.InvalidArgument;\n    }\n\n    /// Parse an optional --limit/-n flag, returning the value if present.\n    fn parseLimitFlag(self: *Self) ParseError!?u32 {\n        if (self.consumeFlag(\"-n\", \"--limit\")) {\n            return try self.consumeU32();\n        }\n        return null;\n    }\n\n    /// Returns the next arg if it's a positional (doesn't start with \"-\"), otherwise null.\n    fn peekPositional(self: *Self) ?[]const u8 {\n        const arg = self.peek() orelse return null;\n        if (std.mem.startsWith(u8, arg, \"-\")) return null;\n        return arg;\n    }\n};\n\n// Tests\n\ntest \"parse no arguments shows help\" {\n    const args = [_][]const u8{};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqual(@as(?[]const u8, null), result.command.help.topic);\n}\n\ntest \"parse global flag --json\" {\n    const args = [_][]const u8{ \"--json\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --json after subcommand\" {\n    const args = [_][]const u8{ \"list\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --json after subcommand with ready\" {\n    const args = [_][]const u8{ \"ready\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse global flags before and after subcommand\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\", \"--json\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --toon\" {\n    const args = [_][]const u8{ \"--toon\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.toon);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -q (quiet)\" {\n    const args = [_][]const u8{ \"-q\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag --quiet\" {\n    const args = [_][]const u8{ \"--quiet\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.quiet);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse global flag -v (verbose)\" {\n    const args = [_][]const u8{ \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n}\n\ntest \"parse global flag -v multiple times\" {\n    const args = [_][]const u8{ \"-v\", \"-v\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag -vv (double verbose)\" {\n    const args = [_][]const u8{ \"-vv\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u8, 2), result.global.verbose);\n}\n\ntest \"parse global flag --no-color\" {\n    const args = [_][]const u8{ \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_color);\n}\n\ntest \"parse global flag --no-auto-flush\" {\n    const args = [_][]const u8{ \"--no-auto-flush\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_flush);\n}\n\ntest \"parse global flag --no-auto-import\" {\n    const args = [_][]const u8{ \"--no-auto-import\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.no_auto_import);\n}\n\ntest \"parse global flag --data with value\" {\n    const args = [_][]const u8{ \"--data\", \"/custom/path\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"/custom/path\", result.global.data_path.?);\n}\n\ntest \"parse global flag --actor with value\" {\n    const args = [_][]const u8{ \"--actor\", \"alice\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"alice\", result.global.actor.?);\n}\n\ntest \"parse global flag --lock-timeout with value\" {\n    const args = [_][]const u8{ \"--lock-timeout\", \"10000\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 10000), result.global.lock_timeout);\n}\n\ntest \"parse multiple global flags\" {\n    const args = [_][]const u8{ \"--json\", \"-v\", \"--no-color\", \"list\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.global.json);\n    try std.testing.expectEqual(@as(u8, 1), result.global.verbose);\n    try std.testing.expect(result.global.no_color);\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse unknown command returns error\" {\n    const args = [_][]const u8{\"unknown_command\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.UnknownCommand, parser.parse());\n}\n\ntest \"parse help command\" {\n    const args = [_][]const u8{\"help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse help command with topic\" {\n    const args = [_][]const u8{ \"help\", \"create\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n    try std.testing.expectEqualStrings(\"create\", result.command.help.topic.?);\n}\n\ntest \"parse --help as help command\" {\n    const args = [_][]const u8{\"--help\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse -h as help command\" {\n    const args = [_][]const u8{\"-h\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .help);\n}\n\ntest \"parse version command\" {\n    const args = [_][]const u8{\"version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse --version as version command\" {\n    const args = [_][]const u8{\"--version\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse -V as version command\" {\n    const args = [_][]const u8{\"-V\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .version);\n}\n\ntest \"parse init command\" {\n    const args = [_][]const u8{\"init\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"bd\", result.command.init.prefix);\n}\n\ntest \"parse init command with prefix\" {\n    const args = [_][]const u8{ \"init\", \"--prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .init);\n    try std.testing.expectEqualStrings(\"proj\", result.command.init.prefix);\n}\n\ntest \"parse create command with title\" {\n    const args = [_][]const u8{ \"create\", \"Fix login bug\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .create);\n    try std.testing.expectEqualStrings(\"Fix login bug\", result.command.create.title);\n}\n\ntest \"parse create command missing title returns error\" {\n    const args = [_][]const u8{\"create\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse create command with all options\" {\n    const args = [_][]const u8{\n        \"create\",\n        \"Fix login bug\",\n        \"--description\",\n        \"OAuth fails for Google\",\n        \"--type\",\n        \"bug\",\n        \"--priority\",\n        \"high\",\n        \"--assignee\",\n        \"alice\",\n        \"--due\",\n        \"2024-02-15\",\n        \"--estimate\",\n        \"60\",\n    };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const create = result.command.create;\n    try std.testing.expectEqualStrings(\"Fix login bug\", create.title);\n    try std.testing.expectEqualStrings(\"OAuth fails for Google\", create.description.?);\n    try std.testing.expectEqualStrings(\"bug\", create.issue_type.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n    try std.testing.expectEqualStrings(\"alice\", create.assignee.?);\n    try std.testing.expectEqualStrings(\"2024-02-15\", create.due.?);\n    try std.testing.expectEqual(@as(i32, 60), create.estimate.?);\n}\n\ntest \"parse q (quick) command\" {\n    const args = [_][]const u8{ \"q\", \"Quick issue\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .q);\n    try std.testing.expectEqualStrings(\"Quick issue\", result.command.q.title);\n}\n\ntest \"parse show command\" {\n    const args = [_][]const u8{ \"show\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .show);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.show.id);\n}\n\ntest \"parse show command missing id returns error\" {\n    const args = [_][]const u8{\"show\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse update command\" {\n    const args = [_][]const u8{ \"update\", \"bd-abc123\", \"--title\", \"New title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .update);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.update.id);\n    try std.testing.expectEqualStrings(\"New title\", result.command.update.title.?);\n}\n\ntest \"parse close command\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n}\n\ntest \"parse close command with reason\" {\n    const args = [_][]const u8{ \"close\", \"bd-abc123\", \"--reason\", \"Fixed in PR #42\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .close);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.close.id);\n    try std.testing.expectEqualStrings(\"Fixed in PR #42\", result.command.close.reason.?);\n}\n\ntest \"parse reopen command\" {\n    const args = [_][]const u8{ \"reopen\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .reopen);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.reopen.id);\n}\n\ntest \"parse delete command\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n}\n\ntest \"parse delete command with flags\" {\n    const args_arr = [_][]const u8{ \"delete\", \"bd-abc123\", \"--cascade\", \"--dry-run\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.delete.id.?);\n    try std.testing.expect(result.command.delete.cascade);\n    try std.testing.expect(result.command.delete.dry_run);\n    try std.testing.expect(!result.command.delete.hard);\n}\n\ntest \"parse delete command with from-file\" {\n    const args_arr = [_][]const u8{ \"delete\", \"--from-file\", \"ids.txt\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_arr);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .delete);\n    try std.testing.expect(result.command.delete.id == null);\n    try std.testing.expectEqualStrings(\"ids.txt\", result.command.delete.from_file.?);\n}\n\ntest \"parse list command\" {\n    const args = [_][]const u8{\"list\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .list);\n}\n\ntest \"parse list command with filters\" {\n    const args = [_][]const u8{ \"list\", \"--status\", \"open\", \"--priority\", \"high\", \"--limit\", \"10\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const list = result.command.list;\n    try std.testing.expectEqualStrings(\"open\", list.status.?);\n    try std.testing.expectEqualStrings(\"high\", list.priority.?);\n    try std.testing.expectEqual(@as(u32, 10), list.limit.?);\n}\n\ntest \"parse list --all flag\" {\n    const args = [_][]const u8{ \"list\", \"--all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.list.all);\n}\n\ntest \"parse list --sort flag\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"priority\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.priority, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc); // default\n}\n\ntest \"parse list --sort with --asc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"updated\", \"--asc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.updated_at, result.command.list.sort);\n    try std.testing.expect(!result.command.list.sort_desc);\n}\n\ntest \"parse list --sort with --desc\" {\n    const args = [_][]const u8{ \"list\", \"--sort\", \"created\", \"--desc\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(SortField.created_at, result.command.list.sort);\n    try std.testing.expect(result.command.list.sort_desc);\n}\n\ntest \"SortField.fromString\" {\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created\").?);\n    try std.testing.expectEqual(SortField.created_at, SortField.fromString(\"created_at\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated\").?);\n    try std.testing.expectEqual(SortField.updated_at, SortField.fromString(\"updated_at\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"priority\").?);\n    try std.testing.expectEqual(SortField.priority, SortField.fromString(\"PRIORITY\").?);\n    try std.testing.expectEqual(@as(?SortField, null), SortField.fromString(\"invalid\"));\n}\n\ntest \"parse ready command\" {\n    const args = [_][]const u8{\"ready\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .ready);\n}\n\ntest \"parse blocked command\" {\n    const args = [_][]const u8{\"blocked\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .blocked);\n}\n\ntest \"parse search command\" {\n    const args = [_][]const u8{ \"search\", \"login\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .search);\n    try std.testing.expectEqualStrings(\"login\", result.command.search.query);\n}\n\ntest \"parse search command missing query returns error\" {\n    const args = [_][]const u8{\"search\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse stale command\" {\n    const args = [_][]const u8{\"stale\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .stale);\n    try std.testing.expectEqual(@as(u32, 30), result.command.stale.days);\n}\n\ntest \"parse stale command with days\" {\n    const args = [_][]const u8{ \"stale\", \"--days\", \"7\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(@as(u32, 7), result.command.stale.days);\n}\n\ntest \"parse count command\" {\n    const args = [_][]const u8{\"count\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .count);\n}\n\ntest \"parse count command with group-by\" {\n    const args = [_][]const u8{ \"count\", \"--group-by\", \"status\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"status\", result.command.count.group_by.?);\n}\n\ntest \"parse dep add command\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .dep);\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n}\n\ntest \"parse dep add command with type\" {\n    const args = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"relates_to\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"relates_to\", add.dep_type);\n}\n\ntest \"parse dep remove command\" {\n    const args = [_][]const u8{ \"dep\", \"remove\", \"bd-child\", \"bd-parent\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const remove = result.command.dep.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-child\", remove.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", remove.parent);\n}\n\ntest \"parse dep list command\" {\n    const args = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.list.id);\n}\n\ntest \"parse dep tree command\" {\n    const args = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.dep.subcommand.tree.id);\n}\n\ntest \"parse dep cycles command\" {\n    const args = [_][]const u8{ \"dep\", \"cycles\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.dep.subcommand == .cycles);\n}\n\ntest \"parse dep add command with metadata\" {\n    const input = [_][]const u8{ \"dep\", \"add\", \"bd-child\", \"bd-parent\", \"--type\", \"blocks\", \"--metadata\", \"{\\\"reason\\\":\\\"needs API\\\"}\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const add = result.command.dep.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-child\", add.child);\n    try std.testing.expectEqualStrings(\"bd-parent\", add.parent);\n    try std.testing.expectEqualStrings(\"blocks\", add.dep_type);\n    try std.testing.expectEqualStrings(\"{\\\"reason\\\":\\\"needs API\\\"}\", add.metadata.?);\n}\n\ntest \"parse dep list command with direction down\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"down\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqualStrings(\"bd-abc123\", list.id);\n    try std.testing.expectEqual(DepDirection.down, list.direction);\n}\n\ntest \"parse dep list command with direction up\" {\n    const input = [_][]const u8{ \"dep\", \"list\", \"bd-abc123\", \"--direction\", \"up\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const list = result.command.dep.subcommand.list;\n    try std.testing.expectEqual(DepDirection.up, list.direction);\n}\n\ntest \"parse dep tree command with format mermaid\" {\n    const input = [_][]const u8{ \"dep\", \"tree\", \"bd-abc123\", \"--format\", \"mermaid\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const tree = result.command.dep.subcommand.tree;\n    try std.testing.expectEqualStrings(\"bd-abc123\", tree.id);\n    try std.testing.expectEqual(TreeFormat.mermaid, tree.format);\n}\n\ntest \"parse label add command\" {\n    const args = [_][]const u8{ \"label\", \"add\", \"bd-abc123\", \"urgent\", \"backend\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.add.labels);\n\n    const add = result.command.label.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqual(@as(usize, 2), add.labels.len);\n    try std.testing.expectEqualStrings(\"urgent\", add.labels[0]);\n    try std.testing.expectEqualStrings(\"backend\", add.labels[1]);\n}\n\ntest \"parse label remove command\" {\n    const args = [_][]const u8{ \"label\", \"remove\", \"bd-abc123\", \"old-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n    defer std.testing.allocator.free(result.command.label.subcommand.remove.labels);\n\n    const remove = result.command.label.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-abc123\", remove.id);\n    try std.testing.expectEqual(@as(usize, 1), remove.labels.len);\n    try std.testing.expectEqualStrings(\"old-label\", remove.labels[0]);\n}\n\ntest \"parse label list command\" {\n    const args = [_][]const u8{ \"label\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.label.subcommand.list.id);\n}\n\ntest \"parse label list-all command\" {\n    const args = [_][]const u8{ \"label\", \"list-all\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.label.subcommand == .list_all);\n}\n\ntest \"parse label rename command\" {\n    const input = [_][]const u8{ \"label\", \"rename\", \"old-label\", \"new-label\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-label\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-label\", rename.new_name);\n}\n\ntest \"parse label mv command (alias for rename)\" {\n    const input = [_][]const u8{ \"label\", \"mv\", \"old-name\", \"new-name\" };\n    var parser = ArgParser.init(std.testing.allocator, &input);\n    const result = try parser.parse();\n\n    const rename = result.command.label.subcommand.rename;\n    try std.testing.expectEqualStrings(\"old-name\", rename.old_name);\n    try std.testing.expectEqualStrings(\"new-name\", rename.new_name);\n}\n\ntest \"parse comments add command\" {\n    const args = [_][]const u8{ \"comments\", \"add\", \"bd-abc123\", \"This is a comment\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const add = result.command.comments.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-abc123\", add.id);\n    try std.testing.expectEqualStrings(\"This is a comment\", add.text);\n}\n\ntest \"parse comments list command\" {\n    const args = [_][]const u8{ \"comments\", \"list\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.comments.subcommand.list.id);\n}\n\ntest \"parse history command\" {\n    const args = [_][]const u8{ \"history\", \"bd-abc123\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .history);\n    try std.testing.expectEqualStrings(\"bd-abc123\", result.command.history.id);\n}\n\ntest \"parse audit command\" {\n    const args = [_][]const u8{\"audit\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .audit);\n}\n\ntest \"parse audit command with limit\" {\n    const args = [_][]const u8{ \"audit\", \"--limit\", \"50\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    var result = try parser.parse();\n    defer result.deinit(std.testing.allocator);\n\n    switch (result.command.audit.subcommand) {\n        .list => |list_args| try std.testing.expectEqual(@as(u32, 50), list_args.limit.?),\n        else => try std.testing.expect(false),\n    }\n}\n\ntest \"parse sync command\" {\n    const args = [_][]const u8{\"sync\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .sync);\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --flush-only\" {\n    const args = [_][]const u8{ \"sync\", \"--flush-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command.sync.flush_only);\n    try std.testing.expect(!result.command.sync.import_only);\n}\n\ntest \"parse sync --import-only\" {\n    const args = [_][]const u8{ \"sync\", \"--import-only\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(!result.command.sync.flush_only);\n    try std.testing.expect(result.command.sync.import_only);\n}\n\ntest \"parse completions command with bash\" {\n    const args = [_][]const u8{ \"completions\", \"bash\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .completions);\n    try std.testing.expectEqual(Shell.bash, result.command.completions.shell);\n}\n\ntest \"parse completions command with zsh\" {\n    const args = [_][]const u8{ \"completions\", \"zsh\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.zsh, result.command.completions.shell);\n}\n\ntest \"parse completions command with fish\" {\n    const args = [_][]const u8{ \"completions\", \"fish\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.fish, result.command.completions.shell);\n}\n\ntest \"parse completions command with powershell\" {\n    const args = [_][]const u8{ \"completions\", \"powershell\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqual(Shell.powershell, result.command.completions.shell);\n}\n\ntest \"parse completions command with invalid shell returns error\" {\n    const args = [_][]const u8{ \"completions\", \"invalid\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.InvalidShell, parser.parse());\n}\n\ntest \"parse completions command missing shell returns error\" {\n    const args = [_][]const u8{\"completions\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"parse config list (default)\" {\n    const args = [_][]const u8{\"config\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .config);\n    try std.testing.expect(result.command.config.subcommand == .list);\n}\n\ntest \"parse config get\" {\n    const args = [_][]const u8{ \"config\", \"get\", \"id.prefix\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expectEqualStrings(\"id.prefix\", result.command.config.subcommand.get.key);\n}\n\ntest \"parse config set\" {\n    const args = [_][]const u8{ \"config\", \"set\", \"id.prefix\", \"proj\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    const set = result.command.config.subcommand.set;\n    try std.testing.expectEqualStrings(\"id.prefix\", set.key);\n    try std.testing.expectEqualStrings(\"proj\", set.value);\n}\n\ntest \"command aliases work\" {\n    // Test 'add' as alias for 'create'\n    {\n        const args = [_][]const u8{ \"add\", \"Test title\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .create);\n    }\n\n    // Test 'ls' as alias for 'list'\n    {\n        const args = [_][]const u8{\"ls\"};\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .list);\n    }\n\n    // Test 'rm' as alias for 'delete'\n    {\n        const args = [_][]const u8{ \"rm\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .delete);\n    }\n\n    // Test 'done' as alias for 'close'\n    {\n        const args = [_][]const u8{ \"done\", \"bd-abc\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .close);\n    }\n\n    // Test 'find' as alias for 'search'\n    {\n        const args = [_][]const u8{ \"find\", \"query\" };\n        var parser = ArgParser.init(std.testing.allocator, &args);\n        const result = try parser.parse();\n        try std.testing.expect(result.command == .search);\n    }\n}\n\ntest \"parse epic create command\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"Test Epic Title\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"Test Epic Title\", create.title);\n}\n\ntest \"parse epic create with options\" {\n    const args = [_][]const u8{ \"epic\", \"create\", \"My Epic\", \"--description\", \"Epic description\", \"--priority\", \"high\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const create = result.command.epic.subcommand.create;\n    try std.testing.expectEqualStrings(\"My Epic\", create.title);\n    try std.testing.expectEqualStrings(\"Epic description\", create.description.?);\n    try std.testing.expectEqualStrings(\"high\", create.priority.?);\n}\n\ntest \"parse epic add command\" {\n    const args = [_][]const u8{ \"epic\", \"add\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const add = result.command.epic.subcommand.add;\n    try std.testing.expectEqualStrings(\"bd-epic1\", add.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", add.issue_id);\n}\n\ntest \"parse epic remove command\" {\n    const args = [_][]const u8{ \"epic\", \"remove\", \"bd-epic1\", \"bd-task1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    const remove = result.command.epic.subcommand.remove;\n    try std.testing.expectEqualStrings(\"bd-epic1\", remove.epic_id);\n    try std.testing.expectEqualStrings(\"bd-task1\", remove.issue_id);\n}\n\ntest \"parse epic list command\" {\n    const args = [_][]const u8{ \"epic\", \"list\", \"bd-epic1\" };\n    var parser = ArgParser.init(std.testing.allocator, &args);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .epic);\n    try std.testing.expectEqualStrings(\"bd-epic1\", result.command.epic.subcommand.list.epic_id);\n}\n\ntest \"parse epic command missing subcommand\" {\n    const args = [_][]const u8{\"epic\"};\n    var parser = ArgParser.init(std.testing.allocator, &args);\n\n    try std.testing.expectError(error.MissingRequiredArgument, parser.parse());\n}\n\ntest \"Shell.fromString handles case insensitivity\" {\n    try std.testing.expectEqual(Shell.bash, Shell.fromString(\"BASH\").?);\n    try std.testing.expectEqual(Shell.zsh, Shell.fromString(\"ZSH\").?);\n    try std.testing.expectEqual(Shell.fish, Shell.fromString(\"Fish\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"PowerShell\").?);\n    try std.testing.expectEqual(Shell.powershell, Shell.fromString(\"ps\").?);\n}\n\ntest \"GlobalOptions.isStructuredOutput\" {\n    // Default: neither json nor toon\n    const default_opts = GlobalOptions{};\n    try std.testing.expect(!default_opts.isStructuredOutput());\n\n    // JSON mode\n    const json_opts = GlobalOptions{ .json = true };\n    try std.testing.expect(json_opts.isStructuredOutput());\n\n    // TOON mode\n    const toon_opts = GlobalOptions{ .toon = true };\n    try std.testing.expect(toon_opts.isStructuredOutput());\n\n    // Both (edge case)\n    const both_opts = GlobalOptions{ .json = true, .toon = true };\n    try std.testing.expect(both_opts.isStructuredOutput());\n}\n\ntest \"parse metrics command\" {\n    const args_list = [_][]const u8{\"metrics\"};\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(!result.command.metrics.reset);\n}\n\ntest \"parse metrics command with reset flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"--reset\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n\ntest \"parse metrics command with -r flag\" {\n    const args_list = [_][]const u8{ \"metrics\", \"-r\" };\n    var parser = ArgParser.init(std.testing.allocator, &args_list);\n    const result = try parser.parse();\n\n    try std.testing.expect(result.command == .metrics);\n    try std.testing.expect(result.command.metrics.reset);\n}\n","structuredPatch":[{"oldStart":777,"oldLines":10,"newStart":777,"newLines":7,"lines":["                 }","             }"," ","-            // Not a global flag - check if it's the subcommand","-            if (cmd_index == null and !std.mem.startsWith(u8, arg, \"-\")) {","-                cmd_index = filtered_indices.items.len;","-            }","+            // Not a global flag - add to filtered list","             filtered_indices.append(self.allocator, i) catch return error.InvalidArgument;","             i += 1;","         }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017hEBTMQCrMyV3JS3hEQKUU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015DRUd4c9K2CJiMsmJ3GMr2","name":"TodoWrite","input":{"todos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"in_progress","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":282,"cache_read_input_tokens":39944,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":282},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"e1b7ffc6-d0bc-4c9e-98c3-808228d5319d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015DRUd4c9K2CJiMsmJ3GMr2","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"779ffd75-5fb4-4168-9289-87d5270c01dc","tool_use_result":{"oldTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"in_progress","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"pending","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"in_progress","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011JtogqdAh82HofvePKVbzi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DBzZLgrv1xzMaLwiQC45EJ","name":"Bash","input":{"command":"zig build test 2>&1","description":"Run all tests to verify changes","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":227,"cache_read_input_tokens":40226,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":227},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"b71ad3f8-7626-492d-8841-66093b297cbe"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DBzZLgrv1xzMaLwiQC45EJ","type":"tool_result","content":"<persisted-output>\nOutput too large (60.2KB). Full output saved to: /home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/6fe22edc-8a2d-4da5-a4e1-dac342168a2c/tool-results/toolu_01DBzZLgrv1xzMaLwiQC45EJ.txt\n\nPreview (first 2KB):\n1/710 root.test_0...OK\n2/710 cli.mod.test_0...OK\n3/710 storage.mod.test_0...OK\n4/710 models.mod.test_0...OK\n5/710 sync.mod.test_0...OK\n6/710 id.mod.test_0...OK\n7/710 config.mod.test_0...OK\n8/710 output.mod.test.OutputMode enum values...OK\n9/710 output.mod.test.Output.init with json option...OK\n10/710 output.mod.test.Output.init with toon option...OK\n11/710 output.mod.test.Output.init with quiet option...OK\n12/710 output.mod.test.Output.init with no_color option forces plain mode...OK\n13/710 output.mod.test.Output.init json overrides quiet...OK\n14/710 output.mod.test.Output.initWithMode sets explicit mode...OK\n15/710 output.mod.test.abbreviateStatus returns 4-char strings...OK\n16/710 output.mod.test.priorityIndicator returns 3-char strings...OK\n17/710 output.mod.test.getStatusColor returns valid ANSI codes...OK\n18/710 output.mod.test.getPriorityColor returns valid ANSI codes...OK\n19/710 output.mod.test.Color constants are valid ANSI escape sequences...OK\n20/710 output.mod.test.Output printIssueListQuiet writes IDs only...OK\n21/710 output.mod.test.Output printIssueListPlain writes formatted lines...OK\n22/710 output.mod.test.Output printIssueListRich includes ANSI codes...OK\n23/710 output.mod.test.Output printIssueListJson produces valid JSON array...OK\n24/710 output.mod.test.Output.err formats error messages correctly...OK\n25/710 output.mod.test.Output.warn formats warning messages correctly...OK\n26/710 output.mod.test.Output quiet mode suppresses print but not err...OK\n27/710 output.mod.test.Output.success uses green color in rich mode...OK\n28/710 output.mod.test.Output.printIssue in plain mode shows all fields...OK\n29/710 errors.test.ErrorCategory.toString returns correct strings...OK\n30/710 errors.test.BeadsError.workspaceNotInitialized...OK\n31/710 errors.test.BeadsError.issueNotFound...OK\n32/710 errors.test.BeadsError.dependencyCycle...OK\n33/710 errors.test.BeadsError.format...OK\n34/710 errors.test.BeadsError.format with details...OK\n...\n</persisted-output>","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"f4f61482-9be6-4f3d-a317-b1075cceeb04","tool_use_result":{"stdout":"1/710 root.test_0...OK\n2/710 cli.mod.test_0...OK\n3/710 storage.mod.test_0...OK\n4/710 models.mod.test_0...OK\n5/710 sync.mod.test_0...OK\n6/710 id.mod.test_0...OK\n7/710 config.mod.test_0...OK\n8/710 output.mod.test.OutputMode enum values...OK\n9/710 output.mod.test.Output.init with json option...OK\n10/710 output.mod.test.Output.init with toon option...OK\n11/710 output.mod.test.Output.init with quiet option...OK\n12/710 output.mod.test.Output.init with no_color option forces plain mode...OK\n13/710 output.mod.test.Output.init json overrides quiet...OK\n14/710 output.mod.test.Output.initWithMode sets explicit mode...OK\n15/710 output.mod.test.abbreviateStatus returns 4-char strings...OK\n16/710 output.mod.test.priorityIndicator returns 3-char strings...OK\n17/710 output.mod.test.getStatusColor returns valid ANSI codes...OK\n18/710 output.mod.test.getPriorityColor returns valid ANSI codes...OK\n19/710 output.mod.test.Color constants are valid ANSI escape sequences...OK\n20/710 output.mod.test.Output printIssueListQuiet writes IDs only...OK\n21/710 output.mod.test.Output printIssueListPlain writes formatted lines...OK\n22/710 output.mod.test.Output printIssueListRich includes ANSI codes...OK\n23/710 output.mod.test.Output printIssueListJson produces valid JSON array...OK\n24/710 output.mod.test.Output.err formats error messages correctly...OK\n25/710 output.mod.test.Output.warn formats warning messages correctly...OK\n26/710 output.mod.test.Output quiet mode suppresses print but not err...OK\n27/710 output.mod.test.Output.success uses green color in rich mode...OK\n28/710 output.mod.test.Output.printIssue in plain mode shows all fields...OK\n29/710 errors.test.ErrorCategory.toString returns correct strings...OK\n30/710 errors.test.BeadsError.workspaceNotInitialized...OK\n31/710 errors.test.BeadsError.issueNotFound...OK\n32/710 errors.test.BeadsError.dependencyCycle...OK\n33/710 errors.test.BeadsError.format...OK\n34/710 errors.test.BeadsError.format with details...OK\n35/710 errors.test.fromError converts common errors...OK\n36/710 errors.test.Result type works for success...OK\n37/710 errors.test.Result type works for error...OK\n38/710 errors.test.Result.unwrapOr returns default on error...OK\n39/710 errors.test.BeadsError JSON serialization...OK\n40/710 test_util.test.createTestDir creates directory...OK\n41/710 tests.mod.test_0...OK\n42/710 cli.args.test.parse no arguments shows help...OK\n43/710 cli.args.test.parse global flag --json...OK\n44/710 cli.args.test.parse global flag --json after subcommand...OK\n45/710 cli.args.test.parse global flag --json after subcommand with ready...OK\n46/710 cli.args.test.parse global flags before and after subcommand...OK\n47/710 cli.args.test.parse global flag --toon...OK\n48/710 cli.args.test.parse global flag -q (quiet)...OK\n49/710 cli.args.test.parse global flag --quiet...OK\n50/710 cli.args.test.parse global flag -v (verbose)...OK\n51/710 cli.args.test.parse global flag -v multiple times...OK\n52/710 cli.args.test.parse global flag -vv (double verbose)...OK\n53/710 cli.args.test.parse global flag --no-color...OK\n54/710 cli.args.test.parse global flag --no-auto-flush...OK\n55/710 cli.args.test.parse global flag --no-auto-import...OK\n56/710 cli.args.test.parse global flag --data with value...OK\n57/710 cli.args.test.parse global flag --actor with value...OK\n58/710 cli.args.test.parse global flag --lock-timeout with value...OK\n59/710 cli.args.test.parse multiple global flags...OK\n60/710 cli.args.test.parse unknown command returns error...OK\n61/710 cli.args.test.parse help command...OK\n62/710 cli.args.test.parse help command with topic...OK\n63/710 cli.args.test.parse --help as help command...OK\n64/710 cli.args.test.parse -h as help command...OK\n65/710 cli.args.test.parse version command...OK\n66/710 cli.args.test.parse --version as version command...OK\n67/710 cli.args.test.parse -V as version command...OK\n68/710 cli.args.test.parse init command...OK\n69/710 cli.args.test.parse init command with prefix...OK\n70/710 cli.args.test.parse create command with title...OK\n71/710 cli.args.test.parse create command missing title returns error...OK\n72/710 cli.args.test.parse create command with all options...OK\n73/710 cli.args.test.parse q (quick) command...OK\n74/710 cli.args.test.parse show command...OK\n75/710 cli.args.test.parse show command missing id returns error...OK\n76/710 cli.args.test.parse update command...OK\n77/710 cli.args.test.parse close command...OK\n78/710 cli.args.test.parse close command with reason...OK\n79/710 cli.args.test.parse reopen command...OK\n80/710 cli.args.test.parse delete command...OK\n81/710 cli.args.test.parse delete command with flags...OK\n82/710 cli.args.test.parse delete command with from-file...OK\n83/710 cli.args.test.parse list command...OK\n84/710 cli.args.test.parse list command with filters...OK\n85/710 cli.args.test.parse list --all flag...OK\n86/710 cli.args.test.parse list --sort flag...OK\n87/710 cli.args.test.parse list --sort with --asc...OK\n88/710 cli.args.test.parse list --sort with --desc...OK\n89/710 cli.args.test.SortField.fromString...OK\n90/710 cli.args.test.parse ready command...OK\n91/710 cli.args.test.parse blocked command...OK\n92/710 cli.args.test.parse search command...OK\n93/710 cli.args.test.parse search command missing query returns error...OK\n94/710 cli.args.test.parse stale command...OK\n95/710 cli.args.test.parse stale command with days...OK\n96/710 cli.args.test.parse count command...OK\n97/710 cli.args.test.parse count command with group-by...OK\n98/710 cli.args.test.parse dep add command...OK\n99/710 cli.args.test.parse dep add command with type...OK\n100/710 cli.args.test.parse dep remove command...OK\n101/710 cli.args.test.parse dep list command...OK\n102/710 cli.args.test.parse dep tree command...OK\n103/710 cli.args.test.parse dep cycles command...OK\n104/710 cli.args.test.parse dep add command with metadata...OK\n105/710 cli.args.test.parse dep list command with direction down...OK\n106/710 cli.args.test.parse dep list command with direction up...OK\n107/710 cli.args.test.parse dep tree command with format mermaid...OK\n108/710 cli.args.test.parse label add command...OK\n109/710 cli.args.test.parse label remove command...OK\n110/710 cli.args.test.parse label list command...OK\n111/710 cli.args.test.parse label list-all command...OK\n112/710 cli.args.test.parse label rename command...OK\n113/710 cli.args.test.parse label mv command (alias for rename)...OK\n114/710 cli.args.test.parse comments add command...OK\n115/710 cli.args.test.parse comments list command...OK\n116/710 cli.args.test.parse history command...OK\n117/710 cli.args.test.parse audit command...OK\n118/710 cli.args.test.parse audit command with limit...OK\n119/710 cli.args.test.parse sync command...OK\n120/710 cli.args.test.parse sync --flush-only...OK\n121/710 cli.args.test.parse sync --import-only...OK\n122/710 cli.args.test.parse completions command with bash...OK\n123/710 cli.args.test.parse completions command with zsh...OK\n124/710 cli.args.test.parse completions command with fish...OK\n125/710 cli.args.test.parse completions command with powershell...OK\n126/710 cli.args.test.parse completions command with invalid shell returns error...OK\n127/710 cli.args.test.parse completions command missing shell returns error...OK\n128/710 cli.args.test.parse config list (default)...OK\n129/710 cli.args.test.parse config get...OK\n130/710 cli.args.test.parse config set...OK\n131/710 cli.args.test.command aliases work...OK\n132/710 cli.args.test.parse epic create command...OK\n133/710 cli.args.test.parse epic create with options...OK\n134/710 cli.args.test.parse epic add command...OK\n135/710 cli.args.test.parse epic remove command...OK\n136/710 cli.args.test.parse epic list command...OK\n137/710 cli.args.test.parse epic command missing subcommand...OK\n138/710 cli.args.test.Shell.fromString handles case insensitivity...OK\n139/710 cli.args.test.GlobalOptions.isStructuredOutput...OK\n140/710 cli.args.test.parse metrics command...OK\n141/710 cli.args.test.parse metrics command with reset flag...OK\n142/710 cli.args.test.parse metrics command with -r flag...OK\n143/710 cli.common.test.CommandContext returns null for uninitialized workspace...OK\n144/710 cli.init.test.init creates workspace directory structure...Initialized beads workspace in .test_tmp/init_structure_1770029212636/.beads/\n  Issue prefix: test\n  Issues file: .test_tmp/init_structure_1770029212636/.beads/issues.jsonl\nOK\n145/710 cli.init.test.init fails if already initialized...Initialized beads workspace in .test_tmp/init_already_1770029212638/.beads/\n  Issue prefix: bd\n  Issues file: .test_tmp/init_already_1770029212638/.beads/issues.jsonl\nerror: workspace already initialized\nOK\n146/710 cli.init.test.init respects custom prefix...Initialized beads workspace in .test_tmp/init_prefix_1770029212639/.beads/\n  Issue prefix: proj\n  Issues file: .test_tmp/init_prefix_1770029212639/.beads/issues.jsonl\nOK\n147/710 cli.init.test.init creates valid metadata.json...Initialized beads workspace in .test_tmp/init_metadata_1770029212640/.beads/\n  Issue prefix: bd\n  Issues file: .test_tmp/init_metadata_1770029212640/.beads/issues.jsonl\nOK\n148/710 cli.init.test.init creates .gitignore with correct entries...Initialized beads workspace in .test_tmp/init_gitignore_1770029212642/.beads/\n  Issue prefix: bd\n  Issues file: .test_tmp/init_gitignore_1770029212642/.beads/issues.jsonl\nOK\n149/710 cli.create.test.parseDateString parses YYYY-MM-DD...OK\n150/710 cli.create.test.parseDateString parses RFC3339...OK\n151/710 cli.create.test.parseDateString returns null for invalid format...OK\n152/710 cli.create.test.getConfigPrefix returns default when file missing...OK\n153/710 cli.create.test.CreateError enum exists...OK\n154/710 cli.create.test.CreateResult struct works...OK\n155/710 cli.create.test.run validates empty title...OK\n156/710 cli.create.test.run validates title length...OK\n157/710 cli.create.test.run creates issue successfully...OK\n158/710 cli.create.test.run detects uninitialized workspace...OK\n159/710 cli.list.test.ListError enum exists...OK\n160/710 cli.list.test.ListResult struct works...OK\n161/710 cli.list.test.run detects uninitialized workspace...OK\n162/710 cli.list.test.run lists issues successfully...OK\n163/710 cli.show.test.ShowError enum exists...OK\n164/710 cli.show.test.ShowResult struct works...OK\n165/710 cli.show.test.run detects uninitialized workspace...OK\n166/710 cli.show.test.run returns error for missing issue...OK\n167/710 cli.show.test.formatTimestamp formats correctly...OK\n168/710 cli.show.test.ShowArgs default values...OK\n169/710 cli.show.test.ShowArgs with_comments can be disabled...OK\n170/710 cli.show.test.ShowArgs with_history can be enabled...OK\n171/710 cli.update.test.UpdateError enum exists...OK\n172/710 cli.update.test.UpdateResult struct works...OK\n173/710 cli.update.test.run detects uninitialized workspace...OK\n174/710 cli.update.test.run returns error for missing issue...OK\n175/710 cli.close.test.CloseError enum exists...OK\n176/710 cli.close.test.CloseResult struct works...OK\n177/710 cli.close.test.run detects uninitialized workspace...OK\n178/710 cli.close.test.runReopen detects uninitialized workspace...OK\n179/710 cli.close.test.run returns error for missing issue...OK\n180/710 cli.delete.test.DeleteError enum exists...OK\n181/710 cli.delete.test.DeleteResult struct works...OK\n182/710 cli.delete.test.run detects uninitialized workspace...OK\n183/710 cli.delete.test.run returns error for missing issue...OK\n184/710 cli.ready.test.ReadyError enum exists...OK\n185/710 cli.ready.test.ReadyResult struct works...OK\n186/710 cli.ready.test.BlockedResult struct works...OK\n187/710 cli.ready.test.run detects uninitialized workspace...OK\n188/710 cli.ready.test.runBlocked detects uninitialized workspace...OK\n189/710 cli.ready.test.run returns empty list for empty workspace...OK\n190/710 cli.dep.test.DepError enum exists...OK\n191/710 cli.dep.test.DepResult struct works...OK\n192/710 cli.dep.test.run detects uninitialized workspace...OK\n193/710 cli.dep.test.runList returns empty for empty workspace...OK\n194/710 cli.graph.test.GraphError enum exists...OK\n195/710 cli.graph.test.GraphResult struct works...OK\n196/710 cli.graph.test.run detects uninitialized workspace...OK\n197/710 cli.graph.test.truncateTitle works correctly...OK\n198/710 cli.graph.test.GraphFormat.fromString parses correctly...OK\n199/710 cli.graph.test.GraphArgs supports all flag...OK\n200/710 cli.graph.test.GraphArgs supports compact flag...OK\n201/710 cli.graph.test.parse graph with all flag...OK\n202/710 cli.graph.test.parse graph with compact flag...OK\n203/710 cli.graph.test.parse graph with id and compact flag...OK\n204/710 cli.graph.test.parse graph with short flags...OK\n205/710 cli.epic.test.EpicError enum exists...OK\n206/710 cli.epic.test.EpicResult struct works...OK\n207/710 cli.epic.test.run detects uninitialized workspace...OK\n208/710 cli.epic.test.runCreate validates empty title...OK\n209/710 cli.epic.test.runCreate creates epic successfully...OK\n210/710 cli.sync.test.SyncError enum exists...OK\n211/710 cli.sync.test.SyncResult struct works...OK\n212/710 cli.sync.test.run detects uninitialized workspace...OK\n213/710 cli.sync.test.hasMergeConflicts returns false for clean file...OK\n214/710 cli.sync.test.hasMergeConflicts returns true for conflicted file...OK\n215/710 cli.sync.test.hasMergeConflicts returns false for missing file...OK\n216/710 cli.sync.test.countJsonlIssues counts valid JSON lines...OK\n217/710 cli.sync.test.countJsonlIssues handles empty lines...OK\n218/710 cli.sync.test.SyncResult with status fields...OK\n219/710 cli.sync.test.SyncArgs parses status flag...OK\n220/710 cli.sync.test.SyncArgs parses manifest flag...OK\n221/710 cli.batch.test.BatchError enum exists...OK\n222/710 cli.batch.test.BatchResult struct works...OK\n223/710 cli.batch.test.ImportResult struct works...OK\n224/710 cli.batch.test.runAddBatch detects uninitialized workspace...OK\n225/710 cli.batch.test.runImport detects uninitialized workspace...OK\n226/710 cli.batch.test.hasMergeConflicts returns false for missing file...OK\n227/710 cli.batch.test.hasMergeConflicts returns false for clean file...OK\n228/710 cli.batch.test.hasMergeConflicts returns true for conflicted file...OK\n229/710 cli.batch.test.runAddBatch creates issues from titles format...OK\n230/710 cli.batch.test.runImport imports issues from JSONL...OK\n231/710 cli.search.test.SearchError enum exists...OK\n232/710 cli.search.test.SearchResult struct works...OK\n233/710 cli.search.test.run detects uninitialized workspace...OK\n234/710 cli.search.test.toLower converts string correctly...OK\n235/710 cli.search.test.run returns empty for no matches...OK\n236/710 cli.stale.test.stale command filters correctly...OK\n237/710 cli.count.test.getFieldValue returns status...OK\n238/710 cli.count.test.getFieldValue returns priority...OK\n239/710 cli.count.test.getFieldValue returns null for unknown field...OK\n240/710 cli.defer.test.parseUntilDate parses RFC3339...OK\n241/710 cli.defer.test.parseUntilDate parses ISO date...OK\n242/710 cli.defer.test.parseUntilDate parses relative days...OK\n243/710 cli.defer.test.parseUntilDate parses relative weeks...OK\n244/710 cli.defer.test.parseUntilDate rejects invalid format...OK\n245/710 cli.label.test.LabelError enum exists...OK\n246/710 cli.label.test.LabelResult struct works...OK\n247/710 cli.label.test.runAdd detects uninitialized workspace...OK\n248/710 cli.label.test.runList detects uninitialized workspace...OK\n249/710 cli.label.test.runListAll detects uninitialized workspace...OK\n250/710 cli.comments.test.CommentsError enum exists...OK\n251/710 cli.comments.test.CommentsResult struct works...OK\n252/710 cli.comments.test.runAdd detects uninitialized workspace...OK\n253/710 cli.comments.test.runList detects uninitialized workspace...OK\n254/710 cli.history.test.HistoryError enum exists...OK\n255/710 cli.history.test.HistoryResult struct works...OK\n256/710 cli.history.test.run detects uninitialized workspace...OK\n257/710 cli.history.test.truncate handles short strings...OK\n258/710 cli.history.test.truncate handles long strings...OK\n259/710 cli.audit.test.AuditError enum exists...OK\n260/710 cli.audit.test.AuditResult struct works...OK\n261/710 cli.audit.test.run detects uninitialized workspace...OK\n262/710 cli.audit.test.AuditSubcommand record parses correctly...OK\n263/710 cli.audit.test.AuditSubcommand summary parses days...OK\n264/710 cli.audit.test.AuditSubcommand list is default...OK\n265/710 cli.changelog.test.ChangelogError enum exists...OK\n266/710 cli.changelog.test.ChangelogResult struct works...OK\n267/710 cli.changelog.test.run detects uninitialized workspace...OK\n268/710 cli.changelog.test.run lists closed issues successfully...OK\n269/710 cli.changelog.test.parseDateToTimestamp parses valid date...OK\n270/710 cli.changelog.test.parseDateToTimestamp returns null for invalid date...OK\n271/710 cli.changelog.test.ChangelogArgs supports since_tag field...OK\n272/710 cli.changelog.test.ChangelogArgs supports since_commit field...OK\n273/710 cli.changelog.test.parse changelog with since-tag flag...OK\n274/710 cli.changelog.test.parse changelog with since-commit flag...OK\n275/710 cli.info.test.InfoError enum exists...OK\n276/710 cli.info.test.InfoResult struct works...OK\n277/710 cli.info.test.run detects uninitialized workspace...OK\n278/710 cli.info.test.formatBytes handles zero...OK\n279/710 cli.info.test.formatBytes handles small values...OK\n280/710 cli.info.test.getFileSize returns 0 for missing file...OK\n281/710 cli.stats.test.StatsError enum exists...OK\n282/710 cli.stats.test.StatsResult struct works...OK\n283/710 cli.stats.test.run detects uninitialized workspace...OK\n284/710 cli.stats.test.StatsArgs default values...OK\n285/710 cli.stats.test.parse stats with activity flag...OK\n286/710 cli.stats.test.parse stats with activity-hours flag...OK\n287/710 cli.doctor.test.DoctorError enum exists...OK\n288/710 cli.doctor.test.DoctorResult struct works...OK\n289/710 cli.doctor.test.run detects uninitialized workspace...OK\n290/710 cli.doctor.test.checkJsonlFile returns pass for existing file...OK\n291/710 cli.doctor.test.checkJsonlFile returns fail for missing file...OK\n292/710 cli.config.test.ConfigError enum exists...OK\n293/710 cli.config.test.ConfigResult struct works...OK\n294/710 cli.config.test.run detects uninitialized workspace...OK\n295/710 cli.config.test.getConfigValue returns null for missing file...OK\n296/710 cli.config.test.setConfigValue and getConfigValue roundtrip...OK\n297/710 cli.config.test.setConfigValue updates existing key...OK\n298/710 cli.config.test.known_keys has expected entries...OK\n299/710 cli.orphans.test.getParentId extracts parent from child ID...OK\n300/710 cli.orphans.test.getParentId returns null for top-level ID...OK\n301/710 cli.orphans.test.getParentId handles edge cases...OK\n302/710 cli.orphans.test.OrphansResult struct works...OK\n303/710 cli.orphans.test.run detects uninitialized workspace...OK\n304/710 cli.lint.test.LintResult struct works...OK\n305/710 cli.lint.test.LintIssue struct works...OK\n306/710 cli.lint.test.run detects uninitialized workspace...OK\n307/710 cli.version.test.VERSION is valid semver...OK\n308/710 cli.version.test.run returns version info...OK\n309/710 cli.schema.test.run displays schema...# beads_zig Storage Schema\n\nStorage Type: JSONL (JSON Lines)\n\n## Files\n\n- `.beads/beads.jsonl` - Main issue storage (git-tracked)\n- `.beads/beads.wal` - Write-ahead log (gitignored)\n- `.beads/beads.lock` - Lock file for flock (gitignored)\n\n## Issue (beads.jsonl)\n\nOne JSON object per line in the main JSONL file.\n\n### Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| id | string | yes | Issue ID (bd-XXXXX format) |\n| content_hash | string | no | SHA256 hash for deduplication |\n| title | string | yes | Issue title (1-500 chars) |\n| description | string | no | Detailed description |\n| design | string | no | Design notes |\n| acceptance_criteria | string | no | Definition of done |\n| notes | string | no | Additional notes |\n| status | string | yes | open, in_progress, blocked, deferred, closed, tombstone, pinned |\n| priority | number | yes | 0 (critical) to 4 (backlog) |\n| issue_type | string | yes | task, bug, feature, epic, chore, docs, question |\n| assignee | string | no | Assigned user |\n| owner | string | no | Issue owner |\n| created_at | string | yes | RFC3339 timestamp |\n| created_by | string | no | Creator |\n| updated_at | string | yes | RFC3339 timestamp |\n| closed_at | string | no | RFC3339 timestamp when closed |\n| close_reason | string | no | Reason for closing |\n| due_at | string | no | RFC3339 due date |\n| defer_until | string | no | RFC3339 defer date |\n| estimated_minutes | number | no | Time estimate |\n| external_ref | string | no | External tracker link |\n| source_system | string | no | Import source |\n| pinned | boolean | yes | High-priority display flag |\n| is_template | boolean | yes | Template flag |\n| labels | array | yes | String array of labels |\n| dependencies | array | yes | Array of Dependency objects |\n| comments | array | yes | Array of Comment objects |\n\n## WAL Entry (beads.wal)\n\nWrite-ahead log for concurrent writes.\n\n### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| op | string | add, update, close, reopen, delete, set_blocked, unset_blocked |\n| ts | number | Unix timestamp for ordering |\n| id | string | Issue ID |\n| data | object | Full Issue object (for add/update) or null |\n\n## Dependency\n\nEmbedded in Issue.dependencies array.\n\n### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| issue_id | string | Dependent issue |\n| depends_on_id | string | Blocker issue |\n| dep_type | string | blocks, parent_child, waits_for, related, etc. |\n| created_at | string | RFC3339 timestamp |\n| created_by | string | Creator |\n| metadata | string | JSON blob for extra data |\n| thread_id | string | Optional thread reference |\n\n## Comment\n\nEmbedded in Issue.comments array.\n\n### Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| id | number | Comment ID |\n| issue_id | string | Parent issue ID |\n| author | string | Comment author |\n| body | string | Comment text |\n| created_at | string | RFC3339 timestamp |\nOK\n310/710 cli.schema.test.run with json option...{\"storage_type\":\"jsonl\",\"files\":{\"main\":\"beads.jsonl\",\"wal\":\"beads.wal\",\"lock\":\"beads.lock\"},\"objects\":[{\"name\":\"Issue\",\"obj_type\":\"entity\",\"description\":\"Primary issue record stored in beads.jsonl\"},{\"name\":\"WalEntry\",\"obj_type\":\"log\",\"description\":\"WAL operation entry in beads.wal\"},{\"name\":\"Dependency\",\"obj_type\":\"embedded\",\"description\":\"Dependency relationship\"},{\"name\":\"Comment\",\"obj_type\":\"embedded\",\"description\":\"Issue comment\"}]}\nOK\n311/710 cli.completions.test.BASH_COMPLETIONS is valid script...OK\n312/710 cli.completions.test.ZSH_COMPLETIONS is valid script...OK\n313/710 cli.completions.test.FISH_COMPLETIONS is valid script...OK\n314/710 cli.completions.test.POWERSHELL_COMPLETIONS is valid script...OK\n315/710 cli.completions.test.run generates bash completions...# bash completion for bz (beads_zig)\n# Add to ~/.bashrc: source <(bz completions bash)\n\n_bz_completions() {\n    local cur prev words cword\n    _init_completion || return\n\n    local commands=\"init create q show update close reopen delete list ready blocked search stale count dep label comments history audit sync config info stats doctor orphans lint version schema completions\"\n\n    if [[ $cword -eq 1 ]]; then\n        COMPREPLY=($(compgen -W \"$commands\" -- \"$cur\"))\n        return\n    fi\n\n    case ${words[1]} in\n        show|update|close|reopen|delete|comments|history)\n            # Complete with issue IDs\n            local ids=$(bz list --quiet 2>/dev/null)\n            COMPREPLY=($(compgen -W \"$ids\" -- \"$cur\"))\n            ;;\n        dep)\n            if [[ $cword -eq 2 ]]; then\n                COMPREPLY=($(compgen -W \"add remove list tree cycles\" -- \"$cur\"))\n            else\n                local ids=$(bz list --quiet 2>/dev/null)\n                COMPREPLY=($(compgen -W \"$ids\" -- \"$cur\"))\n            fi\n            ;;\n        label)\n            if [[ $cword -eq 2 ]]; then\n                COMPREPLY=($(compgen -W \"add remove list list-all\" -- \"$cur\"))\n            else\n                local ids=$(bz list --quiet 2>/dev/null)\n                COMPREPLY=($(compgen -W \"$ids\" -- \"$cur\"))\n            fi\n            ;;\n        comments)\n            if [[ $cword -eq 2 ]]; then\n                COMPREPLY=($(compgen -W \"add list\" -- \"$cur\"))\n            fi\n            ;;\n        config)\n            if [[ $cword -eq 2 ]]; then\n                COMPREPLY=($(compgen -W \"get set list\" -- \"$cur\"))\n            fi\n            ;;\n        sync)\n            COMPREPLY=($(compgen -W \"--flush-only --import-only\" -- \"$cur\"))\n            ;;\n        completions)\n            COMPREPLY=($(compgen -W \"bash zsh fish powershell\" -- \"$cur\"))\n            ;;\n        create)\n            COMPREPLY=($(compgen -W \"--priority --type --assignee --label --dep\" -- \"$cur\"))\n            ;;\n        list)\n            COMPREPLY=($(compgen -W \"--status --priority --type --assignee --label --all --limit --offset\" -- \"$cur\"))\n            ;;\n        stale)\n            COMPREPLY=($(compgen -W \"--days\" -- \"$cur\"))\n            ;;\n        count)\n            COMPREPLY=($(compgen -W \"--by\" -- \"$cur\"))\n            ;;\n    esac\n}\n\ncomplete -F _bz_completions bz\nOK\n316/710 cli.completions.test.run generates zsh completions...#compdef bz\n# zsh completion for bz (beads_zig)\n# Add to ~/.zshrc: source <(bz completions zsh)\n\n_bz() {\n    local -a commands\n    commands=(\n        'init:Initialize beads workspace'\n        'create:Create new issue'\n        'q:Quick capture (create + print ID only)'\n        'show:Display issue details'\n        'update:Update issue fields'\n        'close:Close an issue'\n        'reopen:Reopen a closed issue'\n        'delete:Soft delete (tombstone)'\n        'list:List issues with filters'\n        'ready:Show actionable issues (unblocked)'\n        'blocked:Show blocked issues'\n        'search:Full-text search'\n        'stale:Find stale issues'\n        'count:Count issues'\n        'dep:Manage dependencies'\n        'label:Manage labels'\n        'comments:Manage comments'\n        'history:Show issue history'\n        'audit:View audit log'\n        'sync:Sync with JSONL file'\n        'config:Manage configuration'\n        'info:Workspace info'\n        'stats:Project statistics'\n        'doctor:Run diagnostics'\n        'orphans:Find orphaned issues'\n        'lint:Validate database consistency'\n        'version:Show version'\n        'schema:View storage schema'\n        'completions:Generate shell completions'\n    )\n\n    local -a global_opts\n    global_opts=(\n        '--json[Output in JSON format]'\n        '--toon[Output in TOON format]'\n        '-q[Quiet mode]'\n        '--quiet[Quiet mode]'\n        '-v[Verbose mode]'\n        '--verbose[Verbose mode]'\n        '--no-color[Disable colors]'\n        '--data[Override .beads/ directory]:directory:_files -/'\n    )\n\n    _arguments -C \\\n        $global_opts \\\n        '1:command:->command' \\\n        '*::arg:->args'\n\n    case $state in\n        command)\n            _describe 'command' commands\n            ;;\n        args)\n            case ${words[1]} in\n                show|update|close|reopen|delete)\n                    _arguments '1:issue ID:($(bz list --quiet 2>/dev/null))'\n                    ;;\n                dep)\n                    local -a dep_cmds\n                    dep_cmds=('add:Add dependency' 'remove:Remove dependency' 'list:List dependencies' 'tree:Show dependency tree' 'cycles:Detect cycles')\n                    _describe 'subcommand' dep_cmds\n                    ;;\n                label)\n                    local -a label_cmds\n                    label_cmds=('add:Add labels' 'remove:Remove labels' 'list:List labels' 'list-all:List all labels')\n                    _describe 'subcommand' label_cmds\n                    ;;\n                completions)\n                    local -a shells\n                    shells=('bash' 'zsh' 'fish' 'powershell')\n                    _describe 'shell' shells\n                    ;;\n            esac\n            ;;\n    esac\n}\n\n_bz\nOK\n317/710 cli.completions.test.run generates fish completions...# fish completion for bz (beads_zig)\n# Add to ~/.config/fish/completions/bz.fish\n\nset -l commands init create q show update close reopen delete list ready blocked search stale count dep label comments history audit sync config info stats doctor orphans lint version schema completions\n\ncomplete -c bz -f\n\n# Main commands\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a init -d \"Initialize workspace\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a create -d \"Create issue\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a q -d \"Quick capture\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a show -d \"Show issue\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a update -d \"Update issue\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a close -d \"Close issue\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a reopen -d \"Reopen issue\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a delete -d \"Delete issue\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a list -d \"List issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a ready -d \"Show ready issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a blocked -d \"Show blocked issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a search -d \"Search issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a stale -d \"Find stale issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a count -d \"Count issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a dep -d \"Manage dependencies\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a label -d \"Manage labels\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a comments -d \"Manage comments\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a history -d \"Issue history\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a audit -d \"Audit log\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a sync -d \"Sync JSONL\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a config -d \"Configuration\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a info -d \"Workspace info\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a stats -d \"Statistics\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a doctor -d \"Diagnostics\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a orphans -d \"Find orphaned issues\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a lint -d \"Validate database\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a version -d \"Show version\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a schema -d \"Storage schema\"\ncomplete -c bz -n \"not __fish_seen_subcommand_from $commands\" -a completions -d \"Shell completions\"\n\n# Global options\ncomplete -c bz -l json -d \"JSON output\"\ncomplete -c bz -l toon -d \"TOON output\"\ncomplete -c bz -s q -l quiet -d \"Quiet mode\"\ncomplete -c bz -s v -l verbose -d \"Verbose mode\"\ncomplete -c bz -l no-color -d \"Disable colors\"\ncomplete -c bz -l data -x -d \"Override .beads/ directory\"\n\n# Subcommands\ncomplete -c bz -n \"__fish_seen_subcommand_from dep\" -a \"add remove list tree cycles\"\ncomplete -c bz -n \"__fish_seen_subcommand_from label\" -a \"add remove list list-all\"\ncomplete -c bz -n \"__fish_seen_subcommand_from comments\" -a \"add list\"\ncomplete -c bz -n \"__fish_seen_subcommand_from config\" -a \"get set list\"\ncomplete -c bz -n \"__fish_seen_subcommand_from completions\" -a \"bash zsh fish powershell\"\nOK\n318/710 cli.completions.test.run generates powershell completions...# PowerShell completion for bz (beads_zig)\n# Add to $PROFILE: . (bz completions powershell)\n\nRegister-ArgumentCompleter -Native -CommandName bz -ScriptBlock {\n    param($wordToComplete, $commandAst, $cursorPosition)\n\n    $commands = @(\n        @{Name='init'; Description='Initialize workspace'}\n        @{Name='create'; Description='Create issue'}\n        @{Name='q'; Description='Quick capture'}\n        @{Name='show'; Description='Show issue'}\n        @{Name='update'; Description='Update issue'}\n        @{Name='close'; Description='Close issue'}\n        @{Name='reopen'; Description='Reopen issue'}\n        @{Name='delete'; Description='Delete issue'}\n        @{Name='list'; Description='List issues'}\n        @{Name='ready'; Description='Show ready issues'}\n        @{Name='blocked'; Description='Show blocked issues'}\n        @{Name='search'; Description='Search issues'}\n        @{Name='stale'; Description='Find stale issues'}\n        @{Name='count'; Description='Count issues'}\n        @{Name='dep'; Description='Manage dependencies'}\n        @{Name='label'; Description='Manage labels'}\n        @{Name='comments'; Description='Manage comments'}\n        @{Name='history'; Description='Issue history'}\n        @{Name='audit'; Description='Audit log'}\n        @{Name='sync'; Description='Sync JSONL'}\n        @{Name='config'; Description='Configuration'}\n        @{Name='info'; Description='Workspace info'}\n        @{Name='stats'; Description='Statistics'}\n        @{Name='doctor'; Description='Diagnostics'}\n        @{Name='orphans'; Description='Find orphaned issues'}\n        @{Name='lint'; Description='Validate database'}\n        @{Name='version'; Description='Show version'}\n        @{Name='schema'; Description='Storage schema'}\n        @{Name='completions'; Description='Shell completions'}\n    )\n\n    $commands | Where-Object { $_.Name -like \"$wordToComplete*\" } | ForEach-Object {\n        [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Description)\n    }\n}\nOK\n319/710 cli.metrics.test.MetricsError enum exists...OK\n320/710 cli.metrics.test.MetricsResult struct works...OK\n321/710 cli.help.test.findCommand finds by name...OK\n322/710 cli.help.test.findCommand finds by alias...OK\n323/710 cli.help.test.findCommand returns null for unknown...OK\n324/710 cli.help.test.findCommand finds all main commands...OK\n325/710 cli.help.test.findCommand finds aliases...OK\n326/710 cli.query.test.QueryError enum exists...OK\n327/710 cli.query.test.QueryResult struct works...OK\n328/710 cli.query.test.isValidQueryName accepts valid names...OK\n329/710 cli.query.test.isValidQueryName rejects invalid names...OK\n330/710 cli.query.test.loadQueries returns empty for missing file...OK\n331/710 cli.query.test.run detects uninitialized workspace...OK\n332/710 cli.upgrade.test.UpgradeError enum exists...OK\n333/710 cli.upgrade.test.UpgradeResult struct works...OK\n334/710 cli.upgrade.test.isNewerVersion returns true for newer...OK\n335/710 cli.upgrade.test.isNewerVersion returns false for same or older...OK\n336/710 cli.upgrade.test.getTargetPlatform returns value for supported platforms...OK\n337/710 cli.upgrade.test.parseChecksum parses valid checksum...OK\n338/710 cli.upgrade.test.parseChecksum parses hash-only format...OK\n339/710 cli.upgrade.test.parseChecksum rejects invalid checksums...OK\n340/710 cli.upgrade.test.UpgradeResult dry_run fields...OK\n341/710 cli.where.test.WhereError enum exists...OK\n342/710 cli.where.test.WhereResult struct works...OK\n343/710 cli.where.test.run returns path for nonexistent workspace...OK\n344/710 cli.backup.test.BackupError enum exists...OK\n345/710 cli.backup.test.BackupResult struct works...OK\n346/710 cli.backup.test.run detects uninitialized workspace...OK\n347/710 cli.backup.test.BackupInfo struct works...OK\n348/710 storage.fscheck.test.checkFilesystemSafety on unknown path...OK\n349/710 storage.fscheck.test.checkFilesystemSafety on current directory...OK\n350/710 storage.fscheck.test.FsType.toString returns expected strings...OK\n351/710 storage.store.test.IssueStore insert and get...OK\n352/710 storage.store.test.IssueStore get returns null for missing...OK\n353/710 storage.store.test.IssueStore update modifies fields...OK\n354/710 storage.store.test.IssueStore update increments version...OK\n355/710 storage.store.test.IssueStore update with expected_version succeeds on match...OK\n356/710 storage.store.test.IssueStore update with expected_version fails on mismatch...OK\n357/710 storage.store.test.IssueStore delete sets tombstone...OK\n358/710 storage.store.test.IssueStore list returns issues...OK\n359/710 storage.store.test.IssueStore list excludes tombstones...OK\n360/710 storage.store.test.IssueStore dirty tracking...OK\n361/710 storage.store.test.IssueStore addLabel and removeLabel...OK\n362/710 storage.store.test.StoreLoadResult.hasCorruption...OK\n363/710 storage.store.test.IssueStore loadFromFileWithRecovery handles corrupt entries...OK\n364/710 models.issue.test.Issue.init creates valid issue with defaults...OK\n365/710 models.issue.test.Issue.validate accepts valid issue...OK\n366/710 models.issue.test.Issue.validate rejects empty id...OK\n367/710 models.issue.test.Issue.validate rejects empty title...OK\n368/710 models.issue.test.Issue.validate rejects title longer than 500 chars...OK\n369/710 models.issue.test.Issue.validate accepts title exactly 500 chars...OK\n370/710 models.issue.test.Issue.eql compares identical issues...OK\n371/710 models.issue.test.Issue.eql detects different id...OK\n372/710 models.issue.test.Issue.eql detects different title...OK\n373/710 models.issue.test.Issue.eql detects different priority...OK\n374/710 models.issue.test.Issue.eql detects different timestamps...OK\n375/710 models.issue.test.Issue.clone creates deep copy...OK\n376/710 models.issue.test.Issue.clone handles null optional fields...OK\n377/710 models.issue.test.Issue.clone handles custom status...OK\n378/710 models.issue.test.Issue.deinit frees all memory...OK\n379/710 models.issue.test.Rfc3339Timestamp JSON serialization...OK\n380/710 models.issue.test.Rfc3339Timestamp JSON parse...OK\n381/710 models.issue.test.Rfc3339Timestamp JSON roundtrip...OK\n382/710 models.issue.test.OptionalRfc3339Timestamp JSON serialization with value...OK\n383/710 models.issue.test.OptionalRfc3339Timestamp JSON serialization with null...OK\n384/710 models.issue.test.OptionalRfc3339Timestamp JSON parse null...OK\n385/710 models.issue.test.timestamp.parseRfc3339 parses valid timestamp...OK\n386/710 models.issue.test.timestamp.parseRfc3339 rejects invalid format...OK\n387/710 models.issue.test.Issue JSON serialization roundtrip...OK\n388/710 models.issue.test.Issue JSON serialization with all fields...OK\n389/710 models.issue.test.Issue JSON contains expected RFC3339 timestamp format...OK\n390/710 models.issue.test.Issue JSON with null optional fields...OK\n391/710 models.status.test.toString returns correct strings for known statuses...OK\n392/710 models.status.test.toString returns custom string for custom status...OK\n393/710 models.status.test.fromString parses known statuses correctly...OK\n394/710 models.status.test.fromString is case-insensitive...OK\n395/710 models.status.test.fromString returns custom for unknown values...OK\n396/710 models.status.test.toString/fromString roundtrip for known statuses...OK\n397/710 models.status.test.toString/fromString roundtrip for custom status...OK\n398/710 models.status.test.JSON serialization roundtrip...OK\n399/710 models.status.test.JSON deserialization of custom status...OK\n400/710 models.priority.test.fromInt with valid values...OK\n401/710 models.priority.test.fromInt with invalid values...OK\n402/710 models.priority.test.fromInt with signed negative values...OK\n403/710 models.priority.test.fromString with named priorities...OK\n404/710 models.priority.test.fromString is case-insensitive...OK\n405/710 models.priority.test.fromString with numeric strings...OK\n406/710 models.priority.test.fromString with invalid values...OK\n407/710 models.priority.test.toString returns correct strings...OK\n408/710 models.priority.test.toInt returns correct values...OK\n409/710 models.priority.test.comparison ordering...OK\n410/710 models.priority.test.toString/fromString roundtrip...OK\n411/710 models.priority.test.JSON serialization roundtrip...OK\n412/710 models.priority.test.JSON serializes as integer...OK\n413/710 models.priority.test.JSON deserializes from integer...OK\n414/710 models.priority.test.constants have expected values...OK\n415/710 models.issue_type.test.toString returns correct strings for known types...OK\n416/710 models.issue_type.test.toString returns custom string for custom type...OK\n417/710 models.issue_type.test.fromString parses known types correctly...OK\n418/710 models.issue_type.test.fromString is case-insensitive...OK\n419/710 models.issue_type.test.fromString returns custom for unknown values...OK\n420/710 models.issue_type.test.toString/fromString roundtrip for known types...OK\n421/710 models.issue_type.test.toString/fromString roundtrip for custom type...OK\n422/710 models.issue_type.test.JSON serialization roundtrip...OK\n423/710 models.issue_type.test.JSON deserialization of custom type...OK\n424/710 models.issue_type.test.JSON serializes as lowercase string...OK\n425/710 models.dependency.test.DependencyType.toString returns correct strings for known types...OK\n426/710 models.dependency.test.DependencyType.toString returns custom string for custom type...OK\n427/710 models.dependency.test.DependencyType.fromString parses known types correctly...OK\n428/710 models.dependency.test.DependencyType.fromString is case-insensitive...OK\n429/710 models.dependency.test.DependencyType.fromString returns custom for unknown values...OK\n430/710 models.dependency.test.DependencyType toString/fromString roundtrip for known types...OK\n431/710 models.dependency.test.DependencyType toString/fromString roundtrip for custom type...OK\n432/710 models.dependency.test.DependencyType.eql compares correctly...OK\n433/710 models.dependency.test.DependencyType JSON serialization roundtrip...OK\n434/710 models.dependency.test.DependencyType JSON deserialization of custom type...OK\n435/710 models.dependency.test.DependencyType JSON serializes as lowercase string...OK\n436/710 models.dependency.test.Dependency.eql compares all fields...OK\n437/710 models.dependency.test.Dependency.eql detects issue_id difference...OK\n438/710 models.dependency.test.Dependency.eql detects dep_type difference...OK\n439/710 models.dependency.test.Dependency.eql detects optional field differences...OK\n440/710 models.dependency.test.Dependency.eql handles metadata comparison...OK\n441/710 models.dependency.test.Dependency JSON serialization with all fields...OK\n442/710 models.dependency.test.Dependency JSON serialization with null fields...OK\n443/710 models.dependency.test.Dependency JSON serialization roundtrip with custom dep_type...OK\n444/710 models.dependency.test.Dependency JSON contains expected fields...OK\n445/710 models.comment.test.Comment.validate accepts valid comment...OK\n446/710 models.comment.test.Comment.validate rejects empty body...OK\n447/710 models.comment.test.Comment.validate rejects empty author...OK\n448/710 models.comment.test.Comment.validate rejects empty issue_id...OK\n449/710 models.comment.test.Comment.validate with id=0 for new comment...OK\n450/710 models.comment.test.Comment.eql compares all fields...OK\n451/710 models.comment.test.Comment.eql detects id difference...OK\n452/710 models.comment.test.Comment.eql detects body difference...OK\n453/710 models.comment.test.Comment.eql detects author difference...OK\n454/710 models.comment.test.Comment JSON serialization roundtrip...OK\n455/710 models.comment.test.Comment JSON serialization with multiline body...OK\n456/710 models.comment.test.Comment JSON serialization with unicode body...OK\n457/710 models.comment.test.Comment JSON contains expected fields...OK\n458/710 models.comment.test.Comment JSON serialization with special characters in body...OK\n459/710 models.comment.test.Comment with id=0 JSON roundtrip...OK\n460/710 storage.jsonl.test.JsonlFile.readAll returns empty for missing file...OK\n461/710 storage.jsonl.test.JsonlFile roundtrip...OK\n462/710 storage.jsonl.test.JsonlFile handles empty file...OK\n463/710 storage.jsonl.test.readAllWithRecovery returns empty for missing file...OK\n464/710 storage.jsonl.test.readAllWithRecovery skips corrupt lines and tracks them...OK\n465/710 storage.jsonl.test.readAllWithRecovery handles file with only corrupt entries...OK\n466/710 storage.jsonl.test.LoadResult.hasCorruption...OK\n467/710 storage.mmap.test.MappedFile.open returns FileNotFound for missing file...OK\n468/710 storage.mmap.test.MappedFile.open handles empty file...OK\n469/710 storage.mmap.test.MappedFile roundtrip...OK\n470/710 storage.mmap.test.MappedFile large file...OK\n471/710 storage.simd.test.findNewlinesSimd finds single newline...OK\n472/710 storage.simd.test.findNewlinesSimd finds multiple newlines...OK\n473/710 storage.simd.test.findNewlinesSimd no newlines returns zero...OK\n474/710 storage.simd.test.NewlineScanner.iterate finds all newlines...OK\n475/710 storage.simd.test.NewlineScanner.iterate handles no trailing newline...OK\n476/710 storage.simd.test.NewlineScanner.iterate handles empty string...OK\n477/710 storage.simd.test.NewlineScanner.iterate handles large data...OK\n478/710 storage.simd.test.NewlineScanner.count...OK\n479/710 storage.simd.test.NewlineScanner.positions...OK\n480/710 storage.simd.test.LineIterator yields correct lines...OK\n481/710 storage.simd.test.LineIterator handles empty lines...OK\n482/710 storage.simd.test.LineIterator.nextNonEmpty skips empty lines...OK\n483/710 storage.simd.test.LineIterator handles data larger than VECTOR_SIZE...OK\n484/710 id.generator.test.IdGenerator.init creates generator with defaults...OK\n485/710 id.generator.test.IdGenerator.generate produces valid format...OK\n486/710 id.generator.test.IdGenerator.generate adaptive length increases with count...OK\n487/710 id.generator.test.IdGenerator.generateChild creates hierarchical ID...OK\n488/710 id.generator.test.IdGenerator.generateChild rejects too deep hierarchy...OK\n489/710 id.generator.test.parseId extracts components...OK\n490/710 id.generator.test.parseId extracts child path...OK\n491/710 id.generator.test.parseId rejects invalid formats...OK\n492/710 id.generator.test.validateId accepts valid IDs...OK\n493/710 id.generator.test.validateId rejects invalid IDs...OK\n494/710 id.generator.test.generated IDs are unique...OK\n495/710 id.generator.test.custom prefix works...OK\n496/710 id.generator.test.generateUnique avoids collisions...OK\n497/710 id.base36.test.encode zero...OK\n498/710 id.base36.test.encode produces lowercase...OK\n499/710 id.base36.test.encode max u64...OK\n500/710 id.base36.test.decode accepts lowercase...OK\n501/710 id.base36.test.decode accepts uppercase...OK\n502/710 id.base36.test.decode accepts mixed case...OK\n503/710 id.base36.test.decode error on empty input...OK\n504/710 id.base36.test.decode error on invalid character...OK\n505/710 id.base36.test.decode overflow...OK\n506/710 id.base36.test.encode decode roundtrip...OK\n507/710 id.base36.test.encodedLength...OK\n508/710 id.base36.test.encodedLength matches actual encoded length...OK\n509/710 storage.wal.test.WalOp.toString and fromString roundtrip...OK\n510/710 storage.wal.test.WalOp.fromString returns null for unknown...OK\n511/710 storage.wal.test.Wal.init and deinit...OK\n512/710 storage.wal.test.Wal.rotateGeneration creates new generation...OK\n513/710 storage.wal.test.Wal.refreshGeneration detects external changes...OK\n514/710 storage.wal.test.Wal.readEntries returns empty for missing file...OK\n515/710 storage.wal.test.Wal.appendEntry and readEntries roundtrip...OK\n516/710 storage.wal.test.Wal.replay applies operations to store...OK\n517/710 storage.wal.test.Wal.entryCount...OK\n518/710 storage.wal.test.Wal.truncate clears WAL...OK\n519/710 storage.wal.test.Wal convenience methods...OK\n520/710 storage.wal.test.WalEntry JSON serialization...OK\n521/710 storage.wal.test.WalEntry JSON serialization with null data...OK\n522/710 storage.generation.test.Generation.read returns MIN_GENERATION for missing file...OK\n523/710 storage.generation.test.Generation.write and read roundtrip...OK\n524/710 storage.generation.test.Generation.walPath generates correct paths...OK\n525/710 storage.lock.test.BeadsLock acquire and release...OK\n526/710 storage.lock.test.BeadsLock tryAcquire returns lock when available...OK\n527/710 storage.lock.test.BeadsLock deinit releases lock...OK\n528/710 storage.lock.test.BeadsLock acquireTimeout returns null on timeout...OK\n529/710 storage.lock.test.BeadsLock writes PID to lock file...OK\n530/710 storage.lock.test.BeadsLock.isStale returns false for live process...OK\n531/710 storage.lock.test.BeadsLock.getHolderPid returns null for empty lock file...OK\n532/710 storage.lock.test.BeadsLock.tryAcquireBreakingStale works...OK\n533/710 storage.lock.test.isProcessAlive returns true for current process...OK\n534/710 storage.lock.test.isProcessAlive returns false for non-existent PID...OK\n535/710 storage.lock.test.readPidFromLockFile handles various formats...OK\n536/710 storage.events.test.EventStore.init...OK\n537/710 storage.events.test.EventStore.append and query...OK\n538/710 storage.events.test.EventStore.append assigns sequential IDs...OK\n539/710 storage.events.test.EventStore.loadNextId resumes from existing events...OK\n540/710 storage.events.test.EventStore.queryEvents filters by issue_id...OK\n541/710 storage.events.test.EventStore.queryEvents filters by event_type...OK\n542/710 storage.events.test.EventStore.queryEvents returns empty for missing file...OK\n543/710 storage.events.test.EventStore.count...OK\n544/710 storage.graph.test.DependencyGraph rejects self-dependency...OK\n545/710 storage.graph.test.DependencyGraph rejects direct cycle...OK\n546/710 storage.graph.test.DependencyGraph rejects indirect cycle...OK\n547/710 storage.graph.test.DependencyGraph getReadyIssues excludes blocked...OK\n548/710 storage.graph.test.DependencyGraph getReadyIssues includes when blocker closed...OK\n549/710 storage.graph.test.DependencyGraph getBlockedIssues returns only blocked...OK\n550/710 models.event.test.EventType.toString returns correct strings...OK\n551/710 models.event.test.EventType.fromString parses known event types...OK\n552/710 models.event.test.EventType.fromString returns null for unknown values...OK\n553/710 models.event.test.EventType toString/fromString roundtrip...OK\n554/710 models.event.test.EventType JSON serialization roundtrip...OK\n555/710 models.event.test.Event.validate accepts valid event...OK\n556/710 models.event.test.Event.validate rejects empty actor...OK\n557/710 models.event.test.Event.validate rejects empty issue_id...OK\n558/710 models.event.test.Event.eql compares all fields...OK\n559/710 models.event.test.Event.eql detects differences...OK\n560/710 models.event.test.Event JSON serialization roundtrip...OK\n561/710 models.event.test.Event JSON serialization with null old_value...OK\n562/710 models.event.test.Event JSON serialization with both values null...OK\n563/710 models.event.test.Event.issueCreated produces valid event...OK\n564/710 models.event.test.Event.statusChange produces valid event...OK\n565/710 models.event.test.Event.priorityChange produces valid event...OK\n566/710 models.event.test.Event.assigneeChange produces valid event...OK\n567/710 models.event.test.Event.assigneeChange handles null assignees...OK\n568/710 models.event.test.Event.labelAdded produces valid event...OK\n569/710 models.event.test.Event.labelRemoved produces valid event...OK\n570/710 models.event.test.Event.dependencyAdded produces valid event...OK\n571/710 models.event.test.Event.dependencyRemoved produces valid event...OK\n572/710 models.event.test.Event.issueClosed produces valid event...OK\n573/710 models.event.test.Event.issueClosed handles null close_reason...OK\n574/710 models.event.test.Event.issueReopened produces valid event...OK\n575/710 models.event.test.Event.issueDeleted produces valid event...OK\n576/710 models.event.test.Event.issueRestored produces valid event...OK\n577/710 models.timestamp.test.parseRfc3339 basic UTC with Z suffix...OK\n578/710 models.timestamp.test.parseRfc3339 UTC with explicit +00:00 offset...OK\n579/710 models.timestamp.test.parseRfc3339 with positive timezone offset...OK\n580/710 models.timestamp.test.parseRfc3339 with negative timezone offset...OK\n581/710 models.timestamp.test.parseRfc3339 with fractional seconds...OK\n582/710 models.timestamp.test.parseRfc3339 with long fractional seconds...OK\n583/710 models.timestamp.test.parseRfc3339 lowercase t separator...OK\n584/710 models.timestamp.test.parseRfc3339 lowercase z suffix...OK\n585/710 models.timestamp.test.parseRfc3339 rejects invalid formats...OK\n586/710 models.timestamp.test.parseRfc3339 rejects invalid dates...OK\n587/710 models.timestamp.test.parseRfc3339 rejects invalid times...OK\n588/710 models.timestamp.test.parseRfc3339 accepts leap year Feb 29...OK\n589/710 models.timestamp.test.formatRfc3339 basic...OK\n590/710 models.timestamp.test.formatRfc3339 epoch zero...OK\n591/710 models.timestamp.test.formatRfc3339 buffer too small...OK\n592/710 models.timestamp.test.formatRfc3339Alloc...OK\n593/710 models.timestamp.test.roundtrip format -> parse...OK\n594/710 models.timestamp.test.roundtrip various timestamps...OK\n595/710 models.timestamp.test.year 2038+ timestamps...OK\n596/710 models.timestamp.test.negative timestamps (before 1970)...OK\n597/710 models.timestamp.test.negative timestamp roundtrip...OK\n598/710 models.timestamp.test.now returns reasonable value...OK\n599/710 models.timestamp.test.parseRfc3339Strict returns specific errors...OK\n600/710 storage.metrics.test.LockMetrics.avgWaitNs handles zero acquisitions...OK\n601/710 storage.metrics.test.LockMetrics.avgWaitNs calculates correctly...OK\n602/710 storage.metrics.test.LockMetrics.contentionRate calculates correctly...OK\n603/710 storage.metrics.test.LockMetrics.nsToMs converts correctly...OK\n604/710 storage.metrics.test.AtomicMetrics.recordAcquisition updates counters...OK\n605/710 storage.metrics.test.AtomicMetrics.recordRelease updates hold time...OK\n606/710 storage.metrics.test.AtomicMetrics.reset clears all counters...OK\n607/710 storage.metrics.test.global_metrics functions work...OK\n608/710 storage.metrics.test.LockMetrics.format produces output...OK\n609/710 storage.metrics.test.LockMetrics.toJson produces correct structure...OK\n610/710 storage.migrations.test.MigrationResult struct initialization...OK\n611/710 storage.migrations.test.Metadata struct initialization...OK\n612/710 storage.migrations.test.parseMetadata parses valid JSON...OK\n613/710 storage.migrations.test.parseMetadata handles legacy metadata without bz_version...OK\n614/710 storage.migrations.test.getApplicableMigrations returns empty for no migrations needed...OK\n615/710 storage.migrations.test.CURRENT_SCHEMA_VERSION is valid...OK\n616/710 storage.migrations.test.MigrationError enum exists...OK\n617/710 storage.migrations.test.writeAtomically writes content correctly...OK\n618/710 storage.issues.test.IssueStore.insert creates issue...OK\n619/710 storage.issues.test.IssueStore.get retrieves issue...OK\n620/710 storage.issues.test.IssueStore.get returns null for missing issue...OK\n621/710 storage.issues.test.IssueStore.update modifies fields...OK\n622/710 storage.issues.test.IssueStore.update returns error for missing issue...OK\n623/710 storage.issues.test.IssueStore.delete sets tombstone status...OK\n624/710 storage.issues.test.IssueStore.list returns issues...OK\n625/710 storage.issues.test.IssueStore.list excludes tombstones by default...OK\n626/710 storage.issues.test.IssueStore.list with status filter...OK\n627/710 storage.issues.test.IssueStore.list with priority filter...OK\n628/710 storage.issues.test.IssueStore.list with limit and offset...OK\n629/710 storage.issues.test.IssueStore dirty tracking...OK\n630/710 storage.issues.test.IssueStore.count total...OK\n631/710 storage.issues.test.IssueStore insert with all fields...OK\n632/710 storage.dependencies.test.DependencyStore.add creates dependency...OK\n633/710 storage.dependencies.test.DependencyStore.add rejects self-dependency...OK\n634/710 storage.dependencies.test.DependencyStore.add rejects direct cycle...OK\n635/710 storage.dependencies.test.DependencyStore.add rejects indirect cycle (A->B->C->A)...OK\n636/710 storage.dependencies.test.DependencyStore.remove removes dependency...OK\n637/710 storage.dependencies.test.DependencyStore.getDependencies returns dependencies...OK\n638/710 storage.dependencies.test.DependencyStore.getDependents returns dependents...OK\n639/710 storage.dependencies.test.DependencyStore.getReadyIssues excludes blocked issues...OK\n640/710 storage.dependencies.test.DependencyStore.getReadyIssues includes issue when blocker is closed...OK\n641/710 storage.dependencies.test.DependencyStore.getBlockedIssues returns only blocked issues...OK\n642/710 storage.dependencies.test.DependencyStore dirty tracking on add...OK\n643/710 storage.compact.test.Compactor.init...OK\n644/710 storage.compact.test.Compactor.initWithThresholds...OK\n645/710 storage.compact.test.Compactor.walStats returns stats for empty WAL...OK\n646/710 storage.compact.test.Compactor.walStats detects when compaction needed...OK\n647/710 storage.compact.test.Compactor.maybeCompact skips when below threshold...OK\n648/710 storage.compact.test.Compactor.compact merges WAL into main file...OK\n649/710 storage.compact.test.Compactor.compact handles close operations...OK\n650/710 storage.compact.test.Compactor.compact handles empty main file...OK\n651/710 storage.compact.test.Compactor.maybeCompact triggers at threshold...OK\n652/710 storage.compact.test.Compactor.compact creates backup before compaction...OK\n653/710 storage.compact.test.Compactor.compact skips backup when disabled...OK\n654/710 storage.txlog.test.LogLevel.toString...OK\n655/710 storage.txlog.test.LogEntry.formatJson produces valid output...OK\n656/710 storage.txlog.test.LogEntry.formatHuman produces readable output...OK\n657/710 storage.txlog.test.generateCorrelationId produces unique IDs...OK\n658/710 storage.txlog.test.LogBuffer push and getEntries...OK\n659/710 storage.txlog.test.LogBuffer wraps when full...OK\n660/710 storage.txlog.test.TxLog basic usage...OK\n661/710 storage.txlog.test.setEnabled disables logging...OK\n662/710 id.hash.test.contentHash deterministic...OK\n663/710 id.hash.test.contentHash different for different title...OK\n664/710 id.hash.test.contentHash different for different description...OK\n665/710 id.hash.test.contentHash different for different status...OK\n666/710 id.hash.test.contentHash different for different priority...OK\n667/710 id.hash.test.contentHash different for different issue_type...OK\n668/710 id.hash.test.contentHash different for different assignee...OK\n669/710 id.hash.test.contentHash different for different flags...OK\n670/710 id.hash.test.contentHash produces 64 lowercase hex characters...OK\n671/710 id.hash.test.contentHashAlloc returns heap-allocated copy...OK\n672/710 id.hash.test.contentHash ignores id field...OK\n673/710 id.hash.test.contentHash ignores timestamps...OK\n674/710 id.hash.test.contentHash with custom status...OK\n675/710 id.hash.test.contentHash with custom issue_type...OK\n676/710 config.yaml.test.parse simple key-value...OK\n677/710 config.yaml.test.parse with comments...OK\n678/710 config.yaml.test.parse nested structure...OK\n679/710 config.yaml.test.parse quoted values...OK\n680/710 config.yaml.test.parse empty value...OK\n681/710 config.yaml.test.get returns null for missing key...OK\n682/710 config.yaml.test.parse handles Windows line endings...OK\n683/710 config.yaml.test.parse ignores blank lines...OK\n684/710 tests.cli_test.test.bz version shows version info...OK\n685/710 tests.cli_test.test.bz help shows usage...OK\n686/710 tests.cli_test.test.bz --help shows usage...OK\n687/710 tests.cli_test.test.bz init creates workspace...OK\n688/710 tests.cli_test.test.bz init fails when already initialized...OK\n689/710 tests.cli_test.test.bz create returns ID...OK\n690/710 tests.cli_test.test.bz q returns ID...OK\n691/710 tests.cli_test.test.bz list returns issues...OK\n692/710 tests.cli_test.test.bz list --json returns output...OK\n693/710 tests.cli_test.test.bz show displays issue...OK\n694/710 tests.cli_test.test.bz show not-found returns error...OK\n695/710 tests.cli_test.test.bz close marks issue as closed...OK\n696/710 tests.cli_test.test.bz reopen reopens closed issue...OK\n697/710 tests.cli_test.test.bz delete soft deletes issue...OK\n698/710 tests.cli_test.test.bz search finds matching issues...OK\n699/710 tests.cli_test.test.bz dep add creates dependency...OK\n700/710 tests.cli_test.test.bz dep add rejects cycles...OK\n701/710 tests.cli_test.test.bz ready shows unblocked issues...OK\n702/710 tests.cli_test.test.bz blocked shows blocked issues...OK\n703/710 tests.cli_test.test.bz unknown command returns error...OK\n704/710 tests.cli_test.test.bz without workspace shows error...OK\n705/710 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n706/710 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n707/710 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n708/710 tests.stress_test.test.sequential writes: single thread baseline...OK\n709/710 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n710/710 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 710 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HcrC4ocpVz9FX4ukYyJKhf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011vhgLZBbhHpiuLa6XBJZ9h","name":"Bash","input":{"command":"tail -20 /home/hotschmoe/.claude/projects/-home-hotschmoe-beads-zig/6fe22edc-8a2d-4da5-a4e1-dac342168a2c/tool-results/toolu_01DBzZLgrv1xzMaLwiQC45EJ.txt","description":"Check the end of test output"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":897,"cache_read_input_tokens":40453,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":897},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"a5cf3cb5-f106-492d-99d2-78c5b25d065c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011vhgLZBbhHpiuLa6XBJZ9h","type":"tool_result","content":"699/710 tests.cli_test.test.bz dep add creates dependency...OK\n700/710 tests.cli_test.test.bz dep add rejects cycles...OK\n701/710 tests.cli_test.test.bz ready shows unblocked issues...OK\n702/710 tests.cli_test.test.bz blocked shows blocked issues...OK\n703/710 tests.cli_test.test.bz unknown command returns error...OK\n704/710 tests.cli_test.test.bz without workspace shows error...OK\n705/710 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n706/710 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n707/710 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n708/710 tests.stress_test.test.sequential writes: single thread baseline...OK\n709/710 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n710/710 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 710 tests passed.","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"eb783c4e-c741-47a1-bc82-ea17c294f816","tool_use_result":{"stdout":"699/710 tests.cli_test.test.bz dep add creates dependency...OK\n700/710 tests.cli_test.test.bz dep add rejects cycles...OK\n701/710 tests.cli_test.test.bz ready shows unblocked issues...OK\n702/710 tests.cli_test.test.bz blocked shows blocked issues...OK\n703/710 tests.cli_test.test.bz unknown command returns error...OK\n704/710 tests.cli_test.test.bz without workspace shows error...OK\n705/710 tests.stress_test.test.concurrent writes: 10 agents, 1 write each, serialized...\nSequential writes: 10/10\nIssues in store: 10\nOK\n706/710 tests.stress_test.test.batch writes: 1 agent, 10 issues, zero corruption...\nBatch writes: 10/10\nOK\n707/710 tests.stress_test.test.chaos: concurrent writes with interrupts verify data integrity...\nChaos test: 71 issues created\nOK\n708/710 tests.stress_test.test.sequential writes: single thread baseline...OK\n709/710 tests.stress_test.test.lock cycling: rapid acquire/release does not leak resources...OK\n710/710 tests.stress_test.test.WAL durability: entries persist correctly...OK\nAll 710 tests passed.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QW9qv2x5LWdVjF99WauKHk","type":"message","role":"assistant","content":[{"type":"text","text":"All 710 tests passed. Now let me commit the simplification changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":498,"cache_read_input_tokens":41350,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":498},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"c7e981b0-f56a-4ff1-9bc2-fc0a63adffb4"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QW9qv2x5LWdVjF99WauKHk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KJXTMGAW9MHG7sRK83ceHY","name":"TodoWrite","input":{"todos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"in_progress","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":498,"cache_read_input_tokens":41350,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":498},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"57fccf7b-a4a2-4547-8b52-abcc21528d2d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KJXTMGAW9MHG7sRK83ceHY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"750728a1-cd06-4268-96bc-8ee40eef0ff8","tool_use_result":{"oldTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"in_progress","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"in_progress","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01V2uiwSVPPiYMHjog67mtre","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JUghDZpBHQNSbCydNfeXjb","name":"Bash","input":{"command":"git diff --stat src/cli/args.zig","description":"Check changes to be committed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":244,"cache_read_input_tokens":41848,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":244},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"7358d851-77e9-4cc4-9ade-74d95fc2a80e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JUghDZpBHQNSbCydNfeXjb","type":"tool_result","content":" src/cli/args.zig | 73 +-------------------------------------------------------\n 1 file changed, 1 insertion(+), 72 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"0d83c4c6-fe2a-4c14-8a26-c1822c187cb4","tool_use_result":{"stdout":" src/cli/args.zig | 73 +-------------------------------------------------------\n 1 file changed, 1 insertion(+), 72 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01V2uiwSVPPiYMHjog67mtre","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016VB6fG66Z2hLBacrw8iYz3","name":"Bash","input":{"command":"git log --oneline -5","description":"Check recent commit style"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":244,"cache_read_input_tokens":41848,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":244},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"e2ea9e4a-5134-4a39-82e1-880f6d447dd6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016VB6fG66Z2hLBacrw8iYz3","type":"tool_result","content":"a144e25 feat(id,cli): improve ID collision resistance and global flag parsing\n94fb048 Plan mode: complete 2 tasks\n0c3d523 refactor(migrations): import BZ_VERSION from version.zig\nc1f5e81 feat(storage,docs): add schema versioning and document cleanup\na2ac66f Plan mode: complete 2 tasks","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"da274db3-d3ef-4040-85a3-f050dc4f1a2a","tool_use_result":{"stdout":"a144e25 feat(id,cli): improve ID collision resistance and global flag parsing\n94fb048 Plan mode: complete 2 tasks\n0c3d523 refactor(migrations): import BZ_VERSION from version.zig\nc1f5e81 feat(storage,docs): add schema versioning and document cleanup\na2ac66f Plan mode: complete 2 tasks","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JATnewcE3yerhE1QkWLmqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013YsYNyivrMrasiTW2dhSAm","name":"Bash","input":{"command":"git add src/cli/args.zig && git commit -m \"$(cat <<'EOF'\nrefactor(args): remove dead code from global flag parsing\n\nRemove parseGlobalFlag function that was superseded by isGlobalFlag,\napplyGlobalFlag, and applyGlobalFlagValue in the new parse()\nimplementation. Also remove unused cmd_index variable.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the simplification"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":330,"cache_read_input_tokens":42092,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":330},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"8558afad-3c43-49fd-b4e4-87d00eb4cebf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013YsYNyivrMrasiTW2dhSAm","type":"tool_result","content":"[dev-hotschmoe e26feb7] refactor(args): remove dead code from global flag parsing\n 1 file changed, 1 insertion(+), 72 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"70e683f2-7e9b-4508-914d-41d028eb4596","tool_use_result":{"stdout":"[dev-hotschmoe e26feb7] refactor(args): remove dead code from global flag parsing\n 1 file changed, 1 insertion(+), 72 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016PCVVbeaQyT7SvDhQEzb5z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0168cKyQPgbEWowWc8W3nmwg","name":"TodoWrite","input":{"todos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"completed","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":240,"cache_read_input_tokens":42422,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":240},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"7c149bb7-53bb-45fe-ad87-927c086b3762"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0168cKyQPgbEWowWc8W3nmwg","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"b7b881f9-4991-4ccf-b2eb-8e27786233f5","tool_use_result":{"oldTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"in_progress","activeForm":"Committing changes"}],"newTodos":[{"content":"Remove dead code: parseGlobalFlag function no longer called","status":"completed","activeForm":"Removing dead parseGlobalFlag function"},{"content":"Remove unused variable cmd_index in parse()","status":"completed","activeForm":"Removing unused cmd_index variable"},{"content":"Run tests to verify changes don't break anything","status":"completed","activeForm":"Running tests"},{"content":"Commit simplification changes if tests pass","status":"completed","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ByybrJ89kT35drB1u2DWrC","type":"message","role":"assistant","content":[{"type":"text","text":"Code review and simplification complete.\n\n**Summary of changes:**\n\n1. **Removed dead code** (`src/cli/args.zig:891-955`): The `parseGlobalFlag` function was no longer called after the global flag parsing was refactored to use three standalone functions (`isGlobalFlag`, `applyGlobalFlag`, `applyGlobalFlagValue`). Removed 64 lines of duplicated logic.\n\n2. **Removed unused variable**: The `cmd_index` variable was being assigned but never read - removed it and simplified the comment.\n\n**Result:** 72 lines deleted, all 710 tests pass, committed as `e26feb7`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":225,"cache_read_input_tokens":42662,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":225},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","uuid":"75c597a7-86f0-417b-a931-507d4ad8aa4d"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":95754,"duration_api_ms":99898,"num_turns":22,"result":"Code review and simplification complete.\n\n**Summary of changes:**\n\n1. **Removed dead code** (`src/cli/args.zig:891-955`): The `parseGlobalFlag` function was no longer called after the global flag parsing was refactored to use three standalone functions (`isGlobalFlag`, `applyGlobalFlag`, `applyGlobalFlagValue`). Removed 64 lines of duplicated logic.\n\n2. **Removed unused variable**: The `cmd_index` variable was being assigned but never read - removed it and simplified the comment.\n\n**Result:** 72 lines deleted, all 710 tests pass, committed as `e26feb7`.","session_id":"6fe22edc-8a2d-4da5-a4e1-dac342168a2c","total_cost_usd":0.6394775,"usage":{"input_tokens":2,"cache_creation_input_tokens":24911,"cache_read_input_tokens":687853,"output_tokens":3900,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":24911,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":2,"outputTokens":3900,"cacheReadInputTokens":687853,"cacheCreationInputTokens":24911,"webSearchRequests":0,"costUSD":0.5971302500000001,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":7471,"outputTokens":441,"cacheReadInputTokens":0,"cacheCreationInputTokens":26137,"webSearchRequests":0,"costUSD":0.042347249999999996,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"012e9060-1c73-4c1c-976b-cde23c003c53"}
